/* -----------------------------------------------------------------------------

 Portions of this software may have been derived from the UCD-SNMP
 project,  <http://www.net-snmp.org/>  from the University of
 California at Davis, which was originally based on the Carnegie Mellon
 University SNMP implementation.  Portions of this software are therefore
 covered by the appropriate copyright disclaimers included herein.

 The release used was version 5.0.11.2 of June 2008.  "net-snmp-5.0.11.2"

 -------------------------------------------------------------------------------
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */

#include "vtss_snmp_api.h"
#include "rfc3415_vacm.h"
#include "ucd_snmp_rfc3415_vacm.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"
#include "sysutil_api.h"

/*
 * +++ Start (Internal implementation declarations)
 */
#if RFC3415_SUPPORTED_VACMMIBVIEWS
static long old_vacmViewSpinLock = 0, now_vacmViewSpinLock = 0;
#endif /* RFC3415_SUPPORTED_VACMMIBVIEWS */

/*
 * --- End (Internal implementation declarations)
 */

#if RFC3415_SUPPORTED_VACMCONTEXTTABLE
/* vacmContextTable ----------------------------------------------------------*/
/*
 * vacmContextTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             vacmContextTable_variables_oid[] =
{ 1, 3, 6, 1, 6, 3, 16, 1, 1 };

/*
 * variable4 vacmContextTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the vacmContextTable mib section
 */

struct variable4 vacmContextTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define VACMCONTEXTNAME     1
    {VACMCONTEXTNAME, ASN_OCTET_STR, RONLY, var_vacmContextTable, 2, {1, 1}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the vacmContextTable module
 */
void
ucd_snmp_init_vacmContextTable(void)
{
    DEBUGMSGTL(("vacmContextTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("vacmContextTable", vacmContextTable_variables, variable4,
                 vacmContextTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_vacmContextTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vacmContextTable above.
 */
u_char         *
var_vacmContextTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static u_char string[2];

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case VACMCONTEXTNAME: {
        strcpy(string, "");
        *var_len = strlen(string);
        return (u_char *) string;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_vacmContextTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* RFC3415_SUPPORTED_VACMCONTEXTTABLE */

#if RFC3415_SUPPORTED_VACMSECURITYTOGROUPTABLE
/* vacmSecurityToGroupTable ----------------------------------------------------------*/
/*
 * vacmSecurityToGroupTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             vacmSecurityToGroupTable_variables_oid[] =
{ 1, 3, 6, 1, 6, 3, 16, 1, 2 };

/*
 * variable4 vacmSecurityToGroupTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the vacmSecurityToGroupTable mib section
 */

struct variable4 vacmSecurityToGroupTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    /* not-accessible
    #define VACMSECURITYMODEL       1
        {VACMSECURITYMODEL, ASN_INTEGER, RONLY, var_vacmSecurityToGroupTable, 2, {1, 1}},
    #define VACMSECURITYNAME        2
        {VACMSECURITYNAME, ASN_OCTET_STR, RONLY, var_vacmSecurityToGroupTable, 2, {1, 2}},
    */
#define VACMGROUPNAME                       3
    {VACMGROUPNAME, ASN_OCTET_STR, RWRITE, var_vacmSecurityToGroupTable, 2, {1, 3}},
#define VACMSECURITYTOGROUPSTORAGETYPE      4
    {VACMSECURITYTOGROUPSTORAGETYPE, ASN_INTEGER, RWRITE, var_vacmSecurityToGroupTable, 2, {1, 4}},
#define VACMSECURITYTOGROUPSTATUS           5
    {VACMSECURITYTOGROUPSTATUS, ASN_INTEGER, RWRITE, var_vacmSecurityToGroupTable, 2, {1, 5}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the vacmSecurityToGroupTable module
 */
void
ucd_snmp_init_vacmSecurityToGroupTable(void)
{
    DEBUGMSGTL(("vacmSecurityToGroupTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("vacmSecurityToGroupTable",
                 vacmSecurityToGroupTable_variables, variable4,
                 vacmSecurityToGroupTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_vacmSecurityToGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vacmSecurityToGroupTable above.
 */
u_char         *
var_vacmSecurityToGroupTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long          long_ret;
    static u_char        string[SPRINT_MAX_LEN];
    oid                  *groupSubtree;
    int                  groupSubtreeLen = 0, len = 0;
    int                  secmodel;
    char                 secname[SNMPV3_MAX_NAME_LEN] = { 0 }, *cp;
    snmpv3_groups_conf_t conf, temp_conf;
    vtss_rc              rc = !VTSS_OK;
    int                  found = 0;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long_ret); /* assume an integer and change later if not */
    memset(&conf, 0x0, sizeof(conf));
    memset(&temp_conf, 0x0, sizeof(temp_conf));

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length < 13) {
            return NULL;
        }

        secmodel = name[11];
        groupSubtree = name + 13;
        groupSubtreeLen = *length - 13;
        if (groupSubtreeLen < 0 || groupSubtreeLen > SNMPV3_MAX_NAME_LEN) {
            return 0;
        }
        if ( name[12] != groupSubtreeLen ) {
            return 0;    /* Either extra subids, or an incomplete string */
        }
        cp = secname;
        while (groupSubtreeLen-- > 0) {
            if (*groupSubtree > 255) {
                return 0; /* illegal value */
            }
            if (cp - secname > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            *cp++ = (char) * groupSubtree++;
        }
        *cp = 0;

        conf.security_model = secmodel;
        strcpy(conf.security_name, secname);
        rc = snmpv3_mgmt_groups_conf_get(&conf, FALSE);
    } else {
        secmodel = *length > 11 ? name[11] : 0;
        groupSubtree = name + 12;
        if (groupSubtree >= name + *length) {
        } else {
            groupSubtreeLen = *groupSubtree++;
            if (groupSubtreeLen < 0 || groupSubtreeLen > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            len = ((*length - 13) >= groupSubtreeLen) ? groupSubtreeLen : (*length - 13);
            cp = secname;
            while (len-- > 0) {
                if (*groupSubtree > 255) {
                    return 0; /* illegal value */
                }
                if (cp - secname > SNMPV3_MAX_NAME_LEN) {
                    return 0;
                }
                *cp++ = (char) * groupSubtree++;
            }
            *cp = 0;
        }

        strcpy(conf.security_name, SNMPV3_CONF_ACESS_GETFIRST);
        while ((rc = snmpv3_mgmt_groups_conf_get(&conf, TRUE)) == VTSS_OK) {
            if (conf.security_model > secmodel ||
                (conf.security_model == secmodel && strlen(conf.security_name) > groupSubtreeLen) ||
                (conf.security_model == secmodel && strlen(conf.security_name) == groupSubtreeLen && strcmp(conf.security_name, secname) > 0)) {
                if (found == 0) {
                    found = 1;
                    temp_conf = conf;
                } else if (conf.security_model < temp_conf.security_model ||
                           (conf.security_model == temp_conf.security_model && strlen(conf.security_name) < strlen(temp_conf.security_name)) ||
                           (conf.security_model == temp_conf.security_model && strlen(conf.security_name) == strlen(temp_conf.security_name) && strcmp(conf.security_name, temp_conf.security_name) < 0)) {
                    temp_conf = conf;
                }
            }
        }
        if (found) {
            conf = temp_conf;
            rc = VTSS_OK;
        }

        if (rc == VTSS_OK) {
            name[11] = conf.security_model;
            *length = 12;
            name[(*length)++] = strlen(conf.security_name);
            cp = conf.security_name;
            while (*cp) {
                name[(*length)++] = *cp++;
            }
        }
    }

    if (rc != VTSS_OK) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
        /* not-accessible
        case VACMSECURITYMODEL:
            {
                long_ret = conf.security_model;
                return (u_char *) &long_ret;
            }
        case VACMSECURITYNAME:
            {
                strcpy(string, conf.security_name);
                *var_len = strlen(string);
                return (u_char *) string;
            }
        */
    case VACMGROUPNAME: {
        //*write_method = write_vacmGroupName;
        strcpy(string, conf.group_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case VACMSECURITYTOGROUPSTORAGETYPE: {
        //*write_method = write_vacmSecurityToGroupStorageType;
        long_ret = conf.storage_type;
        return (u_char *) &long_ret;
    }
    case VACMSECURITYTOGROUPSTATUS: {
        //*write_method = write_vacmSecurityToGroupStatus;
        long_ret = conf.status;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_vacmSecurityToGroupTable\n",
                    vp->magic));
    }
    return NULL;
}

int
write_vacmGroupName(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to vacmGroupName: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to vacmGroupName: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to vacmGroupName: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmSecurityToGroupStorageType(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmSecurityToGroupStatus(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP,
                                oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmSecurityToGroupStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC3415_SUPPORTED_VACMSECURITYTOGROUPTABLE */

#if RFC3415_SUPPORTED_VACMACCESSTABLE
/* vacmAccessTable ----------------------------------------------------------*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.6 2006/04/18 17:36:16 hardaker Exp $
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
/*
 * vacmAccessTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             vacmAccessTable_variables_oid[] =
{ 1, 3, 6, 1, 6, 3, 16, 1, 4 };

/*
 * variable4 vacmAccessTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the vacmAccessTable mib section
 */

struct variable4 vacmAccessTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    /* not-accessible
    #define VACMACCESSCONTEXTPREFIX     1
        {VACMACCESSCONTEXTPREFIX, ASN_OCTET_STR, RONLY, var_vacmAccessTable, 2, {1, 1}},
    #define VACMACCESSSECURITYMODEL     2
        {VACMACCESSSECURITYMODEL, ASN_INTEGER, RONLY, var_vacmAccessTable, 2, {1, 2}},
    #define VACMACCESSSECURITYLEVEL     3
        {VACMACCESSSECURITYLEVEL, ASN_INTEGER, RONLY, var_vacmAccessTable, 2, {1, 3}},
    */
#define VACMACCESSCONTEXTMATCH      4
    {VACMACCESSCONTEXTMATCH, ASN_INTEGER, RWRITE, var_vacmAccessTable, 2, {1, 4}},
#define VACMACCESSREADVIEWNAME      5
    {VACMACCESSREADVIEWNAME, ASN_OCTET_STR, RWRITE, var_vacmAccessTable, 2, {1, 5}},
#define VACMACCESSWRITEVIEWNAME     6
    {VACMACCESSWRITEVIEWNAME, ASN_OCTET_STR, RWRITE, var_vacmAccessTable, 2, {1, 6}},
#define VACMACCESSNOTIFYVIEWNAME    7
    {VACMACCESSNOTIFYVIEWNAME, ASN_OCTET_STR, RWRITE, var_vacmAccessTable, 2, {1, 7}},
#define VACMACCESSSTORAGETYPE       8
    {VACMACCESSSTORAGETYPE, ASN_INTEGER, RWRITE, var_vacmAccessTable, 2, {1, 8}},
#define VACMACCESSSTATUS            9
    {VACMACCESSSTATUS, ASN_INTEGER, RWRITE, var_vacmAccessTable, 2, {1, 9}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the vacmAccessTable module
 */
void
ucd_snmp_init_vacmAccessTable(void)
{
    DEBUGMSGTL(("vacmAccessTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("vacmAccessTable", vacmAccessTable_variables, variable4,
                 vacmAccessTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_vacmAccessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vacmAccessTable above.
 */
u_char         *
var_vacmAccessTable(struct variable *vp,
                    oid *name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long            long_ret;
    static u_char          string[SPRINT_MAX_LEN];
    int                    secmodel = 0;
    int                    seclevel = 0;
    char                   groupName[SNMPV3_MAX_NAME_LEN] = { 0 };
    int                    groupNameLen = 0;
    char                   contextPrefix[SNMPV3_MAX_NAME_LEN] = { 0 };
    int                    contextPrefixLen = 0;
    oid                    *op = NULL;
    int                    len = 0;
    char                   *cp;
    snmpv3_accesses_conf_t conf, temp_conf;
    vtss_rc                rc = !VTSS_OK;
    int                    found = 0;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long_ret); /* assume an integer and change later if not */
    memset(&conf, 0x0, sizeof(conf));
    memset(&temp_conf, 0x0, sizeof(temp_conf));

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length < 15) {
            return NULL;
        }

        op = name + 11;
        len = *op++;
        if (len < 0 || len > SNMPV3_MAX_NAME_LEN) {
            return 0;
        }
        cp = groupName;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
            *cp++ = (char) * op++;
        }
        *cp = 0;
        len = *op++;
        if (len < 0 || len > MAX_OID_LEN) {
            return 0;
        }
        cp = contextPrefix;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
            *cp++ = (char) * op++;
        }
        *cp = 0;
        secmodel = *op++;
        seclevel = *op++;
        if (op != name + *length) {
            return NULL;
        }

        strcpy(conf.group_name, groupName);
        strcpy(conf.context_prefix, contextPrefix);
        conf.security_model = secmodel;
        conf.security_level = seclevel;
        rc = snmpv3_mgmt_accesses_conf_get(&conf, FALSE);
    } else {
        op = name + 11;
        if (op >= name + *length) {
        } else {
            groupNameLen = *op++;
            if (groupNameLen < 0 || groupNameLen > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            len = ((*length - 12) >= groupNameLen) ? groupNameLen : (*length - 12);
            cp = groupName;
            while (len-- > 0) {
                if (*op > 255) {
                    return 0; /* illegal value */
                }
                *cp++ = (char) * op++;
            }
            *cp = 0;
        }
        if (op >= name + *length) {
        } else {
            contextPrefixLen = *op++;
            if (contextPrefixLen < 0 || contextPrefixLen > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            len = ((*length - 13 - groupNameLen) >= contextPrefixLen) ? contextPrefixLen : (*length - 13 - contextPrefixLen);
            cp = contextPrefix;
            while (len-- > 0) {
                if (*op > 255) {
                    return 0; /* illegal value */
                }
                *cp++ = (char) * op++;
            }
            *cp = 0;
        }
        if (op >= name + *length) {
        } else {
            secmodel = *op++;
        }
        if (op >= name + *length) {
        } else {
            seclevel = *op++;
        }

        strcpy(conf.group_name, SNMPV3_CONF_ACESS_GETFIRST);
        while ((rc = snmpv3_mgmt_accesses_conf_get(&conf, TRUE)) == VTSS_OK) {
            if (strlen(conf.group_name) > groupNameLen ||
                (strlen(conf.group_name) == groupNameLen && strcmp(conf.group_name, groupName) > 0) ||
                (strlen(conf.group_name) == groupNameLen && (!strcmp(conf.group_name, groupName)) && strlen(conf.context_prefix) > contextPrefixLen) ||
                (strlen(conf.group_name) == groupNameLen && (!strcmp(conf.group_name, groupName)) && strlen(conf.context_prefix) == contextPrefixLen && strcmp(conf.context_prefix, contextPrefix) > 0) ||
                (strlen(conf.group_name) == groupNameLen && (!strcmp(conf.group_name, groupName)) && strlen(conf.context_prefix) == contextPrefixLen && (!strcmp(conf.context_prefix, contextPrefix)) && conf.security_model > secmodel) ||
                (strlen(conf.group_name) == groupNameLen && (!strcmp(conf.group_name, groupName)) && strlen(conf.context_prefix) == contextPrefixLen && (!strcmp(conf.context_prefix, contextPrefix)) && conf.security_model == secmodel && conf.security_level > seclevel)) {
                if (found == 0) {
                    found = 1;
                    temp_conf = conf;
                } else if (strlen(conf.group_name) < strlen(temp_conf.group_name) ||
                           (strlen(conf.group_name) == strlen(temp_conf.group_name) && strcmp(conf.group_name, temp_conf.group_name) < 0) ||
                           (strlen(conf.group_name) == strlen(temp_conf.group_name) && (!strcmp(conf.group_name, temp_conf.group_name)) && strlen(conf.context_prefix) < strlen(temp_conf.context_prefix)) ||
                           (strlen(conf.group_name) == strlen(temp_conf.group_name) && (!strcmp(conf.group_name, temp_conf.group_name)) && strlen(conf.context_prefix) == strlen(temp_conf.context_prefix) && strcmp(conf.context_prefix, temp_conf.context_prefix) < 0) ||
                           (strlen(conf.group_name) == strlen(temp_conf.group_name) && (!strcmp(conf.group_name, temp_conf.group_name)) && strlen(conf.context_prefix) == strlen(temp_conf.context_prefix) && (!strcmp(conf.context_prefix, temp_conf.context_prefix)) && conf.security_model < temp_conf.security_model) ||
                           (strlen(conf.group_name) == strlen(temp_conf.group_name) && (!strcmp(conf.group_name, temp_conf.group_name)) && strlen(conf.context_prefix) == strlen(temp_conf.context_prefix) && (!strcmp(conf.context_prefix, temp_conf.context_prefix)) && conf.security_model == temp_conf.security_model && conf.security_level < temp_conf.security_level)) {
                    temp_conf = conf;
                }
            }
        }
        if (found) {
            conf = temp_conf;
            rc = VTSS_OK;
        }

        if (rc == VTSS_OK) {
            *length = 11;
            name[(*length)++] = strlen(conf.group_name);
            cp = conf.group_name;
            do {
                name[(*length)++] = *cp++;
            } while (*cp);
            name[(*length)++] = strlen(conf.context_prefix);
            if (strlen(conf.context_prefix)) {
                cp = conf.context_prefix;
                do {
                    name[(*length)++] = *cp++;
                } while (*cp);
            }
            name[(*length)++] = conf.security_model;
            name[(*length)++] = conf.security_level;
        }
    }

    if (rc != VTSS_OK) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
        /* not-accessible
        case VACMACCESSCONTEXTPREFIX:
            {
                strcpy(string, conf.context_prefix);
                *var_len = strlen(string);
                return (u_char *) string;
            }
        case VACMACCESSSECURITYMODEL:
            {
                long_ret = conf.security_model;
                return (u_char *) &long_ret;
            }
        case VACMACCESSSECURITYLEVEL:
            {
                long_ret = conf.security_level;
                return (u_char *) &long_ret;
            }
        */
    case VACMACCESSCONTEXTMATCH: {
        //*write_method = write_vacmAccessContextMatch;
        long_ret = conf.context_match;
        return (u_char *) &long_ret;
    }
    case VACMACCESSREADVIEWNAME: {
        //*write_method = write_vacmAccessReadViewName;
        strcpy(string, conf.read_view_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case VACMACCESSWRITEVIEWNAME: {
        //*write_method = write_vacmAccessWriteViewName;
        strcpy(string, conf.write_view_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case VACMACCESSNOTIFYVIEWNAME: {
        //*write_method = write_vacmAccessNotifyViewName;
        strcpy(string, conf.notify_view_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case VACMACCESSSTORAGETYPE: {
        //*write_method = write_vacmAccessStorageType;
        long_ret = conf.storage_type;
        return (u_char *) &long_ret;
    }
    case VACMACCESSSTATUS: {
        //*write_method = write_vacmAccessStatus;
        long_ret = conf.status;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_vacmAccessTable\n",
                    vp->magic));
    }
    return NULL;
}


int
write_vacmAccessContextMatch(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessContextMatch: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessContextMatch: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessContextMatch: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmAccessReadViewName(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessReadViewName: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessReadViewName: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessReadViewName: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmAccessWriteViewName(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessWriteViewName: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessWriteViewName: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessWriteViewName: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmAccessNotifyViewName(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessNotifyViewName: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessNotifyViewName: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessNotifyViewName: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmAccessStorageType(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmAccessStatus(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmAccessStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmAccessStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC3415_SUPPORTED_VACMACCESSTABLE */

#if RFC3415_SUPPORTED_VACMMIBVIEWS
/* vacmMIBViews ----------------------------------------------------------*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.6 2006/04/18 17:36:16 hardaker Exp $
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
/*
 * vacmMIBViews_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             vacmMIBViews_variables_oid[] =
{ 1, 3, 6, 1, 6, 3, 16, 1, 5 };

/*
 * variable4 vacmMIBViews_variables:
 *   this variable defines function callbacks and type return information
 *   for the vacmMIBViews mib section
 */

struct variable4 vacmMIBViews_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define VACMVIEWSPINLOCK                1
    {VACMVIEWSPINLOCK, ASN_INTEGER, RWRITE, var_vacmMIBViews, 1, {1}},
    /* not-accessible
    #define VACMVIEWTREEFAMILYVIEWNAME      2
        {VACMVIEWTREEFAMILYVIEWNAME, ASN_OCTET_STR, RONLY, var_vacmViewTreeFamilyTable, 3, {2, 1, 1}},
    #define VACMVIEWTREEFAMILYSUBTREE       3
        {VACMVIEWTREEFAMILYSUBTREE, ASN_OBJECT_ID, RONLY, var_vacmViewTreeFamilyTable, 3, {2, 1, 2}},
    */
#define VACMVIEWTREEFAMILYMASK          4
    {VACMVIEWTREEFAMILYMASK, ASN_OCTET_STR, RWRITE, var_vacmViewTreeFamilyTable, 3, {2, 1, 3}},
#define VACMVIEWTREEFAMILYTYPE          5
    {VACMVIEWTREEFAMILYTYPE, ASN_INTEGER, RWRITE, var_vacmViewTreeFamilyTable, 3, {2, 1, 4}},
#define VACMVIEWTREEFAMILYSTORAGETYPE   6
    {VACMVIEWTREEFAMILYSTORAGETYPE, ASN_INTEGER, RWRITE, var_vacmViewTreeFamilyTable, 3, {2, 1, 5}},
#define VACMVIEWTREEFAMILYSTATUS        7
    {VACMVIEWTREEFAMILYSTATUS, ASN_INTEGER, RWRITE, var_vacmViewTreeFamilyTable, 3, {2, 1, 6}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the vacmMIBViews module
 */
void
ucd_snmp_init_vacmMIBViews(void)
{
    DEBUGMSGTL(("vacmMIBViews", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("vacmMIBViews", vacmMIBViews_variables, variable4,
                 vacmMIBViews_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_vacmMIBViews():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_vacmMIBViews(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long long_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case VACMVIEWSPINLOCK: {
        //*write_method = write_vacmViewSpinLock;
        long_ret = now_vacmViewSpinLock;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_vacmMIBViews\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_vacmViewTreeFamilyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_vacmMIBViews above.
 */
u_char         *
var_vacmViewTreeFamilyTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long         long_ret;
    static u_char       string[SPRINT_MAX_LEN];
    //static oid          objid[MAX_OID_LEN];
    char                viewName[SNMPV3_MAX_NAME_LEN] = { 0 };
    int                 viewNameLen = 0;
    oid                 subtree[MAX_OID_LEN] = { 0 };
    size_t              subtreeLen = 0;
    oid                 *op, *op1;
    int                 len = 0;
    char                *cp;
    snmpv3_views_conf_t conf, temp_conf;
    vtss_rc             rc = !VTSS_OK;
    int                 found = 0;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long_ret); /* assume an integer and change later if not */
    memset(&conf, 0x0, sizeof(conf));
    memset(&temp_conf, 0x0, sizeof(temp_conf));

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length < 15) {
            return NULL;
        }

        op = name + 12;
        len = *op++;
        if (len < 0 || len > SNMPV3_MAX_NAME_LEN) {
            return 0;
        }
        cp = viewName;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
            *cp++ = (char) * op++;
        }
        *cp = 0;
        len = *op++;
        if (len < 0 || len > MAX_OID_LEN) {
            return 0;
        }
        if ( (op + len) != (name + *length) ) {
            return NULL;    /* Declared length doesn't match what we actually got */
        }
        op1 = subtree;
        while (len-- > 0) {
            *op1++ = *op++;
            subtreeLen++;
        }
        if (op != name + *length) {
            return NULL;
        }

        strcpy(conf.view_name, viewName);
        memcpy(conf.subtree, subtree, sizeof(oid)* subtreeLen);
        conf.subtree_len = subtreeLen;
        rc = snmpv3_mgmt_views_conf_get(&conf, FALSE);
    } else {
        op = name + 12;
        if (op >= name + *length) {
        } else {
            viewNameLen = *op++;
            if (viewNameLen < 0 || viewNameLen > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            len = ((*length - 13) >= viewNameLen) ? viewNameLen : (*length - 13);
            cp = viewName;
            while (len-- > 0) {
                if (*op > 255) {
                    return 0; /* illegal value */
                }
                *cp++ = (char) * op++;
            }
            *cp = 0;
        }
        if (op >= name + *length) {
        } else {
            subtreeLen = *op++;
            if (subtreeLen < 0 || subtreeLen > MAX_OID_LEN) {
                return 0;
            }
            len = ((*length - 13 - (strlen(viewName) + 1)) >= subtreeLen) ? subtreeLen : (*length - 13 - (strlen(viewName) + 1));
            op1 = subtree;
            while (len-- > 0) {
                *op1++ = *op++;
            }
        }

        strcpy(conf.view_name, SNMPV3_CONF_ACESS_GETFIRST);
        while ((rc = snmpv3_mgmt_views_conf_get(&conf, TRUE)) == VTSS_OK) {
            if (strlen(conf.view_name) > viewNameLen ||
                (strlen(conf.view_name) == viewNameLen && strcmp(conf.view_name, viewName) > 0) ||
                (strlen(conf.view_name) == viewNameLen && (!strcmp(conf.view_name, viewName)) && snmp_oid_compare((oid *)conf.subtree, conf.subtree_mask_len, subtree, subtreeLen) > 0)) {
                if (found == 0) {
                    found = 1;
                    temp_conf = conf;
                } else if (strlen(conf.view_name) < strlen(temp_conf.view_name) ||
                           (strlen(conf.view_name) == strlen(temp_conf.view_name) && strcmp(conf.view_name, temp_conf.view_name) < 0) ||
                           (strlen(conf.view_name) == strlen(temp_conf.view_name) && (!strcmp(conf.view_name, temp_conf.view_name)) && snmp_oid_compare((oid *)conf.subtree, conf.subtree_mask_len, (oid *)temp_conf.subtree, temp_conf.subtree_mask_len) < 0)) {
                    temp_conf = conf;
                }
            }
        }
        if (found) {
            conf = temp_conf;
            rc = VTSS_OK;
        }

        if (rc == VTSS_OK) {
            *length = 12;
            name[(*length)++] = strlen(conf.view_name);
            cp = conf.view_name;
            do {
                name[(*length)++] = *cp++;
            } while (*cp);
            op1 = (oid *)conf.subtree;
            len = conf.subtree_len;
            name[(*length)++] = len;
            do {
                name[(*length)++] = *op1++;
            } while (len-- > 0);
            *length = (*length) - 1;
        }
    }

    if (rc != VTSS_OK) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
        /* not-accessible
        case VACMVIEWTREEFAMILYVIEWNAME:
            {
                strcpy(string, conf.view_name);
                *var_len = strlen(string);
                return (u_char *) string;
            }
        case VACMVIEWTREEFAMILYSUBTREE:
            {
                *var_len = sizeof(oid) * conf.subtree_len;
                memcpy(objid, conf.subtree, sizeof(oid) * conf.subtree_len);
                return (u_char *) objid;
            }
        */
    case VACMVIEWTREEFAMILYMASK: {
        //*write_method = write_vacmViewTreeFamilyMask;
        *var_len = (conf.subtree_len + 7) / 8;
        memcpy(string, conf.subtree_mask, conf.subtree_mask_len);
        return (u_char *) string;
    }
    case VACMVIEWTREEFAMILYTYPE: {
        //*write_method = write_vacmViewTreeFamilyType;
        long_ret = conf.view_type;
        return (u_char *) &long_ret;
    }
    case VACMVIEWTREEFAMILYSTORAGETYPE: {
        //*write_method = write_vacmViewTreeFamilyStorageType;
        long_ret = conf.storage_type;
        return (u_char *) &long_ret;
    }
    case VACMVIEWTREEFAMILYSTATUS: {
        //*write_method = write_vacmViewTreeFamilyStatus;
        long_ret = conf.status;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_vacmViewTreeFamilyTable\n",
                    vp->magic));
    }
    return NULL;
}


int
write_vacmViewSpinLock(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;
    int             max_size;
    long            intval;

    buf = &old_vacmViewSpinLock;
    old_buf = &now_vacmViewSpinLock;
    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmViewSpinLock: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmViewSpinLock: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > 2147483647) {
            snmp_log(LOG_ERR, "write to vacmViewSpinLock: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        if (intval != *buf) {
            return SNMP_ERR_INCONSISTENTVALUE;
        }
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val);
        if (*buf == 2147483647) {
            *buf = 0;
        } else {
            *buf = *buf + 1;
        }
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmViewTreeFamilyMask(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyMask: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyMask: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyMask: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmViewTreeFamilyType(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmViewTreeFamilyStorageType(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_vacmViewTreeFamilyStatus(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to vacmViewTreeFamilyStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC3415_SUPPORTED_VACMMIBVIEWS */

