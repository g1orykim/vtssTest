/*
 * 
 * Vitesse Switch Software.
 * 
 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 * 
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* For header_generic() */

#include "ucd_snmp_ieee8021MstpMib.h"
#include "ieee8021MstpMib.h"
#include "ucd_snmp_callout.h"   //ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define IEEE8021MSTPMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021MSTPMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021MSTPMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long            long_ret;
    char            string_ret[IEEE8021MSTPMIB_STR_LEN_MAX + 1];
    struct counter64 c64_ret;
    u_long          ulong_ret;
} ieee8021MstpMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod   ieee8021MstpMib_var;
FindVarMethod   ieee8021MstpCistTable_var;
FindVarMethod   ieee8021MstpTable_var;
FindVarMethod   ieee8021MstpCistPortTable_var;
FindVarMethod   ieee8021MstpPortTable_var;
FindVarMethod   ieee8021MstpFidToMstiTable_var;
FindVarMethod   ieee8021MstpVlanTable_var;
FindVarMethod   ieee8021MstpConfigIdTable_var;
WriteMethod     ieee8021MstpCistMaxHops_write;
WriteMethod     ieee8021MstpBridgePriority_write;
WriteMethod     ieee8021MstpRowStatus_write;
WriteMethod     ieee8021MstpCistPortAdminPathCost_write;
WriteMethod     ieee8021MstpCistPortAdminEdgePort_write;
WriteMethod     ieee8021MstpCistPortMacEnabled_write;
WriteMethod     ieee8021MstpCistPortRestrictedRole_write;
WriteMethod     ieee8021MstpCistPortRestrictedTcn_write;
WriteMethod     ieee8021MstpCistPortProtocolMigration_write;
WriteMethod     ieee8021MstpCistPortEnableBPDURx_write;
WriteMethod     ieee8021MstpCistPortEnableBPDUTx_write;
WriteMethod     ieee8021MstpCistPortPseudoRootId_write;
WriteMethod     ieee8021MstpCistPortIsL2Gp_write;
WriteMethod     ieee8021MstpPortPriority_write;
WriteMethod     ieee8021MstpPortPathCost_write;
WriteMethod     ieee8021MstpFidToMstiMstId_write;
WriteMethod     ieee8021MstpConfigIdFormatSelector_write;
WriteMethod     ieee8021MstpConfigurationName_write;
WriteMethod     ieee8021MstpRevisionLevel_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*
 * lint -esym(459, ieee8021MstpMib_global_ret) 
 */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021MstpMib_ret_t ieee8021MstpMib_global_ret;

/*
 * ieee8021MstpMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid      ieee8021MstpMib_variables_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 6 };



/*
 * variable ieee8021MstpMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021MstpMib mib section
 */

struct variable4 ieee8021MstpMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IEEE8021MSTPCISTBRIDGEIDENTIFIER		1
    {IEEE8021MSTPCISTBRIDGEIDENTIFIER, ASN_OCTET_STR, RONLY,
     ieee8021MstpCistTable_var, 4, {1, 1, 1, 2}},
#define IEEE8021MSTPCISTTOPOLOGYCHANGE		2
    {IEEE8021MSTPCISTTOPOLOGYCHANGE, ASN_INTEGER, RONLY,
     ieee8021MstpCistTable_var, 4, {1, 1, 1, 3}},
#define IEEE8021MSTPCISTREGIONALROOTIDENTIFIER		3
    {IEEE8021MSTPCISTREGIONALROOTIDENTIFIER, ASN_OCTET_STR, RONLY,
     ieee8021MstpCistTable_var, 4, {1, 1, 1, 4}},
#define IEEE8021MSTPCISTPATHCOST		4
    {IEEE8021MSTPCISTPATHCOST, ASN_UNSIGNED, RONLY,
     ieee8021MstpCistTable_var, 4, {1, 1, 1, 5}},
#define IEEE8021MSTPCISTMAXHOPS		5
    {IEEE8021MSTPCISTMAXHOPS, ASN_INTEGER, RWRITE,
     ieee8021MstpCistTable_var, 4, {1, 1, 1, 6}},
#define IEEE8021MSTPBRIDGEID		6
    {IEEE8021MSTPBRIDGEID, ASN_OCTET_STR, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 3}},
#define IEEE8021MSTPTIMESINCETOPOLOGYCHANGE		7
    {IEEE8021MSTPTIMESINCETOPOLOGYCHANGE, ASN_TIMETICKS, RONLY,
     ieee8021MstpTable_var, 4, {1, 2, 1, 4}},
#define IEEE8021MSTPTOPOLOGYCHANGES		8
    {IEEE8021MSTPTOPOLOGYCHANGES, ASN_COUNTER64, RONLY,
     ieee8021MstpTable_var, 4, {1, 2, 1, 5}},
#define IEEE8021MSTPTOPOLOGYCHANGE		9
    {IEEE8021MSTPTOPOLOGYCHANGE, ASN_INTEGER, RONLY, ieee8021MstpTable_var,
     4, {1, 2, 1, 6}},
#define IEEE8021MSTPDESIGNATEDROOT		10
    {IEEE8021MSTPDESIGNATEDROOT, ASN_OCTET_STR, RONLY,
     ieee8021MstpTable_var, 4, {1, 2, 1, 7}},
#define IEEE8021MSTPROOTPATHCOST		11
    {IEEE8021MSTPROOTPATHCOST, ASN_INTEGER, RONLY, ieee8021MstpTable_var,
     4, {1, 2, 1, 8}},
#define IEEE8021MSTPROOTPORT		12
    {IEEE8021MSTPROOTPORT, ASN_UNSIGNED, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 9}},
#define IEEE8021MSTPBRIDGEPRIORITY		13
    {IEEE8021MSTPBRIDGEPRIORITY, ASN_INTEGER, RWRITE,
     ieee8021MstpTable_var, 4, {1, 2, 1, 10}},
#define IEEE8021MSTPVIDS0		14
    {IEEE8021MSTPVIDS0, ASN_OCTET_STR, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 11}},
#define IEEE8021MSTPVIDS1		15
    {IEEE8021MSTPVIDS1, ASN_OCTET_STR, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 12}},
#define IEEE8021MSTPVIDS2		16
    {IEEE8021MSTPVIDS2, ASN_OCTET_STR, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 13}},
#define IEEE8021MSTPVIDS3		17
    {IEEE8021MSTPVIDS3, ASN_OCTET_STR, RONLY, ieee8021MstpTable_var, 4,
     {1, 2, 1, 14}},
#define IEEE8021MSTPROWSTATUS		18
    {IEEE8021MSTPROWSTATUS, ASN_INTEGER, RWRITE, ieee8021MstpTable_var, 4,
     {1, 2, 1, 15}},
#define IEEE8021MSTPCISTPORTUPTIME		19
    {IEEE8021MSTPCISTPORTUPTIME, ASN_TIMETICKS, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 3}},
#define IEEE8021MSTPCISTPORTADMINPATHCOST		20
    {IEEE8021MSTPCISTPORTADMINPATHCOST, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 4}},
#define IEEE8021MSTPCISTPORTDESIGNATEDROOT		21
    {IEEE8021MSTPCISTPORTDESIGNATEDROOT, ASN_OCTET_STR, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 5}},
#define IEEE8021MSTPCISTPORTTOPOLOGYCHANGEACK		22
    {IEEE8021MSTPCISTPORTTOPOLOGYCHANGEACK, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 6}},
#define IEEE8021MSTPCISTPORTHELLOTIME		23
    {IEEE8021MSTPCISTPORTHELLOTIME, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 7}},
#define IEEE8021MSTPCISTPORTADMINEDGEPORT		24
    {IEEE8021MSTPCISTPORTADMINEDGEPORT, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 8}},
#define IEEE8021MSTPCISTPORTOPEREDGEPORT		25
    {IEEE8021MSTPCISTPORTOPEREDGEPORT, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 9}},
#define IEEE8021MSTPCISTPORTMACENABLED		26
    {IEEE8021MSTPCISTPORTMACENABLED, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 10}},
#define IEEE8021MSTPCISTPORTMACOPERATIONAL		27
    {IEEE8021MSTPCISTPORTMACOPERATIONAL, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 11}},
#define IEEE8021MSTPCISTPORTRESTRICTEDROLE		28
    {IEEE8021MSTPCISTPORTRESTRICTEDROLE, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 12}},
#define IEEE8021MSTPCISTPORTRESTRICTEDTCN		29
    {IEEE8021MSTPCISTPORTRESTRICTEDTCN, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 13}},
#define IEEE8021MSTPCISTPORTROLE		30
    {IEEE8021MSTPCISTPORTROLE, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 14}},
#define IEEE8021MSTPCISTPORTDISPUTED		31
    {IEEE8021MSTPCISTPORTDISPUTED, ASN_INTEGER, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 15}},
#define IEEE8021MSTPCISTPORTCISTREGIONALROOTID		32
    {IEEE8021MSTPCISTPORTCISTREGIONALROOTID, ASN_OCTET_STR, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 16}},
#define IEEE8021MSTPCISTPORTCISTPATHCOST		33
    {IEEE8021MSTPCISTPORTCISTPATHCOST, ASN_UNSIGNED, RONLY,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 17}},
#define IEEE8021MSTPCISTPORTPROTOCOLMIGRATION		34
    {IEEE8021MSTPCISTPORTPROTOCOLMIGRATION, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 18}},
#define IEEE8021MSTPCISTPORTENABLEBPDURX		35
    {IEEE8021MSTPCISTPORTENABLEBPDURX, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 19}},
#define IEEE8021MSTPCISTPORTENABLEBPDUTX		36
    {IEEE8021MSTPCISTPORTENABLEBPDUTX, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 20}},
#define IEEE8021MSTPCISTPORTPSEUDOROOTID		37
    {IEEE8021MSTPCISTPORTPSEUDOROOTID, ASN_OCTET_STR, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 21}},
#define IEEE8021MSTPCISTPORTISL2GP		38
    {IEEE8021MSTPCISTPORTISL2GP, ASN_INTEGER, RWRITE,
     ieee8021MstpCistPortTable_var, 4, {1, 3, 1, 22}},
#define IEEE8021MSTPPORTUPTIME		39
    {IEEE8021MSTPPORTUPTIME, ASN_TIMETICKS, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 4}},
#define IEEE8021MSTPPORTSTATE		40
    {IEEE8021MSTPPORTSTATE, ASN_INTEGER, RONLY, ieee8021MstpPortTable_var,
     4, {1, 4, 1, 5}},
#define IEEE8021MSTPPORTPRIORITY		41
    {IEEE8021MSTPPORTPRIORITY, ASN_INTEGER, RWRITE,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 6}},
#define IEEE8021MSTPPORTPATHCOST		42
    {IEEE8021MSTPPORTPATHCOST, ASN_INTEGER, RWRITE,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 7}},
#define IEEE8021MSTPPORTDESIGNATEDROOT		43
    {IEEE8021MSTPPORTDESIGNATEDROOT, ASN_OCTET_STR, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 8}},
#define IEEE8021MSTPPORTDESIGNATEDCOST		44
    {IEEE8021MSTPPORTDESIGNATEDCOST, ASN_INTEGER, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 9}},
#define IEEE8021MSTPPORTDESIGNATEDBRIDGE		45
    {IEEE8021MSTPPORTDESIGNATEDBRIDGE, ASN_OCTET_STR, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 10}},
#define IEEE8021MSTPPORTDESIGNATEDPORT		46
    {IEEE8021MSTPPORTDESIGNATEDPORT, ASN_UNSIGNED, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 11}},
#define IEEE8021MSTPPORTROLE		47
    {IEEE8021MSTPPORTROLE, ASN_INTEGER, RONLY, ieee8021MstpPortTable_var,
     4, {1, 4, 1, 12}},
#define IEEE8021MSTPPORTDISPUTED		48
    {IEEE8021MSTPPORTDISPUTED, ASN_INTEGER, RONLY,
     ieee8021MstpPortTable_var, 4, {1, 4, 1, 13}},
#define IEEE8021MSTPFIDTOMSTIMSTID		49
    {IEEE8021MSTPFIDTOMSTIMSTID, ASN_UNSIGNED, RWRITE,
     ieee8021MstpFidToMstiTable_var, 4, {1, 5, 1, 3}},
#define IEEE8021MSTPVLANMSTID		50
    {IEEE8021MSTPVLANMSTID, ASN_UNSIGNED, RONLY, ieee8021MstpVlanTable_var,
     4, {1, 6, 1, 3}},
#define IEEE8021MSTPCONFIGIDFORMATSELECTOR		51
    {IEEE8021MSTPCONFIGIDFORMATSELECTOR, ASN_INTEGER, RWRITE,
     ieee8021MstpConfigIdTable_var, 4, {1, 7, 1, 2}},
#define IEEE8021MSTPCONFIGURATIONNAME		52
    {IEEE8021MSTPCONFIGURATIONNAME, ASN_OCTET_STR, RWRITE,
     ieee8021MstpConfigIdTable_var, 4, {1, 7, 1, 3}},
#define IEEE8021MSTPREVISIONLEVEL		53
    {IEEE8021MSTPREVISIONLEVEL, ASN_UNSIGNED, RWRITE,
     ieee8021MstpConfigIdTable_var, 4, {1, 7, 1, 4}},
#define IEEE8021MSTPCONFIGURATIONDIGEST		54
    {IEEE8021MSTPCONFIGURATIONDIGEST, ASN_OCTET_STR, RONLY,
     ieee8021MstpConfigIdTable_var, 4, {1, 7, 1, 5}},
};


/******************************************************************************/
// ucd_snmp_init_ieee8021MstpMib()
// Initializes the UCD-SNMP-part of the IEEE8021-MSTP-MIB:ieee8021MstpMib.
/******************************************************************************/
void
ucd_snmp_init_ieee8021MstpMib(void)
{
    DEBUGMSGTL(("ieee8021MstpMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021MstpMib", ieee8021MstpMib_variables, variable4,
                 ieee8021MstpMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021MstpMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
ieee8021MstpMib_var(struct variable *vp,
                    oid * name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod ** write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ieee8021MstpMib_var\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpCistTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpCistTable_parse(oid * name,
                            size_t *length,
                            int exact,
                            ieee8021MstpCistTable_entry_t * table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpCistTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpCistComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpCistTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpCistTable_fillobj(oid * name,
                              size_t *length,
                              ieee8021MstpCistTable_entry_t * table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpCistComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpCistTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpCistTable_var(struct variable * vp,
                          oid * name,
                          size_t *length,
                          int exact,
                          size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpCistTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpCistTable_parse(name, length, exact,
                                     &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpCistTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpCistTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpCistTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPCISTBRIDGEIDENTIFIER:{
            *var_len = table_entry.ieee8021MstpCistBridgeIdentifier_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpCistBridgeIdentifier, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPCISTTOPOLOGYCHANGE:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistTopologyChange;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTREGIONALROOTIDENTIFIER:{
            *var_len =
                table_entry.ieee8021MstpCistRegionalRootIdentifier_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpCistRegionalRootIdentifier,
                   *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPCISTPATHCOST:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpCistPathCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPCISTMAXHOPS:{
            *write_method = ieee8021MstpCistMaxHops_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistMaxHops;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpCistTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpTable_parse(oid * name,
                        size_t *length,
                        int exact, ieee8021MstpTable_entry_t * table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpTable_fillobj(oid * name,
                          size_t *length,
                          ieee8021MstpTable_entry_t * table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpTable_var(struct variable * vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021MSTPROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method = ieee8021MstpRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021MstpTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPBRIDGEID:{
            *var_len = table_entry.ieee8021MstpBridgeId_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpBridgeId, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPTIMESINCETOPOLOGYCHANGE:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpTimeSinceTopologyChange;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPTOPOLOGYCHANGES:{
            ieee8021MstpMib_global_ret.c64_ret =
                table_entry.ieee8021MstpTopologyChanges;
            *var_len = sizeof(ieee8021MstpMib_global_ret.c64_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.c64_ret;
        }
    case IEEE8021MSTPTOPOLOGYCHANGE:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpTopologyChange;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPDESIGNATEDROOT:{
            *var_len = table_entry.ieee8021MstpDesignatedRoot_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpDesignatedRoot, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPROOTPATHCOST:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpRootPathCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPROOTPORT:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpRootPort;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPBRIDGEPRIORITY:{
            *write_method = ieee8021MstpBridgePriority_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpBridgePriority;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPVIDS0:{
            *var_len = table_entry.ieee8021MstpVids0_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpVids0, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPVIDS1:{
            *var_len = table_entry.ieee8021MstpVids1_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpVids1, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPVIDS2:{
            *var_len = table_entry.ieee8021MstpVids2_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpVids2, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPVIDS3:{
            *var_len = table_entry.ieee8021MstpVids3_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpVids3, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPROWSTATUS:{
            *write_method = ieee8021MstpRowStatus_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpRowStatus;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpCistPortTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpCistPortTable_parse(oid * name,
                                size_t *length,
                                int exact,
                                ieee8021MstpCistPortTable_entry_t *
                                table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpCistPortTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpCistPortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpCistPortNum = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpCistPortTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpCistPortTable_fillobj(oid * name,
                                  size_t *length,
                                  ieee8021MstpCistPortTable_entry_t *
                                  table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpCistPortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpCistPortNum;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpCistPortTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpCistPortTable_var(struct variable * vp,
                              oid * name,
                              size_t *length,
                              int exact,
                              size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpCistPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpCistPortTable_parse(name, length, exact,
                                         &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpCistPortTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpCistPortTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpCistPortTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPCISTPORTUPTIME:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpCistPortUptime;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPCISTPORTADMINPATHCOST:{
            *write_method = ieee8021MstpCistPortAdminPathCost_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortAdminPathCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTDESIGNATEDROOT:{
            *var_len = table_entry.ieee8021MstpCistPortDesignatedRoot_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpCistPortDesignatedRoot,
                   *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPCISTPORTTOPOLOGYCHANGEACK:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortTopologyChangeAck;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTHELLOTIME:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortHelloTime;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTADMINEDGEPORT:{
            *write_method = ieee8021MstpCistPortAdminEdgePort_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortAdminEdgePort;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTOPEREDGEPORT:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortOperEdgePort;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTMACENABLED:{
            *write_method = ieee8021MstpCistPortMacEnabled_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortMacEnabled;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTMACOPERATIONAL:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortMacOperational;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTRESTRICTEDROLE:{
            *write_method = ieee8021MstpCistPortRestrictedRole_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortRestrictedRole;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTRESTRICTEDTCN:{
            *write_method = ieee8021MstpCistPortRestrictedTcn_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortRestrictedTcn;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTROLE:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortRole;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTDISPUTED:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortDisputed;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTCISTREGIONALROOTID:{
            *var_len =
                table_entry.ieee8021MstpCistPortCistRegionalRootId_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpCistPortCistRegionalRootId,
                   *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPCISTPORTCISTPATHCOST:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpCistPortCistPathCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPCISTPORTPROTOCOLMIGRATION:{
            *write_method = ieee8021MstpCistPortProtocolMigration_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortProtocolMigration;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTENABLEBPDURX:{
            *write_method = ieee8021MstpCistPortEnableBPDURx_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortEnableBPDURx;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTENABLEBPDUTX:{
            *write_method = ieee8021MstpCistPortEnableBPDUTx_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortEnableBPDUTx;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCISTPORTPSEUDOROOTID:{
            *write_method = ieee8021MstpCistPortPseudoRootId_write;
            *var_len = table_entry.ieee8021MstpCistPortPseudoRootId_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpCistPortPseudoRootId, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPCISTPORTISL2GP:{
            *write_method = ieee8021MstpCistPortIsL2Gp_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpCistPortIsL2Gp;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpCistPortTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpPortTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpPortTable_parse(oid * name,
                            size_t *length,
                            int exact,
                            ieee8021MstpPortTable_entry_t * table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpPortTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpPortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpPortMstId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpPortNum = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpPortTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpPortTable_fillobj(oid * name,
                              size_t *length,
                              ieee8021MstpPortTable_entry_t * table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpPortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpPortMstId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpPortNum;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpPortTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpPortTable_var(struct variable * vp,
                          oid * name,
                          size_t *length,
                          int exact,
                          size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpPortTable_parse(name, length, exact,
                                     &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpPortTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpPortTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpPortTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPPORTUPTIME:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpPortUptime;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPPORTSTATE:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortState;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPPORTPRIORITY:{
            *write_method = ieee8021MstpPortPriority_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortPriority;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPPORTPATHCOST:{
            *write_method = ieee8021MstpPortPathCost_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortPathCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPPORTDESIGNATEDROOT:{
            *var_len = table_entry.ieee8021MstpPortDesignatedRoot_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpPortDesignatedRoot, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPPORTDESIGNATEDCOST:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortDesignatedCost;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPPORTDESIGNATEDBRIDGE:{
            *var_len = table_entry.ieee8021MstpPortDesignatedBridge_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpPortDesignatedBridge, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPPORTDESIGNATEDPORT:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpPortDesignatedPort;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPPORTROLE:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortRole;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPPORTDISPUTED:{
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpPortDisputed;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpPortTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpFidToMstiTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpFidToMstiTable_parse(oid * name,
                                 size_t *length,
                                 int exact,
                                 ieee8021MstpFidToMstiTable_entry_t *
                                 table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpFidToMstiTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpFidToMstiComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpFidToMstiFid = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpFidToMstiTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpFidToMstiTable_fillobj(oid * name,
                                   size_t *length,
                                   ieee8021MstpFidToMstiTable_entry_t *
                                   table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpFidToMstiComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpFidToMstiFid;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpFidToMstiTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpFidToMstiTable_var(struct variable * vp,
                               oid * name,
                               size_t *length,
                               int exact,
                               size_t *var_len,
                               WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpFidToMstiTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpFidToMstiTable_parse(name, length, exact,
                                          &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpFidToMstiTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpFidToMstiTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpFidToMstiTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPFIDTOMSTIMSTID:{
            *write_method = ieee8021MstpFidToMstiMstId_write;
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpFidToMstiMstId;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpFidToMstiTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpVlanTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpVlanTable_parse(oid * name,
                            size_t *length,
                            int exact,
                            ieee8021MstpVlanTable_entry_t * table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpVlanTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpVlanComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021MstpVlanId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpVlanTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpVlanTable_fillobj(oid * name,
                              size_t *length,
                              ieee8021MstpVlanTable_entry_t * table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpVlanComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021MstpVlanId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpVlanTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpVlanTable_var(struct variable * vp,
                          oid * name,
                          size_t *length,
                          int exact,
                          size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpVlanTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpVlanTable_parse(name, length, exact,
                                     &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpVlanTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpVlanTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpVlanTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPVLANMSTID:{
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpVlanMstId;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpVlanTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021MstpConfigIdTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021MstpConfigIdTable_parse(oid * name,
                                size_t *length,
                                int exact,
                                ieee8021MstpConfigIdTable_entry_t *
                                table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (10 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021MstpConfigIdTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021MstpConfigIdComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021MstpConfigIdTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021MstpConfigIdTable_fillobj(oid * name,
                                  size_t *length,
                                  ieee8021MstpConfigIdTable_entry_t *
                                  table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021MstpConfigIdComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021MstpConfigIdTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021MstpMib_var above.
 */
u_char         *
ieee8021MstpConfigIdTable_var(struct variable * vp,
                              oid * name,
                              size_t *length,
                              int exact,
                              size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021MstpConfigIdTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021MstpConfigIdTable_parse(name, length, exact,
                                         &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021MstpConfigIdTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021MstpConfigIdTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021MstpConfigIdTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021MSTPCONFIGIDFORMATSELECTOR:{
            *write_method = ieee8021MstpConfigIdFormatSelector_write;
            ieee8021MstpMib_global_ret.long_ret =
                table_entry.ieee8021MstpConfigIdFormatSelector;
            *var_len = sizeof(ieee8021MstpMib_global_ret.long_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.long_ret;
        }
    case IEEE8021MSTPCONFIGURATIONNAME:{
            *write_method = ieee8021MstpConfigurationName_write;
            *var_len = table_entry.ieee8021MstpConfigurationName_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpConfigurationName, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    case IEEE8021MSTPREVISIONLEVEL:{
            *write_method = ieee8021MstpRevisionLevel_write;
            ieee8021MstpMib_global_ret.ulong_ret =
                table_entry.ieee8021MstpRevisionLevel;
            *var_len = sizeof(ieee8021MstpMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021MstpMib_global_ret.ulong_ret;
        }
    case IEEE8021MSTPCONFIGURATIONDIGEST:{
            *var_len = table_entry.ieee8021MstpConfigurationDigest_len;
            memcpy(ieee8021MstpMib_global_ret.string_ret,
                   table_entry.ieee8021MstpConfigurationDigest, *var_len);
            ieee8021MstpMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021MstpMib_global_ret.string_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021MstpConfigIdTable\n",
                    vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021MstpCistMaxHops_write()
/******************************************************************************/
int
ieee8021MstpCistMaxHops_write(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistTable_entry_t table_entry;
    static ieee8021MstpCistTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistMaxHops: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistMaxHops: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 100 || var_val_len > 4000) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistMaxHops = set_value;
            if (ieee8021MstpCistTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpBridgePriority_write()
/******************************************************************************/
int
ieee8021MstpBridgePriority_write(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpTable_entry_t table_entry;
    static ieee8021MstpTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpBridgePriority: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpBridgePriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 61440) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpBridgePriority = set_value;
            if (ieee8021MstpTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpRowStatus_write()
/******************************************************************************/
int
ieee8021MstpRowStatus_write(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpTable_entry_t table_entry;
    static ieee8021MstpTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021MstpTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpRowStatus = set_value;
            if (ieee8021MstpTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortAdminPathCost_write()
/******************************************************************************/
int
ieee8021MstpCistPortAdminPathCost_write(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortAdminPathCost: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortAdminPathCost: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 200000000) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortAdminPathCost = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortAdminEdgePort_write()
/******************************************************************************/
int
ieee8021MstpCistPortAdminEdgePort_write(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortAdminEdgePort: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortAdminEdgePort: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortAdminEdgePort: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortAdminEdgePort = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortMacEnabled_write()
/******************************************************************************/
int
ieee8021MstpCistPortMacEnabled_write(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortMacEnabled: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortMacEnabled: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortMacEnabled: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortMacEnabled = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortRestrictedRole_write()
/******************************************************************************/
int
ieee8021MstpCistPortRestrictedRole_write(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedRole: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedRole: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedRole: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortRestrictedRole = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortRestrictedTcn_write()
/******************************************************************************/
int
ieee8021MstpCistPortRestrictedTcn_write(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedTcn: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedTcn: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortRestrictedTcn: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortRestrictedTcn = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortProtocolMigration_write()
/******************************************************************************/
int
ieee8021MstpCistPortProtocolMigration_write(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortProtocolMigration: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortProtocolMigration: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortProtocolMigration: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortProtocolMigration = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortEnableBPDURx_write()
/******************************************************************************/
int
ieee8021MstpCistPortEnableBPDURx_write(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDURx: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDURx: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDURx: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortEnableBPDURx = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortEnableBPDUTx_write()
/******************************************************************************/
int
ieee8021MstpCistPortEnableBPDUTx_write(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDUTx: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDUTx: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortEnableBPDUTx: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortEnableBPDUTx = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortPseudoRootId_write()
/******************************************************************************/
int
ieee8021MstpCistPortPseudoRootId_write(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortPseudoRootId: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021MSTPMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortPseudoRootId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 8) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021MstpCistPortPseudoRootId, var_val,
                   var_val_len);
            table_entry.ieee8021MstpCistPortPseudoRootId_len = var_val_len;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpCistPortIsL2Gp_write()
/******************************************************************************/
int
ieee8021MstpCistPortIsL2Gp_write(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpCistPortTable_entry_t table_entry;
    static ieee8021MstpCistPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortIsL2Gp: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortIsL2Gp: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpCistPortIsL2Gp: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpCistPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpCistPortIsL2Gp = set_value;
            if (ieee8021MstpCistPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpCistPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpPortPriority_write()
/******************************************************************************/
int
ieee8021MstpPortPriority_write(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpPortTable_entry_t table_entry;
    static ieee8021MstpPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpPortPriority: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpPortPriority: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 240) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpPortTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpPortPriority = set_value;
            if (ieee8021MstpPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpPortPathCost_write()
/******************************************************************************/
int
ieee8021MstpPortPathCost_write(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpPortTable_entry_t table_entry;
    static ieee8021MstpPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpPortPathCost: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpPortPathCost: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 200000000) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpPortTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpPortPathCost = set_value;
            if (ieee8021MstpPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpFidToMstiMstId_write()
/******************************************************************************/
int
ieee8021MstpFidToMstiMstId_write(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    u_long          set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021MstpFidToMstiTable_entry_t table_entry;
    static ieee8021MstpFidToMstiTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpFidToMstiMstId: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpFidToMstiMstId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 4094) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpFidToMstiTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpFidToMstiTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpFidToMstiMstId = set_value;
            if (ieee8021MstpFidToMstiTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpFidToMstiTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpConfigIdFormatSelector_write()
/******************************************************************************/
int
ieee8021MstpConfigIdFormatSelector_write(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021MstpConfigIdTable_entry_t table_entry;
    static ieee8021MstpConfigIdTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpConfigIdFormatSelector: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpConfigIdFormatSelector: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len != 0) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpConfigIdFormatSelector = set_value;
            if (ieee8021MstpConfigIdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpConfigIdTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpConfigurationName_write()
/******************************************************************************/
int
ieee8021MstpConfigurationName_write(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    ieee8021MstpConfigIdTable_entry_t table_entry;
    static ieee8021MstpConfigIdTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpConfigurationName: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021MSTPMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpConfigurationName: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 32) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021MstpConfigurationName, var_val,
                   var_val_len);
            table_entry.ieee8021MstpConfigurationName_len = var_val_len;
            if (ieee8021MstpConfigIdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpConfigIdTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021MstpRevisionLevel_write()
/******************************************************************************/
int
ieee8021MstpRevisionLevel_write(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    u_long          set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021MstpConfigIdTable_entry_t table_entry;
    static ieee8021MstpConfigIdTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpRevisionLevel: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021MstpRevisionLevel: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 65535) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021MstpConfigIdTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021MstpRevisionLevel = set_value;
            if (ieee8021MstpConfigIdTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021MstpConfigIdTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}
