/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
#if 0
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#endif
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h> /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "ifIndex_api.h"
#include "inet_address.h"
#include "rfc4292_ip_forward.h"
#include "ip2_os_api.h"
#include "ip2_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#define SNMP_ASN_OCTET_STR_MAX_LEN  256  /* FIXME : Re-define it if needed */

//#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP

/*
 * The entry data structure for ipForwardNumber
 */
typedef struct {
    u_long  inetCidrRouteNumber;
    u_long  inetCidrRouteDiscards;
} ipForward_scalar_t;

/*
 * The entry data structure for inetCidrRouteTable
 */
typedef struct {
    /* Entry keys */
    long    inetCidrRouteDestType;
    char    inetCidrRouteDest[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t  inetCidrRouteDest_len;
    u_long  inetCidrRoutePfxLen;
    oid     inetCidrRoutePolicy[MAX_OID_LEN];
    size_t  inetCidrRoutePolicy_len;
    long    inetCidrRouteNextHopType;
    char    inetCidrRouteNextHop[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t  inetCidrRouteNextHop_len;

    /* Entry columns */
    long             inetCidrRouteIfIndex;
    long             inetCidrRouteType;
    long             inetCidrRouteProto;
    u_long             inetCidrRouteAge;
    u_long             inetCidrRouteNextHopAS;
    long             inetCidrRouteMetric1;
    long             inetCidrRouteMetric2;
    long             inetCidrRouteMetric3;
    long             inetCidrRouteMetric4;
    long             inetCidrRouteMetric5;
    long             inetCidrRouteStatus;
} inetCidrRouteTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid                 objid_ret[MAX_OID_LEN];
    size_t              objid_len_ret;
    u_char              ip_string_ret[4];
    u_long              ulong_ret;
} ipForward_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipForward_global_ret) */
static ipForward_return_t ipForward_global_ret; /* static variables for retuning */

/*
 * ipForward_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipForward_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 24};



/*
 * variable ipForward_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipForward mib section
 */

struct variable4 ipForward_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define INETCIDRROUTENUMBER         1
    {INETCIDRROUTENUMBER, ASN_GAUGE, RONLY, var_ipForward, 1, {6}},
#define INETCIDRROUTEIFINDEX        2
    {INETCIDRROUTEIFINDEX, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 7}},
#define INETCIDRROUTETYPE           3
    {INETCIDRROUTETYPE, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 8}},
    /* Not support
    #define INETCIDRROUTEPROTO          4
    {INETCIDRROUTEPROTO, ASN_INTEGER, RONLY, var_inetCidrRouteTable, 3, {7, 1, 9}},
    #define INETCIDRROUTEAGE            5
    {INETCIDRROUTEAGE, ASN_GAUGE, RONLY, var_inetCidrRouteTable, 3, {7, 1, 10}},
    #define INETCIDRROUTENEXTHOPAS      6
    {INETCIDRROUTENEXTHOPAS, ASN_UNSIGNED, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 11}},
    #define INETCIDRROUTEMETRIC1        7
    {INETCIDRROUTEMETRIC1, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 12}},
    #define INETCIDRROUTEMETRIC2        8
    {INETCIDRROUTEMETRIC2, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 13}},
    #define INETCIDRROUTEMETRIC3        9
    {INETCIDRROUTEMETRIC3, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 14}},
    #define INETCIDRROUTEMETRIC4        10
    {INETCIDRROUTEMETRIC4, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 15}},
    #define INETCIDRROUTEMETRIC5        11
    {INETCIDRROUTEMETRIC5, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 16}},
    */
#define INETCIDRROUTESTATUS         12
    {INETCIDRROUTESTATUS, ASN_INTEGER, RWRITE, var_inetCidrRouteTable, 3, {7, 1, 17}},
#define INETCIDRROUTEDISCARDS       13
    /* Not support
    {INETCIDRROUTEDISCARDS, ASN_COUNTER, RONLY, var_ipForward, 1, {8}},
    */
};

/*
 * Initializes the ipForward module
 */
void
init_ipForward(void)
{
    // Register mibContextTable
    mibContextTable_register(ipForward_variables_oid,
                             sizeof(ipForward_variables_oid) / sizeof(oid),
                             "IP-FORWARD-MIB : ipForward");

    DEBUGMSGTL(("ipForward", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipForward", ipForward_variables, variable4,
                 ipForward_variables_oid);

    /* place any other initialization junk you need here */
}

static u32 get_route_num( void )
{
    u32 count = 0;
    vtss_routing_entry_t tmp, *key = &tmp;

    memset(key, 0, sizeof(vtss_routing_entry_t ));

    while (VTSS_RC_OK == vtss_ip2_route_getnext(key, &tmp)) {
        count++;
    }

    return count;
}


static int
get_ipForwardScalar(ipForward_scalar_t *scalar_entry)
{

    scalar_entry->inetCidrRouteNumber = get_route_num();
    return 0;
}

/*
 * var_ipForward():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_ipForward(struct variable *vp,
              oid     *name,
              size_t  *length,
              int     exact,
              size_t  *var_len,
              WriteMethod **write_method)
{
    ipForward_scalar_t ipForward_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (get_ipForwardScalar(&ipForward_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case INETCIDRROUTENUMBER: {
        ipForward_global_ret.ulong_ret = ipForward_scalar_entry.inetCidrRouteNumber;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    /* Not support
    case INETCIDRROUTEDISCARDS: {
        ipForward_global_ret.ulong_ret = ipForward_scalar_entry.inetCidrRouteDiscards;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipForward\n", vp->magic));
    }
    return NULL;
}

static int cmp_route (vtss_routing_entry_t *data, vtss_routing_entry_t *key)
{
    int cmp;
    vtss_ipv4_network_t *key_v4_network = &key->route.ipv4_uc.network, *data_v4_network = &data->route.ipv4_uc.network;
    vtss_ipv6_network_t *key_v6_network = &key->route.ipv6_uc.network, *data_v6_network = &data->route.ipv6_uc.network;
    vtss_ipv4_t         *key_v4_dst = &key->route.ipv4_uc.destination, *data_v4_dst = &data->route.ipv4_uc.destination;
    vtss_ipv6_t         *key_v6_dst = &key->route.ipv6_uc.destination, *data_v6_dst = &data->route.ipv6_uc.destination;

    if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV6_UC && key->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC) {
        return 1;
    } else if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC && key->type == VTSS_ROUTING_ENTRY_TYPE_IPV6_UC) {
        return -1;
    }

    if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC) {
        cmp = (data_v4_network->address >  key_v4_network->address) ? 1 : (data_v4_network->address <  key_v4_network->address) ? -1 : 0;
    } else {
        cmp = memcmp (&data_v6_network->address, &key_v6_network->address, sizeof(data_v6_network->address));
    }

    if (cmp) {
        return cmp;
    }

    cmp = data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC ? (int)data_v4_network->prefix_size - (int)key_v4_network->prefix_size :
          (int)data_v6_network->prefix_size - (int)key_v6_network->prefix_size;
    if (cmp) {
        return cmp;
    }

    if ( data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC ) {
        cmp = (*data_v4_dst > *key_v4_dst) ? 1 : (*data_v4_dst < *key_v4_dst) ? -1 : 0;
    } else {
        cmp = memcmp(data_v6_dst, key_v6_dst, sizeof(vtss_ipv6_t));
    }
    return cmp;


}

static BOOL get_next_route_entry(vtss_routing_entry_t  *entry, vtss_routing_params_t *params, vtss_routing_flags_t  *flags, vtss_if_id_t *interface, BOOL next)
{
#define SIZE 2048
    u32 i, cnt = 0, cnt_v4, cnt_v6;
    BOOL found = FALSE;
    vtss_routing_status_t *rts_v4, *rts_v6, *ptr;
    vtss_routing_entry_t *tmp;

    rts_v4 = VTSS_CALLOC(SIZE, sizeof(vtss_routing_status_t));
    if ( !rts_v4 ) {
        return FALSE;
    }

    rts_v6 = VTSS_CALLOC(SIZE, sizeof(vtss_routing_status_t));
    if ( !rts_v6 ) {
        goto free_v4_return;
    }


    if (vtss_ip2_os_route_get(VTSS_ROUTING_ENTRY_TYPE_IPV4_UC, SIZE, rts_v4, &cnt_v4) != VTSS_RC_OK) {
        cnt_v4 = 0;
    }

    if (vtss_ip2_os_route_get(VTSS_ROUTING_ENTRY_TYPE_IPV6_UC, SIZE, rts_v6, &cnt_v6) != VTSS_RC_OK) {
        cnt_v6 = 0;
    }

    if ( !cnt_v4 && !cnt_v6 ) {
        goto free_v4_v6_return;
    }

    cnt = cnt_v4 + cnt_v6;

    for (i = 0, ptr = rts_v4; i < cnt; i++ ) {
        if ( i == cnt_v4 ) {
            ptr = rts_v6;
        }

        tmp = &ptr->rt;

        if ( (tmp->type != VTSS_ROUTING_ENTRY_TYPE_IPV4_UC && tmp->type != VTSS_ROUTING_ENTRY_TYPE_IPV6_UC ) ||
             ptr->interface.type != VTSS_ID_IF_TYPE_VLAN ) {
            ptr++;
            continue;
        }

        if ( (TRUE == next && cmp_route(tmp, entry) > 0 ) || ( FALSE == next && cmp_route(tmp, entry) == 0 ) ) {
            found = TRUE;
            *entry = *tmp;
            break;
        } else if (( FALSE == next && cmp_route(tmp, entry) > 0 )) {
            found = FALSE;
            break;
        }
        ptr++;
    }

    if ( TRUE == found ) {
        if (params) {
            *params = ptr->params;
        }

        if (flags) {
            *flags = ptr->flags;
        }

        if (interface) {
            *interface = ptr->interface;
        }
    }

free_v4_v6_return:
    VTSS_FREE(rts_v6);
free_v4_return:
    VTSS_FREE(rts_v4);
#undef SIZE
    return found;

}

static void route_2_inet_entry(vtss_routing_entry_t  *entry, vtss_routing_params_t *params, vtss_routing_flags_t  *flags, vtss_if_id_t *interface, inetCidrRouteTable_entry_t *table_entry)
{
    vtss_ipv4_network_t *v4_network = &entry->route.ipv4_uc.network;
    vtss_ipv6_network_t *v6_network = &entry->route.ipv6_uc.network;
    vtss_ipv4_t         *v4_nx_hop     = &entry->route.ipv4_uc.destination, n_v4_dst;
    vtss_ipv6_t         *v6_nx_hop     = &entry->route.ipv6_uc.destination;

    switch (entry->type) {
    case VTSS_ROUTING_ENTRY_TYPE_IPV4_UC:
        table_entry->inetCidrRouteDestType = table_entry->inetCidrRouteNextHopType = INET_ADDRESS_IPV4;
        table_entry->inetCidrRouteDest_len = table_entry->inetCidrRouteNextHop_len = 4;
        n_v4_dst = htonl(v4_network->address);
        memcpy(table_entry->inetCidrRouteDest, &n_v4_dst, table_entry->inetCidrRouteDest_len);
        table_entry->inetCidrRoutePfxLen = v4_network->prefix_size;
        n_v4_dst = htonl(*v4_nx_hop);
        memcpy (table_entry->inetCidrRouteNextHop, &n_v4_dst , table_entry->inetCidrRouteNextHop_len);
        break;
    case VTSS_ROUTING_ENTRY_TYPE_IPV6_UC:
        table_entry->inetCidrRouteDestType = table_entry->inetCidrRouteNextHopType = INET_ADDRESS_IPV6;
        table_entry->inetCidrRouteDest_len = table_entry->inetCidrRouteNextHop_len = 16;
        memcpy(table_entry->inetCidrRouteDest, &v6_network->address, table_entry->inetCidrRouteDest_len);
        table_entry->inetCidrRoutePfxLen = v6_network->prefix_size;
        memcpy (table_entry->inetCidrRouteNextHop, v6_nx_hop, table_entry->inetCidrRouteNextHop_len);
        break;
    default:
        break;
    }

    if (flags) {
        table_entry->inetCidrRouteType = *flags;
    }

    if (interface) {
        iftable_info_t info;
        info.type = IFTABLE_IFINDEX_TYPE_IP;
        info.if_id = interface->u.vlan;
        (void) ifIndex_get_by_interface( &info );
        table_entry->inetCidrRouteIfIndex = info.ifIndex;
    }

    table_entry->inetCidrRoutePolicy_len = 2;
    memset(table_entry->inetCidrRoutePolicy, 0, table_entry->inetCidrRoutePolicy_len);
    table_entry->inetCidrRouteType = 4;
    table_entry->inetCidrRouteStatus = 1;

}

/* Map the inet entry to route entry, if the paramter is not valid, find the next valid parmater
   */
static BOOL inet_2_route_entry(inetCidrRouteTable_entry_t *table_entry, vtss_routing_entry_t  *entry, BOOL valid )
{
    vtss_ipv4_network_t *v4_network = &entry->route.ipv4_uc.network;
    vtss_ipv6_network_t *v6_network = &entry->route.ipv6_uc.network;
    vtss_ipv4_t         *v4_nx_hop     = &entry->route.ipv4_uc.destination, n_v4_dst;
    vtss_ipv6_t         *v6_nx_hop     = &entry->route.ipv6_uc.destination;

    if ( TRUE == valid ) {
        if (table_entry->inetCidrRouteNextHopType != table_entry->inetCidrRouteDestType) {
            return FALSE;
        }

        if (table_entry->inetCidrRouteNextHopType != INET_ADDRESS_IPV4 && table_entry->inetCidrRouteNextHopType != INET_ADDRESS_IPV6) {
            return FALSE;
        }

        if (table_entry->inetCidrRouteNextHop_len != table_entry->inetCidrRouteDest_len) {
            return FALSE;
        }

        if ((table_entry->inetCidrRouteNextHopType == INET_ADDRESS_IPV4 && table_entry->inetCidrRouteNextHop_len != 4) ||
            (table_entry->inetCidrRouteNextHopType == INET_ADDRESS_IPV6 && table_entry->inetCidrRouteNextHop_len != 16)  ) {
            return FALSE;
        }
    }

    switch (table_entry->inetCidrRouteNextHopType) {
    case INET_ADDRESS_IPV4:
        entry->type = VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;
        memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
        v4_network->address = ntohl(n_v4_dst);
        v4_network->prefix_size = table_entry->inetCidrRoutePfxLen;
        memcpy(&n_v4_dst, table_entry->inetCidrRouteNextHop, table_entry->inetCidrRouteNextHop_len);
        *v4_nx_hop = ntohl(n_v4_dst);
        break;
    case INET_ADDRESS_IPV6:
        entry->type = VTSS_ROUTING_ENTRY_TYPE_IPV6_UC;
        memcpy(&v6_network->address, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
        v6_network->prefix_size = table_entry->inetCidrRoutePfxLen;
        memcpy(v6_nx_hop, table_entry->inetCidrRouteNextHop, table_entry->inetCidrRouteNextHop_len);
        break;
    default:
        break;
    }

    return TRUE;

}

static BOOL get_next_oct_str (char *addr, int addr_len)
{
    char *ptr =  addr;
    int i = 0;
    BOOL overflow = TRUE;

    for (i = addr_len; i >= 0; i-- ) {
        if (*(ptr + i) != (char)0xff ) {
            (*(ptr + i))++;
            overflow = FALSE;
            break;
        } else {
            *(ptr + i) = 0x0;
        }
    }

    return !overflow;
}

/* 1. get next dest
   2. update the provious key
   3. the following keys are all zero */
static BOOL get_next_inet_entry_dest(inetCidrRouteTable_entry_t *table_entry, vtss_routing_entry_t  *entry)
{
    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }
    switch (table_entry->inetCidrRouteDestType) {
    case INET_ADDRESS_IPV4:
        if (table_entry->inetCidrRouteDest_len < 4) {
            table_entry->inetCidrRouteDest_len = 4;
            table_entry->inetCidrRouteNextHop_len = 4;
        } else if (table_entry->inetCidrRouteDest_len > 4) {
            table_entry->inetCidrRouteDestType = INET_ADDRESS_IPV6;
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else {
            if ( FALSE == get_next_oct_str(table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len)) {
                memset(table_entry, 0, sizeof(*table_entry));
                table_entry->inetCidrRouteDestType++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, table_entry->inetCidrRouteDest_len);
        break;
    case INET_ADDRESS_IPV6:
        if (table_entry->inetCidrRouteDest_len < 16) {
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else if (table_entry->inetCidrRouteDest_len > 16) {
            return FALSE;
        } else {
            if ( FALSE == get_next_oct_str(table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len)) {
                return FALSE;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, table_entry->inetCidrRouteDest_len);
        break;
    default:
        break;
    }
    table_entry->inetCidrRoutePfxLen = 0;
    table_entry->inetCidrRouteNextHopType = 0;
    memset(table_entry->inetCidrRouteNextHop, 0, table_entry->inetCidrRouteNextHop_len);
    (void) inet_2_route_entry(table_entry, entry, FALSE);
    return TRUE;
}

/* 1. get next PfxLen
   2. update the provious key
   3. the following keys are all zero */
static BOOL get_next_inet_entry_PfxLen(inetCidrRouteTable_entry_t *table_entry, vtss_routing_entry_t  *entry)
{
    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }

    switch (table_entry->inetCidrRouteDestType) {
    case INET_ADDRESS_IPV4:
        if (table_entry->inetCidrRouteDest_len < 4) {
            table_entry->inetCidrRouteDest_len = 4;
            table_entry->inetCidrRouteNextHop_len = 4;
        } else if (table_entry->inetCidrRouteDest_len > 4) {
            table_entry->inetCidrRouteDestType = INET_ADDRESS_IPV6;
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else {
            if (table_entry->inetCidrRoutePfxLen >= 32 ) {
                (void)get_next_inet_entry_dest(table_entry, NULL);
            } else {
                table_entry->inetCidrRoutePfxLen++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, table_entry->inetCidrRouteDest_len);
        break;
    case INET_ADDRESS_IPV6:
        if (table_entry->inetCidrRouteDest_len < 16) {
            table_entry->inetCidrRouteDest_len = 16;
            table_entry->inetCidrRouteNextHop_len = 16;
        } else if (table_entry->inetCidrRouteDest_len > 16) {
            return FALSE;
        } else {
            if (table_entry->inetCidrRoutePfxLen >= 128 ) {
                if ( FALSE == get_next_inet_entry_dest(table_entry, NULL) ) {
                    return FALSE;
                }
            } else {
                table_entry->inetCidrRoutePfxLen++;
            }
            break;
        }
        memset(table_entry->inetCidrRouteDest, 0, table_entry->inetCidrRouteDest_len);
        break;
    default:
        break;
    }

    table_entry->inetCidrRouteNextHopType = 0;
    memset(table_entry->inetCidrRouteNextHop, 0, table_entry->inetCidrRouteNextHop_len);
    (void) inet_2_route_entry(table_entry, entry, FALSE);
    return TRUE;
}

static BOOL get_next_inet_entry(inetCidrRouteTable_entry_t *table_entry)
{
    vtss_routing_entry_t    entry;
    vtss_ipv4_network_t     *v4_network     = &entry.route.ipv4_uc.network;
    vtss_ipv6_network_t     *v6_network     = &entry.route.ipv6_uc.network;
    vtss_ipv4_t             n_v4_dst;
    long                    type;
    size_t                  len;
    u_long                  pfxLen;
    vtss_routing_params_t   params;
    vtss_routing_flags_t    flags;
    vtss_if_id_t            interface;

    if ( table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
        return FALSE;
    }

    if (table_entry->inetCidrRouteDestType < INET_ADDRESS_IPV4) {
        memset(&entry, 0, sizeof(entry));

    } else {

        if (table_entry->inetCidrRouteDestType == INET_ADDRESS_IPV4) {
            type    = INET_ADDRESS_IPV4;
            len     = 4;
            pfxLen   = 32;
        } else {
            type    = INET_ADDRESS_IPV6;
            len     = 16;
            pfxLen   = 128;
        }

        if ( table_entry->inetCidrRouteDest_len > len ) {
            table_entry->inetCidrRouteDestType++;
            if (table_entry->inetCidrRouteDestType > INET_ADDRESS_IPV6 ) {
                return FALSE;
            }
            memset(&entry, 0, sizeof(entry));
            entry.type = type == INET_ADDRESS_IPV6 ? VTSS_ROUTING_ENTRY_TYPE_IPV6_UC : VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;

        } else if ( table_entry->inetCidrRouteDest_len < len )  {
            memset(&entry, 0, sizeof(entry));
            entry.type = type == INET_ADDRESS_IPV6 ? VTSS_ROUTING_ENTRY_TYPE_IPV6_UC : VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;
        } else {
            if (table_entry->inetCidrRoutePfxLen > pfxLen) {
                if ( FALSE == get_next_inet_entry_dest(table_entry, &entry)) {
                    return FALSE;
                }
            } else {
                if (table_entry->inetCidrRouteNextHopType > type ) {
                    if ( FALSE == get_next_inet_entry_PfxLen(table_entry, &entry)) {
                        return FALSE;
                    }
                } else if (table_entry->inetCidrRouteNextHopType < type ) {
                    if (type == INET_ADDRESS_IPV4) {
                        entry.type = VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;
                        memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
                        v4_network->address = ntohl(n_v4_dst);
                        v4_network->prefix_size = table_entry->inetCidrRoutePfxLen;
                    } else {
                        entry.type = VTSS_ROUTING_ENTRY_TYPE_IPV6_UC;
                        memcpy(&v6_network->address, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
                        v6_network->prefix_size = table_entry->inetCidrRoutePfxLen;

                    }
                } else {
                    if (table_entry->inetCidrRouteNextHop_len > len) {
                        if ( FALSE == get_next_inet_entry_PfxLen(table_entry, &entry)) {
                            return FALSE;
                        }
                    } else if (table_entry->inetCidrRouteNextHop_len < len) {
                        if (type == INET_ADDRESS_IPV4) {
                            entry.type = VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;
                            memcpy(&n_v4_dst, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
                            v4_network->address = ntohl(n_v4_dst);
                            v4_network->prefix_size = table_entry->inetCidrRoutePfxLen;
                        } else {
                            entry.type = VTSS_ROUTING_ENTRY_TYPE_IPV6_UC;
                            memcpy(&v6_network->address, table_entry->inetCidrRouteDest, table_entry->inetCidrRouteDest_len);
                            v6_network->prefix_size = table_entry->inetCidrRoutePfxLen;

                        }
                    } else {
                        (void) inet_2_route_entry(table_entry, &entry, FALSE );
                    }
                }
            }
        }

    }

    if ( FALSE == get_next_route_entry( &entry, &params, &flags, &interface, TRUE) ) {
        return FALSE;
    }


    route_2_inet_entry( &entry, &params, &flags, &interface, table_entry);
    return TRUE;

}

static int
getfirst_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(inetCidrRouteTable_entry_t));
    return !get_next_inet_entry(table_entry);
}

static int
get_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry, BOOL getnext)
{
    vtss_routing_entry_t  entry;
    vtss_routing_params_t   params;
    vtss_routing_flags_t    flags;
    vtss_if_id_t            interface;

    if ( FALSE == getnext ) {
        if (FALSE == inet_2_route_entry(table_entry, &entry, TRUE)) {
            return 1;
        }
        if ( FALSE == get_next_route_entry( &entry, &params, &flags, &interface, FALSE) ) {
            return 1;
        }
        route_2_inet_entry( &entry, &params, &flags, &interface, table_entry);
    } else if ( FALSE == get_next_inet_entry(table_entry)) {
        return 1;
    }

    return 0;

}

static int
set_inetCidrRouteTableEntry(inetCidrRouteTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_inetCidrRouteTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         inetCidrRouteTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 9)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_inetCidrRouteTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->inetCidrRouteDestType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->inetCidrRouteDest) ? sizeof(table_entry->inetCidrRouteDest) : len;
    op_pos++;
    table_entry->inetCidrRouteDest_len = len;
    cp = (u_char *) table_entry->inetCidrRouteDest;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->inetCidrRoutePfxLen = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->inetCidrRoutePolicy) ? sizeof(table_entry->inetCidrRoutePolicy) : len;
    op_pos++;
    table_entry->inetCidrRoutePolicy_len = len;
    cp = (u_char *) table_entry->inetCidrRoutePolicy;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->inetCidrRouteNextHopType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->inetCidrRouteNextHop) ? sizeof(table_entry->inetCidrRouteNextHop) : len;
    op_pos++;
    table_entry->inetCidrRouteNextHop_len = len;
    cp = (u_char *) table_entry->inetCidrRouteNextHop;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_inetCidrRouteTable(oid     *name,
                           size_t  *length,
                           inetCidrRouteTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->inetCidrRouteDestType;
    len = (int) table_entry->inetCidrRouteDest_len;
    name[name_pos++] = (oid) table_entry->inetCidrRouteDest_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->inetCidrRouteDest[idx++];
    }
    name[name_pos++] = (oid) table_entry->inetCidrRoutePfxLen;
    len = (int) table_entry->inetCidrRoutePolicy_len;
    name[name_pos++] = (oid) table_entry->inetCidrRoutePolicy_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->inetCidrRoutePolicy[idx++];
    }
    name[name_pos++] = (oid) table_entry->inetCidrRouteNextHopType;
    len = (int) table_entry->inetCidrRouteNextHop_len;
    name[name_pos++] = (oid) table_entry->inetCidrRouteNextHop_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->inetCidrRouteNextHop[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_inetCidrRouteTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipForward above.
 */
u_char *
var_inetCidrRouteTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    inetCidrRouteTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_inetCidrRouteTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_inetCidrRouteTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_inetCidrRouteTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == INETCIDRROUTESTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_inetCidrRouteStatus;
                }
                return NULL;
            }
            if (fillobj_inetCidrRouteTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case INETCIDRROUTEIFINDEX: {
        *write_method = write_inetCidrRouteIfIndex;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteIfIndex;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTETYPE: {
        *write_method = write_inetCidrRouteType;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteType;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }

    /* Not support
    case INETCIDRROUTEPROTO: {
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteProto;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEAGE: {
        ipForward_global_ret.ulong_ret = table_entry.inetCidrRouteAge;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    case INETCIDRROUTENEXTHOPAS: {
        *write_method = write_inetCidrRouteNextHopAS;
        ipForward_global_ret.ulong_ret = table_entry.inetCidrRouteNextHopAS;
        *var_len = sizeof(ipForward_global_ret.ulong_ret);
        return (u_char *) &ipForward_global_ret.ulong_ret;
    }
    case INETCIDRROUTEMETRIC1: {
        *write_method = write_inetCidrRouteMetric1;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric1;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC2: {
        *write_method = write_inetCidrRouteMetric2;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric2;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC3: {
        *write_method = write_inetCidrRouteMetric3;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric3;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC4: {
        *write_method = write_inetCidrRouteMetric4;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric4;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    case INETCIDRROUTEMETRIC5: {
        *write_method = write_inetCidrRouteMetric5;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteMetric5;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    */
    case INETCIDRROUTESTATUS: {
        *write_method = write_inetCidrRouteStatus;
        ipForward_global_ret.long_ret = table_entry.inetCidrRouteStatus;
        *var_len = sizeof(ipForward_global_ret.long_ret);
        return (u_char *) &ipForward_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_inetCidrRouteTable\n", vp->magic));
    }
    return NULL;
}

int
write_inetCidrRouteIfIndex(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteIfIndex: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteIfIndex: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteIfIndex = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteType(int      action,
                        u_char   *var_val,
                        u_char   var_val_type,
                        size_t   var_val_len,
                        u_char   *statP,
                        oid      *name,
                        size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteType = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0  /* Not support */
int
write_inetCidrRouteNextHopAS(int      action,
                             u_char   *var_val,
                             u_char   var_val_type,
                             size_t   var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t   name_len)
{
    u_long         set_value = var_val ? *((u_long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteNextHopAS: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) { /* FIXME */
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteNextHopAS: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        /*
         * FIXME : check the valid range
         * if (set_value < min_value || set_value > max_value) {
         *  (void) snmp_log(LOG_ERR, "write to inetCidrRouteTable: bad value\n");
         *   return SNMP_ERR_WRONGVALUE;
         * }
         */
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteNextHopAS = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric1(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric1: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric1: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric1 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric2(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric2: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric2: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric2 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric3(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric3: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric3: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric3 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric4(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric4: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric4: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric4 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_inetCidrRouteMetric5(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric5: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteMetric5: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteMetric5 = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not support */

int
write_inetCidrRouteStatus(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    inetCidrRouteTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to inetCidrRouteStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_inetCidrRouteTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_inetCidrRouteTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.inetCidrRouteStatus = set_value;
        if (set_inetCidrRouteTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

