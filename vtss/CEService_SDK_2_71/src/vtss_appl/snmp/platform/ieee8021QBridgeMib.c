/*
 *
 * Vitesse Switch Software.
 *
 * Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 * Rights Reserved.
 *
 * Unpublished rights reserved under the copyright laws of the United States of
 * America, other countries and international treaties. Permission to use, copy,
 * store and modify, the software and its source code is granted. Permission to
 * integrate into other products, disclose, transmit and distribute the software
 * in an absolute machine readable format (e.g. HEX file) is also granted.  The
 * source code of the software may not be disclosed, transmitted or distributed
 * without the written permission of Vitesse. The software and its source code
 * may only be used in products utilizing the Vitesse switch products.
 *
 * This copyright notice must appear in any copy, modification, disclosure,
 * transmission or distribution of the software. Vitesse retains all ownership,
 * copyright, trade secret and proprietary rights in the software.
 *
 * THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 * INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 *
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */

#include "vtss_snmp_api.h"
#include "ieee8021QBridgeMib.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_ieee8021QBridgeMib.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_ieee8021QBridgeMib.h"
#endif                          /* SNMP_HAS_UCD_SNMP */
#include "mibContextTable.h"         // mibContextTable_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#include "vlan_api.h"
#include "mac_api.h"
#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "l2proto_api.h"

// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

#define MAC_ADDR_LEN                    6
#define IEEE8021QBRIDGECOMPONENTID      1
#define IEEE8021QBRIDGECOMPONENT_CNT    1
/*
 * for object ieee8021QBridgeVlanStatus
 * only Other and permanent are defined, in HP only permanent is required.
 */
enum {
    SNMP_VLAN_STATUS_OTHER      = 1,
    SNMP_VLAN_STATUS_PERMANENT  = 2,



};

#define IEEE8021QBRIDGEMIB_NOT_SUPPORTED       0


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/
static BOOL IEEE8021QBRIDGE_BridgeTable_entry_get(ieee8021QBridgeTable_entry_t *table_entry)
{
    uint vid, no_of_vlans;
    vlan_mgmt_entry_t  conf;

    vid = VTSS_VID_NULL;
    no_of_vlans = 0;
    while (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vid, &conf, 1, VLAN_USER_STATIC) == VTSS_OK) {
        vid = conf.vid;
        no_of_vlans++;
    }
    table_entry->ieee8021QBridgeComponentId = IEEE8021QBRIDGECOMPONENTID;
    table_entry->ieee8021QBridgeVlanVersionNumber = 2 ;
    table_entry->ieee8021QBridgeMaxSupportedVlans = VLAN_ENTRY_CNT;
    table_entry->ieee8021QBridgeMaxVlanId = VLAN_ID_MAX;
    table_entry->ieee8021QBridgeMvrpEnabledStatus = 2;
    table_entry->ieee8021QBridgeNumVlans = no_of_vlans;

    return TRUE;
}

static int IEEE8021QBRIDGE_FdbIndex_getnext( u_long *bridge_id, vtss_vid_t *vid)
{
    vlan_mgmt_entry_t   vlan_mgmt_entry;
    vtss_vid_t          tmp_vid = 0;
    u_long              tmp_bridge_id = 0;

    if (bridge_id == NULL || vid == NULL) {
        return VTSS_RC_ERROR;
    }

    if ( *bridge_id > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if ( *bridge_id  < IEEE8021QBRIDGECOMPONENTID) {
        tmp_vid = VTSS_VID_NULL;
        tmp_bridge_id = 1;;
    } else {
        tmp_vid = *vid;
        tmp_bridge_id = *bridge_id;
    }
    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, tmp_vid, &vlan_mgmt_entry, TRUE, VLAN_USER_ALL) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }
    *vid = vlan_mgmt_entry.vid;
    *bridge_id = tmp_bridge_id;

    return VTSS_RC_OK;
}

static int IEEE8021QBRIDGE_FdbIndex_get( u_long *bridge_id, vtss_vid_t *vid)
{
    vtss_vid_t          tmp_vid = *vid;
    u_long              tmp_bridge_id = *bridge_id;

    if ( *bridge_id > IEEE8021QBRIDGECOMPONENT_CNT || *bridge_id < IEEE8021QBRIDGECOMPONENTID ) {
        return VTSS_RC_ERROR;
    }
    if (*vid == VTSS_VID_NULL) {
        return VTSS_RC_ERROR;
    }
    tmp_bridge_id = *bridge_id;
    tmp_vid = *vid - 1;
    if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext( &tmp_bridge_id, &tmp_vid)) {
        return VTSS_RC_ERROR;
    }

    if (tmp_vid != *vid || tmp_bridge_id != *bridge_id) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static BOOL IEEE8021QBRIDGE_FdbTable_entry_get(ieee8021QBridgeFdbTable_entry_t *table_entry)
{
    mac_table_stats_t stats;
    mac_age_conf_t  age_conf;

    if (mac_mgmt_table_vlan_stats_get(VTSS_ISID_LOCAL, table_entry->ieee8021QBridgeFdbId, &stats) == VTSS_OK) {
        table_entry->ieee8021QBridgeFdbDynamicCount = stats.learned_total;
    }
    if (mac_mgmt_age_time_get( &age_conf) == VTSS_OK) {
        table_entry->ieee8021QBridgeFdbAgingTime = age_conf.mac_age_time;
    }
    memset(&table_entry->ieee8021QBridgeFdbLearnedEntryDiscards, 0, sizeof(struct counter64));

    return TRUE;
}

void IEEE8021QBRIDGE_TpFdbPort_get_by_port( vtss_isid_t isid, vtss_port_no_t iport, long *qTpFdbPort)
{
    dot1Port_info_t             info;
    aggr_mgmt_group_member_t    aggr_members;
    BOOL                        found = FALSE;
    aggr_mgmt_group_no_t        tmp_aggr;

    for (tmp_aggr = AGGR_MGMT_GROUP_NO_START; tmp_aggr < AGGR_MGMT_GROUP_NO_END; tmp_aggr++) {
        if ((aggr_mgmt_port_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {

            continue;
        }
        if (aggr_members.entry.member[iport] == TRUE) {
            found = TRUE;
            break;
        }
    }


    info.isid = isid;
    if ( FALSE == found ) {
        info.if_id = iport;
        info.type = DOT1PORT_TYPE_PORT;
    } else {
#if defined(HP_PROCURVE)
        aggr_mgmt_group_no_t trunk;
        (void)trunk_mgmt_aggr2trunk(isid, tmp_aggr, &trunk);
        info.if_id = trunk;
#else
        info.if_id = tmp_aggr;
#endif
        info.type = AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr) ? DOT1PORT_TYPE_GLAG : DOT1PORT_TYPE_LLAG;
    }

    if (FALSE == dot1Port_get_by_interface(&info)) {
        ;
    }

    *qTpFdbPort = info.dot1port;
}

//  Rev 19577
static BOOL IEEE8021QBRIDGE_TpFdbTable_entry_get( mac_mgmt_addr_type_t *mac_type, vtss_vid_mac_t  *vid_mac_in, ieee8021QBridgeTpFdbTable_entry_t *table_entry, BOOL getnext)
{
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    vtss_port_no_t port_no = 0;
    vtss_isid_t  isid = 0, mac_isid;
    int learned = 0;

    if (mac_mgmt_stack_get_next(vid_mac_in, &mac_entry, mac_type, getnext) == VTSS_OK) {

        table_entry->ieee8021QBridgeFdbComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeFdbId = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }

            for (port_no = VTSS_PORT_NO_START; port_no < port_isid_port_count(isid); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    learned = 1;
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
                    if (vtss_stacking_enabled()) {
                        mac_isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
                    } else {
                        mac_isid = isid;
                    }
#else
                    mac_isid = isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */
                    IEEE8021QBRIDGE_TpFdbPort_get_by_port(mac_isid, port_no, (long *)&table_entry->ieee8021QBridgeTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->ieee8021QBridgeTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->ieee8021QBridgeTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->ieee8021QBridgeTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->ieee8021QBridgeTpFdbStatus = 1;    /* other   */
        }
        return TRUE;
    } else {
        T_D("no entry");
        return FALSE;
    }
}

static void IEEE8021QBRIDGE_PortList_BF_size_get(u_long *port_count_p)
{
    dot1Port_info_t table_info;
    switch_iter_t   sit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        table_info.isid = sit.isid;
        table_info.if_id = VTSS_PORT_NO_START + port_isid_port_count(sit.isid) - 1;
        table_info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&table_info);
    }

    *port_count_p = VTSS_PORTLIST_BF_SIZE(table_info.dot1port);
}

static int IEEE8021QBRIDGE_TpGroupTable_entry_get(mac_mgmt_addr_type_t *mac_type, vtss_vid_mac_t  *vid_mac_in,
                                                  ieee8021QBridgeTpGroupTable_entry_t *table_entry, BOOL getnext)
{
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    vtss_port_no_t          port_no;

    if (mac_mgmt_stack_get_next(vid_mac_in, &mac_entry, mac_type, getnext) == VTSS_OK) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =  IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeTpGroupAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeTpGroupAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = isid;
            }
#else
            info.isid = isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;

            for (port_no = VTSS_PORT_NO_START; port_no < port_isid_port_count(isid); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeTpGroupEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeTpGroupEgressPorts, dot1port_start + port_no, 0);
                }

            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get((u_long *)&table_entry->ieee8021QBridgeTpGroupEgressPorts_len);
        table_entry->ieee8021QBridgeTpGroupLearnt_len = table_entry->ieee8021QBridgeTpGroupEgressPorts_len;
        memset(table_entry->ieee8021QBridgeTpGroupLearnt, 0, table_entry->ieee8021QBridgeTpGroupEgressPorts_len);
    } else {
        T_D("no entry");
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_StaticUnicastTableEntry_get(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    vtss_port_no_t          port_no;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->ieee8021QBridgeStaticUnicastVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->ieee8021QBridgeStaticUnicastAddress, 6);

    /* Search only for UC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if ( mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK ) {

        table_entry->ieee8021QBridgeStaticUnicastComponentId = 1;
        table_entry->ieee8021QBridgeStaticUnicastVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeStaticUnicastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeStaticUnicastAddress_len = 6;
        table_entry->ieee8021QBridgeStaticUnicastReceivePort = 0;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }
            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = isid;
            }
#else
            info.isid = isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            for (port_no = VTSS_PORT_NO_START; port_no < port_isid_port_count(isid); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts, dot1port_start + port_no, 0);
                }
            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeStaticUnicastStaticEgressPorts_len);
        table_entry->ieee8021QBridgeStaticUnicastRowStatus = 1;
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int IEEE8021QBRIDGE_mac_entry_add (vtss_vid_mac_t *vid_mac, unsigned char *portList, u_long portList_bf_size)
{
    mac_mgmt_addr_entry_t mac_entry;
    vtss_common_port_t    dot1port_start;
    u_long bf_size;
    dot1Port_info_t         info;
    port_iter_t             pit;
    switch_iter_t           sit;


    IEEE8021QBRIDGE_PortList_BF_size_get(&bf_size);
    if ( portList_bf_size > bf_size ) {
        return VTSS_RC_ERROR;
    }

    memset(&mac_entry, 0, sizeof(mac_entry));
    memcpy(&mac_entry.vid_mac, vid_mac, sizeof(vtss_vid_mac_t));
    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (VTSS_PORTLIST_BF_GET(portList, dot1port_start + pit.iport)) {
                mac_entry.destination[pit.iport] = TRUE;
            }
        }
        (void)mac_mgmt_table_add(sit.isid, &mac_entry);
    }

    return VTSS_RC_OK;
}

static int IEEE8021QBRIDGE_mac_entry_del (vtss_vid_mac_t *vid_mac, unsigned char *portList)
{
    vtss_common_port_t    dot1port_start;
    dot1Port_info_t         info;
    port_iter_t             pit;
    switch_iter_t           sit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (VTSS_PORTLIST_BF_GET(portList, dot1port_start + pit.iport)) {
                break;
            }
        }
        (void)mac_mgmt_table_del(sit.isid, vid_mac, FALSE);
    }

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_StaticMulticastTableEntry_get(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t             isid;
    vtss_port_no_t          port_no;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->ieee8021QBridgeVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->ieee8021QBridgeStaticMulticastAddress, 6);

    /* Search only for MC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if ( mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK ) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021QBridgeVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->ieee8021QBridgeStaticMulticastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->ieee8021QBridgeStaticMulticastAddress_len = 6;
        table_entry->ieee8021QBridgeStaticMulticastReceivePort = 0;


        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }
            if (mac_mgmt_table_get_next(isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = isid;
            }
#else
            info.isid = isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            for (port_no = VTSS_PORT_NO_START; port_no < port_isid_port_count(isid); port_no++) {
                if (isid_mac_entry.destination[port_no]) {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts, dot1port_start + port_no, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts, dot1port_start + port_no, 0);
                }
            }
        }
        IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeStaticMulticastStaticEgressPorts_len);
        table_entry->ieee8021QBridgeStaticMulticastRowStatus = 3;    /* permanent */
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
IEEE8021QBRIDGE_VlanCurrentTableEntry_get(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry, BOOL getnext)
{
    vlan_mgmt_entry_t   vlan_mgmt_entry;
    vlan_port_conf_t  port_conf;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    vtss_isid_t           isid;
    vtss_port_no_t        port_no;

    vlan_mgmt_entry.vid = table_entry->ieee8021QBridgeVlanIndex;

    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, getnext, VLAN_USER_ALL) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    table_entry->ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
    table_entry->ieee8021QBridgeVlanIndex = vlan_mgmt_entry.vid;
    table_entry->ieee8021QBridgeVlanFdbId = vlan_mgmt_entry.vid;
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        }
        if (vlan_mgmt_vlan_get(isid, vlan_mgmt_entry.vid, &vlan_mgmt_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
            continue;
        }

        info.isid = isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        for (port_no = VTSS_PORT_NO_START; port_no < port_isid_port_count(isid); port_no++) {
            if (vlan_mgmt_entry.ports[port_no]) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentEgressPorts, dot1port_start + port_no, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentEgressPorts, dot1port_start + port_no, 0);
            }

            if (vlan_mgmt_port_conf_get(isid, port_no, &port_conf, VLAN_USER_ALL) == VTSS_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanCurrentUntaggedPorts, dot1port_start + port_no, vlan_mgmt_vid_gets_tagged(&port_conf, vlan_mgmt_entry.vid) ? 0 : 1);
            }
        }
    }
    IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeVlanCurrentEgressPorts_len);
    table_entry->ieee8021QBridgeVlanCurrentUntaggedPorts_len = table_entry->ieee8021QBridgeVlanCurrentEgressPorts_len;
    table_entry->ieee8021QBridgeVlanStatus = 2; /* permenent */

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_VlanStaticTableEntry_get(ieee8021QBridgeVlanStaticTable_entry_t *table_entry, BOOL getnext)
{
    vlan_mgmt_entry_t  vlan_mgmt_entry;
    char               vlan_name[VLAN_NAME_MAX_LEN];
    vlan_port_conf_t   port_conf;
    dot1Port_info_t    info;
    vtss_common_port_t dot1port_start;
    port_iter_t        pit;
    switch_iter_t      sit;

    vlan_mgmt_entry.vid = table_entry->ieee8021QBridgeVlanStaticVlanIndex;

    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, getnext, VLAN_USER_ALL) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    if (vlan_mgmt_name_get(vlan_mgmt_entry.vid, vlan_name, NULL) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memset(table_entry, 0, sizeof(ieee8021QBridgeVlanStaticTable_entry_t));
    table_entry->ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
    table_entry->ieee8021QBridgeVlanStaticVlanIndex = vlan_mgmt_entry.vid;
    strcpy(table_entry->ieee8021QBridgeVlanStaticName, vlan_name);
    table_entry->ieee8021QBridgeVlanStaticName_len = strlen(vlan_name);

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vlan_mgmt_vlan_get(sit.isid, vlan_mgmt_entry.vid, &vlan_mgmt_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
            T_E("vid = %d not found", vlan_mgmt_entry.vid);
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (vlan_mgmt_entry.ports[pit.iport]) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport, 0);
            }

            if (vlan_mgmt_port_conf_get(sit.isid, pit.iport, &port_conf, VLAN_USER_STATIC) == VTSS_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts, dot1port_start + pit.iport, vlan_mgmt_vid_gets_tagged(&port_conf, vlan_mgmt_entry.vid) ? 0 : 1);
            }
        }
    }
    IEEE8021QBRIDGE_PortList_BF_size_get( (u_long *)&table_entry->ieee8021QBridgeVlanStaticEgressPorts_len);
    table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len = table_entry->ieee8021QBridgeVlanStaticEgressPorts_len;
    table_entry->ieee8021QBridgeVlanStaticRowStatus = SNMP_ROW_ACTIVE;

    return VTSS_RC_OK;
}

static int
IEEE8021QBRIDGE_PortVlanTableEntry_get(dot1Port_info_t   *info, ieee8021QBridgePortVlanTable_entry_t *table_entry)
{
    vlan_port_conf_t  port_conf;
    if (vlan_mgmt_port_conf_get(info->isid, info->if_id, &port_conf, VLAN_USER_STATIC) == VTSS_OK) {
        table_entry->ieee8021BridgeBasePortComponentId = IEEE8021QBRIDGECOMPONENTID;
        table_entry->ieee8021BridgeBasePort = info->dot1port;
        table_entry->ieee8021QBridgePvid = port_conf.pvid;
        if (port_conf.frame_type == VTSS_VLAN_FRAME_ALL) {
            table_entry->ieee8021QBridgePortAcceptableFrameTypes = 1;   /* admitAll */
        } else {
            table_entry->ieee8021QBridgePortAcceptableFrameTypes = 2;   /* adminOnlyVlanTagged  */
        }
        if (port_conf.ingress_filter) {
            table_entry->ieee8021QBridgePortIngressFiltering = 1;    /* TRUE  */
        } else {
            table_entry->ieee8021QBridgePortIngressFiltering = 2;    /* FALSE */
        }
        return 0;
    }

    return 1;
}


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-Q-BRIDGE-MIB:ieee8021QBridgeMib.
  **/
void
ieee8021QBridgeMib_init(void)
{
    oid             ieee8021QBridgeMib_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 4 };

    T_D("enter");

    // Register mibContextTable
    mibContextTable_register(ieee8021QBridgeMib_oid,
                             sizeof(ieee8021QBridgeMib_oid) / sizeof(oid),
                             "IEEE8021-Q-BRIDGE-MIB : ieee8021QBridgeMib");

#if defined(SNMP_HAS_UCD_SNMP)
    ucd_snmp_init_ieee8021QBridgeMib();
#elif defined(SNMP_HAS_NET_SNMP)
    net_snmp_init_ieee8021QBridgeMib();
#endif                          /* SNMP_HAS_UCD_SNMP */

    T_D("exit");
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get scalar data of ieee8021QBridgeVlanScalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanScalar_get(ieee8021QBridgeVlan_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set scalar data of ieee8021QBridgeVlanScalar
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanScalar_set(ieee8021QBridgeVlan_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_getfirst(ieee8021QBridgeTable_entry_t *
                                   table_entry)
{
    T_D("enter");

    if (!IEEE8021QBRIDGE_BridgeTable_entry_get(table_entry)) {
        return 1;
    }

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_get(ieee8021QBridgeTable_entry_t *table_entry,
                              int getnext)
{
    ieee8021QBridgeTable_entry_t buf;

    T_D("enter");

    if (getnext) {
        if (table_entry->ieee8021QBridgeComponentId >= IEEE8021QBRIDGECOMPONENT_CNT) {
            return -1;
        }
        buf.ieee8021QBridgeComponentId = IEEE8021QBRIDGECOMPONENTID;
    }  else {
        buf.ieee8021QBridgeComponentId = IEEE8021QBRIDGECOMPONENTID;
    }

    if (!IEEE8021QBRIDGE_BridgeTable_entry_get(&buf)) {
        return -1;
    }

    memcpy(table_entry, &buf, sizeof(ieee8021QBridgeTable_entry_t));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTableEntry_set(ieee8021QBridgeTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_getfirst
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_get
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeCVlanPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeCVlanPortTableEntry_set
(ieee8021QBridgeCVlanPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/**
  * \brief Get first table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_getfirst(ieee8021QBridgeFdbTable_entry_t *
                                      table_entry)
{
    ieee8021QBridgeFdbTable_entry_t buf;
    u_long              tmp_bridge_id = 0;
    vtss_vid_t          tmp_vid = VTSS_VID_NULL;

    T_D("enter");

    if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext(&tmp_bridge_id, &tmp_vid)) {
        return -1;
    }

    buf.ieee8021QBridgeFdbComponentId   = tmp_bridge_id;
    buf.ieee8021QBridgeFdbId            = tmp_vid;
    (void) IEEE8021QBRIDGE_FdbTable_entry_get(&buf);
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_get(ieee8021QBridgeFdbTable_entry_t *
                                 table_entry, int getnext)
{
    ieee8021QBridgeFdbTable_entry_t buf;
    u_long              tmp_bridge_id = table_entry->ieee8021QBridgeFdbComponentId;
    vtss_vid_t          tmp_vid = table_entry->ieee8021QBridgeFdbId ;

    T_D("enter");
    if (TRUE == getnext) {
        if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_getnext(&tmp_bridge_id, &tmp_vid)) {
            return -1;
        }

    } else {
        if ( VTSS_RC_OK != IEEE8021QBRIDGE_FdbIndex_get(&tmp_bridge_id, &tmp_vid)) {
            return -1;
        }
    }

    buf.ieee8021QBridgeFdbComponentId   = tmp_bridge_id;
    buf.ieee8021QBridgeFdbId            = tmp_vid;
    (void) IEEE8021QBRIDGE_FdbTable_entry_get(&buf);
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeFdbTableEntry_set(ieee8021QBridgeFdbTable_entry_t *
                                 table_entry)
{
    mac_age_conf_t age_conf;

    T_D("enter");

    if ( VTSS_RC_OK != mac_mgmt_age_time_get(&age_conf) ) {
        return -1;
    }
    age_conf.mac_age_time = table_entry->ieee8021QBridgeFdbAgingTime;

    if ( VTSS_RC_OK != mac_mgmt_age_time_set(&age_conf) ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeTpFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpFdbTableEntry_getfirst(ieee8021QBridgeTpFdbTable_entry_t *
                                        table_entry)
{
    vtss_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    memset(&vid_mac, 0, sizeof(vid_mac));
    if ( FALSE == IEEE8021QBRIDGE_TpFdbTable_entry_get(&mac_type, &vid_mac, table_entry, TRUE)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTpFdbTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpFdbTableEntry_get(ieee8021QBridgeTpFdbTable_entry_t *
                                   table_entry, int getnext)
{
    vtss_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if (table_entry->ieee8021QBridgeFdbComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeFdbComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            vid_mac.vid = 0;
            memset(vid_mac.mac.addr, 0, 6);
        }
    } else {
        vid_mac.vid = table_entry->ieee8021QBridgeFdbId;
        memcpy(vid_mac.mac.addr, table_entry->ieee8021QBridgeTpFdbAddress, 6);
    }

    if ( FALSE == IEEE8021QBRIDGE_TpFdbTable_entry_get(&mac_type, &vid_mac, table_entry, getnext)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeTpGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpGroupTableEntry_getfirst
(ieee8021QBridgeTpGroupTable_entry_t *table_entry)
{
    vtss_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 1;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    memset(&vid_mac, 0, sizeof(vid_mac));
    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_TpGroupTable_entry_get(&mac_type, &vid_mac, table_entry, TRUE)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeTpGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeTpGroupTableEntry_get(ieee8021QBridgeTpGroupTable_entry_t *
                                     table_entry, int getnext)
{
    vtss_vid_mac_t vid_mac;
    mac_mgmt_addr_type_t mac_type;

    T_D("enter");

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 1;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            vid_mac.vid = 0;
            memset(vid_mac.mac.addr, 0, 6);
        }
    } else {
        vid_mac.vid = table_entry->ieee8021QBridgeVlanIndex;
        memcpy(vid_mac.mac.addr, table_entry->ieee8021QBridgeTpGroupAddress, 6);
    }

    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_TpGroupTable_entry_get(&mac_type, &vid_mac, table_entry, getnext)) {
        return -1;
    }

    T_D("exit");
    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_getfirst
(ieee8021QBridgeForwardAllTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_get
(ieee8021QBridgeForwardAllTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeForwardAllTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardAllTableEntry_set
(ieee8021QBridgeForwardAllTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_getfirst
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_get
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeForwardUnregisteredTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeForwardUnregisteredTableEntry_set
(ieee8021QBridgeForwardUnregisteredTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/**
  * \brief Get first table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_getfirst
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry)
{
    ieee8021QBridgeStaticUnicastTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (IEEE8021QBRIDGE_StaticUnicastTableEntry_get(&buf, TRUE)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_get
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeStaticUnicastTable_entry_t buf;

    T_D("enter");

    if (table_entry->ieee8021QBridgeStaticUnicastComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021QBridgeStaticUnicastComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeStaticUnicastComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeStaticUnicastReceivePort = 0;
            buf.ieee8021QBridgeStaticUnicastVlanIndex = 0;
            memset(buf.ieee8021QBridgeStaticUnicastAddress, 0, 6);
        }
    } else if (table_entry->ieee8021QBridgeStaticUnicastReceivePort != 0 && FALSE == getnext ) {
        return -1;
    } else {
        buf.ieee8021QBridgeStaticUnicastComponentId = table_entry->ieee8021QBridgeStaticUnicastComponentId;
        buf.ieee8021QBridgeStaticUnicastReceivePort = 0;
        buf.ieee8021QBridgeStaticUnicastVlanIndex = table_entry->ieee8021QBridgeStaticUnicastVlanIndex;
        memcpy(buf.ieee8021QBridgeStaticUnicastAddress, table_entry->ieee8021QBridgeStaticUnicastAddress, 6);
    }

    if ( IEEE8021QBRIDGE_StaticUnicastTableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeStaticUnicastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticUnicastTableEntry_set
(ieee8021QBridgeStaticUnicastTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_getfirst
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry)
{
    ieee8021QBridgeStaticMulticastTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (IEEE8021QBRIDGE_StaticMulticastTableEntry_get(&buf, TRUE)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_get
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry,
 int getnext)
{
    ieee8021QBridgeStaticMulticastTable_entry_t buf;

    T_D("enter");

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeStaticMulticastReceivePort = 0;
            buf.ieee8021QBridgeVlanIndex = 0;
            memset(buf.ieee8021QBridgeStaticMulticastAddress, 0, 6);
        }
    } else if (table_entry->ieee8021QBridgeStaticMulticastReceivePort != 0 && FALSE == getnext ) {
        return -1;
    } else {
        buf.ieee8021QBridgeVlanCurrentComponentId = table_entry->ieee8021QBridgeVlanCurrentComponentId;
        buf.ieee8021QBridgeStaticMulticastReceivePort = table_entry->ieee8021QBridgeStaticMulticastReceivePort;
        buf.ieee8021QBridgeVlanIndex = table_entry->ieee8021QBridgeVlanIndex;
        memcpy(buf.ieee8021QBridgeStaticMulticastAddress, table_entry->ieee8021QBridgeStaticMulticastAddress, 6);
    }

    if (IEEE8021QBRIDGE_StaticMulticastTableEntry_get(&buf, getnext)) {
        return -1;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeStaticMulticastTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeStaticMulticastTableEntry_set
(ieee8021QBridgeStaticMulticastTable_entry_t *table_entry)
{
    vtss_vid_mac_t          vid_mac;
    vid_mac.vid = table_entry->ieee8021QBridgeVlanIndex;
    ieee8021QBridgeStaticMulticastTable_entry_t buf;

    T_D("enter");

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ||
        table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID ) {
        return -1;
    }

    if (0 == (table_entry->ieee8021QBridgeStaticMulticastAddress[0] & 0x1)) {
        return -1;
    }

    memcpy(vid_mac.mac.addr, table_entry->ieee8021QBridgeStaticMulticastAddress, table_entry->ieee8021QBridgeStaticMulticastAddress_len);
    if ( table_entry->ieee8021QBridgeStaticMulticastRowStatus == 1 || table_entry->ieee8021QBridgeStaticMulticastRowStatus == 4 ) {
        return IEEE8021QBRIDGE_mac_entry_add(&vid_mac, (unsigned char *)table_entry->ieee8021QBridgeStaticMulticastForbiddenEgressPorts,
                                             table_entry->ieee8021QBridgeStaticMulticastForbiddenEgressPorts_len);
    }
    if ( table_entry->ieee8021QBridgeStaticMulticastRowStatus == 6 ) {
        memcpy(&buf, table_entry, sizeof(buf));
        if (VTSS_RC_OK != IEEE8021QBRIDGE_StaticMulticastTableEntry_get(&buf, FALSE)) {
            return -1;
        }
        return IEEE8021QBRIDGE_mac_entry_del(&vid_mac, (unsigned char *) buf.ieee8021QBridgeStaticMulticastForbiddenEgressPorts);
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeVlanCurrentTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanCurrentTableEntry_getfirst
(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry)
{
    ieee8021QBridgeVlanCurrentTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_VlanCurrentTableEntry_get(&buf, TRUE)) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeVlanCurrentTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanCurrentTableEntry_get
(ieee8021QBridgeVlanCurrentTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeVlanCurrentTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));

    if (table_entry->ieee8021QBridgeVlanTimeMark > 0 || table_entry->ieee8021QBridgeVlanCurrentComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021QBridgeVlanCurrentComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return VTSS_RC_ERROR;
        } else {
            buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeVlanIndex = 0;
        }
    } else {
        buf.ieee8021QBridgeVlanCurrentComponentId = IEEE8021QBRIDGECOMPONENTID;
        buf.ieee8021QBridgeVlanIndex = table_entry->ieee8021QBridgeVlanIndex;
    }

    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_VlanCurrentTableEntry_get(&buf, getnext)) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_getfirst
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry)
{
    ieee8021QBridgeVlanStaticTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    buf.ieee8021QBridgeVlanStaticVlanIndex = 0;
    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_VlanStaticTableEntry_get(&buf, TRUE)) {
        return -1;
    }

    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_get
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry, int getnext)
{
    ieee8021QBridgeVlanStaticTable_entry_t buf;

    T_D("enter");

    memset(&buf, 0, sizeof(buf));
    if ( table_entry->ieee8021QBridgeVlanStaticComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return -1;
    }

    if (table_entry->ieee8021QBridgeVlanStaticComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return -1;
        } else {
            buf.ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
            buf.ieee8021QBridgeVlanStaticVlanIndex = 0;
        }
    } else {
        buf.ieee8021QBridgeVlanStaticComponentId = IEEE8021QBRIDGECOMPONENTID;
        buf.ieee8021QBridgeVlanStaticVlanIndex = table_entry->ieee8021QBridgeVlanStaticVlanIndex;
    }

    if (VTSS_RC_ERROR == IEEE8021QBRIDGE_VlanStaticTableEntry_get(&buf, getnext)) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021QBridgeVlanStaticTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeVlanStaticTableEntry_set
(ieee8021QBridgeVlanStaticTable_entry_t *table_entry)
{
    vlan_mgmt_entry_t  vlan_entry;
    char               vlan_name[VLAN_NAME_MAX_LEN];
    u_long             bf_size;
    dot1Port_info_t    info;
    vtss_common_port_t dot1port_start;
    port_iter_t        pit;
    switch_iter_t      sit;

    T_D("enter");

    if (table_entry->ieee8021QBridgeVlanStaticComponentId > IEEE8021QBRIDGECOMPONENT_CNT ||
        table_entry->ieee8021QBridgeVlanStaticComponentId < IEEE8021QBRIDGECOMPONENTID ) {
        return -1;
    }

    IEEE8021QBRIDGE_PortList_BF_size_get(&bf_size);
    if (table_entry->ieee8021QBridgeVlanStaticEgressPorts_len > bf_size) {
        return -1;
    }

    vlan_entry.vid = table_entry->ieee8021QBridgeVlanStaticVlanIndex;

    if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 4) {

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            memset(vlan_entry.ports, 0, sizeof(vlan_entry.ports));
            if (vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VLAN_USER_STATIC) != VTSS_RC_OK) {
                return -1;
            }
        }
    } else if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 6) {
        vlan_name[0] = '\0';
        (void)vlan_mgmt_vlan_del(VTSS_ISID_GLOBAL, table_entry->ieee8021QBridgeVlanStaticVlanIndex, VLAN_USER_STATIC);
        (void)vlan_mgmt_name_set(vlan_entry.vid, vlan_name);
    } else if (table_entry->ieee8021QBridgeVlanStaticRowStatus == 1) {
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            info.isid = sit.isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void)dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (VTSS_PORTLIST_BF_GET(table_entry->ieee8021QBridgeVlanStaticEgressPorts, dot1port_start + pit.iport)) {
                    vlan_entry.ports[pit.iport] = TRUE;
                } else {
                    vlan_entry.ports[pit.iport] = FALSE;
                }
            }
            (void)vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VLAN_USER_STATIC);

            strncpy(vlan_name, table_entry->ieee8021QBridgeVlanStaticName, sizeof(vlan_name) - 1);
            vlan_name[MIN(table_entry->ieee8021QBridgeVlanStaticName_len, sizeof(vlan_name) - 1)] = '\0';
            (void)vlan_mgmt_name_set(vlan_entry.vid, vlan_name);


        }
    }

    T_D("exit");
    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeNextFreeLocalVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeNextFreeLocalVlanTableEntry_getfirst
(ieee8021QBridgeNextFreeLocalVlanTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeNextFreeLocalVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeNextFreeLocalVlanTableEntry_get
(ieee8021QBridgeNextFreeLocalVlanTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

// Getfirst table entry of ieee8021QBridgePortVlanTableEntry
// Return 0 if access success, non-zero value otherwise.
int
ieee8021QBridgePortVlanTableEntry_getfirst
(ieee8021QBridgePortVlanTable_entry_t *table_entry)
{
    dot1Port_info_t   info;
    ieee8021QBridgePortVlanTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));
    info.dot1port = DOT1PORT_NO_NONE;
    (void) dot1Port_get_next(&info);
    if ( VTSS_RC_ERROR == IEEE8021QBRIDGE_PortVlanTableEntry_get(&info, &buf)) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));
    return VTSS_RC_OK;

}

// Get or Getnext table entry of ieee8021QBridgePortVlanTableEntry
// Return 0 if access success, non-zero value otherwise.
int
ieee8021QBridgePortVlanTableEntry_get(ieee8021QBridgePortVlanTable_entry_t
                                      * table_entry, int getnext)
{
    dot1Port_info_t   info;
    ieee8021QBridgePortVlanTable_entry_t buf;

    memset(&buf, 0, sizeof(buf));
    if ( table_entry->ieee8021BridgeBasePortComponentId > IEEE8021QBRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if (table_entry->ieee8021BridgeBasePortComponentId < IEEE8021QBRIDGECOMPONENTID) {
        if (FALSE == getnext) {
            return VTSS_RC_ERROR;
        } else {
            info.dot1port = 0;
        }
    } else {
        info.dot1port = table_entry->ieee8021BridgeBasePort;
    }

    if (getnext) {
        if (FALSE == dot1Port_get_next(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if (FALSE == dot1Port_get(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    }

    if ( VTSS_RC_ERROR == IEEE8021QBRIDGE_PortVlanTableEntry_get(&info, &buf)) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &buf, sizeof(buf));
    return VTSS_RC_OK;
}

/**
  * \brief Set table entry of ieee8021QBridgePortVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanTableEntry_set(ieee8021QBridgePortVlanTable_entry_t
                                      * table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgePortVlanStatisticsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanStatisticsTableEntry_getfirst
(ieee8021QBridgePortVlanStatisticsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgePortVlanStatisticsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgePortVlanStatisticsTableEntry_get
(ieee8021QBridgePortVlanStatisticsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/**
  * \brief Get first table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_getfirst
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_get
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeLearningConstraintsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintsTableEntry_set
(ieee8021QBridgeLearningConstraintsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_getfirst
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_get
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry,
 int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeLearningConstraintDefaultsTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
(ieee8021QBridgeLearningConstraintDefaultsTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_getfirst
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_get
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeProtocolGroupTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolGroupTableEntry_set
(ieee8021QBridgeProtocolGroupTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get first table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_getfirst
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_get
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set table entry of ieee8021QBridgeProtocolPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021QBridgeProtocolPortTableEntry_set
(ieee8021QBridgeProtocolPortTable_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

