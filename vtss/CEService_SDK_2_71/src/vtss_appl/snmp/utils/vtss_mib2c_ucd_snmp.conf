######################################################################
## Do the .h file for initialize MIB and data access
######################################################################
@open ${name}.h@
/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40

#ifndef _$name.uc_H_
#define _$name.uc_H_


#define $name.uc_STR_LEN_MAX    63  // FIXME: Redefine a sufficient value for saving the memory
#define $name.uc_OID_LEN_MAX    16  // FIXME: Redefine a sufficient value for saving the memory
#define $name.uc_BITS_LEN_MAX   4   // FIXME: Redefine a sufficient value for saving the memory


/******************************************************************************/
//
// Data structure declarations
//
/******************************************************************************/
@eval $scalar_parent = "''"@
@foreach $i scalar@
    @if $scalar_parent ne $i.parent@
        @if $scalar_parent@
} ${scalar_parent}_scalar_t;
        @end@
        @eval $scalar_parent = "$i.parent"@

// The scalar data structure for ${i}
typedef struct {
    @end@
    @if $i.needlength@
        @if $i.type eq "ASN_OBJECT_ID"@
    $i.decl ${i}[$name.uc_OID_LEN_MAX];
        @else@
            @if $i.syntax eq "MacAddress"@
    $i.decl ${i}[6];
            @else@
    $i.decl ${i}[$name.uc_STR_LEN_MAX + 1];
            @end@
        @end@
    size_t  ${i}_len;
    @elsif $i.type eq "ASN_COUNTER64"@
    struct counter64    $i;
    @else@
    $i.decl $i;
    @end@
@end@
@if $scalar_parent@
} ${scalar_parent}_scalar_t;
@end@

@foreach $i table@

// The table entry data structure for ${i}
typedef struct {
    // Entry keys
    @foreach $idx index@
        @if $idx.needlength@
            @if $idx.type eq "ASN_OBJECT_ID"@
    $idx.decl   ${idx}[$name.uc_OID_LEN_MAX];
            @else@
                @if $idx.syntax eq "MacAddress"@
    $idx.decl   ${idx}[6];
                @else@
    $idx.decl   ${idx}[$name.uc_STR_LEN_MAX + 1];
                @end@
            @end@
    size_t  ${idx}_len;
        @else@
    $idx.decl   $idx;
        @end@
    @end@

    // Entry columns
    @foreach $c nonindex@
        @if $c.needlength@
            @if $c.type eq "ASN_OBJECT_ID"@
    $c.decl ${c}[$name.uc_OID_LEN_MAX + 1];
            @else@
                @if $c.syntax eq "MacAddress"@
    $c.decl ${c}[6];
                @elsif $c.syntax eq "BITS"@
    $c.decl ${c}[$name.uc_BITS_LEN_MAX];
                @else@
    $c.decl ${c}[$name.uc_STR_LEN_MAX + 1];
                @end@
            @end@
    size_t  ${c}_len;
        @elsif $c.type eq "ASN_COUNTER64"@
    struct counter64    $c;
        @else@
    $c.decl $c;
        @end@
    @end@
} ${i}_entry_t;
@end@


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the $name.module:$name.
  **/
void ${name}_init(void);
@eval $has_same_name = 0@
@foreach $i table@
    @if $i eq $name@
        @eval $has_same_name = 1@
    @end@
@end@
@if $has_same_name == 0@


/******************************************************************************/
//
// Scalar access function declarations
//
/******************************************************************************/
    @eval $scalar_parent = "''"@
    @foreach $i scalar@
        @if $scalar_parent ne $i.parent@
            @eval $scalar_parent = "$i.parent"@
/**
  * \brief Get scalar data of ${scalar_parent}Scalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${scalar_parent}Scalar_get(${scalar_parent}_scalar_t *scalar_entry);

/**
  * \brief Set scalar data of ${scalar_parent}Scalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${scalar_parent}Scalar_set(${scalar_parent}_scalar_t *scalar_entry);
        @end@
    @end@
@end@


/******************************************************************************/
//
// Table entry access function declarations
//
/******************************************************************************/
@foreach $i table@
/**
  * \brief Get first table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_getfirst(${i}_entry_t *table_entry);

/**
  * \brief Get/Getnext table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_get(${i}_entry_t *table_entry, int getnext);

    @eval $has_rw_column = 0@
    @foreach $c column@
        @if $c.settable@
            @eval $has_rw_column = 1@
        @end@
    @end@
    @if $has_rw_column != 0@
/**
  * \brief Set table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_set(${i}_entry_t *table_entry);
    @end@
@end@

#endif /* _$name.uc_H_ */

@close ${name}.h@


######################################################################
## Do the .c file for initialize MIB and data access
######################################################################
@open ${name}.c@
/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */

#include "vtss_snmp_api.h"
#include "${name}.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_${name}.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_${name}.h"
#endif /* SNMP_HAS_UCD_SNMP */
@if $name ne "mibContextTable"@
#include "mibContextTable.h" // mibContextTable_register()
// FIXME: Remove the include file if your implementation don't need to redefine the standard standard MIB objects
#include "snmp_mib_redefine.h"  // snmp_mib_redefine_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
@end@

// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the $name.module:$name.
  **/
void ${name}_init(void)
{
    T_D("enter");
#if defined(SNMP_HAS_UCD_SNMP)
    ucd_snmp_init_${name}();
#elif defined(SNMP_HAS_NET_SNMP)
    net_snmp_init_${name}();
#endif /* SNMP_HAS_UCD_SNMP */

#if 0 // FIXME: Remove whole block(#if0 - #endif) if your implementation don't need to redefine the standard MIB objects
    /* Register snmpMibRedefineTable */
@eval $magic = 0@
@eval $namelen = length("$name.commaoid")@
@foreach $i scalar@
    @eval $magic = $magic + 1@
    @eval $suffix = substr("$i.commaoid", $namelen + 1)@
    @eval $suffixlen = $i.oidlength - $name.oidlength@
    @if $i.settable@

    // $i
    oid ${i}_variables_oid[] = { $name.commaoid, $suffix };
    snmp_mib_redefine_register(${i}_variables_oid,
                               sizeof(${i}_variables_oid) / sizeof(oid),
                               "$name.module : $i",
                               "$i.syntax",
                @if $i.creatable@
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                @else@
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                @end@
                               FALSE,
                @if $i.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $i.ranges@
                    @foreach $min $max range $i@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
    @end@
    @if !$i.settable@

    // $i
    oid ${i}_variables_oid[] = { $name.commaoid, $suffix };
    snmp_mib_redefine_register(${i}_variables_oid,
                               sizeof(${i}_variables_oid) / sizeof(oid),
                               "$name.module : $i",
                               "$i.syntax",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                @if $i.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $i.ranges@
                    @foreach $min $max range $i@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
    @end@
@end@

@foreach $i table@
    @eval $suffix = ""@
    @if substr("$i.commaoid", $namelen + 1)@
        @eval $suffix = substr("$i.commaoid", $namelen + 1)@
    @end@
    @eval $suffixlen = $i.oidlength - $name.oidlength + 2@
    @foreach $c column@
        @if $c.noaccess@
            @next@
        @end@
        @eval $magic = $magic + 1@
        @if $suffix != ""@
            @if $c.settable@

    // $c
    oid ${c}_variables_oid[] = { $name.commaoid, $suffix, 1, $c.subid };
    snmp_mib_redefine_register(${c}_variables_oid,
                               sizeof(${c}_variables_oid) / sizeof(oid),
                               "$name.module : $c",
                               "$c.syntax",
                @if $c.creatable@
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                @else@
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                @end@
                               FALSE,
                @if $c.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $c.ranges@
                    @foreach $min $max range $c@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
            @end@
            @if !$c.settable@

    // $c
    oid ${c}_variables_oid[] = { $name.commaoid, $suffix, 1, $c.subid };
    snmp_mib_redefine_register(${c}_variables_oid,
                               sizeof(${c}_variables_oid) / sizeof(oid),
                               "$name.module : $c",
                               "$c.syntax",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                @if $c.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $c.ranges@
                    @foreach $min $max range $c@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
            @end@
        @else@
            @if $c.settable@

    // $c
    oid ${c}_variables_oid[] = { $name.commaoid, 1, $c.subid };
    snmp_mib_redefine_register(${c}_variables_oid,
                               sizeof(${c}_variables_oid) / sizeof(oid),
                               "$name.module : $c",
                               "$c.syntax",
                @if $c.creatable@
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                               SNMP_MIB_ACCESS_TYPE_RCREATE,
                @else@
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                @end@
                               FALSE,
                @if $c.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $c.ranges@
                    @foreach $min $max range $c@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
            @end@
            @if !$c.settable@

    // $c
    oid ${c}_variables_oid[] = { $name.commaoid, 1, $c.subid };
    snmp_mib_redefine_register(${c}_variables_oid,
                               sizeof(${c}_variables_oid) / sizeof(oid),
                               "$name.module : $c",
                               "$c.syntax",
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               SNMP_MIB_ACCESS_TYPE_RONLY,
                               FALSE,
                @if $c.enums@
                               "\
                    @foreach $l, $v enum@
{$v $l} \
                    @end@
");
                @elsif $c.ranges@
                    @foreach $min $max range $c@
                               "{$min $max}");
                    @end@
                @else@
                               "");
                @end@
            @end@
        @end@
    @end@
@end@

#endif

    // FIXME: Place any other initialization you need here

    T_D("exit");
}
@eval $has_same_name = 0@
@foreach $i table@
    @if $i eq $name@
        @eval $has_same_name = 1@
    @end@
@end@
@if $has_same_name == 0@


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/
    @eval $scalar_parent = "''"@
    @foreach $i scalar@
        @if $scalar_parent ne $i.parent@
            @eval $scalar_parent = "$i.parent"@
/**
  * \brief Get scalar data of ${scalar_parent}Scalar.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to get the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${scalar_parent}Scalar_get(${scalar_parent}_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Set scalar data of ${scalar_parent}Scalar
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the scalar
  *                              entry to set the scalar data.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${scalar_parent}Scalar_set(${scalar_parent}_scalar_t *scalar_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}
        @end@
    @end@
@end@


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
@foreach $i table@
/**
  * \brief Get first table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_getfirst(${i}_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

/**
  * \brief Get/Getnext table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_get(${i}_entry_t *table_entry, int getnext)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

    @eval $has_rw_column = 0@
    @foreach $c column@
        @if $c.settable@
            @eval $has_rw_column = 1@
        @end@
    @end@
    @if $has_rw_column != 0@
/**
  * \brief Set table entry of ${i}Entry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int ${i}Entry_set(${i}_entry_t *table_entry)
{
    T_D("enter");

    // FIXME: Return 0 if the operation success, non-zero value otherwise.

    T_D("exit");
    return -1;
}

    @end@
@end@

@close ${name}.c@


######################################################################
## Do the .h file for UCD-SNMP core engine
######################################################################
@open ucd_snmp_${name}.h@
/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40

#ifndef _UCD_SNMP_$name.uc_H_
#define _UCD_SNMP_$name.uc_H_


/******************************************************************************/
// ucd_snmp_init_${name}()
// Initializes the UCD-SNMP-part of the $name.module:$name.
/******************************************************************************/
void ucd_snmp_init_${name}(void);

#endif /* _UCD_SNMP_$name.uc_H_ */

@close ucd_snmp_${name}.h@


######################################################################
## Do the .c file for UCD-SNMP core engine
######################################################################
@open ucd_snmp_${name}.c@
/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <ucd-snmp/config.h>              /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>             /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h> /* For header_generic() */

#include "ucd_snmp_${name}.h"
#include "${name}.h"
#include "ucd_snmp_callout.h"   // ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


// #define $name.uc_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define $name.uc_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define $name.uc_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
@eval $int_type_cnt = 0@
@eval $str_type_cnt = 0@
@eval $objid_type_cnt = 0@
@eval $ipaddr_type_cnt = 0@
@eval $ulong_type_cnt = 0@
@eval $counter64_type_cnt = 0@
@foreach $i scalar@
    @if $i.type eq "ASN_INTEGER"@
        @eval $int_type_cnt = 1@
    @elsif $i.type eq "ASN_OCTET_STR"@
        @eval $str_type_cnt = 1@
    @elsif $i.type eq "ASN_OBJECT_ID"@
        @eval $objid_type_cnt = 1@
    @elsif $i.type eq "ASN_IPADDRESS"@
        @eval $ipaddr_type_cnt = 1@
    @elsif $i.type eq "ASN_COUNTER64"@
        @eval $counter64_type_cnt = 1@
    @else@
        @eval $ulong_type_cnt = 1@
    @end@
@end@
@foreach $i table@
@foreach $c column@
    @if $c.type eq "ASN_INTEGER"@
        @eval $int_type_cnt = 1@
    @elsif $c.type eq "ASN_OCTET_STR"@
        @eval $str_type_cnt = 1@
    @elsif $c.type eq "ASN_OBJECT_ID"@
        @eval $objid_type_cnt = 1@
    @elsif $c.type eq "ASN_IPADDRESS"@
        @eval $ipaddr_type_cnt = 1@
    @elsif $c.type eq "ASN_COUNTER64"@
        @eval $counter64_type_cnt = 1@
    @else@
        @eval $ulong_type_cnt = 1@
    @end@
@end@
@end@
@if $int_type_cnt@
    long                long_ret;
@end@
@if $str_type_cnt@
    char                string_ret[$name.uc_STR_LEN_MAX + 1];
@end@
@if $objid_type_cnt@
    oid                 objid_ret[$name.uc_OID_LEN_MAX];
    size_t              objid_len_ret;
@end@
@if $ipaddr_type_cnt@
    u_char              ip_string_ret[4];
@end@
@if $counter64_type_cnt@
    struct counter64    c64_ret;
@end@
@if $ulong_type_cnt@
    u_long              ulong_ret;
@end@
} ${name}_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod ${name}_var;
@foreach $i table@
FindVarMethod ${i}_var;
@end@
@foreach $i scalar@
    @if $i.settable@
WriteMethod ${i}_write;
    @end@
@end@
@foreach $i table@
    @foreach $c column@
        @if $c.settable@
WriteMethod ${c}_write;
        @end@
    @end@
@end@


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*lint -esym(459, ${name}_global_ret) */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ${name}_ret_t ${name}_global_ret;

/*
 * ${name}_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid ${name}_variables_oid[] = {$name.commaoid};

## Caculate oidsuffix
@eval $suffixlen_cnt = 0@
@foreach $i scalar@
    @eval $suffixlen = $i.oidlength - $name.oidlength@
    @if $suffixlen > $suffixlen_cnt@
        @eval $suffixlen_cnt = $suffixlen@
    @end@
@end@
@foreach $i table@
    @eval $suffixlen = $i.oidlength - $name.oidlength + 2@
    @if $suffixlen > $suffixlen_cnt@
        @eval $suffixlen_cnt = $suffixlen@
    @end@
@end@

@if $suffixlen_cnt <= 2@
    @eval $suffixlen_cnt = 2@
@elsif $suffixlen_cnt <= 4@
    @eval $suffixlen_cnt = 4@
@elsif $suffixlen_cnt <= 7@
    @eval $suffixlen_cnt = 7@
@elsif $suffixlen_cnt <= 8@
    @eval $suffixlen_cnt = 8@
@elsif $suffixlen_cnt <= 13@
    @eval $suffixlen_cnt = 13@
@else@
    ----
    ---- Error! The current oidsuffix is $suffixlen_cnt.
    ---- UCD-SNMP only support 2, 4, 7, 8 and 13
    ---- The struct definition is in <top_dir>\eCos\packages\net\snmp\agent\current\include\var_struct.h
    ----
@end@

/*
 * variable ${name}_variables:
 *   this variable defines function callbacks and type return information
 *   for the $name mib section
 */

struct variable${suffixlen_cnt} ${name}_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
@eval $magic = 0@
@eval $namelen = length("$name.commaoid")@
@foreach $i scalar@
    @eval $magic = $magic + 1@
    @eval $suffix = substr("$i.commaoid", $namelen + 1)@
    @eval $suffixlen = $i.oidlength - $name.oidlength@
#define $i.uc		$magic
    @if $i.settable@
    {$i.uc, $i.type, RWRITE, ${name}_var, $suffixlen, {$suffix}},
    @end@
    @if !$i.settable@
    {$i.uc, $i.type, RONLY, ${name}_var, $suffixlen, {$suffix}},
    @end@
@end@

@foreach $i table@
    @eval $suffix = ""@
    @if substr("$i.commaoid", $namelen + 1)@
        @eval $suffix = substr("$i.commaoid", $namelen + 1)@
    @end@
    @eval $suffixlen = $i.oidlength - $name.oidlength + 2@
    @foreach $c column@
        @if $c.noaccess@
            @next@
        @end@
        @eval $magic = $magic + 1@
#define $c.uc		$magic
        @if $suffix != ""@
            @if $c.settable@
    {$c.uc, $c.type, RWRITE, ${i}_var, $suffixlen, {$suffix, 1, $c.subid}},
            @end@
            @if !$c.settable@
    {$c.uc, $c.type, RONLY, ${i}_var, $suffixlen, {$suffix, 1, $c.subid}},
            @end@
        @else@
            @if $c.settable@
    {$c.uc, $c.type, RWRITE, ${i}_var, $suffixlen, {1, $c.subid}},
            @end@
            @if !$c.settable@
    {$c.uc, $c.type, RONLY, ${i}_var, $suffixlen, {1, $c.subid}},
            @end@
        @end@
    @end@
@end@
};


/******************************************************************************/
// ucd_snmp_init_${name}()
// Initializes the UCD-SNMP-part of the $name.module:$name.
/******************************************************************************/
void ucd_snmp_init_${name}(void)
{
    DEBUGMSGTL(("$name", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("$name", ${name}_variables, variable${suffixlen_cnt}, ${name}_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
@eval $has_same_name = 0@
@foreach $i table@
    @if $i eq $name@
        @eval $has_same_name = 1@
    @end@
@end@
@if $has_same_name == 0@
/*
 * ${name}_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
## var_scalar()
u_char *
${name}_var(struct variable *vp,
          oid     *name,
          size_t  *length,
          int     exact,
          size_t  *var_len,
          WriteMethod **write_method)
{
    @eval $need_decl_cp = 0@
    @eval $scalar_parent = "''"@
    @foreach $i scalar@
        @if $scalar_parent ne $i.parent@
            @eval $scalar_parent = "$i.parent"@
    ${scalar_parent}_scalar_t ${scalar_parent}_scalar_entry;
        @end@
        @if $i.type eq "ASN_IPADDRESS" && $need_decl_cp == 0@
            @eval $need_decl_cp = 1@
    u_char *cp = NULL;
        @end@
    @end@

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    @eval $scalar_parent = "''"@
    @foreach $i scalar@
        @if $scalar_parent ne $i.parent@
            @eval $scalar_parent = "$i.parent"@
    if (${scalar_parent}Scalar_get(&${scalar_parent}_scalar_entry)) {
        return NULL;
    }
        @end@
    @end@

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    @foreach $i scalar@
        @eval $scalar_parent = "$i.parent"@
    case $i.uc: {
        @if $i.settable@
        *write_method = ${i}_write;
        @end@
        @if $i.type eq "ASN_INTEGER"@
        ${name}_global_ret.long_ret = ${scalar_parent}_scalar_entry.${i};
        *var_len = sizeof(${name}_global_ret.long_ret);
        return (u_char *) &${name}_global_ret.long_ret;
        @elsif $i.type eq "ASN_OCTET_STR"@
            @if $c.syntax eq "MacAddress"@
        *var_len = 6;
        memcpy(${name}_global_ret.string_ret, ${scalar_parent}_scalar_entry.${i}, 6);
           @else@
        *var_len = ${scalar_parent}_scalar_entry.${i}_len;
        memcpy(${name}_global_ret.string_ret, ${scalar_parent}_scalar_entry.${i}, *var_len);
        ${name}_global_ret.string_ret[*var_len] = '\0';
            @end@
        return (u_char *) ${name}_global_ret.string_ret;
        @elsif $i.type eq "ASN_OBJECT_ID"@
        memcpy(${name}_global_ret.objid_ret, ${scalar_parent}_scalar_entry.${i}, ${scalar_parent}_scalar_entry.${i}_len * sizeof(oid));
        *var_len = ${scalar_parent}_scalar_entry.${i}_len * sizeof(oid);
        return (u_char *) ${name}_global_ret.objid_ret;
        @elsif $i.type eq "ASN_IPADDRESS"@
        ${scalar_parent}_scalar_entry.${i} = htonl(${scalar_parent}_scalar_entry.${i});
        cp = (u_char *)&${scalar_parent}_scalar_entry.${c};
        ${name}_global_ret.ip_string_ret[0] = *cp++;
        ${name}_global_ret.ip_string_ret[1] = *cp++;
        ${name}_global_ret.ip_string_ret[2] = *cp++;
        ${name}_global_ret.ip_string_ret[3] = *cp;
        ${scalar_parent}_scalar_entry.${i} = ntohl(${scalar_parent}_scalar_entry.${i});
        *var_len = sizeof(${name}_global_ret.ip_string_ret);
        return ${name}_global_ret.ip_string_ret;
        @elsif $i.type eq "ASN_COUNTER64"@
        ${name}_global_ret.c64_ret = ${scalar_parent}_scalar_entry.${i};
        *var_len = sizeof(${name}_global_ret.c64_ret);
        return (u_char *) &${name}_global_ret.c64_ret;
        @else@
        ${name}_global_ret.ulong_ret = ${scalar_parent}_scalar_entry.${i};
        *var_len = sizeof(${name}_global_ret.ulong_ret);
        return (u_char *) &${name}_global_ret.ulong_ret;
        @end@
    }
    @end@
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in ${name}_var\n", vp->magic));
    }
    return NULL;
}
@end@

@foreach $i table@
/******************************************************************************/
// ${i}_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
${i}_parse(oid     *name,
           size_t  *length,
           int     exact,
           ${i}_entry_t *table_entry)
{
    size_t  op_pos = $i.oidlength + 2;
    oid     *op = (oid *)(name + op_pos);
    @eval $need_decl_len = 0@
    @eval $need_decl_cp = 0@
    @foreach $idx index@
        @if $idx.needlength@
            @eval $need_decl_len = 1@
        @end@
        @if $idx.type eq "ASN_IPADDRESS" || $idx.type eq "ASN_OCTET_STR"@
            @eval $need_decl_cp = 1@
            @eval $need_decl_len = 1@
        @end@
    @end@
    @if $need_decl_cp@
    u_char  *cp = NULL;
    @end@
    @if $need_decl_len@
    size_t     len = 0;
    @end@

    memset(table_entry, 0, sizeof(*table_entry));

    @eval $len_cnt = 0@
    @foreach $idx index@
        @if $idx.needlength@
            @eval $len_cnt = $len_cnt + 1@
        @end@
        @eval $len_cnt = $len_cnt + 1@
    @end@
    if (exact && *length < ($i.oidlength + 1 + $len_cnt)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (${i}Entry_getfirst(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    @foreach $idx index@
        @if $idx.needlength@
            @if $idx.syntax eq "MacAddress"@
    len = 6;
            @else@
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->${idx}) ? sizeof(table_entry->${idx}) : len;
    op_pos++;
            @end@
    table_entry->${idx}_len = len;
    cp = (u_char *) table_entry->$idx;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
        @elsif $idx.type eq "ASN_IPADDRESS"@
    len = 4;
    cp = (u_char *) &table_entry->$idx;
    while (len-- > 0) {
        if (*length > op_pos) {
            if (*op > 255) {
                return -1; /* illegal value */
            }
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    table_entry->$idx = ntohl(table_entry->$idx);
        @else@
    if (*length > op_pos) {
        table_entry->$idx = ($idx.decl) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
        @end@
    @end@

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ${i}_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
${i}_fillobj(oid     *name,
             size_t  *length,
             ${i}_entry_t *table_entry)
{
    int     name_pos = $i.oidlength + 2;
    @eval $need_decl_len = 0@
    @eval $need_decl_cp = 0@
    @foreach $idx index@
        @if $idx.needlength@
            @eval $need_decl_len = 1@
        @end@
        @if $idx.type eq "ASN_IPADDRESS"@
            @eval $need_decl_len = 1@
            @eval $need_decl_cp = 1@
        @end@
    @end@
    @if $need_decl_cp@
    u_char  *cp = NULL;
    @end@
    @if $need_decl_len@
    int     len = 0, idx = 0;
    @end@

    @foreach $idx index@
        @if $idx.needlength@
    len = (int) table_entry->${idx}_len;
            @if $idx.syntax ne "MacAddress"@
    name[name_pos++] = (oid) table_entry->${idx}_len;
            @end@
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->$idx[idx++];
    }
        @elsif $idx.type eq "ASN_IPADDRESS"@
    len = 4;
    table_entry->$idx = htonl(table_entry->$idx);
    cp = (u_char *) &table_entry->$idx;
    while (len-- > 0) {
        name[name_pos++] = (oid) *cp++;
    }
    table_entry->$idx = ntohl(table_entry->$idx);
        @else@
    name[name_pos++] = (oid) table_entry->$idx;
        @end@
    @end@

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ${i}_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ${name}_var above.
 */
## var_table()
u_char *
${i}_var(struct variable *vp,
       oid     *name,
       size_t  *length,
       int     exact,
       size_t  *var_len,
       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    @eval $ip_type_cnt = 0@
    @foreach $c column@
        @if $c.type eq "ASN_IPADDRESS" && $ip_type_cnt == 0@
            @eval $ip_type_cnt = 1@
    u_char              *cp = NULL;
        @end@
    @end@
    ${i}_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = ${i}_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (${i}_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (${i}Entry_get(&table_entry, exact ? FALSE : TRUE)) {
                @foreach $c column@
                    @if ($c.syntax eq "RowStatus") or ($c.syntax eq "EntryStatus")@
                if (vp->magic == $c.uc) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = ${c}_write;
                }
                    @end@
                @end@
                return NULL;
            }
            if (${i}_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    @foreach $c column@
        @if $c.noaccess@
            @next@
        @end@
    case $c.uc: {
        @if $c.settable@
        *write_method = ${c}_write;
        @end@
        @if $c.type eq "ASN_INTEGER"@
        ${name}_global_ret.long_ret = table_entry.${c};
        *var_len = sizeof(${name}_global_ret.long_ret);
        return (u_char *) &${name}_global_ret.long_ret;
        @elsif $c.type eq "ASN_OCTET_STR"@
            @if $c.syntax eq "MacAddress"@
        *var_len = 6;
        memcpy(${name}_global_ret.string_ret, table_entry.${c}, *var_len);
           @else@
        *var_len = table_entry.${c}_len;
        memcpy(${name}_global_ret.string_ret, table_entry.${c}, *var_len);
        ${name}_global_ret.string_ret[*var_len] = '\0';
            @end@
        return (u_char *) ${name}_global_ret.string_ret;
        @elsif $c.type eq "ASN_OBJECT_ID"@
        memcpy(${name}_global_ret.objid_ret, table_entry.${c}, table_entry.${c}_len * sizeof(oid));
        *var_len = table_entry.${c}_len * sizeof(oid);
        return (u_char *) ${name}_global_ret.objid_ret;
        @elsif $c.type eq "ASN_IPADDRESS"@
        table_entry.${c} = htonl(table_entry.${c});
        cp = (u_char *) &table_entry.${c};
        ${name}_global_ret.ip_string_ret[0] = *cp++;
        ${name}_global_ret.ip_string_ret[1] = *cp++;
        ${name}_global_ret.ip_string_ret[2] = *cp++;
        ${name}_global_ret.ip_string_ret[3] = *cp;
        table_entry.${c} = ntohl(table_entry.${c});
        *var_len = sizeof(${name}_global_ret.ip_string_ret);
        return ${name}_global_ret.ip_string_ret;
        @elsif $c.type eq "ASN_COUNTER64"@
        ${name}_global_ret.c64_ret = table_entry.${c};
        *var_len = sizeof(${name}_global_ret.c64_ret);
        return (u_char *) &${name}_global_ret.c64_ret;
        @else@
        ${name}_global_ret.ulong_ret = table_entry.${c};
        *var_len = sizeof(${name}_global_ret.ulong_ret);
        return (u_char *) &${name}_global_ret.ulong_ret;
        @end@
    }
    @end@
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_$i\n", vp->magic));
    }
    return NULL;
}
@end@


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/
## write_scalar()
@foreach $c scalar@
        @if $c.settable@

/******************************************************************************/
// ${c}_write()
/******************************************************************************/
int
${c}_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
            @if !$c.needlength@
    $c.decl set_value = var_val ? *(($c.decl *) var_val) : 0;
            @end@
            @eval $scalar_parent = "$c.parent"@
    ${scalar_parent}_scalar_t scalar_entry;
    static ${scalar_parent}_scalar_t *old_scalar_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, valid range
            if (var_val_type != $c.type) {
                (void) snmp_log(LOG_ERR, "write to $c: not $c.type\n");
                return SNMP_ERR_WRONGTYPE;
            }
                @if $c.type eq "ASN_INTEGER"@
            if (var_val_len > sizeof($c.decl)) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                    @eval $x = 0@
                    @foreach $l, $v enum@
                        @if $x == 0@
                            @eval $x = 1@
            if (set_value != $v
                        @else@
                && set_value != $v
                        @end@
                    @end@
                    @if $x != 0@
            ) {
                (void) snmp_log(LOG_ERR, "write to $c: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
                    @end@
                @elsif $c.type eq "ASN_OCTET_STR"@
                    @if $c.syntax eq "MacAddress"@
            if (var_val_len != 6) {
                    @else@
            if (var_val_len > $name.uc_STR_LEN_MAX) {
                    @end@
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @elsif $c.type eq "ASN_OBJECT_ID"@
            if (var_val_len > $name.uc_OID_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @else@
            if (var_val_len > sizeof($c.decl)) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @end@
                @foreach $min $max range $c@
                    @if $c.type eq "ASN_INTEGER" && $min == $max@
             if (var_val_len != $max) {
                    @elsif $min == 0 || $min == $max@
             if (var_val_len > $max) {
                    @else@
            if (var_val_len < $min || var_val_len > $max) {
                    @end@
                return SNMP_ERR_WRONGLENGTH;
            }
                @end@
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if (((old_scalar_entry_p = ucd_snmp_callout_malloc(sizeof(*old_scalar_entry_p))) == NULL) ||
                ${scalar_parent}Scalar_get(old_scalar_entry_p))) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            @if $c.needlength@
                @if $c.type eq "ASN_OBJECT_ID"@
            memcpy(scalar_entry.${c}, var_val, var_val_len * sizeof(oid));
                @else@
            memcpy(scalar_entry.${c}, var_val, var_val_len);
                @end@
            scalar_entry.${c}_len = var_val_len;
            @elsif $c.type eq "ASN_IPADDRESS"@
            scalar_entry.${c} = set_value;
            scalar_entry.${c} = ntohl(scalar_entry.${c});
            @else@
            scalar_entry.${c} = set_value;
            @end@
            if (${scalar_parent}Scalar_set(&scalar_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ${scalar_parent}Scalar_set(old_scalar_entry_p);
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_scalar_entry_p);
            old_scalar_entry_p = NULL;
            break;
        }
            break;
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
        @end@
@end@


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/
## write_table()
@foreach $i table@
    @foreach $c column@
        @if $c.settable@

/******************************************************************************/
// ${c}_write()
/******************************************************************************/
int
${c}_write(int      action,
           u_char   *var_val,
           u_char   var_val_type,
           size_t   var_val_len,
           u_char   *statP,
           oid      *name,
           size_t   name_len)
{
            @if !$c.needlength@
    $c.decl set_value = var_val ? *(($c.decl *) var_val) : 0;
            @end@
    ${i}_entry_t table_entry;
    static ${i}_entry_t *old_table_entry_p = NULL;

    switch (action) {
        case RESERVE1: {
            // Check syntax, variable valid range
            if (var_val_type != $c.type) {
                (void) snmp_log(LOG_ERR, "write to $c: not $c.type\n");
                return SNMP_ERR_WRONGTYPE;
            }
                @if $c.type eq "ASN_INTEGER"@
            if (var_val_len > sizeof($c.decl)) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                    @eval $x = 0@
                    @foreach $l, $v enum@
                        @if $x == 0@
                            @eval $x = 1@
            if (set_value != $v
                        @else@
                && set_value != $v
                        @end@
                    @end@
                    @if $x != 0@
            ) {
                (void) snmp_log(LOG_ERR, "write to $c: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
                    @end@
                @elsif $c.type eq "ASN_OCTET_STR"@
            if (var_val_len > $name.uc_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @elsif $c.type eq "ASN_OBJECT_ID"@
            if (var_val_len > $name.uc_OID_LEN_MAX) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @else@
            if (var_val_len > sizeof($c.decl)) {
                (void) snmp_log(LOG_ERR, "write to $c: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
                @end@
                @foreach $min $max range $c@
                    @if $c.type eq "ASN_INTEGER" && $min == $max@
             if (var_val_len != $max) {
                    @elsif $min == 0 || $min == $max@
             if (var_val_len > $max) {
                    @else@
            if (var_val_len < $min || var_val_len > $max) {
                    @end@
                return SNMP_ERR_WRONGLENGTH;
            }
                @end@
            break;
        }
        case RESERVE2: {
            // Allocate dynamic memory for saving the new configuration and initialize it
            if ((old_table_entry_p = ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) == NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (${i}_parse(name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            @if $c.syntax eq "RowStatus"@
            /* Return error code when the entry isn't existing
               except for "createAndGo(4)" or "createAndWait(5)" status */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ${i}Entry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            @elsif $c.syntax eq "EntryStatus"@
            /* Return error code when the entry isn't existing
               except for "createRequest(2)" status */
            if (set_value != 2 && ${i}Entry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            @else@
            if (${i}Entry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            @end@
            break;
        }
        case FREE: {
            // Release dynamic memory
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
        case ACTION: {
            // Set new configuration
            table_entry = *old_table_entry_p;
            @if $c.needlength@
                @if $c.type eq "ASN_OBJECT_ID"@
            memcpy(table_entry.${c}, var_val, var_val_len * sizeof(oid));
                @else@
            memcpy(table_entry.${c}, var_val, var_val_len);
                @end@
            table_entry.${c}_len = var_val_len;
            @elsif $c.type eq "ASN_IPADDRESS"@
            table_entry.${c} = set_value;
            table_entry.${c} = ntohl(table_entry.${c});
            @else@
            table_entry.${c} = set_value;
            @end@
            if (${i}Entry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        case UNDO: {
            // Restore original configuration
            int undo_rc = ${i}Entry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (undo_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
        case COMMIT: {
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
        default:
            break;
    }
    return SNMP_ERR_NOERROR;
}
        @end@
    @end@
@end@

@close ucd_snmp_${name}.c@
