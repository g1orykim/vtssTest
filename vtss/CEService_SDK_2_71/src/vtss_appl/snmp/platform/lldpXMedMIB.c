/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */


/* We *have* serialized access */
/*lint -esym(459, var_lldpXMedLocLocationTable,var_lldpXMedLocMediaPolicyTable,write_lldpXMedFastStartRepeatCount) */
/*lint -esym(459, var_lldpXMedLocXPoEPSEPortTable,var_lldpXMedPortConfigTable,write_lldpXMedPortConfigNotifEnable) */
/*lint -esym(459, var_lldpXMedMIB) */
/*lint -esym(459, var_lldpXMedRemInventoryTable) */
/*lint -esym(459, var_lldpXMedRemMediaPolicyTable) */
/*lint -esym(459, var_lldpXMedRemCapabilitiesTable) */
/*lint -esym(459, var_lldpXMedRemLocationTable) */
/*lint -esym(459, var_lldpXMedRemXPoEPDTable) */
/*lint -esym(459, write_lldpXMedPortConfigTLVsTxEnable) */
/*lint -esym(459, var_lldpXMedRemXPoEPSETable)*/
/*lint -esym(459, var_lldpXMedRemXPoETable)*/
/*lint -esym(457, snmp_send_vars_trap) */
/*lint -esym(459, write_lldpXMedLocLocationInfo) */
#include <main.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "lldpXMedMIB.h"
#include "msg_api.h"
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register
#include "lldp_api.h"
#include "lldp_remote.h"
#include "lldp_os.h"
#include "lldp.h"
#include "dot1ab_lldp.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"
#ifdef VTSS_SW_OPTION_POE
#include "poe_api.h"
#include "poe_custom_api.h"
#endif
#ifdef VTSS_SW_OPTION_LLDP_MED
#include "dot1ab_lldp_api.h"
#include "lldpmed_shared.h"
#include "lldpmed_tx.h"
#include "lldpmed_rx.h"
#endif

/*
* +++ Start (Internal implementation declarations)
*/
/*
* --- End (Internal implementation declarations)
*/

/*
* lldpXMedMIB_variables_oid:
*   this is the top level oid that we want to register under.  This
*   is essentially a prefix, with the suffix appearing in the
*   variable below.
*/

oid             lldpXMedMIB_variables_oid[] =    { 1, 0, 8802, 1, 1, 2, 1, 5, 4795, 1 };

/*
* variable4 lldpXMedMIB_variables:
*   this variable defines function callbacks and type return information
*   for the lldpXMedMIB mib section
*/

struct variable4 lldpXMedMIB_variables[] = {
    /*
    * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
    */
#define LLDPXMEDLOCDEVICECLASS              1
    {LLDPXMEDLOCDEVICECLASS, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {1, 1}},
#define LLDPXMEDPORTCAPSUPPORTED            2
    {LLDPXMEDPORTCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 1}},
#define LLDPXMEDPORTCONFIGTLVSTXENABLE      3
    {LLDPXMEDPORTCONFIGTLVSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 2}},
#define LLDPXMEDPORTCONFIGNOTIFENABLE       4
    {LLDPXMEDPORTCONFIGNOTIFENABLE, ASN_INTEGER, RWRITE, var_lldpXMedPortConfigTable, 4, {1, 2, 1, 3}},
#define LLDPXMEDFASTSTARTREPEATCOUNT        5
    {LLDPXMEDFASTSTARTREPEATCOUNT, ASN_UNSIGNED, RWRITE, var_lldpXMedMIB, 2, {1, 3}},
#define LLDPXMEDLOCMEDIAPOLICYAPPTYPE       6
    {LLDPXMEDLOCMEDIAPOLICYAPPTYPE, ASN_OCTET_STR, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 1}},
#define LLDPXMEDLOCMEDIAPOLICYVLANID        7
    {LLDPXMEDLOCMEDIAPOLICYVLANID, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 2}},
#define LLDPXMEDLOCMEDIAPOLICYPRIORITY      8
    {LLDPXMEDLOCMEDIAPOLICYPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 3}},
#define LLDPXMEDLOCMEDIAPOLICYDSCP          9
    {LLDPXMEDLOCMEDIAPOLICYDSCP, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 4}},
#define LLDPXMEDLOCMEDIAPOLICYUNKNOWN       10
    {LLDPXMEDLOCMEDIAPOLICYUNKNOWN, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, { 2, 1, 1, 5}},
#define LLDPXMEDLOCMEDIAPOLICYTAGGED        11
    {LLDPXMEDLOCMEDIAPOLICYTAGGED, ASN_INTEGER, RONLY, var_lldpXMedLocMediaPolicyTable, 4, {2, 1, 1, 6}},
#define LLDPXMEDLOCHARDWAREREV              12
    {LLDPXMEDLOCHARDWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 2}},
#define LLDPXMEDLOCFIRMWAREREV              13
    {LLDPXMEDLOCFIRMWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 3}},
#define LLDPXMEDLOCSOFTWAREREV              14
    {LLDPXMEDLOCSOFTWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 4}},
#define LLDPXMEDLOCSERIALNUM                15
    {LLDPXMEDLOCSERIALNUM, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 5}},
#define LLDPXMEDLOCMFGNAME                  16
    {LLDPXMEDLOCMFGNAME, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 6}},
#define LLDPXMEDLOCMODELNAME                17
    {LLDPXMEDLOCMODELNAME, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 7}},
#define LLDPXMEDLOCASSETID                  18
    {LLDPXMEDLOCASSETID, ASN_OCTET_STR, RONLY, var_lldpXMedMIB, 2, {2, 8}},
#define LLDPXMEDLOCLOCATIONSUBTYPE          19
    {LLDPXMEDLOCLOCATIONSUBTYPE, ASN_INTEGER, RONLY, var_lldpXMedLocLocationTable, 4, {2, 9, 1, 1}},
#define LLDPXMEDLOCLOCATIONINFO             20
    {LLDPXMEDLOCLOCATIONINFO, ASN_OCTET_STR, RWRITE, var_lldpXMedLocLocationTable, 4, {2, 9, 1, 2}},
#define LLDPXMEDLOCXPOEDEVICETYPE           21
    {LLDPXMEDLOCXPOEDEVICETYPE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 10}},
#define LLDPXMEDLOCXPOEPSEPORTPOWERAV       22
    {LLDPXMEDLOCXPOEPSEPORTPOWERAV, ASN_GAUGE, RONLY, var_lldpXMedLocXPoEPSEPortTable, 4, {2, 11, 1, 1}},
#define LLDPXMEDLOCXPOEPSEPORTPDPRIORITY    23
    {LLDPXMEDLOCXPOEPSEPORTPDPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedLocXPoEPSEPortTable, 4, {2, 11, 1, 2}},
#define LLDPXMEDLOCXPOEPSEPOWERSOURCE       24
    {LLDPXMEDLOCXPOEPSEPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 12}},
#define LLDPXMEDLOCXPOEPDPOWERREQ           25
    {LLDPXMEDLOCXPOEPDPOWERREQ, ASN_GAUGE, RONLY, var_lldpXMedMIB, 2, {2, 13}},
#define LLDPXMEDLOCXPOEPDPOWERSOURCE        26
    {LLDPXMEDLOCXPOEPDPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 14}},
#define LLDPXMEDLOCXPOEPDPOWERPRIORITY      27
    {LLDPXMEDLOCXPOEPDPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedMIB, 2, {2, 15}},
#define LLDPXMEDREMCAPSUPPORTED             28
    {LLDPXMEDREMCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 1}},
#define LLDPXMEDREMCAPCURRENT               29
    {LLDPXMEDREMCAPCURRENT, ASN_OCTET_STR, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 2}},
#define LLDPXMEDREMDEVICECLASS              30
    {LLDPXMEDREMDEVICECLASS, ASN_INTEGER, RONLY, var_lldpXMedRemCapabilitiesTable, 4, {3, 1, 1, 3}},
#define LLDPXMEDREMMEDIAPOLICYAPPTYPE       31
    {LLDPXMEDREMMEDIAPOLICYAPPTYPE, ASN_OCTET_STR, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 1}},
#define LLDPXMEDREMMEDIAPOLICYVLANID        32
    {LLDPXMEDREMMEDIAPOLICYVLANID, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 2}},
#define LLDPXMEDREMMEDIAPOLICYPRIORITY      33
    {LLDPXMEDREMMEDIAPOLICYPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 3}},
#define LLDPXMEDREMMEDIAPOLICYDSCP          34
    {LLDPXMEDREMMEDIAPOLICYDSCP, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 4}},
#define LLDPXMEDREMMEDIAPOLICYUNKNOWN       35
    {LLDPXMEDREMMEDIAPOLICYUNKNOWN, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 5}},
#define LLDPXMEDREMMEDIAPOLICYTAGGED        36
    {LLDPXMEDREMMEDIAPOLICYTAGGED, ASN_INTEGER, RONLY, var_lldpXMedRemMediaPolicyTable, 4, {3, 2, 1, 6}},
#define LLDPXMEDREMHARDWAREREV              37
    {LLDPXMEDREMHARDWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 1}},
#define LLDPXMEDREMFIRMWAREREV              38
    {LLDPXMEDREMFIRMWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 2}},
#define LLDPXMEDREMSOFTWAREREV              39
    {LLDPXMEDREMSOFTWAREREV, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 3}},
#define LLDPXMEDREMSERIALNUM                40
    {LLDPXMEDREMSERIALNUM, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 4}},
#define LLDPXMEDREMMFGNAME                  41
    {LLDPXMEDREMMFGNAME, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 5}},
#define LLDPXMEDREMMODELNAME                42
    {LLDPXMEDREMMODELNAME, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 6}},
#define LLDPXMEDREMASSETID                  43
    {LLDPXMEDREMASSETID, ASN_OCTET_STR, RONLY, var_lldpXMedRemInventoryTable, 4, {3, 3, 1, 7}},
#define LLDPXMEDREMLOCATIONSUBTYPE          44
    {LLDPXMEDREMLOCATIONSUBTYPE, ASN_INTEGER, RONLY, var_lldpXMedRemLocationTable, 4, {3, 4, 1, 1}},
#define LLDPXMEDREMLOCATIONINFO             45
    {LLDPXMEDREMLOCATIONINFO, ASN_OCTET_STR, RONLY, var_lldpXMedRemLocationTable, 4, {3, 4, 1, 2}},
#define LLDPXMEDREMXPOEDEVICETYPE           46
    {LLDPXMEDREMXPOEDEVICETYPE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoETable, 4, {3, 5, 1, 1}},
#define LLDPXMEDREMXPOEPSEPOWERAV           47
    {LLDPXMEDREMXPOEPSEPOWERAV, ASN_GAUGE, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 1}},
#define LLDPXMEDREMXPOEPSEPOWERSOURCE       48
    {LLDPXMEDREMXPOEPSEPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 2}},
#define LLDPXMEDREMXPOEPSEPOWERPRIORITY     49
    {LLDPXMEDREMXPOEPSEPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPSETable, 4, {3, 6, 1, 3}},
#define LLDPXMEDREMXPOEPDPOWERREQ           50
    {LLDPXMEDREMXPOEPDPOWERREQ, ASN_GAUGE, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 1}},
#define LLDPXMEDREMXPOEPDPOWERSOURCE        51
    {LLDPXMEDREMXPOEPDPOWERSOURCE, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 2}},
#define LLDPXMEDREMXPOEPDPOWERPRIORITY      52
    {LLDPXMEDREMXPOEPDPOWERPRIORITY, ASN_INTEGER, RONLY, var_lldpXMedRemXPoEPDTable, 4, {3, 7, 1, 3}},
};

#ifdef VTSS_SW_OPTION_LLDP_MED
static u_long bool2truthvalue(BOOL value)
{
    long truthvalue;
    if (value) {
        truthvalue = 1;    /* Enabled */
    } else {
        truthvalue = 2;    /* Disabled */
    }

    return truthvalue;
}
#endif

/*
* (L = length of the oidsuffix)
*/

static iftable_info_t  table_info;

#define PORT_INDEX  table_info.if_id

/*
* Initializes the lldpXMedMIB module
*/
void
init_lldpXMedMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(lldpXMedMIB_variables_oid,
                             sizeof(lldpXMedMIB_variables_oid) / sizeof(oid),
                             "LLDP-EXT-MED-MIB : lldpXMedMIB");

    DEBUGMSGTL(("lldpXMedMIB", "Initializing\n"));

    /*
    * register ourselves with the agent to handle our mib tree
    */
    REGISTER_MIB("lldpXMedMIB", lldpXMedMIB_variables, variable4,
                 lldpXMedMIB_variables_oid);

    /*
    * place any other initialization junk you need here
    */
}

/*
* var_lldpXMedMIB():
*   This function is called every time the agent gets a request for
*   a scalar variable that might be found within your mib section
*   registered above.  It is up to you to do the right thing and
*   return the correct value.
*     You should also correct the value of "var_len" if necessary.
*
*   Please see the documentation for more information about writing
*   module extensions, and check out the examples in the examples
*   and mibII directories.
*/
u_char         *
var_lldpXMedMIB(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    // No indexes, so we can use header_generic
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;

    }


    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid);

    static long VALUE = 0;
    static long VAR = 0;

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCMODELNAME: {
        // PD only
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_LLDP_MED
    case LLDPXMEDLOCDEVICECLASS: {
        VAR = DEVICE_CLASS_TYPE;
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCSOFTWAREREV: {
        // PD only
        VAR = VALUE;
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPSEPOWERSOURCE: {
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - Enter");
        poe_power_source_t power_source = poe_custom_get_power_source();
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - Enter 2");

        // See IEEE MIB definition of power source
        switch (power_source) {
        case PRIMARY: {
            VAR = 2;
            break;
        }
        case BACKUP: {
            VAR = 3;
            break;
        }
        default:
            T_EG(TRACE_GRP_SNMP, "Unknwon power source : %d", power_source);
            VAR = 2;  // Set source to primary as default.
            break;
        }
        T_DG(TRACE_GRP_SNMP, "LLDPXMEDLOCXPOEPSEPOWERSOURCE - power source =%lu", VAR);
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCFIRMWAREREV: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPDPOWERSOURCE: {
        VAR = 1; // We are a PSE, so we returns "unknown"
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEDEVICETYPE: {
        VAR = 2;        // The switch will always be PSE type - See IEEE Mib definitions
        return (u_char *) & VAR;
    }
#endif
#ifdef VTSS_SW_OPTION_LLDP_MED
    case LLDPXMEDFASTSTARTREPEATCOUNT: {
        *write_method = write_lldpXMedFastStartRepeatCount;
        VAR = lldp_conf.medFastStartRepeatCount;
        return (u_char *) & VAR;
    }
#endif
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPDPOWERPRIORITY: {
        T_NG_PORT(TRACE_GRP_SNMP, (u32)PORT_INDEX, "LLDPXMEDLOCXPOEPDPOWERPRIORITY");
        VAR = 1; // We are a PSE, so we returns "unknown"
        return (u_char *) & VAR;
    }
#endif
    case LLDPXMEDLOCASSETID: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCHARDWAREREV: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMFGNAME: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEPDPOWERREQ: {
        VAR = 0; // Not a PSE
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCSERIALNUM: {
        // Only for PDs
        VAR = VALUE;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpXMedMIB\n",
                    vp->magic));
    }
    return NULL;
}

#ifdef VTSS_SW_OPTION_LLDP_MED
static ulong port2table_index(vtss_port_no_t iport)
{
    if (table_info.isid != 0) {
        return (topo_isid2usid(table_info.isid) - 1) * IFTABLE_IFINDEX_SWITCH_INTERVAL + iport + 1;
    } else {
        return iport + 1;
    }
}


static vtss_rc get_table_info(ulong *table_index,
                              ulong lldp_loc_port_num,
                              oid *name,
                              size_t *length,
                              int exact)
{
    iftable_info_t tbl_info;

    //  Select first port if "get next"
    if (lldp_loc_port_num == 0 && !exact) {
        lldp_loc_port_num = 1;
    }

    tbl_info.ifIndex = exact ? lldp_loc_port_num : lldp_loc_port_num - 1;

    if (exact && FALSE == ifIndex_get(&tbl_info)) {
        return VTSS_UNSPECIFIED_ERROR;
    }

    if (!exact && FALSE == ifIndex_get_next(&tbl_info)) {
        return VTSS_UNSPECIFIED_ERROR;
    }

    if (tbl_info.type != IFTABLE_IFINDEX_TYPE_PORT && tbl_info.type != IFTABLE_IFINDEX_TYPE_LLAG) {
        return VTSS_UNSPECIFIED_ERROR;
    }

    *table_index = (u_long)tbl_info.ifIndex;

    if (get_ifTableIndex_info(*table_index, &tbl_info) == FALSE) {
        T_NG(TRACE_GRP_SNMP, "get_ifTableIndex_info false");
        return VTSS_UNSPECIFIED_ERROR;
    }

    return VTSS_OK;
}



//
// The application type is of type 0-8 (table 12, TIA1057), while the MIB uses BITS type.
// Therefore we need to be able to convert between the 2 types.

// Converting from application type to BITS type
static ulong appl_type2bits(ulong appl_type)
{
    return 1 << appl_type;
}


// Converting from BITS to apllication type
static ulong bits2appl_type(ulong bits)
{
    int i;
    for (i = 0; i < 32; i++) {
        if (bits & (1 << i)) {
            return i;
        }
    }
    return 0;
}
#endif

/*
* var_lldpXMedLocMediaPolicyTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocMediaPolicyTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    ulong           table_index = 0;
    static long     VAR;
    int             p_index;

    int lowest_table_index = 0;
    int lowest_port_num = 0;
    oid       *op = NULL;

    ulong lldp_loc_port_num = 0;
    ulong lldpx_med_loc_media_policy_app_type = 0;


    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long); /* assume an integer and change later if not */


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    BOOL found = FALSE;
    int oid_length = 14; // (oid = 1.0.8802.1.1.2.5.4795.1.2.1.1.2)

    op = name + oid_length; // point to first index
    if (op < name + *length) {
        lldp_loc_port_num = *op++;
    }

    if (op < name + *length) {
        lldpx_med_loc_media_policy_app_type = bits2appl_type(*op++);
    }

    if (get_table_info(&table_index,
                       lldp_loc_port_num,
                       name,
                       length,
                       exact) != VTSS_OK) {
        return NULL;
    }

    T_NG(TRACE_GRP_SNMP, "lldp_loc_port_num =%u, lldpx_med_loc_media_policy_app_type =%u, *length =%zu, port_no = %u",
         lldp_loc_port_num, lldpx_med_loc_media_policy_app_type, *length, table_info.if_id);



    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid);


    if (exact) {
        if (table_index != lldp_loc_port_num) {
            return NULL;
        }

        for (p_index = LLDPMED_POLICY_MIN ; p_index <= LLDPMED_POLICY_MAX; p_index++ ) {
            if (lldp_conf.ports_policies[table_info.if_id][p_index]) {
                if (lldp_conf.policies_table[p_index].application_type == lldpx_med_loc_media_policy_app_type) {
                    found = TRUE;
                    lowest_port_num = table_info.if_id;
                    lowest_table_index = p_index;
                    break;
                }
            }
        }
    } else {

        // Not exact. Find policy with lowest indexes above the request oid indexes.


        int iport;
        int lowest_app_type = VIDEO_SIGNALING;
        lowest_port_num = LLDP_PORTS + 1;

        for (iport = LLDP_PORTS - 1 ; iport >= (int)table_info.if_id; iport-- ) {
            if (iport < 0) {
                break;
            }


            for (p_index = LLDPMED_POLICY_MAX ; p_index >= LLDPMED_POLICY_MIN; p_index-- ) {
                if (lldp_conf.ports_policies[iport][p_index]) {
                    if (iport != lowest_port_num) {
                        lowest_app_type = VIDEO_SIGNALING;
                    }

                    if (lldp_conf.policies_table[p_index].application_type <= lowest_app_type) {
                        if (iport == table_info.if_id) {
                            if (lldp_conf.policies_table[p_index].application_type > lldpx_med_loc_media_policy_app_type) {
                                found = TRUE;

                                lowest_app_type = lldp_conf.policies_table[p_index].application_type;
                                lowest_port_num = iport;
                                lowest_table_index = p_index;
                            }
                        } else {
                            found = TRUE;
                            lowest_app_type = lldp_conf.policies_table[p_index].application_type;
                            lowest_port_num = iport;
                            lowest_table_index = p_index;

                        }
                    }
                }
            }
        }
    }

    if (!found) {
        T_NG(TRACE_GRP_SNMP, "NOT found");
        return NULL;
    }

    // Return the index found
    *length = oid_length;

    name[(*length)++] = port2table_index(lowest_port_num);
    name[(*length)++] = appl_type2bits(lldp_conf.policies_table[lowest_table_index].application_type);



    T_NG(TRACE_GRP_SNMP, " lldp_conf.policies_table[%d].application_type = %d, lowest_port_num = %d",
         lowest_table_index, lldp_conf.policies_table[lowest_table_index].application_type, lowest_port_num);

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCMEDIAPOLICYAPPTYPE: {
        return NULL;
    }
    case LLDPXMEDLOCMEDIAPOLICYVLANID: {
        T_NG(TRACE_GRP_SNMP, "LLDPXMEDLOCMEDIAPOLICYVLANID");
        VAR = lldp_conf.policies_table[lowest_table_index].vlan_id;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYPRIORITY: {
        VAR = (i32) lldp_conf.policies_table[lowest_table_index].l2_priority;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYDSCP: {
        VAR = lldp_conf.policies_table[lowest_table_index].dscp_value;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYUNKNOWN: {
        VAR = 0;
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCMEDIAPOLICYTAGGED: {
        VAR = bool2truthvalue(lldp_conf.policies_table[lowest_table_index].tagged_flag);
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocMediaPolicyTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}



/*
* var_lldpXMedLocXPoEPSEPortTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocXPoEPSEPortTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_POE
    static long VAR;
#endif

    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDLOCXPOEPSEPORTPOWERAV: {

        // Get PoE status
        poe_status_t          poe_status;
        poe_mgmt_get_status(table_info.isid, &poe_status);
        VAR = poe_status.power_allocated[PORT_INDEX];
        return (u_char *) & VAR;
    }
    case LLDPXMEDLOCXPOEPSEPORTPDPRIORITY: {
        poe_local_conf_t poe_local_conf;
        poe_mgmt_get_local_config(&poe_local_conf, table_info.isid );

        switch (poe_local_conf.priority[PORT_INDEX]) {
        case LOW: {
            VAR = 4;
            break;
        }
        case HIGH: {
            VAR = 3;
            break;
        }
        case CRITICAL: {
            VAR = 2;
            break;
        }
        default: {
            T_EG_PORT(TRACE_GRP_SNMP, (u32)PORT_INDEX, "Unknown priority");
            VAR = 1; // Default to unknown
        }
        }
        T_DG_PORT(TRACE_GRP_SNMP, (u32)PORT_INDEX, "LLDPXMEDLOCXPOEPSEPORTPDPRIORITY found");

        return (u_char *) & VAR;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocXPoEPSEPortTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
* var_lldpXMedPortConfigTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedPortConfigTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED

    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }
    static long VAR = 0 ;// Default

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDPORTCAPSUPPORTED: {
        VAR = BITS_type_swapbyte(lldpmed_get_capabilities_word(PORT_INDEX));
        T_NG(TRACE_GRP_SNMP, "Capabilities = %lu", VAR);
        return (u_char *) & VAR;
    }
    case LLDPXMEDPORTCONFIGTLVSTXENABLE: {
        *write_method = write_lldpXMedPortConfigTLVsTxEnable;
        lldp_struc_0_t   lldp_conf;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        VAR = BITS_type_swapbyte(lldp_conf.lldpmed_optional_tlv[PORT_INDEX]);
        *var_len = 1;
        return (u_char *) & VAR;
    }
    case LLDPXMEDPORTCONFIGNOTIFENABLE: {
        VAR = lldpmed_mgmt_get_notification_ena(PORT_INDEX, table_info.isid);
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedPortConfigTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemCapabilitiesTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemCapabilitiesTable(struct variable *vp,
                                 oid *name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len,
                                 WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static long VAR;

    lldp_remote_entry_t    entry;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_OK) {
        return NULL;
    }

    VAR = 0 ;// Default
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMCAPSUPPORTED: {
        if (entry.lldpmed_capabilities_vld) {
            VAR = BITS_type_swapbyte(entry.lldpmed_capabilities);
            T_NG(TRACE_GRP_SNMP, "entry.lldpmed_capabilities = 0x%X", entry.lldpmed_capabilities);
            return (u_char *) & VAR;
        } else {
            return NULL;
        }

    }
    case LLDPXMEDREMCAPCURRENT: {
        if (entry.lldpmed_capabilities_vld) {
            VAR = BITS_type_swapbyte(entry.lldpmed_capabilities_current);
            return (u_char *) & VAR;
        } else {
            return NULL;
        }
    }
    case LLDPXMEDREMDEVICECLASS: {
        if (entry.lldpmed_capabilities_vld) { // Note : Device type is in the TLV as capabilities (Figure 6, TIA1057), so we use the same valid bit.
            T_NG(TRACE_GRP_SNMP, "Device Type = %d", entry.lldpmed_device_type);
            VAR = entry.lldpmed_device_type;
            return (u_char *) & VAR;
        } else {
            return NULL;
        }
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemCapabilitiesTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}





/*
* var_lldpXMedRemXPoETable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoETable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    lldp_remote_entry_t    entry;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_OK) {
        return NULL;
    }

#ifdef VTSS_SW_OPTION_POE
    static long VAR    = 0;
    int power_type     = 0;
    int power_source   = 0;
    int power_priority = 0;
    int power_value    = 0;
    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        T_DG(TRACE_GRP_SNMP, "entry NOT in use");
        power_type = 4; // Set power type to none - see IEEE MIBS
        power_source = 2 ; // Set power power source to primary - see IEEE MIBS
        power_priority = 4; // Set power priority to low - - see IEEE MIBS
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMXPOEDEVICETYPE: {


        // Convertion between power type and MIB power type ( IEEE 801.2at/D3 table 33-22 vs IEEE MIB )
        T_DG(TRACE_GRP_SNMP, "power_type = %d", power_type);
        switch (power_type) {
        case 0:
        case 2: {
            VAR = 2; // 2 = PSE - See IEEE MIB
            break;
        }
        case 1:
        case 3: {
            VAR = 3; // 3 = PD - See IEEE MIB
            break;
        }
        default:
            VAR = 4; // Set power type to none - see IEEE MIBS
        }

        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoETable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemInventoryTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemInventoryTable(struct variable *vp,
                              oid *name,
                              size_t *length,
                              int exact,
                              size_t *var_len,
                              WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static char     VAR_STR[255];
    lldp_remote_entry_t entry;


    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.3.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_OK) {
        return NULL;
    }



    T_NG(TRACE_GRP_SNMP, "Getting var_lldpXMedRemInventoryTable");
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMHARDWAREREV: {
        if (entry.lldpmed_hw_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_hw_rev, entry.lldpmed_hw_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMFIRMWAREREV: {
        if (entry.lldpmed_firm_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_firm_rev, entry.lldpmed_firm_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }

    }
    case LLDPXMEDREMSOFTWAREREV: {
        if (entry.lldpmed_sw_rev_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_sw_rev, entry.lldpmed_sw_rev_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMSERIALNUM: {
        if (entry.lldpmed_serial_no_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_serial_no, entry.lldpmed_serial_no_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMMFGNAME: {
        if (entry.lldpmed_manufacturer_name_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_manufacturer_name, entry.lldpmed_manufacturer_name_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMMODELNAME: {
        if (entry.lldpmed_model_name_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_model_name, entry.lldpmed_model_name_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    case LLDPXMEDREMASSETID: {
        if (entry.lldpmed_assert_id_length == 0) {
            return NULL;
        } else {
            strncpy(VAR_STR, entry.lldpmed_assert_id, entry.lldpmed_assert_id_length);
            strcat(VAR_STR, "");
            *var_len = strlen(VAR_STR);
            return (u_char *) VAR_STR;
        }
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemInventoryTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedLocLocationTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedLocLocationTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static uchar     VAR_STR[255];

    oid                    *op = NULL;
    lldp_u32_t index_loc_port_num = 0;
    lldp_u32_t index_xmed_loc_location_subtype = 0;

    vtss_rc rc = VTSS_UNSPECIFIED_ERROR;
    lldp_u16_t   subtype_idx;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    int oid_length = 14; // (oid =  (1.0.8802.1.1.2.1.5.4795.1.2.9.1.2)
    op = name + oid_length; // point to first index

    // The 2 indexes
    if (op < name + *length) {
        index_loc_port_num = *op++;
    }
    if (op < name + *length) {
        index_xmed_loc_location_subtype = *op++;
    }

    ulong          table_index = 0;
    if (get_table_info(&table_index,
                       index_loc_port_num,
                       name,
                       length,
                       exact) != VTSS_OK) {
        return NULL;
    }

    if (exact) {
        // Check that the OID has the correct length
        if (*length < 16) {
            return NULL;
        }

        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }
        rc = VTSS_OK;
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");

        for (subtype_idx = 1; subtype_idx <= 3; subtype_idx++) {
            T_NG(TRACE_GRP_SNMP, "index_loc_port_num = %u, index_xmed_loc_location_subtype = %u, subtype_idx = %d" ,
                 index_loc_port_num, index_xmed_loc_location_subtype, subtype_idx);

            if (subtype_idx > index_xmed_loc_location_subtype) {
                index_xmed_loc_location_subtype = subtype_idx;
                rc = VTSS_OK;
                break;
            }
        }

        T_DG(TRACE_GRP_SNMP, "index_xmed_loc_location_subtype = %u", index_xmed_loc_location_subtype);
//        if (index_loc_port_num == 0) {
//            index_loc_port_num = 1;
//        }

    }

    if (rc != VTSS_OK) {
        return NULL;
    }


    // length = 14 (1.0.8802.1.1.2.1.5.4795.1.2.9.1.2)
    *length = oid_length;
    name[(*length)++] = table_index;
    name[(*length)++] = index_xmed_loc_location_subtype;

    lldp_u16_t i;
    for (i = 0; i < *length; i++) {
        T_DG(TRACE_GRP_SNMP, "%lu", name[i]);
    }



    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDLOCLOCATIONSUBTYPE: {
        return NULL;
    }
    case LLDPXMEDLOCLOCATIONINFO: {
#ifdef VTSS_SW_OPTION_LLDP_MED
        *write_method = write_lldpXMedLocLocationInfo;

        *var_len = 0 ;
        switch (index_xmed_loc_location_subtype) {
        case 1:
            *var_len = (size_t) lldp_mgmt_lldpmed_coordinate_location_tlv_add(&VAR_STR[0]);
            break;
        case 2:
            *var_len = (size_t) lldp_mgmt_lldpmed_civic_location_tlv_add(&VAR_STR[0]);
            break;

        case 3:
            *var_len = (size_t) lldp_mgmt_lldpmed_ecs_location_tlv_add(&VAR_STR[0]) ;
            break;
        default:
            T_W("Invalid location subtype = %u", index_xmed_loc_location_subtype);
#endif
            return NULL;
        }

        return (u_char *) &VAR_STR[0];
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedLocLocationTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemXPoEPDTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoEPDTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{

#ifdef VTSS_SW_OPTION_POE
    lldp_remote_entry_t entry;
    static long         VAR;


    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.7.1.3)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_OK) {
        return NULL;
    }


    int power_type     = 0;
    int power_source   = 0;
    int power_priority = 0;
    int power_value    = 0;


    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        T_DG(TRACE_GRP_SNMP, "entry NOT in use");
        power_source = 1 ; // Set power power source to unknown - see IEEE MIBS
        power_priority = 1; // Set power priority to unknown - - see IEEE MIBS
        power_value = 0;
    }


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMXPOEPDPOWERREQ: {
        VAR = power_value;
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPDPOWERSOURCE: {
        T_DG(TRACE_GRP_SNMP, "power_source = %d", power_source);
        VAR = power_source + 1;  // Power source has added one for the MIB - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPDPOWERPRIORITY: {
        VAR = power_priority + 1;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoEPDTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemXPoEPSETable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemXPoEPSETable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_POE
    lldp_remote_entry_t entry;

    // Oid Length = 14 (1.0.8802.1.1.2.1.5.4795.1.3.5.1.1)
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    14,
                                    &entry) != VTSS_OK) {
        return NULL;
    }


    static long VAR;
    int power_type;
    int power_source;
    int power_priority;
    int power_value;

    if (lldp_remote_get_poe_power_info(&entry, &power_type, &power_source, &power_priority, &power_value) == 0) {
        // Power information not valid.
        power_source = 1 ; // Set power power source to unknown - see IEEE MIBS
        power_priority = 1; // Set power priority to unknown- - see IEEE MIBS
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
#ifdef VTSS_SW_OPTION_POE
    case LLDPXMEDREMXPOEPSEPOWERAV: {
        VAR = power_value;
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPSEPOWERSOURCE: {

        VAR = power_source + 1;  // Power source has added one for the MIB - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
    case LLDPXMEDREMXPOEPSEPOWERPRIORITY: {


        VAR = power_priority + 1;    // The MIB has added one to the priority - See IEEE 802.3at/D3 table 33-22 vs IEEE MIB
        return (u_char *) & VAR;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemXPoEPSETable\n",
                    vp->magic));
    }
#endif // VTSS_SW_OPTION_POE
    return NULL;
}

/*
* var_lldpXMedRemMediaPolicyTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemMediaPolicyTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static long          VAR = 0;
    oid                  *op = NULL;
    int                  idx_num;
    lldp_remote_entry_t  entry, temp_entry;
    lldp_u8_t            entry_appl_type = 0, temp_entry_appl_type = 0;
    ulong                table_index = 0;
    lldp_u32_t           index_rem_time_mark = 0;
    lldp_u32_t           index_rem_local_port_num = 0;
    lldp_u16_t           index_rem_index = 0;
    lldp_u32_t           index_xmed_media_policy_app_type = 0;
    int                  policy_idx_to_be_used = 0;
    int                  policy_idx = 0;
    lldp_bool_t          found = LLDP_FALSE;


    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long);     /* assume an integer and change later if not */

    // Clear the entry to start from knwon point
    memset(&entry, 0x0, sizeof(entry));
    memset(&temp_entry, 0x0, sizeof(temp_entry));


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    // Get the entries
    lldp_remote_entry_t *entries = NULL;
    lldp_mgmt_get_lock();
    entries = lldp_mgmt_get_entries(table_info.isid);
    lldp_mgmt_get_unlock();


    op = name + 14; // point to first index

    if (op < name + *length) {
        index_rem_time_mark = *op++;
    }

    if (op < name + *length) {
        index_rem_local_port_num = *op++;
    }

    if (op < name + *length) {
        index_rem_index = *op++;
    }

    if (op < name + *length) {
        index_xmed_media_policy_app_type = bits2appl_type(*op++);
    }

    if (get_table_info(&table_index,
                       index_rem_local_port_num,
                       name,
                       length,
                       exact) != VTSS_OK ) {
        return NULL;
    }


    if (exact) {

        // Check that the OID has the correct length
        if (*length < 18) { /* 1.0.8802.1.1.2.5.4795.1.3.2.1.2 + 4 indexes */
            return NULL;
        }


        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }


            if (entry.time_mark          == index_rem_time_mark &&
                entry.receive_port       == table_info.if_id &&
                entry.lldp_remote_index  == index_rem_index) {


                for (policy_idx = 0; policy_idx < MAX_LLDPMED_POLICY_APPLICATIONS_CNT; policy_idx++ ) {
                    entry_appl_type = entry.lldpmed_policy[policy_idx] >> 24 & 0xFF;
                    if (entry.lldpmed_policy_vld[policy_idx] == LLDP_TRUE &&
                        entry_appl_type == index_xmed_media_policy_app_type) {
                        policy_idx_to_be_used = policy_idx;
                        found = TRUE;
                        break;
                    }
                }
            }
        }
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");
        T_NG(TRACE_GRP_SNMP, "mark time %u - port %u - index %u, appl  %u",
             index_rem_time_mark,
             table_info.if_id,
             index_rem_index,
             index_xmed_media_policy_app_type);



        /* Use parameters of time_mark, local_port_num, index, policy_app_type
        to lookup your entry, find a entry that entry keys is great current keys */

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            for (policy_idx = 0; policy_idx < MAX_LLDPMED_POLICY_APPLICATIONS_CNT; policy_idx++ ) {
                T_RG(TRACE_GRP_SNMP, "entry.lldpmed_policy_vld[%d] = %d", policy_idx, entry.lldpmed_policy_vld[policy_idx]);
                if (entry.lldpmed_policy_vld[policy_idx] == LLDP_TRUE) {
                    entry_appl_type = entry.lldpmed_policy[policy_idx] >> 24 & 0xFF;
                    T_NG(TRACE_GRP_SNMP, "Policy found, policy_idx = %d", policy_idx);



                    if (entry.time_mark > index_rem_time_mark ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port > table_info.if_id) ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port == table_info.if_id && entry.lldp_remote_index > index_rem_index) ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port == table_info.if_id && entry.lldp_remote_index == index_rem_index &&
                         entry_appl_type > index_xmed_media_policy_app_type)) {

                        if (found == 0) {
                            /* record the fist find entry that entry keys is great current keys */
                            T_NG(TRACE_GRP_SNMP, "found = 1");
                            found = 1;
                            temp_entry = entry;
                            temp_entry_appl_type = entry_appl_type;
                            policy_idx_to_be_used = policy_idx;

                            /* keep lookup to find if there is any smaller keys entry */

                        } else if (temp_entry.time_mark > entry.time_mark ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port > entry.receive_port) ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index > entry.lldp_remote_index) ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index == entry.lldp_remote_index && temp_entry_appl_type > entry_appl_type)) {
                            /* find another smaller keys entry */
                            T_NG(TRACE_GRP_SNMP, "Update temp entry");
                            temp_entry = entry;
                            temp_entry_appl_type = entry_appl_type;
                            policy_idx_to_be_used = policy_idx;
                        }
                    }
                }
            }

        }

        entry = temp_entry;
        entry_appl_type = temp_entry_appl_type;
    }

    if (found) {
        T_NG(TRACE_GRP_SNMP, "rc = VTSS_OK");
        *length = 14; // 1.0.8802.1.1.2.1.5.4795.1.3.2.1.2
        name[(*length)++] = entry.time_mark;
        name[(*length)++] = port2table_index(entry.receive_port);
        name[(*length)++] = entry.lldp_remote_index;
        name[(*length)++] = appl_type2bits(entry_appl_type);
    } else {
        return NULL;
    }


    T_NG(TRACE_GRP_SNMP, "Policy found,policy_idx_to_be_used = %d, %d", policy_idx_to_be_used, MAX_LLDPMED_POLICY_APPLICATIONS_CNT);
    T_NG(TRACE_GRP_SNMP, "vp->magic = %u", vp->magic);
    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMMEDIAPOLICYAPPTYPE: {
        return NULL;
    }
    case LLDPXMEDREMMEDIAPOLICYVLANID: {
        VAR = (entry.lldpmed_policy[policy_idx_to_be_used] >> 9) & 0xFFF;
        T_NG(TRACE_GRP_SNMP, "LLDPXMEDREMMEDIAPOLICYVLANID VAR = %lu", VAR);
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYPRIORITY: {
        VAR = ((entry.lldpmed_policy[policy_idx_to_be_used] >> 6) & 0x7);
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYDSCP: {
        VAR = entry.lldpmed_policy[policy_idx_to_be_used] & 0x3F;
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYUNKNOWN: {
        VAR = lldpmed_get_unknown_policy_flag(entry.lldpmed_policy[policy_idx_to_be_used]);
        T_NG(TRACE_GRP_SNMP, "Unknown policy");
        return (u_char *) &VAR;
    }
    case LLDPXMEDREMMEDIAPOLICYTAGGED: {

        VAR = bool2truthvalue(lldpmed_get_tagged_flag(entry.lldpmed_policy[policy_idx_to_be_used]));
        return (u_char *) &VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemMediaPolicyTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

/*
* var_lldpXMedRemLocationTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpXMedMIB above.
*/
u_char         *
var_lldpXMedRemLocationTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
#ifdef VTSS_SW_OPTION_LLDP_MED
    static char            VAR_STR[255];
    oid                    *op = NULL;
    int                    idx_num;
    lldp_remote_entry_t    entry, temp_entry;

    lldp_u32_t index_rem_time_mark = 0;
    lldp_u32_t index_rem_local_port_num = 0;
    lldp_u16_t index_rem_index = 0;
    lldp_u16_t index_xmed_rem_location_subtype = 0;
    int       p_idx_to_be_used = 0;
    int       p_idx = 0;
    lldp_bool_t found = LLDP_FALSE;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long);     /* assume an integer and change later if not */

    // Clear the entry to start from knwon point
    memset(&entry, 0x0, sizeof(entry));
    memset(&temp_entry, 0x0, sizeof(temp_entry));


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }


    // Get the entries
    lldp_remote_entry_t *entries = NULL;
    lldp_mgmt_get_lock();
    entries = lldp_mgmt_get_entries(table_info.isid);
    lldp_mgmt_get_unlock();


    op = name + 14; // point to first index

    if (op < name + *length) {
        index_rem_time_mark = *op++;
    }

    if (op < name + *length) {
        index_rem_local_port_num = *op++;
    }

    if (op < name + *length) {
        index_rem_index = *op++;
    }

    if (op < name + *length) {
        index_xmed_rem_location_subtype = *op++;
        // For some strange reason Table 14, TIA1057 doesn't use the same numbering as the MIB in TIA1057,
        // so we have to subtract one.
        if (index_xmed_rem_location_subtype > 0) {
            index_xmed_rem_location_subtype--;
        }
    }

    ulong          table_index = 0;
    if (get_table_info(&table_index,
                       index_rem_local_port_num,
                       name,
                       length,
                       exact) != VTSS_OK) {
        return NULL;
    }


    if (exact) {

        // Check that the OID has the correct length
        if (*length < 18) { /* 1.0.8802.1.1.2.5.4795.1.3.4.1.1 + 4 indexes */
            return NULL;
        }

        // make sure that we are *exact*
        if (op != name + *length) {
            return NULL;
        }

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }


            if (entry.time_mark          == index_rem_time_mark &&
                entry.receive_port       == table_info.if_id &&
                entry.lldp_remote_index  == index_rem_index) {


                for (p_idx = 0; p_idx < MAX_LLDPMED_LOCATION_CNT; p_idx ++) {
                    if (entry.lldpmed_location_vld[p_idx] == 1) {
                        p_idx_to_be_used = p_idx;
                        found = TRUE;
                        break;
                    }
                }

            }
        }


    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");

        /* Use parameters of time_mark, local_port_num, index, policy_app_type
        to lookup your entry, find a entry that entry keys is great current keys */

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }



            for (p_idx = 0; p_idx < MAX_LLDPMED_LOCATION_CNT; p_idx ++) {
                if (entry.lldpmed_location_vld[p_idx] == 1) {
                    p_idx_to_be_used = p_idx;


                    if (entry.time_mark > index_rem_time_mark ||
                        (entry.time_mark == index_rem_time_mark && entry.receive_port > table_info.if_id) ||
                        (entry.time_mark == index_rem_time_mark &&
                         entry.receive_port == table_info.if_id &&
                         entry.lldp_remote_index > index_rem_index) ||
                        (entry.time_mark == index_rem_time_mark &&
                         entry.receive_port == table_info.if_id &&
                         entry.lldp_remote_index == index_rem_index &&
                         entry.lldpmed_location_format[p_idx_to_be_used] > index_xmed_rem_location_subtype)) {

                        if (found == FALSE) {
                            /* record the fist find entry that entry keys is great current keys */
                            T_NG(TRACE_GRP_SNMP, "found = 1");
                            found = 1;
                            temp_entry = entry;
                            p_idx_to_be_used = p_idx;
                            /* keep lookup to find if there is any smaller keys entry */

                        } else if (temp_entry.time_mark > entry.time_mark ||
                                   (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port > entry.receive_port) ||
                                   (temp_entry.time_mark == entry.time_mark &&
                                    temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index > entry.lldp_remote_index) ||
                                   (temp_entry.time_mark == entry.time_mark &&
                                    temp_entry.receive_port == entry.receive_port &&
                                    temp_entry.lldp_remote_index == entry.lldp_remote_index &&
                                    temp_entry.lldpmed_location_format[p_idx_to_be_used] > entry.lldpmed_location_format[p_idx_to_be_used])) {
                            /* find another smaller keys entry */
                            T_NG(TRACE_GRP_SNMP, "Update temp entry");
                            temp_entry = entry;
                            p_idx_to_be_used = p_idx;
                        }

                        T_NG(TRACE_GRP_SNMP, "mark time %u, %u %u - port %u, %u %u - index %u, %u %u - subtype %u %u %u",
                             entry.time_mark, temp_entry.time_mark, index_rem_time_mark,
                             entry.receive_port, temp_entry.receive_port, table_info.if_id,
                             entry.lldp_remote_index, temp_entry.lldp_remote_index, index_rem_index,
                             entry.lldpmed_location_format[p_idx_to_be_used], temp_entry.lldpmed_location_format[p_idx_to_be_used], index_xmed_rem_location_subtype);

                    }
                }
            }
        }

        entry = temp_entry;

    }


    if (found) {
        T_NG(TRACE_GRP_SNMP, "rc = VTSS_OK");
        *length = 14; // 1.0.8802.1.1.2.1.5.4795.1.3.4.1.1
        name[(*length)++] = entry.time_mark;
        name[(*length)++] = port2table_index(entry.receive_port);
        name[(*length)++] = entry.lldp_remote_index;

        // For some strange reason Table 14, TIA1057 doesn't use the same numbering as the MIB in TIA1057,
        // so we have to add one.
        name[(*length)++] = entry.lldpmed_location_format[p_idx_to_be_used] + 1;
    } else {
        return NULL;
    }

    T_NG(TRACE_GRP_SNMP, "p_idx_to_be_used = %d, %d", p_idx_to_be_used, MAX_LLDPMED_POLICY_APPLICATIONS_CNT);


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPXMEDREMLOCATIONSUBTYPE: {
        return NULL;
    }

    case LLDPXMEDREMLOCATIONINFO: {
        lldpmed_location2str(&entry, &VAR_STR[0], p_idx_to_be_used);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpXMedRemLocationTable\n",
                    vp->magic));
    }
#endif
    return NULL;
}

#ifdef VTSS_SW_OPTION_LLDP_MED
int
write_lldpXMedFastStartRepeatCount(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    static u_long  buf     = FAST_START_REPEAT_COUNT_DEFAULT;
    static u_long  old_buf = FAST_START_REPEAT_COUNT_DEFAULT;
    size_t           max_size = sizeof(u_long);
    u_char          intval = *((u_char *) var_val);


    // Get current configuration
    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid);


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < FAST_START_REPEAT_COUNT_MIN || intval  > FAST_START_REPEAT_COUNT_MAX) {
            T_NG(TRACE_GRP_SNMP, "intval = %d, var_val = %d", intval, *var_val);
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedFastStartRepeatCount: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((u_char *) var_val);
        lldp_conf.medFastStartRepeatCount = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_conf.medFastStartRepeatCount = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_UNDOFAILED;
        }
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpXMedPortConfigTLVsTxEnable(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    static long    buf, old_buf;
    long            intval;

    intval = (long)(*(var_val));

    // Get current configuration
    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid) ;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > 1) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 0 && intval > 0x3F) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigTLVsTxEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *var_val;
        lldp_conf.lldpmed_optional_tlv[PORT_INDEX] = buf;
        T_DG_PORT(TRACE_GRP_SNMP, PORT_INDEX, "Setting lldpmed_optional_tlv to 0x%X", lldp_conf.lldpmed_optional_tlv[PORT_INDEX]);
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_conf.lldpmed_optional_tlv[PORT_INDEX] = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif
int
write_lldpXMedPortConfigNotifEnable(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    static long           buf = 1, old_buf = 1;
    size_t          max_size;
    long            intval;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedPortConfigNotifEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((long *) var_val);

        if (lldpmed_mgmt_set_notification_ena(buf, PORT_INDEX, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#ifdef VTSS_SW_OPTION_LLDP_MED
int
write_lldpXMedLocLocationInfo(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    static char     buf[CIVIC_CA_VALUE_LEN_MAX + 1], old_buf[CIVIC_CA_VALUE_LEN_MAX + 1];
    size_t          max_size =  CIVIC_CA_VALUE_LEN_MAX;

    // Get current configuration
    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid) ;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedLocLocationInfo: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpXMedLocLocationInfo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }

    case ACTION:
        memcpy(buf, var_val, var_val_len);

        u8 LCI_len = buf[0]; // see figure 10 , TIA1057

        // Make sure that we don't go out of bounds
        if (LCI_len > CIVIC_CA_VALUE_LEN_MAX || LCI_len > var_val_len) {
            return SNMP_ERROR_PARM;
        }

        lldp_conf.location_info.ca_country_code[0] = buf[2]; // See figure 10 , TIA1057
        lldp_conf.location_info.ca_country_code[1] = buf[1]; // See figure 10 , TIA1057

        u8 i = 4; // Start at byte 4 (Byte 0 = LCI length, Byte 1 = What, Bytes 2,3 = Country code) - TIA1057 Figure 10
        while (i < LCI_len) {
            u8 ca_type = buf[i++];  // Get CAType and let i point to CAlength - TIA1057 Figure 10
            u8 ca_len  = buf[i++];  // Get CAlength and let i point to CAvalue - TIA1057 Figure 10
            lldpmed_update_civic_info(&lldp_conf.location_info.civic, ca_type, &buf[i]);

            i += ca_len; // Point to next civic information
        }

        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;

    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        memcpy(buf, old_buf, sizeof(buf));
        break;
    }
    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        memcpy(old_buf, buf, sizeof(buf));
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif //VTSS_SW_OPTION_LLDP_MED

// LLDP notification Trap - Must be called when ever a entry is modified.
void snmpLLDPXemMIBNotificationChange(vtss_isid_t isid, int port_index)
{

    // Set the notification OID
    oid  lldp_notifications_oid[] = {1, 0, 8802, 1, 1, 2, 1, 5, 4795, 0, 1};

    snmp_vars_trap_entry_t  trap_entry;

    // Check if notfication for the port the has has changed is enabled
    if (lldp_mgmt_get_notification_ena(port_index, table_info.isid, FALSE) == 1) {

        T_DG(TRACE_GRP_SNMP, "Notification for port was enabled");


        // Transmit the SNMP trap
        memset(&trap_entry, 0x0, sizeof(trap_entry));
        trap_entry.oid_len = OID_LENGTH(lldp_notifications_oid);
        memcpy(trap_entry.oid, lldp_notifications_oid, sizeof(oid) * trap_entry.oid_len);
        trap_entry.vars = NULL;
        snmp_send_vars_trap(SNMP_TRAP_ENTERPRISESPECIFIC, &trap_entry); // 1 means lldpRemTablesChange
    }
}

