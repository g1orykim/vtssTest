/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc4668_radiusclient.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif                     /* VTSS_SWITCH_STACKABLE */

#include "msg_api.h"
#include "sysutil_api.h"
#include "mibContextTable.h"  //mibContextTable_register

/*
 * +++ Start (Internal implementation declarations)
 */
#include "vtss_common_os.h"
#include "misc_api.h"
#ifdef VTSS_SW_OPTION_RADIUS
#include "vtss_radius_api.h"
#endif

typedef struct {
    u_long                  radiusAuthServerInetAddressType;
    u_long                  radiusAuthServerInetAddress;
    u_long                  radiusAuthClientServerInetPortNumber;
    u_long                  radiusAuthClientExtRoundTripTime;
    vtss_common_counter_t   radiusAuthClientExtAccessRequests;
    vtss_common_counter_t   radiusAuthClientExtAccessRetransmissions;
    vtss_common_counter_t   radiusAuthClientExtAccessAccepts;
    vtss_common_counter_t   radiusAuthClientExtAccessRejects;
    vtss_common_counter_t   radiusAuthClientExtAccessChallenges;
    vtss_common_counter_t   radiusAuthClientExtMalformedAccessResponses;
    vtss_common_counter_t   radiusAuthClientExtBadAuthenticators;
    u_long                  radiusAuthClientExtPendingRequests;
    vtss_common_counter_t   radiusAuthClientExtTimeouts;
    vtss_common_counter_t   radiusAuthClientExtUnknownTypes;
    vtss_common_counter_t   radiusAuthClientExtPacketsDropped;
    u_long                  radiusAuthClientCounterDiscontinuity;
} radiusAuthServerExtTable_entry_t;

int get_available_radiusAuthServerExtTableIndex(int if_num)
{
    vtss_radius_auth_client_server_mib_s   radius_auth_client_server_mib;
    vtss_rc                                rc;
    uint                                   i;

    if ((if_num < 1) || (if_num > VTSS_RADIUS_NUMBER_OF_SERVERS)) {
        return VTSS_RADIUS_NUMBER_OF_SERVERS + 1;
    }

    for (i = if_num; i <= VTSS_RADIUS_NUMBER_OF_SERVERS; i++) {
        rc = vtss_radius_auth_client_mib_get(i - 1, &radius_auth_client_server_mib);
        if ((rc != VTSS_OK) || (radius_auth_client_server_mib.state != VTSS_RADIUS_SERVER_STATE_READY)) {
            continue;
        } else {
            break;
        }
    }
    if (i > VTSS_RADIUS_NUMBER_OF_SERVERS) {
        return VTSS_RADIUS_NUMBER_OF_SERVERS + 1;
    } else {
        return i;
    }
}

BOOL get_radiusAuthServerExtTable_entry(int table_index, radiusAuthServerExtTable_entry_t *table_entry_p)
{
    vtss_radius_auth_client_server_mib_s   radius_auth_client_server_mib;
    vtss_rc                                rc;

    if (table_index > VTSS_RADIUS_NUMBER_OF_SERVERS) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(radiusAuthServerExtTable_entry_t));

    rc = vtss_radius_auth_client_mib_get(table_index - 1, &radius_auth_client_server_mib);
    if (rc != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->radiusAuthServerInetAddressType = 1; // Always IPv4 now
    table_entry_p->radiusAuthServerInetAddress = radius_auth_client_server_mib.radiusAuthServerInetAddress;
    table_entry_p->radiusAuthClientServerInetPortNumber = radius_auth_client_server_mib.radiusAuthClientServerInetPortNumber;
    table_entry_p->radiusAuthClientExtRoundTripTime = radius_auth_client_server_mib.radiusAuthClientExtRoundTripTime;
    table_entry_p->radiusAuthClientExtAccessRequests = radius_auth_client_server_mib.radiusAuthClientExtAccessRequests;
    table_entry_p->radiusAuthClientExtAccessRetransmissions = radius_auth_client_server_mib.radiusAuthClientExtAccessRetransmissions;
    table_entry_p->radiusAuthClientExtAccessAccepts = radius_auth_client_server_mib.radiusAuthClientExtAccessAccepts;
    table_entry_p->radiusAuthClientExtAccessRejects = radius_auth_client_server_mib.radiusAuthClientExtAccessRejects;
    table_entry_p->radiusAuthClientExtAccessChallenges = radius_auth_client_server_mib.radiusAuthClientExtAccessChallenges;
    table_entry_p->radiusAuthClientExtMalformedAccessResponses = radius_auth_client_server_mib.radiusAuthClientExtMalformedAccessResponses;
    table_entry_p->radiusAuthClientExtBadAuthenticators = radius_auth_client_server_mib.radiusAuthClientExtBadAuthenticators;
    table_entry_p->radiusAuthClientExtPendingRequests = radius_auth_client_server_mib.radiusAuthClientExtPendingRequests;
    table_entry_p->radiusAuthClientExtTimeouts = radius_auth_client_server_mib.radiusAuthClientExtTimeouts;
    table_entry_p->radiusAuthClientExtUnknownTypes = radius_auth_client_server_mib.radiusAuthClientExtUnknownTypes;
    table_entry_p->radiusAuthClientExtPacketsDropped = radius_auth_client_server_mib.radiusAuthClientExtPacketsDropped;
    table_entry_p->radiusAuthClientCounterDiscontinuity = radius_auth_client_server_mib.radiusAuthClientCounterDiscontinuity;

    return TRUE;
}

/*
 * --- End (Internal implementation declarations)
 */

/*
 * radiusAuthClientMIBObjects_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             radiusAuthClientMIBObjects_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 67, 1, 2, 1 };

/*
 * variable4 radiusAuthClientMIBObjects_variables:
 *   this variable defines function callbacks and type return information
 *   for the radiusAuthClientMIBObjects mib section
 */

struct variable4 radiusAuthClientMIBObjects_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define RADIUSAUTHCLIENTINVALIDSERVERADDRESSES          1
//    {RADIUSAUTHCLIENTINVALIDSERVERADDRESSES, ASN_COUNTER, RONLY, var_radiusAuthClientMIBObjects, 2, {1, 1}},
#define RADIUSAUTHCLIENTIDENTIFIER                      2
    {RADIUSAUTHCLIENTIDENTIFIER, ASN_OCTET_STR, RONLY, var_radiusAuthClientMIBObjects, 2, {1, 2}},

    /* These OIDs are Obsolete in RFC 4668
    #define RADIUSAUTHSERVERINDEX                           3
        {RADIUSAUTHSERVERINDEX, ASN_INTEGER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 1}},
    #define RADIUSAUTHSERVERADDRESS                         4
        {RADIUSAUTHSERVERADDRESS, ASN_IPADDRESS, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 2}},
    #define RADIUSAUTHCLIENTSERVERPORTNUMBER                5
        {RADIUSAUTHCLIENTSERVERPORTNUMBER, ASN_INTEGER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 3}},
    #define RADIUSAUTHCLIENTROUNDTRIPTIME                   6
        {RADIUSAUTHCLIENTROUNDTRIPTIME, ASN_TIMETICKS, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 4}},
    #define RADIUSAUTHCLIENTACCESSREQUESTS                  7
        {RADIUSAUTHCLIENTACCESSREQUESTS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 5}},
    #define RADIUSAUTHCLIENTACCESSRETRANSMISSIONS           8
        {RADIUSAUTHCLIENTACCESSRETRANSMISSIONS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 6}},
    #define RADIUSAUTHCLIENTACCESSACCEPTS                   9
        {RADIUSAUTHCLIENTACCESSACCEPTS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 7}},
    #define RADIUSAUTHCLIENTACCESSREJECTS                   10
        {RADIUSAUTHCLIENTACCESSREJECTS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 8}},
    #define RADIUSAUTHCLIENTACCESSCHALLENGES                11
        {RADIUSAUTHCLIENTACCESSCHALLENGES, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 9}},
    #define RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES        12
        {RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 10}},
    #define RADIUSAUTHCLIENTBADAUTHENTICATORS               13
        {RADIUSAUTHCLIENTBADAUTHENTICATORS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 11}},
    #define RADIUSAUTHCLIENTPENDINGREQUESTS                 14
        {RADIUSAUTHCLIENTPENDINGREQUESTS, ASN_GAUGE, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 12}},
    #define RADIUSAUTHCLIENTTIMEOUTS                        15
        {RADIUSAUTHCLIENTTIMEOUTS, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 13}},
    #define RADIUSAUTHCLIENTUNKNOWNTYPES                    16
        {RADIUSAUTHCLIENTUNKNOWNTYPES, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 14}},
    #define RADIUSAUTHCLIENTPACKETSDROPPED                  17
        {RADIUSAUTHCLIENTPACKETSDROPPED, ASN_COUNTER, RONLY, var_radiusAuthServerTable, 4, {1, 3, 1, 15}},*/
#define RADIUSAUTHSERVEREXTINDEX                        18
//    {RADIUSAUTHSERVEREXTINDEX, ASN_INTEGER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 1}},
#define RADIUSAUTHSERVERINETADDRESSTYPE                 19
    {RADIUSAUTHSERVERINETADDRESSTYPE, ASN_INTEGER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 2}},
#define RADIUSAUTHSERVERINETADDRESS                     20
    {RADIUSAUTHSERVERINETADDRESS, ASN_OCTET_STR, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 3}},
#define RADIUSAUTHCLIENTSERVERINETPORTNUMBER            21
    {RADIUSAUTHCLIENTSERVERINETPORTNUMBER, ASN_UNSIGNED, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 4}},
#define RADIUSAUTHCLIENTEXTROUNDTRIPTIME                22
    {RADIUSAUTHCLIENTEXTROUNDTRIPTIME, ASN_TIMETICKS, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 5}},
#define RADIUSAUTHCLIENTEXTACCESSREQUESTS               23
    {RADIUSAUTHCLIENTEXTACCESSREQUESTS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 6}},
#define RADIUSAUTHCLIENTEXTACCESSRETRANSMISSIONS        24
    {RADIUSAUTHCLIENTEXTACCESSRETRANSMISSIONS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 7}},
#define RADIUSAUTHCLIENTEXTACCESSACCEPTS                25
    {RADIUSAUTHCLIENTEXTACCESSACCEPTS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 8}},
#define RADIUSAUTHCLIENTEXTACCESSREJECTS                26
    {RADIUSAUTHCLIENTEXTACCESSREJECTS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 9}},
#define RADIUSAUTHCLIENTEXTACCESSCHALLENGES             27
    {RADIUSAUTHCLIENTEXTACCESSCHALLENGES, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 10}},
#define RADIUSAUTHCLIENTEXTMALFORMEDACCESSRESPONSES     28
    {RADIUSAUTHCLIENTEXTMALFORMEDACCESSRESPONSES, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 11}},
#define RADIUSAUTHCLIENTEXTBADAUTHENTICATORS            29
    {RADIUSAUTHCLIENTEXTBADAUTHENTICATORS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 12}},
#define RADIUSAUTHCLIENTEXTPENDINGREQUESTS              30
    {RADIUSAUTHCLIENTEXTPENDINGREQUESTS, ASN_GAUGE, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 13}},
#define RADIUSAUTHCLIENTEXTTIMEOUTS                     31
    {RADIUSAUTHCLIENTEXTTIMEOUTS, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 14}},
#define RADIUSAUTHCLIENTEXTUNKNOWNTYPES                 32
    {RADIUSAUTHCLIENTEXTUNKNOWNTYPES, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 15}},
#define RADIUSAUTHCLIENTEXTPACKETSDROPPED               33
    {RADIUSAUTHCLIENTEXTPACKETSDROPPED, ASN_COUNTER, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 16}},
#define RADIUSAUTHCLIENTCOUNTERDISCONTINUITY            34
    {RADIUSAUTHCLIENTCOUNTERDISCONTINUITY, ASN_TIMETICKS, RONLY, var_radiusAuthServerExtTable, 4, {1, 4, 1, 17}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * FIXME: template declaration for compiler completed
 */
static long     VAR = 0, VALUE = 0;

/*
 * Initializes the radiusAuthClientMIBObjects module
 */
void
init_radiusAuthClientMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(radiusAuthClientMIBObjects_variables_oid,
                             sizeof(radiusAuthClientMIBObjects_variables_oid) / sizeof(oid),
                             "RADIUS-AUTH-CLIENT-MIB : radiusAuthClientMIBObjects");

    DEBUGMSGTL(("radiusAuthClientMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("radiusAuthClientMIBObjects",
                 radiusAuthClientMIBObjects_variables, variable4,
                 radiusAuthClientMIBObjects_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_radiusAuthClientMIBObjects():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_radiusAuthClientMIBObjects(struct variable *vp,
                               oid *name,
                               size_t *length,
                               int exact,
                               size_t *var_len,
                               WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */
    system_conf_t   system_conf;
    static u_char   string[VTSS_SYS_STRING_LEN];

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSAUTHCLIENTINVALIDSERVERADDRESSES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTIDENTIFIER: {
        (void)system_get_config(&system_conf);
        *var_len = strlen(system_conf.sys_name);
        memcpy(string, system_conf.sys_name, strlen(system_conf.sys_name));
        return (u_char *)string;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAuthClientMIBObjects\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* These OIDs are Obsolete in RFC 4668 */
/*
 * var_radiusAuthServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_radiusAuthClientMIBObjects above.
 */
u_char         *
var_radiusAuthServerTable(struct variable *vp,
                          oid *name,
                          size_t *length,
                          int exact,
                          size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //radiusAuthServerTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_radiusAuthServerTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_radiusAuthServerTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSAUTHSERVERINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHSERVERADDRESS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTSERVERPORTNUMBER: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTROUNDTRIPTIME: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTACCESSREQUESTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTACCESSRETRANSMISSIONS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTACCESSACCEPTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTACCESSREJECTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTACCESSCHALLENGES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTBADAUTHENTICATORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTPENDINGREQUESTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTTIMEOUTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTUNKNOWNTYPES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHCLIENTPACKETSDROPPED: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAuthServerTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif

/*
 * var_radiusAuthServerExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_radiusAuthClientMIBObjects above.
 */
u_char         *
var_radiusAuthServerExtTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                                table_size;
    int                                idx_num;
    int                                table_index;
    radiusAuthServerExtTable_entry_t   table_entry;
    static u_long                      ulong_ret;

    table_size = VTSS_RADIUS_NUMBER_OF_SERVERS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_radiusAuthServerExtTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_radiusAuthServerExtTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSAUTHSERVEREXTINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSAUTHSERVERINETADDRESSTYPE: {
        ulong_ret = table_entry.radiusAuthServerInetAddressType;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHSERVERINETADDRESS: {
        static char ip_buf[16];

        (void)misc_ipv4_txt(table_entry.radiusAuthServerInetAddress, ip_buf);
        *var_len = strlen(ip_buf);
        return (u_char *)ip_buf;
    }
    case RADIUSAUTHCLIENTSERVERINETPORTNUMBER: {
        ulong_ret = table_entry.radiusAuthClientServerInetPortNumber;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTROUNDTRIPTIME: {
        ulong_ret = table_entry.radiusAuthClientExtRoundTripTime * ECOS_MSECS_PER_HWTICK * 100 / 1000;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTACCESSREQUESTS: {
        ulong_ret = table_entry.radiusAuthClientExtAccessRequests;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTACCESSRETRANSMISSIONS: {
        ulong_ret = table_entry.radiusAuthClientExtAccessRetransmissions;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTACCESSACCEPTS: {
        ulong_ret = table_entry.radiusAuthClientExtAccessAccepts;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTACCESSREJECTS: {
        ulong_ret = table_entry.radiusAuthClientExtAccessRejects;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTACCESSCHALLENGES: {
        ulong_ret = table_entry.radiusAuthClientExtAccessChallenges;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTMALFORMEDACCESSRESPONSES: {
        ulong_ret = table_entry.radiusAuthClientExtMalformedAccessResponses;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTBADAUTHENTICATORS: {
        ulong_ret = table_entry.radiusAuthClientExtBadAuthenticators;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTPENDINGREQUESTS: {
        ulong_ret = table_entry.radiusAuthClientExtPendingRequests;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTTIMEOUTS: {
        ulong_ret = table_entry.radiusAuthClientExtTimeouts;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTUNKNOWNTYPES: {
        ulong_ret = table_entry.radiusAuthClientExtUnknownTypes;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTEXTPACKETSDROPPED: {
        ulong_ret = table_entry.radiusAuthClientExtPacketsDropped;
        return (u_char *) & ulong_ret;
    }
    case RADIUSAUTHCLIENTCOUNTERDISCONTINUITY: {
        ulong_ret = table_entry.radiusAuthClientCounterDiscontinuity * ECOS_MSECS_PER_HWTICK * 100 / 1000;
        return (u_char *) & ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAuthServerExtTable\n",
                    vp->magic));
    }
    return NULL;
}

