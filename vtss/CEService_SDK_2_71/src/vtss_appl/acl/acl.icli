#
# Vitesse Switch software.
#
# Copyright (c) 2002-2014 Vitesse Semiconductor Corporation "Vitesse". All
# Rights Reserved.
#
# Unpublished rights reserved under the copyright laws of the United States of
# America, other countries and international treaties. Permission to use, copy,
# store and modify, the software and its source code is granted. Permission to
# integrate into other products, disclose, transmit and distribute the software
# in an absolute machine readable format (e.g. HEX file) is also granted.  The
# source code of the software may not be disclosed, transmitted or distributed
# without the written permission of Vitesse. The software and its source code
# may only be used in products utilizing the Vitesse switch products.
#
# This copyright notice must appear in any copy, modification, disclosure,
# transmission or distribution of the software. Vitesse retains all ownership,
# copyright, trade secret and proprietary rights in the software.
#
# THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
# INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR USE AND NON-INFRINGEMENT.
#

MODULE_IF_FLAG = defined(VTSS_SW_OPTION_ACL)

INCLUDE_BEGIN
#include "icli_porting_util.h"
#include "acl_api.h"
#include "misc_api.h"   //uport2iport(), iport2uport()
#include "port_api.h"
#include "mgmt_api.h"   //mgmt_acl_type_txt()
#include "msg_api.h"    //msg_switch_exists()
#include "topo_api.h"   //topo_usid2isid(), topo_isid2usid()
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
#include "evc_api.h"
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */

/*lint --e{438, 550} */
//(438) Last value assigned to variable 'xxx' not used - It is occured the runtime option.
//(550) Symbol 'xx' not accessed - It is occured the runtime option.
INCLUDE_END

FUNCTION_BEGIN

#define ACL_ICLI_BUF_SIZE               80
#define ICLI_SESSION_CTRL_C_CHECK_CNT   100
#define ICLI_SESSION_CTRL_C_WAIT        100     /* 0.1 secs */


static BOOL ACL_ICLI_runtime_has_stackable(u32                session_id,
                                           icli_runtime_ask_t ask,
                                           icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SWITCH_STACKABLE */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_v1(u32                session_id,
                                    icli_runtime_ask_t ask,
                                    icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_FEATURE_ACL_V1)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_FEATURE_ACL_V1 */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_v2(u32                session_id,
                                    icli_runtime_ask_t ask,
                                    icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_FEATURE_ACL_V2)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_FEATURE_ACL_V2 */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_serval(u32                session_id,
                                        icli_runtime_ask_t ask,
                                        icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_SERVAL)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_SERVAL */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_ipv6(u32                session_id,
                                      icli_runtime_ask_t ask,
                                      icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(ACL_IPV6_SUPPORTED)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* ACL_IPV6_SUPPORTED */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_evc(u32                session_id,
                                     icli_runtime_ask_t ask,
                                     icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_evc_policer_id_init) */
/*lint -esym(459,ACL_ICLI_runtime_evc_policer_id_txt) */
static BOOL ACL_ICLI_runtime_evc_policer_id(u32                session_id,
                                            icli_runtime_ask_t ask,
                                            icli_runtime_t     *runtime)
{
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = TRUE;
        return TRUE;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<EvcPolicerId : %u-%u>", ACL_EVC_POLICER_NO_START, ACL_EVC_POLICER_NO_END);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = ACL_EVC_POLICER_NO_START;
        runtime->range.u.sr.range[0].max = ACL_EVC_POLICER_NO_END;
        return TRUE;
    default:
        break;
    }
#else
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = FALSE;
        return TRUE;
    default:
        break;
    }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_ace_init) */
/*lint -esym(459,ACL_ICLI_runtime_ace_txt) */
static BOOL ACL_ICLI_runtime_ace(u32                session_id,
                                 icli_runtime_ask_t ask,
                                 icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<AceId : %u-%u>", ACE_ID_START, ACE_ID_END);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = ACE_ID_START;
        runtime->range.u.sr.range[0].max = ACE_ID_END;
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_ace_list_init) */
/*lint -esym(459,ACL_ICLI_runtime_ace_list_txt) */
static BOOL ACL_ICLI_runtime_ace_list(u32                session_id,
                                      icli_runtime_ask_t ask,
                                      icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<AceId : %u~%u>", ACE_ID_START, ACE_ID_END);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = ACE_ID_START;
        runtime->range.u.sr.range[0].max = ACE_ID_END;
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_switch_port_id_init) */
/*lint -esym(459,ACL_ICLI_runtime_switch_port_id_txt) */
static BOOL ACL_ICLI_runtime_switch_port_id(u32                session_id,
                                            icli_runtime_ask_t ask,
                                            icli_runtime_t     *runtime)
{
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE && defined (VTSS_FEATURE_ACL_V1)
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = TRUE;
        return TRUE;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<SwitchPortId : %u-%u>", VTSS_PORT_NO_START + 1, VTSS_PORT_NO_END);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = VTSS_PORT_NO_START + 1;
        runtime->range.u.sr.range[0].max = VTSS_PORT_NO_END;
        return TRUE;
    default:
        break;
    }
#else
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = FALSE;
        return TRUE;
    default:
        break;
    }
#endif /* VTSS_SWITCH_STACKABLE && VTSS_FEATURE_ACL_V1 */

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_switch_port_list_init) */
/*lint -esym(459,ACL_ICLI_runtime_switch_port_list_txt) */
static BOOL ACL_ICLI_runtime_switch_port_list(u32                session_id,
                                              icli_runtime_ask_t ask,
                                              icli_runtime_t     *runtime)
{
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE && defined (VTSS_FEATURE_ACL_V2)
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = TRUE;
        return TRUE;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<SwitchPortList : %u~%u>", VTSS_PORT_NO_START + 1, VTSS_PORT_NO_END);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = VTSS_PORT_NO_START + 1;
        runtime->range.u.sr.range[0].max = VTSS_PORT_NO_END;
        return TRUE;
    default:
        break;
    }
#else
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = FALSE;
        return TRUE;
    default:
        break;
    }
#endif /* VTSS_SWITCH_STACKABLE && VTSS_FEATURE_ACL_V2 */

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_policy_init) */
/*lint -esym(459,ACL_ICLI_runtime_policy_txt) */
static BOOL ACL_ICLI_runtime_policy(u32                session_id,
                                    icli_runtime_ask_t ask,
                                    icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<PolicyId : 0-%u>", ACL_POLICIES);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 0;
        runtime->range.u.sr.range[0].max = ACL_POLICIES;
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_policy_bitmask_init) */
/*lint -esym(459,ACL_ICLI_runtime_policy_bitmask_txt) */
static BOOL ACL_ICLI_runtime_policy_bitmask(u32                session_id,
                                            icli_runtime_ask_t ask,
                                            icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<PolicyBitmask : 0-0x%X>", ACL_POLICIES_BITMASK);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 0;
        runtime->range.u.sr.range[0].max = ACL_POLICIES_BITMASK;
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_rate_limiter_init) */
/*lint -esym(459,ACL_ICLI_runtime_rate_limiter_txt) */
static BOOL ACL_ICLI_runtime_rate_limiter(u32                session_id,
                                          icli_runtime_ask_t ask,
                                          icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<RateLimiterId : %u-%u>", ipolicer2upolicer(ACL_POLICER_NO_START), ipolicer2upolicer(ACL_POLICER_NO_END - 1));
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = ipolicer2upolicer(ACL_POLICER_NO_START);
        runtime->range.u.sr.range[0].max = ipolicer2upolicer(ACL_POLICER_NO_END - ACL_POLICER_NO_START - 1);
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_rate_limiter_list_init) */
/*lint -esym(459,ACL_ICLI_runtime_rate_limiter_list_txt) */
static BOOL ACL_ICLI_runtime_rate_limiter_list(u32                session_id,
                                               icli_runtime_ask_t ask,
                                               icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<RateLimiterList : %u~%u>", ipolicer2upolicer(ACL_POLICER_NO_START), ipolicer2upolicer(ACL_POLICER_NO_END - 1));
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = ipolicer2upolicer(ACL_POLICER_NO_START);
        runtime->range.u.sr.range[0].max = ipolicer2upolicer(ACL_POLICER_NO_END - ACL_POLICER_NO_START - 1);
        return TRUE;
    default:
        break;
    }

    return FALSE;
}

// Protected by ICLI thread                       
/*lint -esym(459,ACL_ICLI_runtime_pps_init) */
/*lint -esym(459,ACL_ICLI_runtime_pps_txt) */
static BOOL ACL_ICLI_runtime_pps(u32                session_id,
                                 icli_runtime_ask_t ask,
                                 icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
#if !defined(VTSS_ARCH_LUTON28)
#if defined(VTSS_ARCH_SERVAL)
        icli_sprintf(runtime->byword, "<PpsRate : 0-99>");
#else
        icli_sprintf(runtime->byword, "<PpsRate : 0-%u>", ACL_PACKET_RATE_MAX);
#endif /* VTSS_ARCH_SERVAL */
        return TRUE;
#endif /* !VTSS_ARCH_LUTON28 */
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
#if !defined(VTSS_ARCH_LUTON28)
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 0;
#if defined(VTSS_ARCH_SERVAL)
        runtime->range.u.sr.range[0].max = 99;
#else
        runtime->range.u.sr.range[0].max = ACL_PACKET_RATE_MAX;
#endif /* VTSS_ARCH_SERVAL */
        return TRUE;
#endif /* !VTSS_ARCH_LUTON28 */
    default:
        break;
    }

    return FALSE;
}

static BOOL ACL_ICLI_runtime_100pps(u32                session_id,
                                    icli_runtime_ask_t ask,
                                    icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_SERVAL)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_SERVAL */
        return TRUE;
    case ICLI_ASK_BYWORD:
#if defined(VTSS_ARCH_SERVAL)
        icli_sprintf(runtime->byword, "<100PpsRate : 1-%u>", ACL_PACKET_RATE_MAX / 100);
        return TRUE;
#endif /* VTSS_ARCH_SERVAL */
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
#if defined(VTSS_ARCH_SERVAL)
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 1;
        runtime->range.u.sr.range[0].max = ACL_PACKET_RATE_MAX / 100;
        return TRUE;
#endif /* VTSS_ARCH_SERVAL */
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_kpps(u32                session_id,
                                  icli_runtime_ask_t ask,
                                  icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_LUTON28)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_LUTON28 */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

// Protected by ICLI thread
/*lint -esym(459,ACL_ICLI_runtime_100kbps_init) */
/*lint -esym(459,ACL_ICLI_runtime_100kbps_txt) */
static BOOL ACL_ICLI_runtime_100kbps(u32                session_id,
                                     icli_runtime_ask_t ask,
                                     icli_runtime_t     *runtime)
{
#if defined(VTSS_FEATURE_ACL_V2)
    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<100KbpsRate : 0-%u>", (ACL_BIT_RATE_MAX / 100));
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 0;
        runtime->range.u.sr.range[0].max = (ACL_PACKET_RATE_MAX / 100);
        return TRUE;
    default:
        break;
    }
#else
    switch (ask) {
    case ICLI_ASK_PRESENT:
        runtime->present = FALSE;
        return TRUE;
    default:
        break;
    }
#endif /* VTSS_FEATURE_ACL_V2 */

    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_redirect(u32                session_id,
                                          icli_runtime_ask_t ask,
                                          icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if !defined(VTSS_ARCH_LUTON28)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_LUTON28 */
        return TRUE;

    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_has_port_copy(u32                session_id,
                                           icli_runtime_ask_t ask,
                                           icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_LUTON28)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_LUTON28 */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

#if 0 //defined(VTSS_ARCH_LUTON28)
// Protected by ICLI thread
/*lint -esym(459,ACL_ICLI_runtime_port_copy_init) */
/*lint -esym(459,ACL_ICLI_runtime_port_copy_txt) */
static BOOL ACL_ICLI_runtime_port_copy(u32                session_id,
                                       icli_runtime_ask_t ask,
                                       icli_runtime_t     *runtime)
{
    u32                         port_count, max_port_count = 0;
    icli_switch_port_range_t    switch_range;

    memset(&switch_range, 0, sizeof(switch_range));
    while (icli_switch_get_next(&switch_range)) {
        if ((port_count = port_isid_port_count(switch_range.isid)) > max_port_count) {
            max_port_count = port_count;
        }
    }

    switch (ask) {
    case ICLI_ASK_PRESENT:
        break;
    case ICLI_ASK_BYWORD:
        icli_sprintf(runtime->byword, "<PortCopyNo : 1-%u>", max_port_count);
        return TRUE;
    case ICLI_ASK_HELP:
        break;
    case ICLI_ASK_RANGE:
        runtime->range.type = ICLI_RANGE_TYPE_UNSIGNED;
        runtime->range.u.sr.cnt = 1;
        runtime->range.u.sr.range[0].min = 1;
        runtime->range.u.sr.range[0].max = max_port_count;
        return TRUE;
    default:
        break;
    }
    return FALSE;
}
#endif /* VTSS_ARCH_LUTON28 */

static BOOL ACL_ICLI_runtime_vol_link_oam(u32                session_id,
                                          icli_runtime_ask_t ask,
                                          icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_ETH_LINK_OAM)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_ETH_LINK_OAM */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_loop_protect(u32                session_id,
                                              icli_runtime_ask_t ask,
                                             icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_LOOP_PROTECT)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_LOOP_PROTECT */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_dhcp(u32                session_id,
                                      icli_runtime_ask_t ask,
                                      icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_DHCP_HELPER)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_DHCP_HELPER */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_ptp(u32                session_id,
                                     icli_runtime_ask_t ask,
                                     icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_PTP) || defined(VTSS_SW_OPTION_PHY_1588_SIM)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_PTP) || VTSS_SW_OPTION_PHY_1588_SIM */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_upnp(u32                session_id,
                                      icli_runtime_ask_t ask,
                                      icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_UPNP)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_UPNP */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_arp_inspection(u32                session_id,
                                               icli_runtime_ask_t ask,
                                               icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_ARP_INSPECTION)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_ARP_INSPECTION */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_evc(u32                session_id,
                                     icli_runtime_ask_t ask,
                                     icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_EVC)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_EVC */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_mep(u32                session_id,
                                     icli_runtime_ask_t ask,
                                     icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_MEP)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_MEP */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_ipmc(u32                session_id,
                                      icli_runtime_ask_t ask,
                                      icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_IPMC) || defined(VTSS_SW_OPTION_IGMPS) || defined(VTSS_SW_OPTION_MLDSNP)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_IPMC || VTSS_SW_OPTION_IGMPS || VTSS_SW_OPTION_MLDSNP */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_ip_source_guard(u32                session_id,
                                                 icli_runtime_ask_t ask,
                                                icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_SW_OPTION_IP_SOURCE_GUARD)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_SW_OPTION_IP_SOURCE_GUARD */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

static BOOL ACL_ICLI_runtime_vol_ip_mgmt(u32                session_id,
                                        icli_runtime_ask_t ask,
                                        icli_runtime_t     *runtime)
{
    switch (ask) {
    case ICLI_ASK_PRESENT:
#if defined(VTSS_ARCH_JAGUAR_1_CE_MAC) || defined(VTSS_SW_OPTION_IP_MGMT_ACL)
        runtime->present = TRUE;
#else
        runtime->present = FALSE;
#endif /* VTSS_ARCH_JAGUAR_1_CE_MAC || VTSS_SW_OPTION_IP_MGMT_ACL */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

#if defined (VTSS_FEATURE_ACL_V1)
static char *ACL_ICLI_port_or_disabled_txt(vtss_isid_t isid, vtss_port_no_t iport, char *str_buf_p)
{
    if (iport == VTSS_PORT_NO_NONE) {
        strcpy(str_buf_p, icli_bool_txt(FALSE));
    } else {
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
        if (isid == VTSS_ISID_GLOBAL) {
            sprintf(str_buf_p, "%u", iport2uport(iport));
        } else {
            (void) icli_port_info_txt(topo_isid2usid(isid), iport2uport(iport), str_buf_p);
        }
#else
        (void) icli_port_info_txt(VTSS_USID_START, iport2uport(iport), str_buf_p);
#endif /* VTSS_SWITCH_STACKABLE */
    }
    return str_buf_p;
}
#endif /* VTSS_FEATURE_ACL_V1 */

static char *ACL_ICLI_policer_txt(vtss_acl_policer_no_t ipolicer, char *buf, BOOL lower)
{
    if (ipolicer == ACL_POLICER_NONE) {
        if (lower) {
            strcpy(buf, "disabled");
        } else {
            strcpy(buf, "Disabled");
        }
    } else {
        sprintf(buf, "%u", ipolicer2upolicer(ipolicer));
    }
    return buf;
}

static void ACL_ICLI_port_conf_show(u32 session_id, vtss_usid_t usid, vtss_port_no_t uport, BOOL first)
{
    vtss_rc         rc;
    vtss_isid_t     isid = topo_usid2isid(usid);
    vtss_port_no_t  iport = uport2iport(uport);
    acl_port_conf_t port_conf;
    port_vol_conf_t port_state;
    u32             port_counter;
    char            str_buf[ACL_ICLI_BUF_SIZE], port_buf[16 * VTSS_PORTS];

    //ignore stacking port
    if (port_isid_port_no_is_stack(isid, iport)) {
        return;
    }

    icli_port_header(session_id, usid, uport, "", !first, FALSE);

    memset(&port_state, 0, sizeof(port_state));
    if ((rc = acl_mgmt_port_conf_get(isid, iport, &port_conf)) != VTSS_OK ||
        (msg_switch_exists(isid) && (rc = port_vol_conf_get(PORT_USER_ACL, isid, iport, &port_state) != VTSS_OK)) ||
        (rc = acl_mgmt_port_counter_get(isid, iport, &port_counter) != VTSS_OK)) {
        ICLI_PRINTF("%% Failed to get access-list port configuration.\n");
        return;
    }

    (void) icli_port_info_txt(usid, uport, port_buf);
#if defined(VTSS_FEATURE_ACL_V2)
     ICLI_PRINTF("%s access-list action is %s\n", port_buf, port_conf.action.port_action == VTSS_ACL_PORT_ACTION_NONE ? "permit" : "deny");
#else
    ICLI_PRINTF("%s access-list action is %s\n", port_buf, port_conf.action.permit ? "permit" : "deny");
#endif /* VTSS_FEATURE_ACL_V2 */

    ICLI_PRINTF("%s access-list policy ID is %u\n", port_buf, port_conf.policy_no);
    ICLI_PRINTF("%s access-list rate limiter ID is %s\n", port_buf, ACL_ICLI_policer_txt(port_conf.action.policer, str_buf, TRUE));

#if defined(VTSS_FEATURE_ACL_V2)
    ICLI_PRINTF("%s access-list %s is %s\n",
                port_buf,
                "redirect",
                port_conf.action.port_action != VTSS_ACL_PORT_ACTION_REDIR ? "disabled" : icli_port_list_info_txt(isid, port_conf.action.port_list, str_buf, FALSE));
#else

#if defined(VTSS_ARCH_LUTON28)
    ICLI_PRINTF("%s access-list port-copy is %s\n",
                port_buf,
                ACL_ICLI_port_or_disabled_txt(isid, port_conf.action.port_no, str_buf));
#else
    ICLI_PRINTF("%s access-list redirect is %s\n",
                port_buf,
                ACL_ICLI_port_or_disabled_txt(isid, port_conf.action.port_no, str_buf));
#endif /* VTSS_ARCH_LUTON28 */

#endif /* VTSS_FEATURE_ACL_V2 */

#if defined(VTSS_FEATURE_ACL_V2)
    ICLI_PRINTF("%s access-list mirror is %s\n", port_buf, icli_bool_txt(port_conf.action.mirror));
#endif /* VTSS_FEATURE_ACL_V2 */

    ICLI_PRINTF("%s access-list logging is %s\n", port_buf, icli_bool_txt(port_conf.action.logging));
    ICLI_PRINTF("%s access-list shutdown is %s\n", port_buf, icli_bool_txt(port_conf.action.shutdown));
    ICLI_PRINTF("%s access-list port-state is %s\n", port_buf, icli_bool_txt(!port_state.disable));
    ICLI_PRINTF("%s access-list counter is %u\n", port_buf, port_counter);
}

static void ACL_ICLI_interface_parse(u32 session_id, icli_stack_port_range_t *port_type_list_p)
{
    u32                         range_idx, cnt_idx;
    vtss_usid_t                 usid;
    vtss_port_no_t              uport;
    icli_switch_port_range_t    switch_range;
    BOOL                        first = TRUE;

    if (port_type_list_p) { //at least one range input
        for (range_idx = 0; range_idx < port_type_list_p->cnt; range_idx++) {
            usid = port_type_list_p->switch_range[range_idx].usid;
            for (cnt_idx = 0; cnt_idx < port_type_list_p->switch_range[range_idx].port_cnt; cnt_idx++) {
                uport = port_type_list_p->switch_range[range_idx].begin_uport + cnt_idx;

                //ignore stacking port
                if (port_isid_port_no_is_stack(topo_usid2isid(usid), uport2iport(uport))) {
                    continue;
                }

                ACL_ICLI_port_conf_show(session_id, usid, uport, port_type_list_p->cnt == 1 ? FALSE : first);
                if (first) {
                    first = FALSE;
                }
            }
        }
    } else { //show all port configuraton
        memset(&switch_range, 0, sizeof(switch_range));
        while (icli_port_get_next(&switch_range)) {
                ACL_ICLI_port_conf_show(session_id, switch_range.usid, switch_range.begin_uport, first);
                if (first) {
                    first = FALSE;
                }
        }
    }
}

static void ACL_ICLI_rate_limiter_show(u32 session_id, vtss_acl_policer_no_t upolicer)
{
    vtss_rc            rc;
    acl_policer_conf_t conf;

    if ((rc = acl_mgmt_policer_conf_get(upolicer2ipolicer(upolicer), &conf) != VTSS_OK)) {
        ICLI_PRINTF("%% Failed to get access-list rate-limiter configuration.\n");
        return;
    }

#if defined(VTSS_FEATURE_ACL_V2)
    if (conf.bit_rate_enable) {
        ICLI_PRINTF("Switch access-list rate limiter ID %u is %u kbps\n",
                    upolicer,
                    conf.bit_rate);
    }
    else
#endif /* VTSS_FEATURE_ACL_V2 */
    {
        ICLI_PRINTF("Switch access-list rate limiter ID %u is %u %s\n",
                    upolicer,
                    conf.packet_rate / 1000 ? conf.packet_rate / 1000 : conf.packet_rate,
                    conf.packet_rate / 1000 ? "kpps" : "pps");
    }

    return;
}

static void ACL_ICLI_rate_limiter_parse(u32 session_id, icli_unsigned_range_t *rate_limiter_list_p)
{
    u32                     range_idx;
    vtss_acl_policer_no_t   policer_idx;

    if (rate_limiter_list_p) { //at least one range input
        for (range_idx = 0; range_idx < rate_limiter_list_p->cnt; range_idx++) {
            for (policer_idx = rate_limiter_list_p->range[range_idx].min; policer_idx <= rate_limiter_list_p->range[range_idx].max; policer_idx++) {
                ACL_ICLI_rate_limiter_show(session_id, policer_idx);
            }
        }
    } else { //show all rate limiter configuraton
        for (policer_idx = ACL_POLICER_NO_START; policer_idx < ACL_POLICER_NO_END; policer_idx++) {
            ACL_ICLI_rate_limiter_show(session_id, ipolicer2upolicer(policer_idx));
        }
    }
}

static char *ACL_ICLI_acl_user_txt(BOOL acronym, acl_user_t user_id, char *buf)
{
    if (acronym) {
        switch (user_id) {
        case ACL_USER_STATIC:
            strcpy(buf, "S   ");
            break;
#if defined(VTSS_ARCH_JAGUAR_1_CE_MAC) || defined(IP_MGMT_USING_MAC_ACL_ENTRIES)
        case ACL_USER_IP_MGMT:
            strcpy(buf, "IPMG");
            break;
#endif
#ifdef VTSS_SW_OPTION_IP_SOURCE_GUARD
        case ACL_USER_IP_SOURCE_GUARD:
            strcpy(buf, "IPSG");
            break;
#endif
#if defined(VTSS_SW_OPTION_IPMC) || defined(VTSS_SW_OPTION_IGMPS) || defined(VTSS_SW_OPTION_MLDSNP)
        case ACL_USER_IPMC:
            strcpy(buf, "IPMC");
            break;
#endif
#ifdef VTSS_SW_OPTION_MEP
        case ACL_USER_MEP:
            strcpy(buf, "MEP ");
            break;
#endif
#ifdef VTSS_SW_OPTION_ARP_INSPECTION
        case ACL_USER_ARP_INSPECTION:
            strcpy(buf, "ARPI");
            break;
#endif
#ifdef VTSS_SW_OPTION_EVC
        case ACL_USER_EVC:
            strcpy(buf, "EVC");
            break;
#endif
#ifdef VTSS_SW_OPTION_UPNP
        case ACL_USER_UPNP:
            strcpy(buf, "UPnP");
            break;
#endif
#if defined(VTSS_SW_OPTION_PTP) || defined(VTSS_SW_OPTION_PHY_1588_SIM)
        case ACL_USER_PTP:
            strcpy(buf, "PTP ");
            break;
#endif
#ifdef VTSS_SW_OPTION_DHCP_HELPER
        case ACL_USER_DHCP:
            strcpy(buf, "DHCP");
            break;
#endif
#ifdef VTSS_SW_OPTION_LOOP_PROTECT
        case ACL_USER_LOOP_PROTECT:
            strcpy(buf, "LOOP");
            break;
#endif
#ifdef VTSS_SW_OPTION_ETH_LINK_OAM
        case ACL_USER_LINK_OAM:
            strcpy(buf, "LOAM");
            break;
#endif
        default:
            strcpy(buf, "?   ");
        }
    } else {
        sprintf(buf, "%s", acl_user_names[user_id]);
    }

    return buf;
}

static char *ACL_ICLI_range_txt(char *buf, ulong min, ulong max)
{
    sprintf(buf, "%u-%u", min, max);
    return buf;
}

static char *ACL_ICLI_usid_txt(vtss_isid_t isid, char *buf)
{
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
    if (isid == VTSS_ISID_GLOBAL) {
        strcpy(buf, "Any");
    } else {
        sprintf(buf, "%-2d", topo_isid2usid(isid));
    }
#else
    if (isid == VTSS_ISID_GLOBAL) {
        strcpy(buf, "GLOBAL");
    } else {
        sprintf(buf, "LOCAL");
    }
#endif /* VTSS_SWITCH_STACKABLE */

    return buf;
}

#if defined(VTSS_FEATURE_ACL_V1) && (!defined(VTSS_ARCH_LUTON28) || (defined(VTSS_ARCH_LUTON28) && defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE))
static char *ACL_ICLI_port_no_txt(vtss_port_no_t iport, char *buf, BOOL lower)
{
    if (iport == VTSS_PORT_NO_NONE) {
        if (lower) {
            strcpy(buf, "disabled");
        } else {
            strcpy(buf, "Disabled");
        }
    } else {
        sprintf(buf, "%u", iport2uport(iport));
    }
    return buf;
}
#endif /* VTSS_FEATURE_ACL_V1 */

static void ACL_ICLI_ace_show(u32 session_id,
                              acl_user_t user_id,
                              vtss_ace_id_t id,
                              acl_entry_conf_t *conf_p,
                              u32 counter,
                              BOOL *first,
                              BOOL local_status)
{
    vtss_ace_u8_t   *proto;
    char            buf[ACL_ICLI_BUF_SIZE];
    acl_action_t    *action = &conf_p->action;
#if defined(VTSS_FEATURE_ACL_V2)
    vtss_port_no_t  port_idx;
    u32             port_filter_list_cnt = 0;
    BOOL            is_filter_enable;
#endif /* VTSS_FEATURE_ACL_V2 */

    if (*first) {
        *first = 0;
        if (local_status) {
#if defined(VTSS_FEATURE_ACL_V2)
            ICLI_PRINTF("\nUser ID   Frame  Action Rate L.  Mirror   CPU    Counter Conflict\n");
            ICLI_PRINTF("---- --   -----  ------ -------- -------- ------ ------- -------\n");
#else
            ICLI_PRINTF("\nUser ID   Frame  Action Rate L.  CPU    Counter Conflict\n");
            ICLI_PRINTF("---- --   -----  ------ -------- ------ ------- --------\n");
#endif /* VTSS_FEATURE_ACL_V2 */
        } else {
            ICLI_PRINTF("ID   ");
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
            ICLI_PRINTF("SID      ");
#else
            ICLI_PRINTF("Type     ");
#endif
#if defined(VTSS_FEATURE_ACL_V2)
            ICLI_PRINTF("Policy   Frame  Action Rate L.  Mirror   Counter\n");
            ICLI_PRINTF("--   -------- -------- -----  ------- ------- -------- -------\n");
#else
            ICLI_PRINTF("Policy   Frame  Action Rate L.  Counter\n");
            ICLI_PRINTF("--   ---      -------- -----  ------ -------  -------\n");
#endif /* VTSS_FEATURE_ACL_V2 */
        }
    }

    if (local_status) {
        ICLI_PRINTF("%-5s", ACL_ICLI_acl_user_txt(TRUE, user_id, buf));
        ICLI_PRINTF("%-5u", id);
    } else {
        ICLI_PRINTF("%-5u%-9s", id, ACL_ICLI_usid_txt(conf_p->isid, buf));
    }

    //policy, policy_bitmask
    if (!local_status) {
        if (conf_p->policy.mask == 0x0) {
            ICLI_PRINTF("%-9s", "Any");
        } else {
            sprintf(buf, "%d/0x%x", conf_p->policy.value, conf_p->policy.mask);
            ICLI_PRINTF("%-9s", buf);
        }
    }
    proto = &conf_p->frame.ipv4.proto;
    ICLI_PRINTF("%-7s",
                conf_p->type != VTSS_ACE_TYPE_IPV4 ? mgmt_acl_type_txt(conf_p->type, buf, FALSE) :
                proto->mask == 0xff && proto->value == 1 ? "ICMP" :
                proto->mask == 0xff && proto->value == 17 ? "UDP" :
                proto->mask == 0xff && proto->value == 6 ? "TCP" : "IPv4");
#if defined(VTSS_FEATURE_ACL_V2)
    for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
        if (action->port_list[port_idx]) {
            port_filter_list_cnt++;
        }
    }

    if (action->port_action == VTSS_ACL_PORT_ACTION_FILTER && port_filter_list_cnt != 0) {
        is_filter_enable = TRUE;
    } else {
        is_filter_enable = FALSE;
    }
    ICLI_PRINTF("%-7s", action->port_action == VTSS_ACL_PORT_ACTION_NONE ? "Permit" : is_filter_enable ? "Filter" : "Deny");
#else
    ICLI_PRINTF("%-7s", action->permit ? "Permit" : "Deny");
#endif /* VTSS_FEATURE_ACL_V2 */
    ICLI_PRINTF("%-9s", ACL_ICLI_policer_txt(action->policer, buf, FALSE));
#if defined(VTSS_FEATURE_ACL_V2)
    ICLI_PRINTF("%-9s", action->mirror ? "Enabled" : "Disabled");
#endif /* VTSS_FEATURE_ACL_V2 */
    if (local_status) {
        ICLI_PRINTF("%-3s%-4s", conf_p->action.force_cpu ? "Yes" : "No", conf_p->action.cpu_once ? "(O)" : "");
    }
    ICLI_PRINTF("%7u", counter);
    if (local_status) {
        ICLI_PRINTF(" %-3s", conf_p->conflict ? "Yes" : "No");
    }
    ICLI_PRINTF("\n");
}

static void ACL_ICLI_ace_show_detail(u32 session_id,
                                     acl_user_t user_id,
                                     vtss_ace_id_t id,
                                     acl_entry_conf_t *conf_p,
                                     u32 counter,
                                     BOOL local_status)
{
    acl_action_t    *action = &conf_p->action;
    uchar           ip_proto;
    BOOL            icmp, udp, tcp;
    char            col[80], buf[ACL_ICLI_BUF_SIZE];
#if defined(ACL_IPV6_SUPPORTED)
    u32             sip_v6_mask;
#endif /* ACL_IPV6_SUPPORTED */
#if defined(VTSS_FEATURE_ACL_V2)
    vtss_port_no_t  port_idx;
    u32             port_list_cnt = 0, port_filter_list_cnt = 0;
    BOOL            is_filter_enable;
#endif /* VTSS_FEATURE_ACL_V2 */

        sprintf(col, "ACE ID        : %u", conf_p->id);
        ICLI_PRINTF("%-35s Rate Limiter : %s\n", col, ACL_ICLI_policer_txt(action->policer, buf, FALSE));
#if defined(VTSS_FEATURE_ACL_V2)
        for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
            if (conf_p->port_list[port_idx]) {
                port_list_cnt++;
            }
            if (action->port_list[port_idx]) {
                port_filter_list_cnt++;
            }
        }
        if (port_list_cnt == VTSS_PORT_NO_END) {
            sprintf(col, "Ingress Port  : All");
        } else {
            sprintf(col, "Ingress Port  : %s", mgmt_iport_list2txt(conf_p->port_list, buf));
        }
#else
        if (conf_p->port_no == VTSS_PORT_NO_ANY) {
            sprintf(col, "Ingress Port  : All");
        } else {
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
            if (conf_p->isid == VTSS_ISID_GLOBAL) {
                sprintf(col, "Ingress Port  : %u", iport2uport(conf_p->port_no));
            } else {
                 sprintf(col, "Ingress Port  : %s", icli_port_info_txt(topo_isid2usid(conf_p->isid), iport2uport(conf_p->port_no), buf));
            }
#else
            sprintf(col, "Ingress Port  : %s", icli_port_info_txt(VTSS_USID_START, iport2uport(conf_p->port_no), buf));
#endif /* VTSS_SWITCH_STACKABLE */
        }
#endif /* VTSS_FEATURE_ACL_V2 */

#if defined(VTSS_FEATURE_ACL_V2)
        if (action->port_action == VTSS_ACL_PORT_ACTION_REDIR) {
#if defined(VTSS_ARCH_LUTON28)
            ICLI_PRINTF("%-35s Port Copy    : %s\n", col, mgmt_iport_list2txt(action->port_list, buf));
#else
            ICLI_PRINTF("%-35s Port Redirect: %s\n", col, mgmt_iport_list2txt(action->port_list, buf));
#endif
        } else {
#if defined(VTSS_ARCH_LUTON28)
            ICLI_PRINTF("%-35s Port Copy    : Disabled\n", col);
#else
            ICLI_PRINTF("%-35s Port Redirect: Disabled\n", col);
#endif
        }
        col[0] = '\0';
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
        if (action->evc_police) {
            sprintf(col, "EVC Policer   : %u", ievcpolicer2uevcpolicer(action->evc_policer_id));
        } else {
            sprintf(col, "EVC Policer   : Disabled");
        }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */
        ICLI_PRINTF("%-35s Mirror       : %s\n", col, icli_bool_txt(action->mirror));
#else
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
        if (action->evc_police) {
            ICLI_PRINTF("EVC Policer   : %u\n", ievcpolicer2uevcpolicer(action->evc_policer_id));
        } else {
            ICLI_PRINTF("EVC Policer   : Disabled\n");
        }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */
#if defined(VTSS_ARCH_LUTON28)
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
            if (conf_p->isid == VTSS_ISID_GLOBAL) {
                ICLI_PRINTF("%-35s Port Copy    : %s\n", col, ACL_ICLI_port_no_txt(action->port_no, buf, TRUE));
            } else {
                 ICLI_PRINTF("%-35s Port Copy    : %s\n", col, icli_port_info_txt(topo_isid2usid(conf_p->isid), iport2uport(action->port_no), buf));
            }
#else
        ICLI_PRINTF("%-35s Port Copy    : %s\n", col, icli_port_info_txt(topo_isid2usid(conf_p->isid), iport2uport(action->port_no), buf));
#endif /* VTSS_SWITCH_STACKABLE */

#else
        ICLI_PRINTF("%-35s Port Redirect: %s\n", col, ACL_ICLI_port_no_txt(action->port_no, buf, TRUE));
#endif
#endif /* VTSS_FEATURE_ACL_V2 */

        if (conf_p->policy.mask == 0x0) {
            sprintf(col, "Policy/Bitmask: Any");
        } else {
            sprintf(col, "Policy/Bitmask: %u/0x%X", conf_p->policy.value, conf_p->policy.mask);
        }
        ICLI_PRINTF("%-35s Logging      : %s\n", col, icli_bool_txt(action->logging));
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
        sprintf(col, "Switch ID     : %s", ACL_ICLI_usid_txt(conf_p->isid, buf));
#else
        sprintf(col, "Type          : %s", ACL_ICLI_usid_txt(conf_p->isid, buf));
#endif
        ICLI_PRINTF("%-35s Shutdown     : %s\n", col, icli_bool_txt(action->shutdown));
        sprintf(col, "Frame Type    : %s", mgmt_acl_type_txt(conf_p->type, buf, 0));
        ICLI_PRINTF("%-35s Counter      : %u\n", col, counter);
#if defined(VTSS_FEATURE_ACL_V2)
        if (action->port_action == VTSS_ACL_PORT_ACTION_FILTER && port_filter_list_cnt != 0) {
            is_filter_enable = TRUE;
        } else {
            is_filter_enable = FALSE;
        }
        sprintf(col, "Action        : %s", action->port_action == VTSS_ACL_PORT_ACTION_NONE ? "Permit" : is_filter_enable ? "Filter" : "Deny");
        ICLI_PRINTF("%-35s %-11s  %s %s\n", col, is_filter_enable ? "Filter Port" : " ", is_filter_enable ? ":" : " ", is_filter_enable ? port_filter_list_cnt == VTSS_PORT_NO_END ? "All" : mgmt_iport_list2txt(action->port_list, buf) : " ");
#else
        ICLI_PRINTF("Action        : %s\n", action->permit ? "Permit" : "Deny");
#endif /* VTSS_FEATURE_ACL_V2 */
#if defined(VTSS_ARCH_SERVAL)
        ICLI_PRINTF("Lookup        : %s\n", icli_bool_txt(conf_p->lookup));
#endif /* VTSS_ARCH_SERVAL */
        if (user_id != ACL_USER_STATIC) {
            ICLI_PRINTF("%-35s Force CPU     : %s\n", col, action->force_cpu ? "Yes" : "No");
            sprintf(col, "CPU Once    : %s", action->cpu_once ? "Yes" : "No");
            ICLI_PRINTF("Conflict    : %s\n", conf_p->conflict ? "Yes" : "No");
        }
        sprintf(buf, "\n%-35s %s", "MAC Parameters", "VLAN Parameters");
        icli_parm_header(session_id, buf);
#if defined(VTSS_FEATURE_ACL_V2)
        if (conf_p->type == VTSS_ACE_TYPE_ANY) {
            col[0] = '\0';
        } else {
            sprintf(col, "DMAC Type     : %s", mgmt_acl_dmac_txt(conf_p, buf, 0));
        }
        ICLI_PRINTF("%-35s 802.1Q Tagged: %s\n", col, conf_p->tagged == VTSS_ACE_BIT_ANY ? "Any" : conf_p->tagged == VTSS_ACE_BIT_0 ? "Disabled" : "Enabled");
#else
        sprintf(col, "DMAC Type     : %s", mgmt_acl_dmac_txt(conf_p, buf, 0));
        ICLI_PRINTF("%-35s VLAN ID      : %s\n",
                col, mgmt_acl_ulong_txt(conf_p->vid.value, conf_p->vid.mask, buf, 0));
#endif /* VTSS_FEATURE_ACL_V2 */
        col[0] = '\0';
        if (conf_p->type == VTSS_ACE_TYPE_ETYPE)
            sprintf(col, "DMAC          : %s",
                    mgmt_acl_uchar6_txt(&conf_p->frame.etype.dmac, buf, 0));
        if (conf_p->type == VTSS_ACE_TYPE_ARP)
            sprintf(col, "SMAC          : %s",
                    mgmt_acl_uchar6_txt(&conf_p->frame.arp.smac, buf, 0));
#if defined(VTSS_FEATURE_ACL_V2)
        if (conf_p->type == VTSS_ACE_TYPE_IPV4 && conf_p->frame.ipv4.sip_smac.enable)
            sprintf(col, "SMAC          : %s",
                    misc_mac_txt(conf_p->frame.ipv4.sip_smac.smac.addr, buf));
        ICLI_PRINTF("%-35s VLAN ID      : %s\n",
                col, mgmt_acl_ulong_txt(conf_p->vid.value, conf_p->vid.mask, buf, 0));
        if (conf_p->type != VTSS_ACE_TYPE_ETYPE)
            ICLI_PRINTF("%-35s Tag Priority : %s\n",
                    "", (conf_p->usr_prio.mask != 0 && conf_p->usr_prio.mask != 0x7) ? ACL_ICLI_range_txt(buf, conf_p->usr_prio.value & conf_p->usr_prio.mask, conf_p->usr_prio.value) :
                    mgmt_acl_ulong_txt(conf_p->usr_prio.value, conf_p->usr_prio.mask, buf, 0));
#else
        ICLI_PRINTF("%-35s Tag Priority : %s\n",
                col, (conf_p->usr_prio.mask != 0 && conf_p->usr_prio.mask != 0x7) ? ACL_ICLI_range_txt(buf, conf_p->usr_prio.value & conf_p->usr_prio.mask, conf_p->usr_prio.value) :
                mgmt_acl_ulong_txt(conf_p->usr_prio.value, conf_p->usr_prio.mask, buf, 0));
#endif /* VTSS_FEATURE_ACL_V2 */

        if (conf_p->type == VTSS_ACE_TYPE_ETYPE) {
#if defined(VTSS_FEATURE_ACL_V2)
            sprintf(col, "SMAC          : %s", mgmt_acl_uchar6_txt(&conf_p->frame.etype.smac, buf, 0));
            ICLI_PRINTF("%-35s Tag Priority : %s\n",
                    col, mgmt_acl_ulong_txt(conf_p->usr_prio.value, conf_p->usr_prio.mask, buf, 0));
#else
            ICLI_PRINTF("SMAC          : %s\n", mgmt_acl_uchar6_txt(&conf_p->frame.etype.smac, buf, 0));
#endif /* VTSS_FEATURE_ACL_V2 */
            ICLI_PRINTF("Ether Type    : %s\n",
                    mgmt_acl_uchar2_txt(&conf_p->frame.etype.etype, buf, 0));
        }

        if (conf_p->type == VTSS_ACE_TYPE_ARP) {
            ICLI_PRINTF("\n");
            icli_parm_header(session_id, "ARP/RARP Parameters");
            sprintf(col, "Opcode        : %s", mgmt_acl_opcode_txt(conf_p, buf, 0));
            ICLI_PRINTF("%-35s Sender MAC   : %s\n", col,
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_SMAC, 0));
            sprintf(col, "Request       : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_REQ, 0));
            ICLI_PRINTF("%-35s Target MAC   : %s\n", col,
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_DMAC, 0));
            sprintf(col, "Sender IP     : %s", mgmt_acl_ipv4_txt(&conf_p->frame.arp.sip, buf, 0));
            ICLI_PRINTF("%-35s Length Check : %s\n", col,
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_LEN, 0));
            sprintf(col, "Target IP     : %s", mgmt_acl_ipv4_txt(&conf_p->frame.arp.dip, buf, 0));
            ICLI_PRINTF("%-35s Ethernet     : %s\n", col,
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_ETHER, 0));
            ICLI_PRINTF("%-35s IP           : %s\n", "",
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_ARP_IP, 0));
        }

        if (conf_p->type == VTSS_ACE_TYPE_IPV4) {
            ip_proto = mgmt_acl_ip_proto(conf_p);
            icmp = (ip_proto == 1);
            udp = (ip_proto == 17);
            tcp = (ip_proto == 6);
            if (icmp || udp || tcp) {
                ICLI_PRINTF("\n");
            }
            sprintf(buf, "%-35s %s",
                    "IP Parameters",
                    icmp ? "ICMP Parameters" :
                    udp ? "UDP Parameters" :
                    tcp ? "TCP Parameters" : "");
            icli_parm_header(session_id, buf);
            sprintf(col, "Protocol      : %s",
                    mgmt_acl_uchar_txt(&conf_p->frame.ipv4.proto, buf, 0));
            ICLI_PRINTF("%-35s ", col);
            if (icmp)
                ICLI_PRINTF("Type         : %s",
                        mgmt_acl_ulong_txt(conf_p->frame.ipv4.data.value[0],
                                           conf_p->frame.ipv4.data.mask[0], buf, 0));
            if (udp || tcp)
                ICLI_PRINTF("Source Port  : %s",
                        mgmt_acl_port_txt(&conf_p->frame.ipv4.sport, buf, 0));
            ICLI_PRINTF("\n");
#if defined(VTSS_FEATURE_ACL_V2)
            if (conf_p->type == VTSS_ACE_TYPE_IPV4 && conf_p->frame.ipv4.sip_smac.enable) {
                sprintf(col, "Source        : %s", misc_ipv4_txt(conf_p->frame.ipv4.sip_smac.sip, buf));
            } else {
                sprintf(col, "Source        : %s", mgmt_acl_ipv4_txt(&conf_p->frame.ipv4.sip, buf, 0));
            }
#else
            sprintf(col, "Source        : %s", mgmt_acl_ipv4_txt(&conf_p->frame.ipv4.sip, buf, 0));
#endif /* VTSS_FEATURE_ACL_V2 */
            ICLI_PRINTF("%-35s ", col);
            if (icmp)
                ICLI_PRINTF("Code         : %s",
                        mgmt_acl_ulong_txt(conf_p->frame.ipv4.data.value[1],
                                           conf_p->frame.ipv4.data.mask[1], buf, 0));
            if (udp || tcp)
                ICLI_PRINTF("Dest. Port   : %s",
                        mgmt_acl_port_txt(&conf_p->frame.ipv4.dport, buf, 0));
            ICLI_PRINTF("\n");
            sprintf(col, "Destination   : %s", mgmt_acl_ipv4_txt(&conf_p->frame.ipv4.dip, buf, 0));
            ICLI_PRINTF("%-35s ", col);
            if (tcp) {
                ICLI_PRINTF("SYN          : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_SYN, 0));
            }
            ICLI_PRINTF("\n");
            sprintf(col, "TTL           : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_IP_TTL, 0));
            ICLI_PRINTF("%-35s ", col);
            if (tcp) {
                ICLI_PRINTF("ACK          : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_ACK, 0));
            }
            ICLI_PRINTF("\n");
            sprintf(col, "Fragment      : %s",
                    mgmt_acl_flag_txt(conf_p, ACE_FLAG_IP_FRAGMENT, 0));
            ICLI_PRINTF("%-35s ", col);
            if (tcp) {
                ICLI_PRINTF("FIN          : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_FIN, 0));
            }
            ICLI_PRINTF("\n");

            sprintf(col, "Options       : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_IP_OPTIONS, 0));
            ICLI_PRINTF("%-35s ", col);
            if (tcp) {
                ICLI_PRINTF("RST          : %s", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_RST, 0));
            }
            ICLI_PRINTF("\n");

            if (tcp) {
                ICLI_PRINTF("%-35s URG          : %s\n",
                        "",  mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_URG, 0));
                ICLI_PRINTF("%-35s PSH          : %s\n",
                        "",  mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_PSH, 0));
            }
        }

        if (conf_p->type == VTSS_ACE_TYPE_IPV6) {
            ICLI_PRINTF("\n");
            sprintf(buf, "%-35s", "IPv6 Parameters");
            icli_parm_header(session_id, buf);
            sprintf(col, "Next Header : %s",
                    mgmt_acl_uchar_txt(&conf_p->frame.ipv6.proto, buf, 0));
#if defined(VTSS_FEATURE_ACL_V2)
            ICLI_PRINTF("%-35s Hop Limit    : %s\n",
                    col, conf_p->frame.ipv6.ttl == VTSS_ACE_BIT_ANY ? "Any" : conf_p->frame.ipv6.ttl == VTSS_ACE_BIT_0 ? "0" : "1");
#else
            ICLI_PRINTF("%-35s\n", col);
#endif /* VTSS_FEATURE_ACL_V2 */
            ICLI_PRINTF("Source      : %s\n",
                    mgmt_acl_ipv6_txt(&conf_p->frame.ipv6.sip, buf, 0));
#if defined(ACL_IPV6_SUPPORTED)
            sip_v6_mask = (conf_p->frame.ipv6.sip.mask[12] << 24) +
                          (conf_p->frame.ipv6.sip.mask[13] << 16) +
                          (conf_p->frame.ipv6.sip.mask[14] << 8) +
                          conf_p->frame.ipv6.sip.mask[15];
            if (sip_v6_mask) {
                ICLI_PRINTF("Source Mask : 0x%X\n", sip_v6_mask);
            }
#endif /* ACL_IPV6_SUPPORTED */
#if defined(VTSS_FEATURE_ACL_V2)
            ip_proto = mgmt_acl_ip_proto(conf_p);
            icmp = (ip_proto == 58);
            udp = (ip_proto == 17);
            tcp = (ip_proto == 6);
            if (icmp || udp || tcp) {
                ICLI_PRINTF("\n");
                sprintf(buf, "%s",
                        icmp ? "ICMP Parameters" :
                        udp ? "UDP Parameters" :
                        tcp ? "TCP Parameters" : "");
                icli_parm_header(session_id, buf);
            }
            if (icmp) {
                ICLI_PRINTF("Type         : %s\n",
                        mgmt_acl_ulong_txt(conf_p->frame.ipv6.data.value[0],
                                           conf_p->frame.ipv6.data.mask[0], buf, 0));
                ICLI_PRINTF("Code         : %s\n",
                        mgmt_acl_ulong_txt(conf_p->frame.ipv6.data.value[1],
                                           conf_p->frame.ipv6.data.mask[1], buf, 0));
            }
            if (udp || tcp) {
                ICLI_PRINTF("Source Port : %s\n",
                        mgmt_acl_port_txt(&conf_p->frame.ipv6.sport, buf, 0));
                ICLI_PRINTF("Dest. Port  : %s\n",
                        mgmt_acl_port_txt(&conf_p->frame.ipv6.dport, buf, 0));
                if (tcp) {
                    ICLI_PRINTF("SYN         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_SYN, 0));
                    ICLI_PRINTF("ACK         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_ACK, 0));
                    ICLI_PRINTF("FIN         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_FIN, 0));
                    ICLI_PRINTF("RST         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_RST, 0));
                    ICLI_PRINTF("URG         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_URG, 0));
                    ICLI_PRINTF("PSH         : %s\n", mgmt_acl_flag_txt(conf_p, ACE_FLAG_TCP_PSH, 0));
                }
            }
#endif /* VTSS_FEATURE_ACL_V2 */
        }

#if defined(VTSS_FEATURE_ACL_V2)
        if (user_id != ACL_USER_STATIC &&
            (conf_p->type == VTSS_ACE_TYPE_ETYPE || conf_p->type == VTSS_ACE_TYPE_IPV4 || conf_p->type == VTSS_ACE_TYPE_IPV6)) {
            vtss_ace_ptp_t *ptp;

            ICLI_PRINTF("\n");
            sprintf(buf, "%s", "PTP Parameters");
            icli_parm_header(session_id, buf);
            if (conf_p->type == VTSS_ACE_TYPE_ETYPE) {
                ptp = &conf_p->frame.etype.ptp;
            } else if (conf_p->type == VTSS_ACE_TYPE_IPV4) {
                ptp = &conf_p->frame.ipv4.ptp;
            } else {
                ptp = &conf_p->frame.ipv6.ptp;
            }
            sprintf(col, "PTP         : %s", icli_bool_txt(ptp->enable));
            ICLI_PRINTF("%-35s PTP Header    : %s, %s, %s, %s\n",
                    col,
                    mgmt_acl_ulong_txt(ptp->header.value[0], ptp->header.value[0], buf, 0),
                    mgmt_acl_ulong_txt(ptp->header.value[1], ptp->header.value[1], buf, 0),
                    mgmt_acl_ulong_txt(ptp->header.value[2], ptp->header.value[2], buf, 0),
                    mgmt_acl_ulong_txt(ptp->header.value[3], ptp->header.value[3], buf, 0));
        }
#endif /* VTSS_FEATURE_ACL_V2 */

    ICLI_PRINTF("\n");
}

static void ACL_ICLI_ace_show_by_isid(u32 session_id,
                                      vtss_isid_t isid,
                                      BOOL *first_p,
                                      int *ace_cnt_p,
                                      BOOL show_all_status,
                                      BOOL has_static,
                                      BOOL has_link_oam,
                                      BOOL has_loop_protect,
                                      BOOL has_dhcp,
                                      BOOL has_ptp,
                                      BOOL has_upnp,
                                      BOOL has_arp_inspection,
                                      BOOL has_evc,
                                      BOOL has_mep,
                                      BOOL has_ipmc,
                                      BOOL has_ip_source_guard,
                                      BOOL has_ip_mgmt,
                                      BOOL has_conflicts)
{
    int                 acl_user_idx;
    vtss_ace_id_t       ace_id;
    acl_entry_conf_t    ace_conf;
    ulong               ace_counter;
    BOOL                show_ace_brief = TRUE;
    char                str_buf[ACL_ICLI_BUF_SIZE];

    //acl_user_idx must use signed number
    for (acl_user_idx = ACL_USER_CNT - 1; acl_user_idx >= ACL_USER_STATIC; acl_user_idx--) {
        if (!show_all_status && !has_conflicts && (
            (!has_static && acl_user_idx == ACL_USER_STATIC)
#if defined(VTSS_SW_OPTION_ETH_LINK_OAM)
            || (!has_link_oam &&  acl_user_idx == ACL_USER_LINK_OAM)
#endif
#if defined(VTSS_SW_OPTION_LOOP_PROTECT)
            || (!has_loop_protect && acl_user_idx == ACL_USER_LOOP_PROTECT)
#endif
#if defined(VTSS_SW_OPTION_DHCP_HELPER)
            || (!has_dhcp && acl_user_idx == ACL_USER_DHCP)
#endif
#if defined(VTSS_SW_OPTION_PTP) || defined(VTSS_SW_OPTION_PHY_1588_SIM)
            || (!has_ptp && acl_user_idx == ACL_USER_PTP)
#endif
#if defined(VTSS_SW_OPTION_UPNP)
            || (!has_upnp && acl_user_idx == ACL_USER_UPNP)
#endif
#if defined(VTSS_SW_OPTION_ARP_INSPECTION)
            || (!has_arp_inspection && acl_user_idx == ACL_USER_ARP_INSPECTION)
#endif
#if defined(VTSS_SW_OPTION_EVC)
            || (!has_evc && acl_user_idx == ACL_USER_EVC)
#endif
#if defined(VTSS_SW_OPTION_MEP)
            || (!has_mep && acl_user_idx == ACL_USER_MEP)
#endif
#if defined(VTSS_SW_OPTION_IPMC) || defined(VTSS_SW_OPTION_IGMPS) || defined(VTSS_SW_OPTION_MLDSNP)
            || (!has_ipmc && acl_user_idx == ACL_USER_IPMC)
#endif
#if defined(VTSS_SW_OPTION_IP_SOURCE_GUARD)
            || (!has_ip_source_guard && acl_user_idx == ACL_USER_IP_SOURCE_GUARD)
#endif
#if defined(VTSS_ARCH_JAGUAR_1_CE_MAC) || defined(VTSS_SW_OPTION_IP_MGMT_ACL)
            || (!has_ip_mgmt && acl_user_idx == ACL_USER_IP_MGMT)
#endif
            )) {
            continue;
        }

        ace_id = ACE_ID_NONE;
        while (acl_mgmt_ace_get(acl_user_idx, isid, ace_id, &ace_conf, &ace_counter, TRUE) == VTSS_OK) {
            //Show ACE brief description
            if (show_ace_brief) {
                int acl_user_show_header_idx;
                show_ace_brief = FALSE;
                ICLI_PRINTF("User\n");
                ICLI_PRINTF("----\n");
                for (acl_user_show_header_idx = 0; acl_user_show_header_idx < ACL_USER_CNT; acl_user_show_header_idx++) {
                    ICLI_PRINTF("%s: %s\n", ACL_ICLI_acl_user_txt(TRUE, acl_user_show_header_idx, str_buf), acl_user_names[acl_user_show_header_idx]);
                }
            }

            ace_id = ace_conf.id;
            if (has_conflicts && !ace_conf.conflict) {
                continue;
            }
            ACL_ICLI_ace_show(session_id, acl_user_idx, ace_id, &ace_conf, ace_counter, first_p, TRUE);
            *ace_cnt_p = *ace_cnt_p + 1;


            /* Check if break condition (ctrl+c) occured */
            if ((((*ace_cnt_p) % ICLI_SESSION_CTRL_C_CHECK_CNT) == 0) &&
                icli_session_ctrl_c_get(session_id, ICLI_SESSION_CTRL_C_WAIT) == ICLI_RC_OK) {
                break;
            }
        }
        if (acl_user_idx == 0) {
            break;  //last ACL user
        }
    }
}

static void ACL_ICLI_ace_parse(u32 session_id, icli_unsigned_range_t *ace_list_p, BOOL detail)
{
    u32                 range_idx;
    vtss_ace_id_t       ace_idx;
    acl_entry_conf_t    ace_conf;
    vtss_ace_counter_t  ace_counter;
    int                 ace_cnt = 0;
    BOOL                first = TRUE;

    if (ace_list_p) { //at least one range input
        for (range_idx = 0; range_idx < ace_list_p->cnt; range_idx++) {
            for (ace_idx = ace_list_p->range[range_idx].min; ace_idx <= ace_list_p->range[range_idx].max; ace_idx++) {
                if (acl_mgmt_ace_get(ACL_USER_STATIC, VTSS_ISID_GLOBAL, ace_idx, &ace_conf, &ace_counter, FALSE) == VTSS_OK) {
                    if (detail) {
                        ACL_ICLI_ace_show_detail(session_id, ACL_USER_STATIC, ace_idx, &ace_conf, ace_counter, FALSE);
                    } else {
                        ACL_ICLI_ace_show(session_id, ACL_USER_STATIC, ace_idx, &ace_conf, ace_counter, &first, FALSE);
                    }
                    ace_cnt++;
                }

            }
        }
    } else { //show all ACEs
        ace_idx = ACE_ID_NONE;
        while (acl_mgmt_ace_get(ACL_USER_STATIC, VTSS_ISID_GLOBAL, ace_idx, &ace_conf, &ace_counter, TRUE) == VTSS_OK) {
            ace_idx = ace_conf.id;
            if (detail) {
                ACL_ICLI_ace_show_detail(session_id, ACL_USER_STATIC, ace_idx, &ace_conf, ace_counter, FALSE);
            } else {
                ACL_ICLI_ace_show(session_id, ACL_USER_STATIC, ace_idx, &ace_conf, ace_counter, &first, FALSE);
            }
            ace_cnt++;
        }
    }

    ICLI_PRINTF("\nSwitch access-list ace number: %u\n", ace_cnt);
}

#if defined(VTSS_FEATURE_ACL_V1)
/* Check if the single port ID is out of local port count */
static i32 ACL_ICLI_local_port_check(u32 session_id, icli_stack_port_range_t *mode_port_list_p, icli_switch_port_range_t *single_port_p)
{
    i32             rc = ICLI_RC_OK;
    u32             range_idx, port_count;
    vtss_usid_t     usid, single_port_usid;
    vtss_port_no_t  single_port_uport;
    char            str_buf[ACL_ICLI_BUF_SIZE];

    //only allow single port ID
    if (single_port_p->port_cnt != 1) {
        return ICLI_RC_ERROR;
    }
    single_port_usid = single_port_p->usid;
    single_port_uport = single_port_p->begin_uport;

    if (port_isid_port_no_is_stack(topo_usid2isid(single_port_usid), uport2iport(single_port_uport))) {
        ICLI_PRINTF("%% Cannot be configured on stacking interface.\n");
        return ICLI_RC_ERROR;
    }

    //go through mode_port_list_p
    for (range_idx = 0; range_idx < mode_port_list_p->cnt; range_idx++) {
        usid = mode_port_list_p->switch_range[range_idx].usid;

        if (usid != single_port_usid) {
            ICLI_PRINTF("%% %s is not the local interface on switch %u.\n",
                        icli_port_info_txt(single_port_usid, single_port_uport, str_buf),
                        usid);
            rc = ICLI_RC_ERROR;
            continue;
        }

        port_count = port_isid_port_count(topo_usid2isid(usid));
        if (single_port_uport > port_count) {
            ICLI_PRINTF("%% %s is out of the port count on switch %u.\n",
                        icli_port_info_txt(single_port_usid, single_port_uport, str_buf),
                        single_port_usid);
            return ICLI_RC_ERROR;
        }
    }

    return rc;
}
#endif /*VTSS_FEATURE_ACL_V1 */

enum {
    ACL_ICLI_OPCODE_POLICY_NO,
    ACL_ICLI_OPCODE_ACTION_POLICER,
    ACL_ICLI_OPCODE_ACTION_EVC_POLICER_ID,
    ACL_ICLI_OPCODE_ACTION_MIRROR,
    ACL_ICLI_OPCODE_ACTION_PORT_REDIRECT,
    ACL_ICLI_OPCODE_ACTION_PERMIT,
    ACL_ICLI_OPCODE_ACTION_LOGGING,
    ACL_ICLI_OPCODE_ACTION_SHUTDOWN,
};
static void ACL_ICLI_port_conf_set(u32 session_id, icli_stack_port_range_t *port_list_p, acl_port_conf_t *new_port_conf_p, u32 opcode)
{
    vtss_rc         rc;
    u32             range_idx, cnt_idx;
    vtss_usid_t     usid;
    vtss_port_no_t  uport;
    acl_port_conf_t port_conf;
    char            str_buf[ACL_ICLI_BUF_SIZE];

    for (range_idx = 0; range_idx < port_list_p->cnt; range_idx++) {
        for (cnt_idx = 0; cnt_idx < port_list_p->switch_range[range_idx].port_cnt; cnt_idx++) {
            usid = port_list_p->switch_range[range_idx].usid;
            uport = port_list_p->switch_range[range_idx].begin_uport + cnt_idx;

            //ignore stacking port
            if (port_isid_port_no_is_stack(topo_usid2isid(usid), uport2iport(uport))) {
                continue;
            }

            if ((rc = acl_mgmt_port_conf_get(topo_usid2isid(usid), uport2iport(uport), &port_conf)) != VTSS_OK) {
                ICLI_PRINTF("%% Failed to get access-list port configuration for %s.\n",
                            icli_port_info_txt(usid, uport, str_buf));
                return;
            }

            switch (opcode) {
                case ACL_ICLI_OPCODE_POLICY_NO:
                    port_conf.policy_no = new_port_conf_p->policy_no;
                    break;
                case ACL_ICLI_OPCODE_ACTION_POLICER:
                    port_conf.action.policer = new_port_conf_p->action.policer;
                    break;
#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
                case ACL_ICLI_OPCODE_ACTION_EVC_POLICER_ID:
                    port_conf.action.evc_police = new_port_conf_p->action.evc_police;
                    port_conf.action.evc_policer_id = new_port_conf_p->action.evc_policer_id;
                    break;
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */
#if defined(VTSS_FEATURE_ACL_V2)
                case ACL_ICLI_OPCODE_ACTION_MIRROR:
                    port_conf.action.mirror = new_port_conf_p->action.mirror;
                    break;
#endif /* VTSS_FEATURE_ACL_V2 */
                case ACL_ICLI_OPCODE_ACTION_PORT_REDIRECT:
#if defined(VTSS_FEATURE_ACL_V2)
                    if (port_conf.action.port_action == VTSS_ACL_PORT_ACTION_NONE) {
                        ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action on %s.\n",
                                    icli_port_info_txt(usid, uport, str_buf));
                        continue;
                    }
                    port_conf.action.port_action = new_port_conf_p->action.port_action;
                    memcpy(port_conf.action.port_list, new_port_conf_p->action.port_list, sizeof(port_conf.action.port_list));
#else
                    port_conf.action.port_no = new_port_conf_p->action.port_no;
#endif /* VTSS_FEATURE_ACL_V2 */
                    break;
                case ACL_ICLI_OPCODE_ACTION_PERMIT:
#if defined(VTSS_FEATURE_ACL_V2)
                    if (port_conf.action.port_action == VTSS_ACL_PORT_ACTION_REDIR) {
                        ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action on %s.\n",
                                    icli_port_info_txt(usid, uport, str_buf));
                        continue;
                    }
                    if (port_conf.action.port_action == VTSS_ACL_PORT_ACTION_NONE ||
                        new_port_conf_p->action.port_action == VTSS_ACL_PORT_ACTION_NONE) {
                        //original setting is permitted or new setting is permitted
                        port_conf.action.port_action = new_port_conf_p->action.port_action;
                        memcpy(port_conf.action.port_list, new_port_conf_p->action.port_list, sizeof(port_conf.action.port_list));
                    }
#else
                    port_conf.action.permit = new_port_conf_p->action.permit;
#endif /* VTSS_FEATURE_ACL_V2 */
                    break;
                case ACL_ICLI_OPCODE_ACTION_LOGGING:
                    port_conf.action.logging = new_port_conf_p->action.logging;
                    break;
                case ACL_ICLI_OPCODE_ACTION_SHUTDOWN:
                    port_conf.action.shutdown = new_port_conf_p->action.shutdown;
                    break;
                default:
                    continue;
            }

            // Reject new configuration due to chip limition
#if defined(VTSS_ARCH_JAGUAR_1)
            if (port_conf.action.permit && port_conf.action.port_no != VTSS_PORT_NO_NONE) {
                ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action on %s.\n",
                            icli_port_info_txt(usid, uport, str_buf));
                continue;
            }
#endif /* VTSS_ARCH_JAGUAR_1 */

#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
            if (port_conf.action.evc_police && port_conf.action.policer != ACL_POLICER_NONE) {
                ICLI_PRINTF("%% The ACL rate limiter and EVC policer can not both be enabled on %s.\n",
                            icli_port_info_txt(usid, uport, str_buf));
                continue;
            }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */

            if ((rc = acl_mgmt_port_conf_set(topo_usid2isid(usid), uport2iport(uport), &port_conf)) != VTSS_OK) {
                ICLI_PRINTF("%% Failed to set access-list port configuration for %s.\n",
                            icli_port_info_txt(usid, uport, str_buf));
            }
        }
    }
}

static void ACL_ICLI_port_state_set(u32 session_id, icli_stack_port_range_t *port_list_p, BOOL enable)
{
    vtss_rc         rc;
    u32             range_idx, cnt_idx;
    vtss_usid_t     usid;
    vtss_port_no_t  uport;
    port_vol_conf_t port_state;

    for (range_idx = 0; range_idx < port_list_p->cnt; range_idx++) {
        for (cnt_idx = 0; cnt_idx < port_list_p->switch_range[range_idx].port_cnt; cnt_idx++) {
            usid = port_list_p->switch_range[range_idx].usid;
            uport = port_list_p->switch_range[range_idx].begin_uport + cnt_idx;

            //ignore stacking port
            if (port_isid_port_no_is_stack(topo_usid2isid(usid), uport2iport(uport))) {
                continue;
            }

            memset(&port_state, 0, sizeof(port_state));
            if (msg_switch_exists(topo_usid2isid(usid)) && (rc = port_vol_conf_get(PORT_USER_ACL, topo_usid2isid(usid), uport2iport(uport), &port_state)) != VTSS_OK) {
                ICLI_PRINTF("%% Calling port_vol_conf_get(%u, %u) failed.\n", usid, uport);
                return;
            }

            port_state.disable = !enable;

            if ((rc = port_vol_conf_set(PORT_USER_ACL, topo_usid2isid(usid), uport2iport(uport), &port_state)) != VTSS_OK) {
                ICLI_PRINTF("%% Failed to set access-list port-state %u.\n", uport);
            }
        }
    }
}

static void ACL_ICLI_ace_mac_set(vtss_ace_u48_t *ace_mac_p, u8 *mac_p, BOOL is_any)
{
    int i;

    for (i = 0; i < 6; i++) {
        ace_mac_p->value[i] = is_any ? 0 : mac_p[i];
        ace_mac_p->mask[i] = is_any ? 0 : 0xFF;
    }
}

static void ACL_ICLI_ace_flag_set(acl_entry_conf_t *ace_p, acl_flag_t flag, u8 value, BOOL is_any)
{
    VTSS_BF_SET(ace_p->flags.value, flag, is_any ? 0 : value);
    VTSS_BF_SET(ace_p->flags.mask, flag, is_any ? 0 : 1);
}

static void ACL_ICLI_ace_ip_set(vtss_ace_ip_t *ace_ip_p, icli_ipv4_subnet_t ip_addr, BOOL is_any)
{
    ace_ip_p->value = is_any ? 0 : ip_addr.ip;
    ace_ip_p->mask = is_any ? 0 : ip_addr.netmask;
}

static void ACL_ICLI_ace_udp_tcp_port_set(vtss_ace_udp_tcp_t *ace_udp_tcp_port, vtss_udp_tcp_t min, vtss_udp_tcp_t max, BOOL is_any)
{
    ace_udp_tcp_port->in_range = TRUE;
    ace_udp_tcp_port->low = is_any ? 0 : (min < max ? min : max);
    ace_udp_tcp_port->high = is_any ? 0XFFFF : (min > max ? min : max);
}

static void ACL_ICLI_ace_ipv6_set(vtss_ace_u128_t *ace_ipv6_p, vtss_ipv6_t sipv6_addr, u32 bitmask, BOOL is_any)
{
    int idx;

    if (is_any) {
        memset(ace_ipv6_p, 0, sizeof(*ace_ipv6_p));
    } else {
        for (idx = 0; idx < 16; idx++) {
            ace_ipv6_p->value[idx] = sipv6_addr.addr[idx];
            if (idx == 12) {
                ace_ipv6_p->mask[idx] = bitmask >> 24 & 0xFF;
            } else if (idx == 13) {
                ace_ipv6_p->mask[idx] = bitmask >> 16 & 0xFF;
            } else if (idx == 14) {
                ace_ipv6_p->mask[idx] = bitmask >> 8 & 0xFF;
            } else if (idx == 15) {
                ace_ipv6_p->mask[idx] = bitmask & 0xFF;
            } else {
#if defined(VTSS_ARCH_LUTON28)
                ace_ipv6_p->mask[idx] = 0xFF;
#else
                ace_ipv6_p->mask[idx] = 0x0;
#endif /* VTSS_ARCH_LUTON28 */
            }
        }
    }
}

static void ACL_ICLI_ace_ipv6_flag_set(vtss_ace_bit_t *ace_ipv6_flag_p, u32 value, BOOL is_any)
{
    *ace_ipv6_flag_p = is_any ? VTSS_ACE_BIT_ANY : value ? VTSS_ACE_BIT_1 : VTSS_ACE_BIT_0;
}
FUNCTION_END

EXPORT_BEGIN
EXPORT_END

HELP_ACL                        = Access list
HELP_ACE                        = Access list entry
HELP_ACE_ID                     = ACE ID
HELP_ACL_ACTION                 = Access list action
HELP_ACL_PERMIT                 = Permit
HELP_ACL_DENY                   = Deny
HELP_ACL_FILTER                 = Filter
HELP_ACL_RATE_LIMITER           = Rate limiter
HELP_ACL_RATE_LIMITER_ID        = Rate limiter ID
HELP_ACL_REDIRECT               = Redirect frame to specific port
HELP_ACL_PORT_COPY              = Copy frame to specific port
HELP_ACL_MIRROR                 = Mirror frame to destination mirror port
HELP_ACL_LOGGING                = Logging frame information. Note: The logging feature only works when the packet length is less than 1518 (without VLAN tags) and the System Log memory size and logging rate is limited.
HELP_ACL_SHUTDOWN               = Shutdown incoming port. The shutdown feature only works when the packet length is less than 1518 (without VLAN tags).
HELP_ACL_EVC_POLICER            = EVC policer
HELP_ACL_EVC_POLICER_ID         = EVC policer ID
HELP_ACL_POLICY                 = Policy
HELP_ACL_POLICY_ID              = Policy ID
HELP_ACL_PORT_STATE             = Re-enable shutdown port that was shutdown by access-list module
HELP_ACL_RATE_VALUE             = Rate value
HELP_ACL_RATE_PPS               = Packets per second
HELP_ACL_RATE_100PPS            = 100 packets per second
HELP_ACL_RATE_KPPS              = 1K packets per second
HELP_ACL_RATE_100KBPS           = 100k bits per second
HELP_ACE_STATUS                 = The local ACEs status
HELP_ACE_STATIC                 = The ACEs that are configured by users manually
HELP_ACE_LINK_OAM               = The ACEs that are configured by Link OAM module
HELP_ACE_LOOP_PROTECT           = The ACEs that are configured by Loop Protect module
HELP_ACE_DHCP                   = The ACEs that are configured by DHCP module
HELP_ACE_PTP                    = The ACEs that are configured by PTP module
HELP_ACE_UPNP                   = The ACEs that are configured by UPnP module
HELP_ACE_ARP_INSPECTION         = The ACEs that are configured by ARP Inspection module
HELP_ACE_EVC                    = The ACEs that are configured by EVC module
HELP_ACE_MEP                    = The ACEs that are configured by MEP module
HELP_ACE_IPMC                   = The ACEs that are configured by IPMC module
HELP_ACE_IPSG                   = The ACEs that are configured by IP Source Guard module
HELP_ACE_IP_MGMT                = The ACEs that are configured by IP Mamagement module
HELP_ACE_CONFLICT               = The ACEs that did not get applied to the hardware due to hardware limitations
HELP_ACE_DETAIL                 = Detail ACE information
HELP_ACL_SWITCH                 = Switch
HELP_ACL_SWITCH_ID              = Switch ID
HELP_ACL_SWITCHPORT             = Switchport

HELP_ACE_UPDATE                 = Update an existing ACE
HELP_ACE_NEXT                   = insert the current ACE before the next ACE ID
HELP_NEXT_ACE_ID                = The next ID
HELP_ACE_LAST                   = Place the current ACE to the end of access list
HELP_ACE_SWITCHPORT_ID          = Swithport ID
HELP_ACE_SWITCHPORT_LIST        = List of swithport ID
HELP_ACE_INGRESS                = Ingress
HELP_ACE_ANY_INGRESS            = Don't-care the ingress interface

HELP_ACE_VID                    = VID field
HELP_ACE_VID_VALUE              = The value of VID field
HELP_ACE_ANY_VID                = Don't-care the value of VID field

HELP_ACE_TAG                    = Tag
HELP_ACE_TAGGED                 = Tagged
HELP_ACE_UNTAGGED               = Untagged 
HELP_ACE_ANY_TAG                = Don't-care tagged or untagged

HELP_ACE_TAG_PRI                = Tag priority
HELP_ACE_TAG_PRI_VALUE          = The value of tag priority
HELP_ACE_TAG_PRI_RANGE          = The range of tag priority
HELP_ACE_ANY_TAG_PRI            = Don't-care the value of tag priority field     

HELP_ACE_POLICY_BITMASK         = The bitmask for policy ID
HELP_ACE_POLICY_BITMASK_VALUE   = The value of policy bitmask

HELP_ACE_DMAC_TYPE              = The type of destination MAC address
HELP_ACE_DMAC_TYPE_UNICAST      = Unicast destination MAC address
HELP_ACE_DMAC_TYPE_MULTICAST    = Multicast destination MAC address
HELP_ACE_DMAC_TYPE_BROADCAST    = Broadcast destination MAC address
HELP_ACE_ANY_DMAC_TYPE          = Don't-care the type of destination MAC address

HELP_ACE_FRAMETYPE              = Frame type
HELP_ACE_FRAMETYPE_ETYPE        = Frame type of etype
HELP_ACE_FRAMETYPE_ARP          = Frame type of ARP
HELP_ACE_FRAMETYPE_IPV4         = Frame type of IPv4
HELP_ACE_FRAMETYPE_IPV4_ICMP    = Frame type of IPv4 ICMP
HELP_ACE_FRAMETYPE_IPV4_UDP     = Frame type of IPv4 TCP
HELP_ACE_FRAMETYPE_IPV4_TCP     = Frame type of IPv4 TCP
HELP_ACE_FRAMETYPE_IPV6         = Frame type of IPv6
HELP_ACE_FRAMETYPE_IPV6_ICMP    = Frame type of IPv6 ICMP
HELP_ACE_FRAMETYPE_IPV6_UDP     = Frame type of IPv6 UDP
HELP_ACE_FRAMETYPE_IPV6_TCP     = Frame type of IPv6 TCP
HELP_ACE_ANY_FRAMETYPE          = Don't-care the frame type

HELP_ACE_SMAC                   = Source MAC address field
HELP_ACE_DMAC                   = Destination MAC address field
HELP_ACE_SMAC_VALUE             = The value of source MAC address field
HELP_ACE_DMAC_VALUE             = The value of destination MAC address field
HELP_ACE_ANY_SMAC               = Don't-care the value of source MAC address field
HELP_ACE_ANY_DMAC               = Don't-care the value of destination MAC address field

HELP_ACE_ETYPE                  = Etype value
HELP_ACE_ETYPE_VALUE            = The value of etype field
HELP_ACE_ANY_ETYPE              = Don't-care the value of etype field

HELP_ACE_ICMP_TYPE              = ICMP type field
HELP_ACE_ICMP_CODE              = ICMP code field
HELP_ACE_ICMP_TYPE_VALUE        = The value of ICMP type field
HELP_ACE_ICMP_CODE_VALUE        = The value of ICMP code field
HELP_ACE_ANY_ICMP_TYPE          = Don't-care the value of ICMP type field
HELP_ACE_ANY_ICMP_CODE          = Don't-care the value of ICMP code field

HELP_ACE_IP_PROTO               = IPv4 protocol field
HELP_ACE_IP_PROTO_VALUE         = The value of IPv4 protocol field
HELP_ACE_ANY_IP_PROTO           = Don't-care the value of IPv4 protocol field

HELP_ACE_SIP                    = Source IP address field
HELP_ACE_DIP                    = Destination IP address field
HELP_ACE_SIP_VALUE              = The value of source IP address field
HELP_ACE_DIP_VALUE              = The value of destination IP address field
HELP_ACE_ANY_SIP                = Don't-care the value of source IP address field
HELP_ACE_ANY_DIP                = Don't-care the value of destination IP address field

HELP_ACE_RANGE_TO               = Port range 
HELP_ACE_UDP_SPORT              = UDP source port field
HELP_ACE_UDP_DPORT              = UDP destination port field
HELP_ACE_TCP_SPORT              = TCP source port field
HELP_ACE_TCP_DPORT              = TCP destination port field
HELP_ACE_UDP_SPORT_VALUE        = The value of UDP source port field
HELP_ACE_UDP_DPORT_VALUE        = The value of UDP destination port field
HELP_ACE_TCP_SPORT_VALUE        = The value of TCP source port field
HELP_ACE_TCP_DPORT_VALUE        = The value of TCP destination Iport field
HELP_ACE_ANY_UDP_SPORT          = The value of UDP source port field
HELP_ACE_ANY_UDP_DPORT          = Don't-care the value of UDP destination port field
HELP_ACE_ANY_TCP_SPORT          = Don't-care the value of TCP source port field
HELP_ACE_ANY_TCP_DPORT          = Don't-care the value of TCP destination port field

HELP_ACE_ARP_FLAG               = ARP flag
HELP_ACE_ARP_OPCODE             = ARP/RARP opcode field
HELP_ACE_ARP_OPCODE_ARP         = ARP opcode
HELP_ACE_ARP_OPCODE_RARP        = RARP opcode
HELP_ACE_ARP_OPCODE_OTHER       = None ARP/RARP opcode
HELP_ACE_ARP_FLAG_REQ           = ARP Request/Reply opcode field
HELP_ACE_ARP_FLAG_SMAC          = ARP sender hardware address (SHA) field
HELP_ACE_ARP_FLAG_TMAC          = ARP target hardware address (THA) field
HELP_ACE_ARP_FLAG_LEN           = ARP/RARP hardware address length (HLN) and protocol address length (PLN) field
HELP_ACE_ARP_FLAG_IP            = ARP/RARP hardware address space (HRD) field
HELP_ACE_ARP_FLAG_ETHER         = ARP/RARP protocol address space (PRO) field
HELP_ACE_ARP_FLAG_REQ_VALUE     = The value of ARP Request/Reply opcode field
HELP_ACE_ARP_FLAG_SMAC_VALUE    = The value of ARP sender hardware address (SHA) field
HELP_ACE_ARP_FLAG_TMAC_VALUE    = The value of ARP target hardware address (THA) field
HELP_ACE_ARP_FLAG_LEN_VALUE     = The value of ARP/RARP hardware address length (HLN) and protocol address length (PLN) field
HELP_ACE_ARP_FLAG_IP_VALUE      = The value of ARP/RARP hardware address space (HRD) field
HELP_ACE_ARP_FLAG_ETHER_VALUE   = The value of ARP/RARP protocol address space (PRO) field
HELP_ACE_ANY_ARP_OPCODE         = Don't-care the value of ARP/RARP opcode field
HELP_ACE_ANY_ARP_FLAG_REQ       = Don't-care the value of ARP Request/Reply opcode field
HELP_ACE_ANY_ARP_FLAG_SMAC      = Don't-care the value of ARP sender hardware address (SHA) field
HELP_ACE_ANY_ARP_FLAG_TMAC      = Don't-care the value of ARP target hardware address (THA) field
HELP_ACE_ANY_ARP_FLAG_LEN       = Don't-care the value of ARP/RARP hardware address length (HLN) and protocol address length (PLN) field
HELP_ACE_ANY_ARP_FLAG_IP        = Don't-care the value of ARP/RARP hardware address space (HRD) field
HELP_ACE_ANY_ARP_FLAG_ETHER     = Don't-care the value of ARP/RARP protocol address space (PRO) field

HELP_ACE_IP_FLAG                = IP flag
HELP_ACE_IP_FLAG_TTL            = IPv4 TTL field
HELP_ACE_IP_FLAG_OPT            = IPv4 options field
HELP_ACE_IP_FLAG_FRAG           = IPv4 fragment field
HELP_ACE_IP_FLAG_TTL_VALUE      = The value of IPv4 TTL field
HELP_ACE_IP_FLAG_OPT_VALUE      = The value of IPv4 options field
HELP_ACE_IP_FLAG_FRAG_VALUE     = The value of IPv4 fragment field
HELP_ACE_ANY_IP_FLAG_TTL        = Don't-care the value of IPv4 TTL field
HELP_ACE_ANY_IP_FLAG_OPT        = Don't-care the value of IPv4 options field
HELP_ACE_ANY_IP_FLAG_FRAG       = Don't-care the value of IPv4 fragment field

HELP_ACE_TCP_FLAG               = TCP flag
HELP_ACE_TCP_FLAG_FIN           = TCP FIN field
HELP_ACE_TCP_FLAG_SYN           = TCP SYN field
HELP_ACE_TCP_FLAG_RST           = TCP RST field
HELP_ACE_TCP_FLAG_ACK           = TCP ACK field
HELP_ACE_TCP_FLAG_PSH           = TCP PSH field
HELP_ACE_TCP_FLAG_URG           = TCP URG field
HELP_ACE_TCP_FLAG_FIN_VALUE     = The value of TCP FIN field
HELP_ACE_TCP_FLAG_SYN_VALUE     = The value of TCP SYN field
HELP_ACE_TCP_FLAG_RST_VALUE     = The value of TCP RST field
HELP_ACE_TCP_FLAG_ACK_VALUE     = The value of TCP ACK field
HELP_ACE_TCP_FLAG_PSH_VALUE     = The value of TCP PSH field
HELP_ACE_TCP_FLAG_URG_VALUE     = The value of TCP URG field
HELP_ACE_ANY_TCP_FLAG_FIN       = Don't-care the value of TCP FIN field
HELP_ACE_ANY_TCP_FLAG_SYN       = Don't-care the value of TCP SYN field
HELP_ACE_ANY_TCP_FLAG_RST       = Don't-care the value of TCP RST field
HELP_ACE_ANY_TCP_FLAG_ACK       = Don't-care the value of TCP ACK field
HELP_ACE_ANY_TCP_FLAG_PSH       = Don't-care the value of TCP PSH field
HELP_ACE_ANY_TCP_FLAG_URG       = Don't-care the value of TCP URG field

HELP_ACE_IPV6_NEXT_HEADER       = IPv6 next header field                        
HELP_ACE_ANY_HOP_LIMITER        = IPv6 hop limiter field                       
HELP_ACE_SIPV6_BITMASK          = The bitmask for IPv6 source address
HELP_ACE_IPV6_NEXT_HEADER_VALUE = The value of IPv6 next header field  
HELP_ACE_ANY_HOP_LIMITER_VALUE  = The value of IPv6 hop limiter field
HELP_ACE_SIPV6_BITMASK_VALUE    = The value of IPv6 source address bitmask
HELP_ACE_ANY_IPV6_NEXT_HEADER   = Don't-care the value of IPv6 next header field
HELP_ACE_ANY_IPV6_HOP_LIMITER   = Don't-care the value of IPv6 hop limiter field

HELP_ACE_DISABLE                = Disable
HELP_ACE_DISABLE_RATE_LIMITER   = Disable rate-limiter
HELP_ACE_DISABLE_EVC_POLICER    = Disable evc-policer
HELP_ACE_DISABLE_MIRROR         = Disable mirror
HELP_ACE_DISABLE_LOGGING        = Disable logging
HELP_ACE_DISABLE_SHUTDOWN       = Disable shutdown
HELP_ACE_DISABLE_LOOKUP         = Disable second lookup
HELP_ACE_LOOKUP                 = Second lookup

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list action { permit | deny }

DOC_CMD_DESC    = Use the access-list action interface configuration command to \
                  configure access-list action. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = access-list action is permitted.
DOC_CMD_USAGE   = Configure access-list action.
DOC_CMD_EXAMPLE = This example shows how to configure access-list permit:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list permit
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_action
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: access-list
! 2: action
! 3: permit
! 4: deny

CMD_VAR =
CMD_VAR =
CMD_VAR = has_permit
CMD_VAR = has_deny

HELP = ##HELP_ACL
HELP = ##HELP_ACL_ACTION
HELP = ##HELP_ACL_PERMIT
HELP = ##HELP_ACL_DENY

BYWORD =
BYWORD =
BYWORD = <Permit : option>
BYWORD = <Deny : option>

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
#if defined(VTSS_FEATURE_ACL_V2)
    vtss_port_no_t  port_idx;
#endif /* VTSS_FEATURE_ACL_V2 */
VARIABLE_END

CODE_BEGIN
#if defined(VTSS_FEATURE_ACL_V2)
    if (has_deny) {
        port_conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
    } else {
        port_conf.action.port_action = VTSS_ACL_PORT_ACTION_NONE;
    }
    for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
        port_conf.action.port_list[port_idx] = (port_conf.action.port_action == VTSS_ACL_PORT_ACTION_NONE ? TRUE : FALSE);
    }
#else
    if (has_deny) {
        port_conf.action.permit = FALSE;
    } else {
        port_conf.action.permit = TRUE;
    }
#endif /* VTSS_FEATURE_ACL_V2 */

    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_PERMIT);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list rate-limiter <1-16>

DOC_CMD_DESC    = Use the access-list rate-limiter interface configuration command to \
                  configure the access-list rate-limiter ID . \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list rate-limiter is diabled.
DOC_CMD_USAGE   = Configure the access-list rate-limiter ID.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list rate-limiter ID 1:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list rate-limiter 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_rate_limiter
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_rate_limiter

! 1: access-list
! 2: rate-limiter
! 3: <rate_limiter_id:1-16>

CMD_VAR =
CMD_VAR =
CMD_VAR = rate_limiter_id

HELP = ##HELP_ACL
HELP = ##HELP_ACL_RATE_LIMITER
HELP = ##HELP_ACL_RATE_LIMITER_ID

BYWORD =
BYWORD =
BYWORD = <RateLimiterId : 1-16>

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    port_conf.action.policer = upolicer2ipolicer(rate_limiter_id);
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_POLICER);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no access-list rate-limiter

DOC_CMD_DESC    = Use the no access-list rate-limiter interface configuration command to \
                  disable the access-list rate-limiter. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list rate-limiter is disabled.
DOC_CMD_USAGE   = Disable the access-list rate-limiter.
DOC_CMD_EXAMPLE = This example shows how to disable the access-list rate-limiter:
DOC_CMD_EXAMPLE = Switch(config)# no access-list rate-limiter
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_rate_limiter_disable
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: no
! 2: access-list
! 3: rate-limiter

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_ACL
HELP = ##HELP_ACL_RATE_LIMITER

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    port_conf.action.policer = ACL_POLICER_NONE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_POLICER);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list { redirect | port-copy } interface { <port_type_id> | <port_type_list> }

DOC_CMD_DESC    = Use the no access-list redirect interface configuration command to \
                  configure the access-list redirect interface. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DESC    = Note: The command keyword of port-copy only supported on specific platform (Lu28)\
                  and the parameter of <port_type_id> is used for ACLv1, <port_type_list> is used for ACLv2. \
                  In stackable platform, the feature only supported for local interfaces.
DOC_CMD_DEFAULT = The access-list redirect is disabled.
DOC_CMD_USAGE   = Configure the access-list redirect.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list redirect interface to interface GigaEthernet 1/1:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list redirect interface to interface GigaEthernet 1/1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_redirect
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME = ACL_ICLI_runtime_has_redirect
RUNTIME = ACL_ICLI_runtime_has_port_copy
RUNTIME =
RUNTIME = ACL_ICLI_runtime_has_v1
RUNTIME = ACL_ICLI_runtime_has_v2

! 1: access-list
! 2: redirect
! 3: port-copy
! 4: interface
! 5: <port_type_id>
! 6: <port_type_list>

CMD_VAR =
CMD_VAR = has_redirect
CMD_VAR = has_port_copy
CMD_VAR =
CMD_VAR = port_type_id
CMD_VAR = port_type_list

HELP = ##HELP_ACL
HELP = ##HELP_ACL_REDIRECT
HELP = ##HELP_ACL_PORT_COPY
HELP = ##ICLI_HELP_INTERFACE
HELP = ##ICLI_HELP_PORT_TYPE_ID
HELP = ##ICLI_HELP_PORT_TYPE_LIST

BYWORD =
BYWORD = <Redirect : option>
BYWORD = <PortCopy : option>
BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
#if defined(VTSS_FEATURE_ACL_V2)
    port_conf.action.port_action = VTSS_ACL_PORT_ACTION_REDIR;
    if (!plist) {
        ICLI_PRINTF("%% Internal error: Null point of port mode list.\n");
        return ICLI_RC_ERROR;
    }
    if (icli_porttypelist2iportlist(plist->switch_range[0].usid, port_type_list, port_conf.action.port_list, VTSS_PORT_ARRAY_SIZE)) {
        ICLI_PRINTF("%% Cannot be configured on different switch ID.\n");
        return ICLI_RC_ERROR;
    }
#else
    if (ACL_ICLI_local_port_check(session_id, plist, &port_type_id) != ICLI_RC_OK) {
        return ICLI_RC_ERROR;
    }
    port_conf.action.port_no = uport2iport(port_type_id.begin_uport);
#endif
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_PORT_REDIRECT);
CODE_END

CMD_END


!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no access-list { redirect | port-copy }

DOC_CMD_DESC    = Use the no access-list redirect interface configuration command to \
                  disable the access-list redirect. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list redirect is disabled.
DOC_CMD_USAGE   = Disable the access-list redirect.
DOC_CMD_EXAMPLE = This example shows how to disable the access-list redirect:
DOC_CMD_EXAMPLE = Switch(config)# no access-list redirect
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_redirect_disable
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_has_redirect
RUNTIME = ACL_ICLI_runtime_has_port_copy

! 1: no
! 2: access-list
! 3: redirect
! 4: port-copy

CMD_VAR =
CMD_VAR =
CMD_VAR = has_redirect
CMD_VAR = has_port_copy

HELP = ##ICLI_HELP_NO
HELP = ##HELP_ACL
HELP = ##HELP_ACL_REDIRECT
HELP = ##HELP_ACL_PORT_COPY

BYWORD =
BYWORD =
BYWORD = <Redirect : option>
BYWORD = <PortCopy : option>

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
#if defined(VTSS_FEATURE_ACL_V2)
    port_conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
    memset(port_conf.action.port_list, 0, sizeof(port_conf.action.port_list));
#else
    port_conf.action.port_no = VTSS_PORT_NO_NONE;
#endif /* VTSS_FEATURE_ACL_V2 */
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_PORT_REDIRECT);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_FEATURE_ACL_V2)

COMMAND = access-list mirror

DOC_CMD_DESC    = Use the access-list mirror interface configuration command to \
                  enable access-list mirror. Use the no form of this \
                  command to disable access-list mirror. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = access-list mirror is disabled.
DOC_CMD_USAGE   = Enable access-list mirror.
DOC_CMD_EXAMPLE = This example shows how to enable access-list mirror:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list mirror
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

NO_FORM_DOC_CMD_DESC    = Use the no access-list mirror interface configuration command to \
                          disable access-list mirror.
NO_FORM_DOC_CMD_DEFAULT = access-list mirror is disabled.
NO_FORM_DOC_CMD_USAGE   = Disable access-list mirror.
NO_FORM_DOC_CMD_EXAMPLE = This example shows how to disable access-list mirror:
NO_FORM_DOC_CMD_EXAMPLE = Switch(if-port)# no access-list mirror
NO_FORM_DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_mirror
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: access-list
! 2: mirror

CMD_VAR =
CMD_VAR =

HELP = ##HELP_ACL
HELP = ##HELP_ACL_MIRROR

BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    acl_port_conf_t port_conf;
NO_FORM_VARIABLE_END

CODE_BEGIN
    port_conf.action.mirror = TRUE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_MIRROR);
CODE_END

NO_FORM_CODE_BEGIN
    port_conf.action.mirror = FALSE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_MIRROR);

NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list logging

DOC_CMD_DESC    = Use the access-list logging interface configuration command to \
                  enable access-list logging. Use the no form of this \
                  command to disable access-list logging. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DESC    = Note: The logging feature only works when the packet length is less than 1518(without VLAN tags).
DOC_CMD_DEFAULT = access-list logging is disabled.
DOC_CMD_USAGE   = Enable access-list logging.
DOC_CMD_EXAMPLE = This example shows how to enable access-list logging:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list logging
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

NO_FORM_DOC_CMD_DESC    = Use the no access-list logging interface configuration command to \
                          disable access-list logging.
NO_FORM_DOC_CMD_DEFAULT = access-list logging is disabled.
NO_FORM_DOC_CMD_USAGE   = Disable access-list logging.
NO_FORM_DOC_CMD_EXAMPLE = This example shows how to disable access-list logging:
NO_FORM_DOC_CMD_EXAMPLE = Switch(if-port)# no access-list logging
NO_FORM_DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_logging
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: access-list
! 2: logging

CMD_VAR =
CMD_VAR =

HELP = ##HELP_ACL
HELP = ##HELP_ACL_LOGGING

BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    acl_port_conf_t port_conf;
NO_FORM_VARIABLE_END

CODE_BEGIN
    port_conf.action.logging = TRUE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_LOGGING);
CODE_END

NO_FORM_CODE_BEGIN
    port_conf.action.logging = FALSE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_LOGGING);
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list shutdown

DOC_CMD_DESC    = Use the access-list shutdown interface configuration command to \
                  enable access-list shutdown. Use the no form of this \
                  command to disable access-list shutdown. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DESC    = Note: The shutdown feature only works when the packet length is less than 1518(without VLAN tags).
DOC_CMD_DEFAULT = access-list shutdown is disabled.
DOC_CMD_USAGE   = Enable access-list shutdown.
DOC_CMD_EXAMPLE = This example shows how to enable access-list shutdown:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list shutdown
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

NO_FORM_DOC_CMD_DESC    = Use the no access-list shutdown interface configuration command to \
                          disable access-list shutdown.
NO_FORM_DOC_CMD_DEFAULT = access-list shutdown is disabled.
NO_FORM_DOC_CMD_USAGE   = Disable access-list shutdown.
NO_FORM_DOC_CMD_EXAMPLE = This example shows how to disable access-list shutdown:
NO_FORM_DOC_CMD_EXAMPLE = Switch(if-port)# no access-list shutdown
NO_FORM_DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_shutdown
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: access-list
! 2: shutdown

CMD_VAR =
CMD_VAR =

HELP = ##HELP_ACL
HELP = ##HELP_ACL_SHUTDOWN

BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
    acl_port_conf_t port_conf;
NO_FORM_VARIABLE_END

CODE_BEGIN
    port_conf.action.shutdown = TRUE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_SHUTDOWN);
CODE_END

NO_FORM_CODE_BEGIN
    port_conf.action.shutdown = FALSE;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_SHUTDOWN);
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)

COMMAND = access-list evc-policer <1-256>

DOC_CMD_DESC    = Use the access-list evc-policer interface configuration command to \
                  configure the access-list evc-policer ID. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list policy is 0.
DOC_CMD_USAGE   = Configure the access-list policy value.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list policy value 1:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list policy 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_evc_police
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_evc_policer_id

! 1: access-list
! 2: evc-policer
! 3: <evc_policer_id:1-256>

CMD_VAR =
CMD_VAR =
CMD_VAR = evc_policer_id

HELP = ##HELP_ACL
HELP = ##HELP_ACL_EVC_POLICER
HELP = ##HELP_ACL_EVC_POLICER_ID

BYWORD =
BYWORD =
BYWORD = <EvcPolicerId : 1-256>

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    port_conf.action.evc_police = TRUE;
    port_conf.action.evc_policer_id = uevcpolicer2ievcpolicer(evc_policer_id);
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_EVC_POLICER_ID);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG = defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)

COMMAND = no access-list evc-policer

DOC_CMD_DESC    = Use the no access-list evc-policer interface configuration command to \
                  configure the access-list evc-policer ID. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list evc-policer is disabled.
DOC_CMD_USAGE   = Configure the access-list evc-policer ID.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list evc-policer ID 1:
DOC_CMD_EXAMPLE = Switch(config)# access-list evc-policer 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_evc_police_disable
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: no
! 2: access-list
! 3: evc-policer

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_ACL
HELP = ##HELP_ACL_EVC_POLICER

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    port_conf.action.evc_police = FALSE;
    port_conf.action.evc_policer_id = 0;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_ACTION_EVC_POLICER_ID);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list policy <0-255>

DOC_CMD_DESC    = Use the access-list policy interface configuration command to \
                  configure the access-list policy value. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list policy is 0.
DOC_CMD_USAGE   = Configure the access-list policy value.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list policy value 1:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list policy 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_policy
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_policy

! 1: access-list
! 2: policy
! 3: <policy_id:0-255>

CMD_VAR =
CMD_VAR =
CMD_VAR = policy_id

HELP = ##HELP_ACL
HELP = ##HELP_ACL_POLICY
HELP = ##HELP_ACL_POLICY_ID

BYWORD =
BYWORD =
BYWORD = <PolicyId : 0-255>

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    port_conf.policy_no = policy_id;
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_POLICY_NO);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no access-list policy

DOC_CMD_DESC    = Use the no access-list policy interface configuration command to \
                  restore the default access-list policy ID. \
                  The access-list interface configuration will affect the received frames if it doesn't match any ACE.
DOC_CMD_DEFAULT = The access-list policy is 0.
DOC_CMD_USAGE   = Restore the default access-list policy ID.
DOC_CMD_EXAMPLE = This example shows how to restore the default access-list policy ID:
DOC_CMD_EXAMPLE = Switch(config)# no access-list policy
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_policy_disable
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: no
! 2: access-list
! 3: policy

CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_NO
HELP = ##HELP_ACL
HELP = ##HELP_ACL_POLICY

BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
    acl_port_conf_t port_conf;
VARIABLE_END

CODE_BEGIN
    acl_mgmt_port_conf_get_default(&port_conf);
    ACL_ICLI_port_conf_set(session_id, plist, &port_conf, ACL_ICLI_OPCODE_POLICY_NO);
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list port-state

DOC_CMD_DESC    = Use the access-list port-state interface configuration command to \
                  enable access-list port state. Use the no form of this \
                  command to disable access-list port state.
DOC_CMD_DEFAULT = access-list port-state is enabled.
DOC_CMD_USAGE   = Enable access-list port state. If a interface had been shutdown by access-list module,\
                  this command can be used to reopen the interface, then it can receive normal frame again.
DOC_CMD_EXAMPLE = This example shows how to enable access-list port state:
DOC_CMD_EXAMPLE = Switch(if-port)# access-list port-state
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

NO_FORM_DOC_CMD_DESC    = Use the no access-list port-state interface configuration command to \
                          disable access-list port state.
NO_FORM_DOC_CMD_DEFAULT = access-list port-state enabled.
NO_FORM_DOC_CMD_USAGE   = Disable access-list port state.
NO_FORM_DOC_CMD_EXAMPLE = This example shows how to disable access-list port state:
NO_FORM_DOC_CMD_EXAMPLE = Switch(if-port)# no access-list port-state
NO_FORM_DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list interface privileged EXEC command.

FUNC_NAME = icli_acl_port_state
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_INTERFACE_PORT_LIST
MODE_VAR = plist

RUNTIME =

! 1: access-list
! 2: port-state

CMD_VAR =
CMD_VAR =

HELP = ##HELP_ACL
HELP = ##HELP_ACL_PORT_STATE

BYWORD =
BYWORD =

VARIABLE_BEGIN
VARIABLE_END

NO_FORM_VARIABLE_BEGIN
NO_FORM_VARIABLE_END

CODE_BEGIN
    ACL_ICLI_port_state_set(session_id, plist, TRUE);
CODE_END

NO_FORM_CODE_BEGIN
    ACL_ICLI_port_state_set(session_id, plist, FALSE);
NO_FORM_CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list rate-limiter [ <1~16> ] { pps <1,2,4,8,16,32,64,128,256,512>| 100pps <1-32767> | kpps <1,2,4,8,16,32,64,128,256,512,1024> | 100kbps <0-10000> }

DOC_CMD_DESC    = Use the access-list rate-limiter global configuration command to \
                  configure the access-list rate-limiter.
DOC_CMD_DEFAULT = The access-list rate-limiter is 1 pps.
DOC_CMD_USAGE   = Configure the access-list rate-limiter.
DOC_CMD_EXAMPLE = This example shows how to configure the access-list rate-limiter ID 1 to 512 pps:
DOC_CMD_EXAMPLE = Switch(config)# access-list rate-limiter 1 pps 512
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list rate-limiter privileged EXEC command.

FUNC_NAME = icli_acl_rate_limiter
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_rate_limiter_list
RUNTIME =
RUNTIME = ACL_ICLI_runtime_pps
RUNTIME = ACL_ICLI_runtime_100pps
RUNTIME = ACL_ICLI_runtime_100pps
RUNTIME = ACL_ICLI_runtime_kpps
RUNTIME = ACL_ICLI_runtime_kpps
RUNTIME = ACL_ICLI_runtime_100kbps
RUNTIME = ACL_ICLI_runtime_100kbps

! 1: access-list
! 2: rate-limiter
! 3: <rate_limiter_list:1~16>
! 4: pps
! 5: <pps_rate:1,2,4,8,16,32,64,128,256,512>
! 6: 100pps
! 7: <100pps_rate:0-32767>
! 8: kpps
! 9: <kpps_rate:1,2,4,8,16,32,64,128,256,512,1024>
! 10: 100kbps
! 11: <kpbs_rate:0-10000>

CMD_VAR =
CMD_VAR =
CMD_VAR = rate_limiter_list
CMD_VAR = has_pps
CMD_VAR = pps_rate
CMD_VAR = has_100pps
CMD_VAR = pps100_rate
CMD_VAR = has_kpps
CMD_VAR = kpps_rate
CMD_VAR = has_100kbps
CMD_VAR = kpbs100_rate

HELP = ##HELP_ACL
HELP = ##HELP_ACL_RATE_LIMITER
HELP = ##HELP_ACL_RATE_LIMITER_ID
HELP = ##HELP_ACL_RATE_PPS
HELP = ##HELP_ACL_RATE_VALUE
HELP = ##HELP_ACL_RATE_100PPS
HELP = ##HELP_ACL_RATE_VALUE
HELP = ##HELP_ACL_RATE_KPPS
HELP = ##HELP_ACL_RATE_VALUE
HELP = ##HELP_ACL_RATE_100KBPS
HELP = ##HELP_ACL_RATE_VALUE

BYWORD =
BYWORD =
BYWORD = <RateLimiterList : 1~16>
BYWORD =
BYWORD = <PpsRate : 1,2,4,8,16,32,64,128,256,512>
BYWORD =
BYWORD = <100PpsRate : 1-32767>
BYWORD =
BYWORD = <KppsRate : 1,2,4,8,16,32,64,128,256,512,1024>
BYWORD =
BYWORD = <100KbpsRate : 0-1000000>

VARIABLE_BEGIN
    u32                     range_idx;
    vtss_acl_policer_no_t   policer_idx;
    acl_policer_conf_t      conf;
VARIABLE_END

CODE_BEGIN
    if (rate_limiter_list) { //at least one range input
        for (range_idx = 0; range_idx < rate_limiter_list->cnt; range_idx++) {
            for (policer_idx = rate_limiter_list->range[range_idx].min; policer_idx <= rate_limiter_list->range[range_idx].max; policer_idx++) {
                ICLI_RC_CHECK(acl_mgmt_policer_conf_get(upolicer2ipolicer(policer_idx), &conf),
                              "%% Failed to get access-list rate-limiter configuration\n");
                if (has_pps) {
                    conf.packet_rate = pps_rate;
                } else if (has_100pps) {
                     conf.packet_rate = pps100_rate * 100;
                } else if (has_kpps) {
                    conf.packet_rate = kpps_rate * 1000;
                }
#if defined(VTSS_FEATURE_ACL_V2)
                if (has_100kbps) {
                    conf.bit_rate_enable = TRUE;
                    conf.bit_rate = kpbs100_rate * 100;
                } else {
                    conf.bit_rate_enable = FALSE;
                    conf.bit_rate = 0;
                }
#endif /* VTSS_FEATURE_ACL_V2 */
                ICLI_RC_CHECK(acl_mgmt_policer_conf_set(upolicer2ipolicer(policer_idx), &conf),
                              "%% Failed to set access-list policer configuration\n");
            }
        }
    } else { //all rate limiter
        for (policer_idx = ACL_POLICER_NO_START; policer_idx < ACL_POLICER_NO_END; policer_idx++) {
            ICLI_RC_CHECK(acl_mgmt_policer_conf_get(policer_idx, &conf),
                          "%% Failed to get access-list rate-limiter configuration\n");
            if (has_pps) {
                conf.packet_rate = pps_rate;
            } else if (has_100pps) {
                conf.packet_rate = pps100_rate * 100;
            } else if (has_kpps) {
                conf.packet_rate = kpps_rate * 1000;
            }
#if defined(VTSS_FEATURE_ACL_V2)
            if (has_100kbps) {
                conf.bit_rate_enable = TRUE;
                conf.bit_rate = kpbs100_rate * 100;
            } else {
                conf.bit_rate_enable = FALSE;
                conf.bit_rate = 0;
            }
#endif /* VTSS_FEATURE_ACL_V2 */
            ICLI_RC_CHECK(acl_mgmt_policer_conf_set(policer_idx, &conf),
                          "%% Failed to set access-list rate-limiter configuration\n");
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = default access-list rate-limiter [ <1~16> ]

DOC_CMD_DESC    = Use the default access-list rate-limiter global configuration command to \
                  restore the default setting of access-list rate-limiter.
DOC_CMD_DEFAULT = 
DOC_CMD_USAGE   = Restore the default setting of access-list rate-limiter.
DOC_CMD_EXAMPLE = This example shows how to restore the default setting on all rate-limiter IDs:
DOC_CMD_EXAMPLE = Switch(config)# default access-list rate-limiter
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list rate-limiter privileged EXEC command.

FUNC_NAME = icli_acl_rate_limiter_clear
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_rate_limiter

! 1: default
! 2: access-list
! 3: rate-limiter
! 4: <rate_limiter_id:1-16>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = rate_limiter_list

HELP = ##ICLI_HELP_DEFAULT
HELP = ##HELP_ACL
HELP = ##HELP_ACL_RATE_LIMITER
HELP = ##HELP_ACL_RATE_LIMITER_ID

BYWORD =
BYWORD =
BYWORD =
BYWORD = <RateLimiterId : 1-16>

VARIABLE_BEGIN
    u32                     range_idx;
    vtss_acl_policer_no_t   policer_idx;
    acl_policer_conf_t      def_conf;
VARIABLE_END

CODE_BEGIN
    acl_mgmt_policer_conf_get_default(&def_conf);
    if (rate_limiter_list) { //at least one range input
        for (range_idx = 0; range_idx < rate_limiter_list->cnt; range_idx++) {
            for (policer_idx = rate_limiter_list->range[range_idx].min; policer_idx <= rate_limiter_list->range[range_idx].max; policer_idx++) {
                ICLI_RC_CHECK(acl_mgmt_policer_conf_set(upolicer2ipolicer(policer_idx), &def_conf),
                              "%% Failed to set access-list policer configuration\n");
            }
        }
    } else { //all rate limiter
        for (policer_idx = ACL_POLICER_NO_START; policer_idx < ACL_POLICER_NO_END; policer_idx++) {
            ICLI_RC_CHECK(acl_mgmt_policer_conf_set(policer_idx, &def_conf),
                          "%% Failed to set access-list rate-limiter configuration\n");
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = access-list ace [update] <1-256>\
    [next {<1-256>|last}]\
    [ingress {switch <switch_id>|switchport {<1-53>|<1~53>}|interface {<port_type_id>|<port_type_list>}|any}]\
    [policy <0-255> [policy-bitmask <0x0-0xFF>]]\
    [tag {tagged|untagged|any}]\
    [vid {<1-4095>|any}]\
    [tag-priority {<0-7>|0-1|2-3|4-5|6-7|0-3|4-7|any}]\
    [dmac-type {unicast|multicast|broadcast|any}]\
    [frame-type {\
        any|\
        etype [etype-value {<0x600-0x7ff,0x801-0x805,0x807-0x86dc,0x86de-0xffff>|any}] [smac {<mac_addr>|any}] [dmac {<mac_addr>|any}]|\
        arp [sip {<ipv4_subnet>|any}] [dip {<ipv4_subnet>|any}] [smac {<mac_addr>|any}] [arp-opcode {arp|rarp|other|any}] [arp-flag [arp-request {<0-1>|any}] [arp-smac {<0-1>|any}] [arp-tmac {<0-1>|any}] [arp-len {<0-1>|any}] [arp-ip {<0-1>|any}] [arp-ether {<0-1>|any}]]|\
        ipv4 [sip {<ipv4_subnet>|any}] [dip {<ipv4_subnet>|any}] [ip-protocol {<0,2-5,7-16,18-255>|any}] [ip-flag [ip-ttl {<0-1>|any}] [ip-options {<0-1>|any}] [ip-fragment {<0-1>|any}]]|\
        ipv4-icmp [sip {<ipv4_subnet>|any}] [dip {<ipv4_subnet>|any}] [icmp-type {<0-255>|any}] [icmp-code {<0-255>|any}] [ip-flag [ip-ttl {<0-1>|any}] [ip-options {<0-1>|any}] [ip-fragment {<0-1>|any}]]|\
        ipv4-udp [sip {<ipv4_subnet>|any}] [dip {<ipv4_subnet>|any}] [sport {<0-65535> [to <0-65535>]|any}] [dport {<0-65535> [to <0-65535>]|any}] [ip-flag [ip-ttl {<0-1>|any}] [ip-options {<0-1>|any}] [ip-fragment {<0-1>|any}]]|\
        ipv4-tcp [sip {<ipv4_subnet>|any}] [dip {<ipv4_subnet>|any}] [sport {<0-65535> [to <0-65535>]|any}] [dport {<0-65535> [to <0-65535>]|any}] [ip-flag [ip-ttl {<0-1>|any}] [ip-options {<0-1>|any}] [ip-fragment {<0-1>|any}]] [tcp-flag [tcp-fin {<0-1>|any}] [tcp-syn {<0-1>|any}] [tcp-rst {<0-1>|any}] [tcp-psh {<0-1>|any}] [tcp-ack {<0-1>|any}] [tcp-urg {<0-1>|any}]]|\
        ipv6 [next-header {<0-5,7-16,18-57,59-255>|any}] [sip {<ipv6_addr> [sip-bitmask <uint>]|any}] [hop-limit {<0-1>|any}]|\
        ipv6-icmp [sip {<ipv6_addr> [sip-bitmask <uint>]|any}] [icmp-type {<0-255>|any}] [icmp-code {<0-255>|any}] [hop-limit {<0-1>|any}]|\
        ipv6-udp [sip {<ipv6_addr> [sip-bitmask <uint>]|any}] [sport {<0-65535> [to <0-65535>]|any}] [dport {<0-65535> [to <0-65535>]|any}] [hop-limit {<0-1>|any}]|\
        ipv6-tcp [sip {<ipv6_addr> [sip-bitmask <uint>]|any}] [sport {<0-65535> [to <0-65535>]|any}] [dport {<0-65535> [to <0-65535>]|any}] [hop-limit {<0-1>|any}] [tcp-flag [tcp-fin {<0-1>|any}] [tcp-syn {<0-1>|any}] [tcp-rst {<0-1>|any}] [tcp-psh {<0-1>|any}] [tcp-ack {<0-1>|any}] [tcp-urg {<0-1>|any}]]}\
    ]\
    [action {permit|deny|filter {switchport <1~53>|interface <port_type_list>}}]\
    [rate-limiter {<1-16>|disable}]\
    [evc-policer {<1-256>|disable}]\
    [{redirect|port-copy} {switchport {<1-53>|<1~53>}|interface {<port_type_id>|<port_type_list>}|disable}]\
    [mirror [disable]]\
    [logging [disable]]\
    [shutdown [disable]] \
    [lookup [disable]]

DOC_CMD_DESC    = Use the access-list ace global configuration command to set \
                  the access-list ace. The command without the update keywrod \
                  will creates or overwrites an existing ACE, any unspecified \
                  parameter will be set to its default value. Use the update \
                  keyword to update an existing ACE and only specified parameter \
                  are modified. The ACE must ordered by an appropriate sequence, \
                  the received frame will only be hit on the first matched ACE. \
                  Use the next or last keyword to adjust the ACE's sequence order.
DOC_CMD_DESC    = Note1: There are a lot of parameters are depended on these \
                  features if supported on the platform. For example, \
                  The parameter of switch <SwitchID> and switchport \
                  {<SwitchPortId>|<SwitchPortList>} only support on stackable platform. \
                  The parameter of <port_type_id>, is used for ACLv1, \
                  <port_type_list>, action filter, tag, mirror, ipv6-icmp, ipv6-udp and ipv6-tcp is used for ACLv2. \
                  In stackable platform, the feature only supported for local interfaces. \
                  The command keyword of port-copy only supported on specific platform (Lu28). \
                  The command keyword of evc-policer only supported on CE platform. \
                  Use the parameter of redirect switchport for global ACE on stackable device.
DOC_CMD_DESC    = Note2: The logging and shutdown features only works when the packet length is less than 1518(without VLAN tags).
DOC_CMD_DEFAULT = 
DOC_CMD_USAGE   = Set the access-list ace.
DOC_CMD_EXAMPLE = This example shows how to set the access-list ace ID 1:
DOC_CMD_EXAMPLE = Switch(config)# aaccess-list ace 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list ace privileged EXEC command.

FUNC_NAME = icli_acl_ace_add
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

! 1: access-list
RUNTIME =
CMD_VAR =
BYWORD =
HELP = ##HELP_ACL
! 2: ace
RUNTIME =
CMD_VAR =
BYWORD =
HELP = ##HELP_ACE
! 3: update
RUNTIME =
CMD_VAR = has_update
BYWORD = <Update : option>
HELP = ##HELP_ACE_UPDATE
! 4: <ace_id:1-256>
RUNTIME = ACL_ICLI_runtime_ace
CMD_VAR = ace_id
BYWORD = <AceId : 1-256>
HELP = ##HELP_ACE_ID
! 5: next
RUNTIME =
CMD_VAR = has_next
BYWORD = <Next : option>
HELP = ##HELP_ACE_NEXT
! 6: <ace_id_next:1-256>
RUNTIME = ACL_ICLI_runtime_ace
CMD_VAR = ace_id_next
BYWORD = <AceIdNext : 1-256>
HELP = ##HELP_NEXT_ACE_ID
! 7: last
RUNTIME =
CMD_VAR = has_last
BYWORD = <Last : option>
HELP = ##HELP_ACE_LAST
! 8: ingress
RUNTIME =
CMD_VAR = has_ingress
BYWORD = <Ingress : option>
HELP = ##HELP_ACE_INGRESS
! 9: switch
RUNTIME = ACL_ICLI_runtime_has_stackable
CMD_VAR = has_ingress_switch
BYWORD = <Switch : option>
HELP = ##HELP_ACL_SWITCH
! 10: <ingress_switch_id:1-16>
RUNTIME = ACL_ICLI_runtime_has_stackable
CMD_VAR = ingress_switch_id
BYWORD = <IngressSwitchId : 1-16>
HELP = ##HELP_ACL_SWITCH_ID
! 11: switchport
RUNTIME = ACL_ICLI_runtime_has_stackable
CMD_VAR = has_ingress_switchport
BYWORD = <Switchport : option>
HELP = ##HELP_ACL_SWITCHPORT
! 12: <ingress_switch_port_id:1-53>
RUNTIME = ACL_ICLI_runtime_switch_port_id
CMD_VAR = ingress_switch_port_id
BYWORD = <IngressSwitchPortId : 1-53>
HELP = ##HELP_ACE_SWITCHPORT_ID
! 13: <ingress_switch_port_list:1~53>
RUNTIME = ACL_ICLI_runtime_switch_port_list
CMD_VAR = ingress_switch_port_list
BYWORD = <IngressSwitchPortList : 1~53>
HELP = ##HELP_ACE_SWITCHPORT_LIST
! 14: interface
RUNTIME =
CMD_VAR = has_ingress_interface
BYWORD = <Interface : option>
HELP = ##ICLI_HELP_INTERFACE
! 15: <ingress_port_id:port_type_id>
RUNTIME = ACL_ICLI_runtime_has_v1
CMD_VAR = ingress_port_id
BYWORD = <IngressPortId : port_type_id>
HELP = ##ICLI_HELP_PORT_TYPE_ID
! 16: <ingress_port_list:port_type_list>
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = ingress_port_list
BYWORD = <IngressPortList : port_type_list>
HELP = ##ICLI_HELP_PORT_TYPE_LIST
! 17: any
RUNTIME =
CMD_VAR = has_any_ingress
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_INGRESS
! 18: policy
RUNTIME = 
CMD_VAR = has_policy
BYWORD = <Policy : option>
HELP = ##HELP_ACL_POLICY
! 19: <policy:0-255>
RUNTIME = ACL_ICLI_runtime_policy
CMD_VAR = policy
BYWORD = <Policy : 0-255>
HELP = ##HELP_ACL_POLICY_ID
! 20: policy-bitmask
RUNTIME =
CMD_VAR = has_policy_bitmask
BYWORD = <PolicyBitmask : option>
HELP = ##HELP_ACE_POLICY_BITMASK
! 21: <policy-bitmask:0x0-0xFF>
RUNTIME = ACL_ICLI_runtime_policy_bitmask
CMD_VAR = policy_bitmask
BYWORD = <PolicyBitmask : 0x0-0xFF>
HELP = ##HELP_ACE_POLICY_BITMASK_VALUE
! 22: tag
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_tag
BYWORD = <Tag : option>
HELP = ##HELP_ACE_TAG
! 23: tagged
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_tagged
BYWORD = <Tagged : option>
HELP = ##HELP_ACE_TAGGED
! 24: untagged
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_untagged
BYWORD = <Untagged : option>
HELP = ##HELP_ACE_UNTAGGED
! 25: any
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_any_tag
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TAG
! 26: vid
RUNTIME =
CMD_VAR = has_vid
BYWORD = <Vid : option>
HELP = ##HELP_ACE_VID
! 27: <vid:1-4095>
RUNTIME =
CMD_VAR = vid
BYWORD = <Vid : 1-4095>
HELP = ##HELP_ACE_VID_VALUE
! 28: any
RUNTIME =
CMD_VAR = has_any_vid
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_VID
! 29: tag-priority
RUNTIME =
CMD_VAR = has_tag_priority
BYWORD = <TagPriority : option>
HELP = ##HELP_ACE_TAG_PRI
! 30: <tag_priority:0-7>
RUNTIME =
CMD_VAR = tag_priority
BYWORD = <TagPriority : 0-7>
HELP = ##HELP_ACE_TAG_PRI_VALUE

RUNTIME =
CMD_VAR = tag_priority_01
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE
RUNTIME =
CMD_VAR = tag_priority_23
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE
RUNTIME =
CMD_VAR = tag_priority_45
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE
RUNTIME =
CMD_VAR = tag_priority_67
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE
RUNTIME =
CMD_VAR = tag_priority_03
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE
RUNTIME =
CMD_VAR = tag_priority_47
BYWORD =
HELP = ##HELP_ACE_TAG_PRI_RANGE

! 31: any
RUNTIME =
CMD_VAR = has_any_tag_priority
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TAG_PRI
! 32: dmac-type
RUNTIME =
CMD_VAR = has_dmac_type
BYWORD = <DmacType : option>
HELP = ##HELP_ACE_DMAC_TYPE
! 33: unicast
RUNTIME =
CMD_VAR = has_dmac_type_unicast
BYWORD = <Unicast : option>
HELP = ##HELP_ACE_DMAC_TYPE_UNICAST
! 34: multicast
RUNTIME =
CMD_VAR = has_dmac_type_multicast
BYWORD = <Multicast : option>
HELP = ##HELP_ACE_DMAC_TYPE_MULTICAST
! 35: broadcast
RUNTIME =
CMD_VAR = has_dmac_type_broadcast
BYWORD = <Broadcast : option>
HELP = ##HELP_ACE_DMAC_TYPE_BROADCAST
! 36: any
RUNTIME =
CMD_VAR = has_any_dmac_type
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DMAC_TYPE
! 37: frametype
RUNTIME =
CMD_VAR = has_frametype
BYWORD = <Frametype : option>
HELP = ##HELP_ACE_FRAMETYPE
! 38: any
RUNTIME =
CMD_VAR = has_any_frametype
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_FRAMETYPE
! 39: etype
RUNTIME =
CMD_VAR = has_frametype_etype
BYWORD = <Etype : option>
HELP = ##HELP_ACE_FRAMETYPE_ETYPE
! 40: etype-value
RUNTIME =
CMD_VAR = has_etype_value
BYWORD = <EtypeValue : option>
HELP = ##HELP_ACE_ETYPE
! 41: <etype_value:0x600-0x7ff,0x801-0x805,0x807-0x86dc,0x86de-0xffff>
RUNTIME =
CMD_VAR = etype_value
BYWORD = <EtypeValue : 0x600-0x7ff,0x801-0x805,0x807-0x86dc,0x86de-0xffff>
HELP = ##HELP_ACE_ETYPE_VALUE
! 42: any
RUNTIME =
CMD_VAR = has_any_etype_value
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ETYPE
! 43: smac
RUNTIME =
CMD_VAR = has_etype_smac
BYWORD = <Smac : option>
HELP = ##HELP_ACE_SMAC
! 44: <etype_smac:mac_addr>
RUNTIME =
CMD_VAR = etype_smac
BYWORD = <SmacAddr : mac_addr>
HELP = ##HELP_ACE_SMAC_VALUE
! 45: any
RUNTIME =
CMD_VAR = has_any_etype_smac
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SMAC
! 46: dmac
RUNTIME =
CMD_VAR = has_etype_dmac
BYWORD = <Dmac : option>
HELP = ##HELP_ACE_DMAC
! 47: <etype_dmac:mac_addr>
RUNTIME =
CMD_VAR = etype_dmac
BYWORD = <DmacAddr : mac_addr>
HELP = ##HELP_ACE_DMAC_VALUE
! 48: any
RUNTIME =
CMD_VAR = has_any_etype_dmac
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DMAC
! 49: arp
RUNTIME =
CMD_VAR = has_frametype_arp
BYWORD = <Arp : option>
HELP = ##HELP_ACE_FRAMETYPE_ARP
! 50: sip
RUNTIME =
CMD_VAR = has_arp_sip
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 51: <sipv4_arp:ipv4_subnet>
RUNTIME =
CMD_VAR = arp_sip
BYWORD = <SipAddr : ipv4_subnet>
HELP = ##HELP_ACE_SIP_VALUE
! 52: any
RUNTIME =
CMD_VAR = has_any_arp_sip
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 53: dip
RUNTIME =
CMD_VAR = has_arp_dip
BYWORD = <Dip : option>
HELP = ##HELP_ACE_DIP
! 54: <dipv4_arp:ipv4_subnet>
RUNTIME =
CMD_VAR = arp_dip
BYWORD = <DipAddr : ipv4_subnet>
HELP = ##HELP_ACE_DIP_VALUE
! 55: any
RUNTIME =
CMD_VAR = has_any_arp_dip
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DIP
! 56: smac
RUNTIME =
CMD_VAR = has_arp_smac
BYWORD = <Smac : option>
HELP = ##HELP_ACE_SMAC
! 57: <arp_smac:mac_addr>
RUNTIME = 
CMD_VAR = arp_smac
BYWORD = <SmacAddr : mac_addr>
HELP = ##HELP_ACE_SMAC_VALUE
! 58: any
RUNTIME =
CMD_VAR = has_any_arp_smac
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SMAC
! 59: arp-opcode
RUNTIME =
CMD_VAR = has_arp_opcode
BYWORD = <ArpOpcode : option>
HELP = ##HELP_ACE_ARP_OPCODE
! 60: arp
RUNTIME =
CMD_VAR = has_arp_opcode_arp
BYWORD = <Arp : option>
HELP = ##HELP_ACE_ARP_OPCODE_ARP
! 61: rarp
RUNTIME =
CMD_VAR = has_arp_opcode_rarp
BYWORD = <Rarp : option>
HELP = ##HELP_ACE_ARP_OPCODE_RARP
! 62: other
RUNTIME =
CMD_VAR = has_arp_opcode_other
BYWORD = <Other : option>
HELP = ##HELP_ACE_ARP_OPCODE_OTHER
! 63: any
RUNTIME =
CMD_VAR = has_any_arp_opcode
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_OPCODE
! 64: arp-flag
RUNTIME =
CMD_VAR = has_arp_flag
BYWORD = <ArpFlag : option>
HELP = ##HELP_ACE_ARP_FLAG
! 65: arp-request
RUNTIME =
CMD_VAR = has_arp_flag_request
BYWORD = <ArpRequest : option>
HELP = ##HELP_ACE_ARP_FLAG_REQ
! 66: <arp_flag_request:0-1>
RUNTIME =
CMD_VAR = arp_flag_request
BYWORD = <ArpFlagRequest : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_REQ_VALUE
! 67: any
RUNTIME =
CMD_VAR = has_any_arp_flag_request
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_REQ
! 68: arp-smac
RUNTIME =
CMD_VAR = has_arp_flag_smac
BYWORD = <ArpSmac : option>
HELP = ##HELP_ACE_ARP_FLAG_SMAC
! 69: <arp_flag_smac:0-1>
RUNTIME =
CMD_VAR = arp_flag_smac
BYWORD = <ArpFlagSmac : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_SMAC_VALUE
! 70: any
RUNTIME =
CMD_VAR = has_any_arp_flag_smac
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_SMAC
! 71: arp-tmac
RUNTIME =
CMD_VAR = has_arp_flag_tmac
BYWORD = <ArpTmac : option>
HELP = ##HELP_ACE_ARP_FLAG_TMAC
! 72: <arp_flag_tmac:0-1>
RUNTIME =
CMD_VAR = arp_flag_tmac
BYWORD = <ArpFlagTmac : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_TMAC_VALUE
! 73: any
RUNTIME =
CMD_VAR = has_any_arp_flag_tmac
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_TMAC
! 74: arp-len
RUNTIME =
CMD_VAR = has_arp_flag_len
BYWORD = <ArpLen : option>
HELP = ##HELP_ACE_ARP_FLAG_LEN
! 75: <arp_flag_len:0-1>
RUNTIME =
CMD_VAR = arp_flag_len
BYWORD = <ArpFlagLen : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_LEN_VALUE
! 76: any
RUNTIME =
CMD_VAR = has_any_arp_flag_len
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_LEN
! 77: arp-ip
RUNTIME =
CMD_VAR = has_arp_flag_ip
BYWORD = <ArpIp : option>
HELP = ##HELP_ACE_ARP_FLAG_IP
! 78: <arp_flag_ip:0-1>
RUNTIME =
CMD_VAR = arp_flag_ip
BYWORD = <ArpFlagIp : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_IP_VALUE
! 79: any
RUNTIME =
CMD_VAR = has_any_arp_flag_ip
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_IP
! 80: arp-ether
RUNTIME =
CMD_VAR = has_arp_flag_ether
BYWORD = <ArpEther : option>
HELP = ##HELP_ACE_ARP_FLAG_ETHER
! 81: <arp_flag_ether:0-1>
RUNTIME =
CMD_VAR = arp_flag_ether
BYWORD = <ArpFlagEther : 0-1>
HELP = ##HELP_ACE_ARP_FLAG_ETHER_VALUE
! 82: any
RUNTIME =
CMD_VAR = has_any_arp_flag_ether
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ARP_FLAG_ETHER
! 83: ipv4
RUNTIME =
CMD_VAR = has_frametype_ip
BYWORD = <Ip : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV4
! 84: sip
RUNTIME =
CMD_VAR = has_sipv4
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 85: <sipv4:ipv4_subnet>
RUNTIME =
CMD_VAR = sipv4
BYWORD = <SipAddr : ipv4_subnet>
HELP = ##HELP_ACE_SIP_VALUE
! 86: any
RUNTIME =
CMD_VAR = has_any_sipv4
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 87: dip
RUNTIME =
CMD_VAR = has_dipv4
BYWORD = <Dip : option>
HELP = ##HELP_ACE_DIP
! 88: <dipv4:ipv4_subnet>
RUNTIME =
CMD_VAR = dipv4
BYWORD = <DipAddr : ipv4_subnet>
HELP = ##HELP_ACE_DIP_VALUE
! 89: any
RUNTIME =
CMD_VAR = has_any_dipv4
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DIP
! 90: ip-protocol
RUNTIME =
CMD_VAR = has_ipv4_protocol
BYWORD = <IpProtocol : option>
HELP = HELP_ACE_IP_PROTO
! 91: <ipv4_protocol:0,2-5,7-16,18-255>
RUNTIME =
CMD_VAR = ipv4_protocol
BYWORD = <Ipv4Protocol : 0,2-5,7-16,18-255>
HELP = ##HELP_ACE_IP_PROTO_VALUE
! 92: any
RUNTIME =
CMD_VAR = has_any_ipv4_protocol
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_PROTO
! 93: ip-flag
RUNTIME =
CMD_VAR = has_ip_flag
BYWORD = <IpFlag : option>
HELP = ##HELP_ACE_IP_FLAG
! 94: ip-ttl
RUNTIME =
CMD_VAR = has_ip_flag_ttl
BYWORD = <IpTtl : option>
HELP = ##HELP_ACE_IP_FLAG_TTL
! 95: <ip_flag_ttl:0-1>
RUNTIME =
CMD_VAR = ip_flag_ttl
BYWORD = <IpFlagTtl : 0-1>
HELP = ##HELP_ACE_IP_FLAG_TTL_VALUE
! 96: any
RUNTIME =
CMD_VAR = has_any_ip_flag_ttl
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_TTL
! 97: ip-options
RUNTIME =
CMD_VAR = has_ip_flag_options
BYWORD = <IpOptions : option>
HELP = ##HELP_ACE_IP_FLAG_OPT
! 98: <ip_flag_options:0-1>
RUNTIME =
CMD_VAR = ip_flag_options
BYWORD = <IpFlagOptions : 0-1>
HELP = ##HELP_ACE_IP_FLAG_OPT_VALUE
! 99: any
RUNTIME =
CMD_VAR = has_any_ip_flag_options
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_OPT
! 100: ip-fragment
RUNTIME =
CMD_VAR = has_ip_flag_fragment
BYWORD = <IpFragment : option>
HELP = ##HELP_ACE_IP_FLAG_FRAG
! 101: <ip_flag_fragment:0-1>
RUNTIME =
CMD_VAR = ip_flag_fragment
BYWORD = <IpFlagFragment : 0-1>
HELP = ##HELP_ACE_IP_FLAG_FRAG_VALUE
! 102: any
RUNTIME =
CMD_VAR = has_any_ip_flag_fragment
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_FRAG
! 103: ipv4-icmp
RUNTIME =
CMD_VAR = has_frametype_icmp
BYWORD = <Icmp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV4_ICMP
! 104: sip
RUNTIME =
CMD_VAR = has_sipv4_icmp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 105: <sipv4_icmp:ipv4_subnet>
RUNTIME =
CMD_VAR = sipv4_icmp
BYWORD = <SipAddr : ipv4_subnet>
HELP = ##HELP_ACE_SIP_VALUE
! 106: any
RUNTIME =
CMD_VAR = has_any_sipv4_icmp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 107: dip
RUNTIME =
CMD_VAR = has_dipv4_icmp
BYWORD = <Dip : option>
HELP = ##HELP_ACE_DIP
! 108: <dipv4_icmp:ipv4_subnet>
RUNTIME =
CMD_VAR = dipv4_icmp
BYWORD = <DipAddr : ipv4_subnet>
HELP = ##HELP_ACE_DIP_VALUE
! 109: any
RUNTIME =
CMD_VAR = has_any_dipv4_icmp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DIP
! 110: icmp-type
RUNTIME =
CMD_VAR = has_icmpv4_type
BYWORD = <IcmpType : option>
HELP = ##HELP_ACE_ICMP_TYPE
! 111: <icmpv4_type:0-255>
RUNTIME =
CMD_VAR = icmpv4_type
BYWORD = <Icmpv4Type : 0-255>
HELP = ##HELP_ACE_ICMP_TYPE_VALUE
! 112: any
RUNTIME =
CMD_VAR = has_any_icmpv4_type
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ICMP_TYPE
! 113: icmp-code
RUNTIME =
CMD_VAR = has_icmpv4_code
BYWORD = <IcmpCode : option>
HELP = ##HELP_ACE_ICMP_CODE
! 114: <icmpv4_code:0-255>
RUNTIME =
CMD_VAR = icmpv4_code
BYWORD = <Icmpv4Code : 0-255>
HELP = ##HELP_ACE_ICMP_CODE_VALUE
! 115: any
RUNTIME =
CMD_VAR = has_any_icmpv4_code
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ICMP_CODE
! 116: ip-flag
RUNTIME =
CMD_VAR = has_ip_flag_icmp
BYWORD = <IpFlag : option>
HELP = ##HELP_ACE_IP_FLAG
! 117: ip-ttl
RUNTIME =
CMD_VAR = has_ip_flag_icmp_ttl
BYWORD = <IpTtl : option>
HELP = ##HELP_ACE_IP_FLAG_TTL
! 118: <ip_flag_icmp_ttl:0-1>
RUNTIME =
CMD_VAR = ip_flag_icmp_ttl
BYWORD = <IpFlagTtl : 0-1>
HELP = ##HELP_ACE_IP_FLAG_TTL_VALUE
! 119: any
RUNTIME =
CMD_VAR = has_any_ip_flag_icmp_ttl
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_TTL
! 120: ip-options
RUNTIME =
CMD_VAR = has_ip_flag_icmp_options
BYWORD = <IpOptions : option>
HELP = ##HELP_ACE_IP_FLAG_OPT
! 121: <ip_flag_icmp_options:0-1>
RUNTIME =
CMD_VAR = ip_flag_icmp_options
BYWORD = <IpFlagOptions : 0-1>
HELP = ##HELP_ACE_IP_FLAG_OPT_VALUE
! 122: any
RUNTIME =
CMD_VAR = has_any_ip_flag_icmp_options
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_OPT
! 123: ip-fragment
RUNTIME =
CMD_VAR = has_ip_flag_icmp_fragment
BYWORD = <IpFragment : option>
HELP = ##HELP_ACE_IP_FLAG_FRAG
! 124: <ip_flag_icmp_fragment:0-1>
RUNTIME =
CMD_VAR = ip_flag_icmp_fragment
BYWORD = <IpFlagFragment : 0-1>
HELP = ##HELP_ACE_IP_FLAG_FRAG_VALUE
! 125: any
RUNTIME =
CMD_VAR = has_any_ip_flag_icmp_fragment
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_FRAG
! 126: ipv4-udp
RUNTIME =
CMD_VAR = has_frametype_udp
BYWORD = <Udp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV4_UDP
! 127: sip
RUNTIME =
CMD_VAR = has_sipv4_udp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 128: <sipv4_udp:ipv4_subnet>
RUNTIME =
CMD_VAR = sipv4_udp
BYWORD = <SipAddr : ipv4_subnet>
HELP = ##HELP_ACE_SIP_VALUE
! 129: any
RUNTIME =
CMD_VAR = has_any_sipv4_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 130: dip
RUNTIME =
CMD_VAR = has_dipv4_udp
BYWORD = <Dip : option>
HELP = ##HELP_ACE_DIP
! 131: <dipv4_udp:ipv4_subnet>
RUNTIME =
CMD_VAR = dipv4_udp
BYWORD = <DipAddr : ipv4_subnet>
HELP = ##HELP_ACE_DIP_VALUE
! 132: any
RUNTIME =
CMD_VAR = has_any_dipv4_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DIP
! 133: sport
RUNTIME =
CMD_VAR = has_sportv4_udp
BYWORD = <Sport : option>
HELP = ##HELP_ACE_UDP_SPORT
! 134: <sportv4_udp_start:0-65535>
RUNTIME =
CMD_VAR = sportv4_udp_start
BYWORD = <SportStart : 0-65535>
HELP = ##HELP_ACE_UDP_SPORT_VALUE
! 135: to
RUNTIME =
CMD_VAR = has_sportv4_udp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 136: <sportv4_udp_end:0-65535>
RUNTIME =
CMD_VAR = sportv4_udp_end
BYWORD = <SportEnd : 0-65535>
HELP = ##HELP_ACE_UDP_SPORT_VALUE
! 137: any
RUNTIME =
CMD_VAR = has_any_sportv4_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_UDP_SPORT
! 138: dport
RUNTIME =
CMD_VAR = has_dportv4_udp
BYWORD = <Dport : option>
HELP = ##HELP_ACE_UDP_DPORT
! 139: <dportv4_udp_start:0-65535>
RUNTIME =
CMD_VAR = dportv4_udp_start
BYWORD = <DportStart : 0-65535>
HELP = ##HELP_ACE_UDP_DPORT_VALUE
! 140: to
RUNTIME =
CMD_VAR = has_dportv4_udp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 141: <dportv4_udp_end:0-65535>
RUNTIME =
CMD_VAR = dportv4_udp_end
BYWORD = <DportEnd : 0-65535>
HELP = ##HELP_ACE_UDP_DPORT_VALUE
! 142: any
RUNTIME =
CMD_VAR = has_any_dportv4_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_UDP_DPORT
! 143: ip-flag
RUNTIME =
CMD_VAR = has_ip_flag_udp
BYWORD = <IpFlag : option>
HELP = ##HELP_ACE_IP_FLAG
! 144: ip-ttl
RUNTIME =
CMD_VAR = has_ip_flag_udp_ttl
BYWORD = <IpTtl : option>
HELP = ##HELP_ACE_IP_FLAG_TTL
! 145: <ip_flag_udp_ttl:0-1>
RUNTIME =
CMD_VAR = ip_flag_udp_ttl
BYWORD = <IpFlagTtl : 0-1>
HELP = ##HELP_ACE_IP_FLAG_TTL_VALUE
! 146: any
RUNTIME =
CMD_VAR = has_any_ip_flag_udp_ttl
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_TTL
! 147: ip-options
RUNTIME =
CMD_VAR = has_ip_flag_udp_options
BYWORD = <IpOptions : option>
HELP = ##HELP_ACE_IP_FLAG_OPT
! 148: <ip_flag_udp_options:0-1>
RUNTIME =
CMD_VAR = ip_flag_udp_options
BYWORD = <IpFlagOptions : 0-1>
HELP = ##HELP_ACE_IP_FLAG_OPT_VALUE
! 149: any
RUNTIME =
CMD_VAR = has_any_ip_flag_udp_options
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_OPT
! 150: ip-fragment
RUNTIME =
CMD_VAR = has_ip_flag_udp_fragment
BYWORD = <IpFragment : option>
HELP = ##HELP_ACE_IP_FLAG_FRAG
! 151: <ip_flag_udp_fragment:0-1>
RUNTIME =
CMD_VAR = ip_flag_udp_fragment
BYWORD = <IpFlagFragment : 0-1>
HELP = ##HELP_ACE_IP_FLAG_FRAG_VALUE
! 152: any
RUNTIME =
CMD_VAR = has_any_ip_flag_udp_fragment
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_FRAG
! 153: ipv4-tcp
RUNTIME =
CMD_VAR = has_frametype_tcp
BYWORD = <Tcp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV4_TCP
! 154: sip
RUNTIME =
CMD_VAR = has_sipv4_tcp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 155: <sipv4_tcp:ipv4_subnet>
RUNTIME =
CMD_VAR = sipv4_tcp
BYWORD = <SipAddr : ipv4_subnet>
HELP = ##HELP_ACE_SIP_VALUE
! 156: any
RUNTIME =
CMD_VAR = has_any_sipv4_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 157: dip
RUNTIME =
CMD_VAR = has_dipv4_tcp
BYWORD = <Dip : option>
HELP = ##HELP_ACE_DIP
! 158: <dipv4_tcp:ipv4_subnet>
RUNTIME =
CMD_VAR = dipv4_tcp
BYWORD = <DipAddr : ipv4_subnet>
HELP = ##HELP_ACE_DIP_VALUE
! 159: any
RUNTIME =
CMD_VAR = has_any_dipv4_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_DIP
! 160: sport
RUNTIME =
CMD_VAR = has_sportv4_tcp
BYWORD = <Sport : option>
HELP = ##HELP_ACE_TCP_SPORT
! 161: <sportv4_tcp_start:0-65535>
RUNTIME =
CMD_VAR = sportv4_tcp_start
BYWORD = <SportStart : 0-65535>
HELP = ##HELP_ACE_TCP_SPORT_VALUE
! 162: to
RUNTIME =
CMD_VAR = has_sportv4_tcp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 163: <sportv4_tcp_end:0-65535>
RUNTIME =
CMD_VAR = sportv4_tcp_end
BYWORD = <SportEnd : 0-65535>
HELP = ##HELP_ACE_TCP_SPORT_VALUE
! 164: any
RUNTIME =
CMD_VAR = has_any_sportv4_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_SPORT
! 165: dport
RUNTIME =
CMD_VAR = has_dportv4_tcp
BYWORD = <Dport : option>
HELP = ##HELP_ACE_TCP_DPORT
! 166: <dportv4_tcp_start:0-65535>
RUNTIME =
CMD_VAR = dportv4_tcp_start
BYWORD = <DportStart : 0-65535>
HELP = ##HELP_ACE_TCP_DPORT_VALUE
! 167: to
RUNTIME =
CMD_VAR = has_dportv4_tcp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 168: <dportv4_tcp_end:0-65535>
RUNTIME =
CMD_VAR = dportv4_tcp_end
BYWORD = <DportEnd : 0-65535>
HELP = ##HELP_ACE_TCP_DPORT_VALUE
! 169: any
RUNTIME =
CMD_VAR = has_any_dportv4_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_DPORT
! 170: ip-flag
RUNTIME =
CMD_VAR = has_ip_flag_tcp
BYWORD = <IpFlag : option>
HELP = ##HELP_ACE_IP_FLAG
! 171: ip-ttl
RUNTIME =
CMD_VAR = has_ip_flag_tcp_ttl
BYWORD = <IpTtl : option>
HELP = ##HELP_ACE_IP_FLAG_TTL
! 172: <ip_flag_tcp_ttl:0-1>
RUNTIME =
CMD_VAR = ip_flag_tcp_ttl
BYWORD = <IpFlagTtl : 0-1>
HELP = ##HELP_ACE_IP_FLAG_TTL_VALUE
! 173: any
RUNTIME =
CMD_VAR = has_any_ip_flag_tcp_ttl
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_TTL
! 174: ip-options
RUNTIME =
CMD_VAR = has_ip_flag_tcp_options
BYWORD = <IpOptions : option>
HELP = ##HELP_ACE_IP_FLAG_OPT
! 175: <ip_flag_tcp_options:0-1>
RUNTIME =
CMD_VAR = ip_flag_tcp_options
BYWORD = <IpFlagOptions : 0-1>
HELP = ##HELP_ACE_IP_FLAG_OPT_VALUE
! 176: any
RUNTIME =
CMD_VAR = has_any_ip_flag_tcp_options
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_OPT
! 177: ip-fragment
RUNTIME =
CMD_VAR = has_ip_flag_tcp_fragment
BYWORD = <IpFragment : option>
HELP = ##HELP_ACE_IP_FLAG_FRAG
! 178: <ip_flag_tcp_fragment:0-1>
RUNTIME =
CMD_VAR = ip_flag_tcp_fragment
BYWORD = <IpFlagFragment : 0-1>
HELP = ##HELP_ACE_IP_FLAG_FRAG_VALUE
! 179: any
RUNTIME =
CMD_VAR = has_any_ip_flag_tcp_fragment
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IP_FLAG_FRAG
! 180: tcp-flag
RUNTIME =
CMD_VAR = has_tcpv4_flag
BYWORD = <TcpFlag : option>
HELP = ##HELP_ACE_TCP_FLAG
! 181: tcp-fin
RUNTIME =
CMD_VAR = has_tcpv4_flag_fin
BYWORD = <TcpFin : option>
HELP = ##HELP_ACE_TCP_FLAG_FIN
! 182: <tcpv4_flag_fin:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_fin
BYWORD = <TcpFlagFin : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_FIN_VALUE
! 183: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_fin
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_FIN
! 184: tcp-syn
RUNTIME =
CMD_VAR = has_tcpv4_flag_syn
BYWORD = <TcpSyn : option>
HELP = ##HELP_ACE_TCP_FLAG_SYN
! 185: <tcpv4_flag_syn:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_syn
BYWORD = <TcpFlagSyn : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_SYN_VALUE
! 186: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_syn
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_SYN
! 187: tcp-rst
RUNTIME =
CMD_VAR = has_tcpv4_flag_rst
BYWORD = <TcpRst : option>
HELP = ##HELP_ACE_TCP_FLAG_RST
! 188: <tcpv4_flag_rst:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_rst
BYWORD = <TcpFlagRst : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_RST_VALUE
! 189: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_rst
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_RST
! 190: tcp-psh
RUNTIME =
CMD_VAR = has_tcpv4_flag_psh
BYWORD = <TcpPsh : option>
HELP = ##HELP_ACE_TCP_FLAG_PSH
! 191: <tcpv4_flag_psh:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_psh
BYWORD = <TcpFlagPsh : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_PSH_VALUE
! 192: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_psh
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_PSH
! 193: tcp-ack
RUNTIME =
CMD_VAR = has_tcpv4_flag_ack
BYWORD = <TcpAck : option>
HELP = ##HELP_ACE_TCP_FLAG_ACK
! 194: <tcpv4_flag_ack:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_ack
BYWORD = <TcpFlagAck : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_ACK_VALUE
! 195: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_ack
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_ACK
! 196: tcp-urg
RUNTIME =
CMD_VAR = has_tcpv4_flag_urg
BYWORD = <TcpUrg : option>
HELP = ##HELP_ACE_TCP_FLAG_URG
! 197: <tcpv4_flag_urg:0-1>
RUNTIME =
CMD_VAR = tcpv4_flag_urg
BYWORD = <TcpFlagUrg : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_URG_VALUE
! 198: any
RUNTIME =
CMD_VAR = has_any_tcpv4_flag_urg
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_URG
! 199: ipv6
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_frametype_ipv6
BYWORD = <Ipv6 : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV6
! 200: next-header
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_next_header
BYWORD = <NextHeader : option>
HELP = ##HELP_ACE_ANY_HOP_LIMITER
! 201: <next_header:0-5,7-16,18-57,59-255>
RUNTIME = 
CMD_VAR = next_header
BYWORD = <NextHeader : 0-5,7-16,18-57,59-255>
HELP = ##HELP_ACE_ANY_HOP_LIMITER_VALUE
! 202: any
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_any_next_header
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IPV6_NEXT_HEADER
! 203: sip
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_sipv6
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 204: <sipv6:ipv6_addr>
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = sipv6
BYWORD = <Sipv6Addr : ipv6_addr>
HELP = ##HELP_ACE_SIP_VALUE
! 205: sip-bitmask
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_sipv6_bitmask
BYWORD = <SipBitmask : option>
HELP = ##HELP_ACE_SIPV6_BITMASK
! 206: <sipv6_mask:uint>
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = sipv6_bitmask
BYWORD = <Sipv6BitMask : 0x0-0xFFFFFFFF>
HELP = ##HELP_ACE_SIPV6_BITMASK_VALUE
! 207: any
RUNTIME = ACL_ICLI_runtime_has_ipv6
CMD_VAR = has_any_sipv6
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 208: hop-limit
RUNTIME = 
CMD_VAR = has_hop_limit
BYWORD = <HopLimit : option>
HELP = ##HELP_ACE_ANY_HOP_LIMITER
! 209: <hop_limit:0-1>
RUNTIME = 
CMD_VAR = hop_limit
BYWORD = <Ipv6FlagHopLimit : 0-1>
HELP = ##HELP_ACE_ANY_HOP_LIMITER_VALUE
! 210: any
RUNTIME = 
CMD_VAR = has_any_hop_limit
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IPV6_HOP_LIMITER
! 211: ipv6-icmp
RUNTIME = 
CMD_VAR = has_frametype_ipv6_icmp
BYWORD = <Ipv6Icmp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV6_ICMP
! 212: sip
RUNTIME = 
CMD_VAR = has_sipv6_icmp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 213: <sipv6_icmp:ipv6_addr>
RUNTIME = 
CMD_VAR = sipv6_icmp
BYWORD = <Sipv6Addr : ipv6_addr>
HELP = ##HELP_ACE_SIP_VALUE
! 214: sip-bitmask
RUNTIME = 
CMD_VAR = has_sipv6_bitmask_icmp
BYWORD = <SipBitmask : option>
HELP = ##HELP_ACE_SIPV6_BITMASK
! 215: <sipv6_bitmask_icmp:uint>
RUNTIME = 
CMD_VAR = sipv6_bitmask_icmp
BYWORD = <Sipv6BitMask : 0x0-0xFFFFFFFF>
HELP = ##HELP_ACE_SIPV6_BITMASK_VALUE
! 216: any
RUNTIME = 
CMD_VAR = has_any_sipv6_icmp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 217: icmp-type
RUNTIME = 
CMD_VAR = has_icmpv6_type
BYWORD = <IcmpType : option>
HELP = ##HELP_ACE_ICMP_TYPE
! 218: <icmpv6_type:0-255>
RUNTIME = 
CMD_VAR = icmpv6_type
BYWORD = <Icmpv6Type : 0-255>
HELP = ##HELP_ACE_ICMP_TYPE_VALUE
! 219: any
RUNTIME = 
CMD_VAR = has_any_icmpv6_type
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ICMP_TYPE
! 220: icmp-code
RUNTIME = 
CMD_VAR = has_icmpv6_code
BYWORD = <IcmpCode : option>
HELP = ##HELP_ACE_ICMP_CODE
! 221: <icmpv6_code:0-255>
RUNTIME = 
CMD_VAR = icmpv6_code
BYWORD = <Icmpv6Code : 0-255>
HELP = ##HELP_ACE_ICMP_CODE_VALUE
! 222: any
RUNTIME = 
CMD_VAR = has_any_icmpv6_code
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_ICMP_CODE
! 223: hop-limit
RUNTIME = 
CMD_VAR = has_hop_limit_icmp
BYWORD = <HopLimit : option>
HELP = ##HELP_ACE_ANY_HOP_LIMITER
! 224: <hop_limit_icmp:0-1>
RUNTIME = 
CMD_VAR = hop_limit_icmp
BYWORD = <Ipv6FlagHopLimit : 0-1>
HELP = ##HELP_ACE_ANY_HOP_LIMITER_VALUE
! 225: any
RUNTIME = 
CMD_VAR = has_any_hop_limit_icmp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IPV6_HOP_LIMITER
! 226: ipv6-udp
RUNTIME = 
CMD_VAR = has_frametype_ipv6_udp
BYWORD = <Ipv6Udp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV6_UDP
! 227: sip
RUNTIME = 
CMD_VAR = has_sipv6_udp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 228: <sipv6_udp:ipv6_addr>
RUNTIME = 
CMD_VAR = sipv6_udp
BYWORD = <Sipv6Addr : ipv6_addr>
HELP = ##HELP_ACE_SIP_VALUE
! 229: sip-bitmask
RUNTIME = 
CMD_VAR = has_sipv6_bitmask_udp
BYWORD = <SipBitmask : option>
HELP = ##HELP_ACE_SIPV6_BITMASK
! 230: <sipv6_bitmask_udp:uint>
RUNTIME = 
CMD_VAR = sipv6_bitmask_udp
BYWORD = <Sipv6BitMask : 0x0-0xFFFFFFFF>
HELP = ##HELP_ACE_SIPV6_BITMASK_VALUE
! 231: any
RUNTIME = 
CMD_VAR = has_any_sipv6_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 232: sport
RUNTIME = 
CMD_VAR = has_sportv6_udp
BYWORD = <Sport : option>
HELP = ##HELP_ACE_UDP_SPORT
! 233: <sportv6_udp_start:0-65535>
RUNTIME = 
CMD_VAR = sportv6_udp_start
BYWORD = <SportStart : 0-65535>
HELP = ##HELP_ACE_UDP_SPORT_VALUE
! 234: to
RUNTIME = 
CMD_VAR = has_sportv6_udp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 235: <sportv6_udp_end:0-65535>
RUNTIME = 
CMD_VAR = sportv6_udp_end
BYWORD = <SportEnd : 0-65535>
HELP = ##HELP_ACE_UDP_SPORT_VALUE
! 236: any
RUNTIME = 
CMD_VAR = has_any_sportv6_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_UDP_SPORT
! 237: dport
RUNTIME = 
CMD_VAR = has_dportv6_udp
BYWORD = <Dport : option>
HELP = ##HELP_ACE_UDP_DPORT
! 238: <dportv6_udp_start:0-65535>
RUNTIME = 
CMD_VAR = dportv6_udp_start
BYWORD = <DportStart : 0-65535>
HELP = ##HELP_ACE_UDP_DPORT_VALUE
! 239: to
RUNTIME = 
CMD_VAR = has_dportv6_udp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 240: <dportv6_udp_end:0-65535>
RUNTIME = 
CMD_VAR = dportv6_udp_end
BYWORD = <DportEnd : 0-65535>
HELP = ##HELP_ACE_UDP_DPORT_VALUE
! 241: any
RUNTIME = 
CMD_VAR = has_any_dportv6_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_UDP_DPORT
! 242: hop-limit
RUNTIME = 
CMD_VAR = has_hop_limit_udp
BYWORD = <HopLimit : option>
HELP = ##HELP_ACE_ANY_HOP_LIMITER
! 243: <hop_limit_udp:0-1>
RUNTIME = 
CMD_VAR = hop_limit_udp
BYWORD = <Ipv6FlagHopLimit : 0-1>
HELP = ##HELP_ACE_ANY_HOP_LIMITER_VALUE
! 244: any
RUNTIME = 
CMD_VAR = has_any_hop_limit_udp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IPV6_HOP_LIMITER
! 245: ipv6-tcp
RUNTIME = 
CMD_VAR = has_frametype_ipv6_tcp
BYWORD = <Ipv6Tcp : option>
HELP = ##HELP_ACE_FRAMETYPE_IPV6_TCP
! 246: sip
RUNTIME = 
CMD_VAR = has_sipv6_tcp
BYWORD = <Sip : option>
HELP = ##HELP_ACE_SIP
! 247: <sipv6_tcp:ipv6_addr>
RUNTIME = 
CMD_VAR = sipv6_tcp
BYWORD = <Sipv6Addr : ipv6_addr>
HELP = ##HELP_ACE_SIP_VALUE
! 248: sip-bitmask
RUNTIME = 
CMD_VAR = has_sipv6_bitmask_tcp
BYWORD = <SipBitmask : option>
HELP = ##HELP_ACE_SIPV6_BITMASK
! 249: <sipv6_bitmask_tcp:uint>
RUNTIME = 
CMD_VAR = sipv6_bitmask_tcp
BYWORD = <Sipv6BitMask : 0x0-0xFFFFFFFF>
HELP = ##HELP_ACE_SIPV6_BITMASK_VALUE
! 250: any
RUNTIME = 
CMD_VAR = has_any_sipv6_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_SIP
! 251: sport
RUNTIME = 
CMD_VAR = has_sportv6_tcp
BYWORD = <Sport : option>
HELP = ##HELP_ACE_TCP_SPORT
! 252: <sportv6_tcp_start:0-65535>
RUNTIME = 
CMD_VAR = sportv6_tcp_start
BYWORD = <SportStart : 0-65535>
HELP = ##HELP_ACE_TCP_SPORT_VALUE
! 253: to
RUNTIME = 
CMD_VAR = has_sportv6_tcp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 254: <sportv6_tcp_end:0-65535>
RUNTIME = 
CMD_VAR = sportv6_tcp_end
BYWORD = <SportEnd : 0-65535>
HELP = ##HELP_ACE_TCP_SPORT_VALUE
! 255: any
RUNTIME = 
CMD_VAR = has_any_sportv6_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_SPORT
! 256: dport
RUNTIME = 
CMD_VAR = has_dportv6_tcp
BYWORD = <Dport : option>
HELP = ##HELP_ACE_TCP_DPORT
! 257: <dportv6_tcp_start:0-65535>
RUNTIME = 
CMD_VAR = dportv6_tcp_start
BYWORD = <DportStart : 0-65535>
HELP = ##HELP_ACE_TCP_DPORT_VALUE
! 258: to
RUNTIME = 
CMD_VAR = has_dportv6_tcp_end
BYWORD = <To : option>
HELP = ##HELP_ACE_RANGE_TO
! 259: <dportv6_tcp_end:0-65535>
RUNTIME = 
CMD_VAR = dportv6_tcp_end
BYWORD = <DportEnd : 0-65535>
HELP = ##HELP_ACE_TCP_DPORT_VALUE
! 260: any
RUNTIME = 
CMD_VAR = has_any_dportv6_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_DPORT
! 261: hop-limit
RUNTIME = 
CMD_VAR = has_hop_limit_tcp
BYWORD = <HopLimit : option>
HELP = ##HELP_ACE_ANY_HOP_LIMITER
! 262: <hop_limit_tcp:0-1>
RUNTIME = 
CMD_VAR = hop_limit_tcp
BYWORD = <Ipv6FlagHopLimit : 0-1>
HELP = ##HELP_ACE_ANY_HOP_LIMITER_VALUE
! 263: any
RUNTIME = 
CMD_VAR = has_any_hop_limit_tcp
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_IPV6_HOP_LIMITER
! 264: tcp-flag
RUNTIME = 
CMD_VAR = has_tcpv6_flag
BYWORD = <TcpFlag : option>
HELP = ##HELP_ACE_TCP_FLAG
! 265: tcp-fin
RUNTIME = 
CMD_VAR = has_tcpv6_flag_fin
BYWORD = <TcpFin : option>
HELP = ##HELP_ACE_TCP_FLAG_FIN
! 266: <tcpv6_flag_fin:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_fin
BYWORD = <TcpFlagFin : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_FIN_VALUE
! 267: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_fin
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_FIN
! 268: tcp-syn
RUNTIME = 
CMD_VAR = has_tcpv6_flag_syn
BYWORD =
HELP = ##HELP_ACE_TCP_FLAG_SYN
! 269: <tcpv6_flag_syn:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_syn
BYWORD = <TcpFlagSyn : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_SYN_VALUE
! 270: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_syn
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_SYN
! 271: tcp-rst
RUNTIME = 
CMD_VAR = has_tcpv6_flag_rst
BYWORD = <TcpRst : option>
HELP = ##HELP_ACE_TCP_FLAG_RST
! 272: <tcpv6_flag_rst:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_rst
BYWORD = <TcpFlagRst : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_RST_VALUE
! 273: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_rst
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_RST
! 274: tcp-psh
RUNTIME = 
CMD_VAR = has_tcpv6_flag_psh
BYWORD = <TcpPsh : option>
HELP = ##HELP_ACE_TCP_FLAG_PSH
! 275: <tcpv6_flag_psh:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_psh
BYWORD = <TcpFlagPsh : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_PSH_VALUE
! 276: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_psh
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_PSH
! 277: tcp-ack
RUNTIME = 
CMD_VAR = has_tcpv6_flag_ack
BYWORD = <TcpAck : option>
HELP = ##HELP_ACE_TCP_FLAG_ACK
! 278: <tcpv6_flag_ack:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_ack
BYWORD = <TcpFlagAck : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_ACK_VALUE
! 279: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_ack
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_ACK
! 280: tcp-urg
RUNTIME = 
CMD_VAR = has_tcpv6_flag_urg
BYWORD = <TcpUrg : option>
HELP = ##HELP_ACE_TCP_FLAG_URG
! 281: <tcpv6_flag_urg:0-1>
RUNTIME = 
CMD_VAR = tcpv6_flag_urg
BYWORD = <TcpFlagUrg : 0-1>
HELP = ##HELP_ACE_TCP_FLAG_URG_VALUE
! 282: any
RUNTIME = 
CMD_VAR = has_any_tcpv6_flag_urg
BYWORD = <Any : option>
HELP = ##HELP_ACE_ANY_TCP_FLAG_URG
! 283: action
RUNTIME =
CMD_VAR = has_action
BYWORD = <Action : option>
HELP = ##HELP_ACL_ACTION
! 284: permit
RUNTIME =
CMD_VAR = has_permit
BYWORD = <Permit : option>
HELP = ##HELP_ACL_PERMIT
! 285: deny
RUNTIME =
CMD_VAR = has_deny
BYWORD = <Deny : option>
HELP = ##HELP_ACL_DENY
! 286: filter
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_filter
BYWORD = <Filter : option>
HELP = ##HELP_ACL_FILTER
! 287: switchport
RUNTIME = ACL_ICLI_runtime_has_stackable
CMD_VAR = has_filter_switchport
BYWORD = <Switchport : option>
HELP = ##HELP_ACL_SWITCHPORT
! 288: <filter_switch_port_list:1~53>
RUNTIME = ACL_ICLI_runtime_switch_port_list
CMD_VAR = filter_switch_port_list
BYWORD = <FilterSwitchPortList : 1~53>
HELP = ##HELP_ACE_SWITCHPORT_LIST
! 289: interface
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_filter_interface
BYWORD = <Interface : option>
HELP = ##ICLI_HELP_INTERFACE
! 290: <fliter_port_list:port_type_list>
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = fliter_port_list
BYWORD = <FliterPortList : port_type_list>
HELP = ##ICLI_HELP_PORT_TYPE_ID
! 291: rate-limiter
RUNTIME = 
CMD_VAR = has_rate_limiter
BYWORD = <RateLimiter : option>
HELP = ##HELP_ACL_RATE_LIMITER
! 292: <rate_limiter_id:1-16>
RUNTIME = ACL_ICLI_runtime_rate_limiter
CMD_VAR = rate_limiter_id
BYWORD = <RateLimiterId : 1-16>
HELP = ##HELP_ACL_RATE_LIMITER_ID
! 293: disable
RUNTIME =
CMD_VAR = has_disable_rate_limiter
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_RATE_LIMITER
! 294: evc-policer
RUNTIME = ACL_ICLI_runtime_has_evc
CMD_VAR = has_evc_policer
BYWORD = <EvcPolicer : option>
HELP = ##HELP_ACL_EVC_POLICER
! 295: <evc_policer_id : 1-256>
RUNTIME = ACL_ICLI_runtime_evc_policer_id
CMD_VAR = evc_policer_id
BYWORD = <EvcPolicerId : 1-256>
HELP = ##HELP_ACL_EVC_POLICER_ID
! 296: disable
RUNTIME = ACL_ICLI_runtime_has_evc
CMD_VAR = has_disable_evc_policer
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_EVC_POLICER
! 297: redirect
RUNTIME = ACL_ICLI_runtime_has_redirect
CMD_VAR = has_redirect
BYWORD = <Redirect : option>
HELP = ##HELP_ACL_REDIRECT
! 298: port-copy
RUNTIME = ACL_ICLI_runtime_has_port_copy
CMD_VAR = has_port_copy
BYWORD = <PortCopy : option>
HELP = ##HELP_ACL_PORT_COPY
! 299: switchport
RUNTIME = ACL_ICLI_runtime_has_stackable
CMD_VAR = has_redirect_switchport
BYWORD = <Switchport : option>
HELP = ##HELP_ACL_SWITCHPORT
! 300: <redirect_switch_port_id:1-53>
RUNTIME = ACL_ICLI_runtime_switch_port_id
CMD_VAR = redirect_switch_port_id
BYWORD = <RedirectSwitchPortId : 1-53>
HELP = ##HELP_ACE_SWITCHPORT_ID
! 301: <redirect_switch_port_list:1~53>
RUNTIME = ACL_ICLI_runtime_switch_port_list
CMD_VAR = redirect_switch_port_list
BYWORD = <RedirectSwitchPortList : 1~53>
HELP = ##HELP_ACE_SWITCHPORT_LIST
! 302: interface
RUNTIME =
CMD_VAR = has_redirect_interface
BYWORD = <Interface : option>
HELP = ##ICLI_HELP_INTERFACE
! 303: <redirect_port:port_type_id>
RUNTIME = ACL_ICLI_runtime_has_v1
CMD_VAR = redirect_port_id
BYWORD = <RedirectPort : port_type_id>
HELP = ##ICLI_HELP_PORT_TYPE_ID
! 304: <redirect_port_list:port_type_list>
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = redirect_port_list
BYWORD = <RedirectPortList : port_type_list>
HELP = ##ICLI_HELP_PORT_TYPE_LIST
! 305: disable
RUNTIME =
CMD_VAR = has_disable_redirect
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE
! 306: mirror
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_mirror
BYWORD = <Mirror : option>
HELP = ##HELP_ACL_MIRROR
! 307: disable
RUNTIME = ACL_ICLI_runtime_has_v2
CMD_VAR = has_disable_mirror
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_MIRROR
! 308: logging
RUNTIME =
CMD_VAR = has_logging
BYWORD = <Logging : option>
HELP = ##HELP_ACL_LOGGING
! 309: disable
RUNTIME =
CMD_VAR = has_disable_logging
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_LOGGING
! 310: shutdown
RUNTIME = 
CMD_VAR = has_shutdown
BYWORD = <Shutdown : option>
HELP = ##HELP_ACL_SHUTDOWN
! 311: disable
RUNTIME =
CMD_VAR = has_disable_shutdown
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_SHUTDOWN
! 312: lookup
RUNTIME = ACL_ICLI_runtime_has_serval
CMD_VAR = has_lookup
BYWORD = <Disable : option>
HELP = ##HELP_ACE_LOOKUP
! 313: disable
RUNTIME = ACL_ICLI_runtime_has_serval
CMD_VAR = has_disable_lookup
BYWORD = <Disable : option>
HELP = ##HELP_ACE_DISABLE_LOOKUP


VARIABLE_BEGIN
    vtss_rc             rc;
    vtss_ace_id_t       next_ace_id = ACE_ID_NONE;
    vtss_ace_type_t     ace_type = VTSS_ACE_TYPE_ANY;
    acl_entry_conf_t    conf;
    BOOL                is_frametype_detail = FALSE;
#if defined(VTSS_FEATURE_ACL_V2)
    vtss_port_no_t      port_idx;
    u32                 port_filter_list_cnt;
#endif /* VTSS_FEATURE_ACL_V2 */
VARIABLE_END

CODE_BEGIN
    //check if ACE existing
    rc = acl_mgmt_ace_get(ACL_USER_STATIC, VTSS_ISID_GLOBAL, ace_id, &conf, NULL, FALSE);
    if (has_update && rc != VTSS_OK) {
        ICLI_PRINTF("%% ACE ID %u isn't existing.\n", ace_id);
        return ICLI_RC_ERROR;
    }

    //next_ace_id
    if (has_next && !has_last) {
        next_ace_id = ace_id_next;
    }

    //frametype
    if (has_frametype) {
        if (has_frametype_etype) {
            ace_type = VTSS_ACE_TYPE_ETYPE;
        } else if (has_frametype_arp) {
             ace_type = VTSS_ACE_TYPE_ARP;
        } else if (has_frametype_ip || has_frametype_icmp || has_frametype_udp || has_frametype_tcp) {
            ace_type = VTSS_ACE_TYPE_IPV4;
        } else if (has_frametype_ipv6 || has_frametype_ipv6_icmp || has_frametype_ipv6_udp || has_frametype_ipv6_tcp) {
            ace_type = VTSS_ACE_TYPE_IPV6;
        }
    }

    if (!has_update && acl_mgmt_ace_init(ace_type, &conf) != VTSS_OK) {
        ICLI_PRINTF("%% Calling acl_mgmt_ace_init(%u, %u) failed.\n", ace_type, ace_id);
        return ICLI_RC_ERROR;
    } else if (has_update && has_frametype && (conf.type != ace_type)) {
        acl_entry_conf_t    default_conf;
        acl_flag_t          ace_flag_idx;

        // Clear frame configuration
        if (acl_mgmt_ace_init(ace_type, &default_conf) != VTSS_OK) {
            ICLI_PRINTF("%% Calling acl_mgmt_ace_init(%u, %u) failed.\n", ace_type, ace_id);
            return ICLI_RC_ERROR;
        }
        conf.type = ace_type;
        conf.frame = default_conf.frame;
        for (ace_flag_idx = ACE_FLAG_ARP_ARP; ace_flag_idx < ACE_FLAG_COUNT; ace_flag_idx++) {
            ACL_ICLI_ace_flag_set(&conf, ace_flag_idx, 0, TRUE);
        }
#if defined(VTSS_FEATURE_ACL_V2)
        /* The DMAC type parameter is not supported for VTSS_ACE_TYPE_ANY.
           This is a chip limitation. */
        if (conf.type == VTSS_ACE_TYPE_ANY) {
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_BC, 0, TRUE);
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_MC, 0, TRUE);
        }
#endif /* VTSS_FEATURE_ACL_V2 */
    }
    conf.id = ace_id;

    //frametype detail
    if (has_frametype) {
        switch (ace_type) {
        case VTSS_ACE_TYPE_ETYPE:
            //etype_value
            if (has_etype_value) {
                int i;

                is_frametype_detail = TRUE;
                for (i = 0; i < 2; i++) {
                    conf.frame.etype.etype.value[i] = has_any_etype_value ? 0 : ((etype_value >> (i == 0 ? 8 : 0)) & 0xFF);
                    conf.frame.etype.etype.mask[i] = has_any_etype_value ? 0x0 : 0xFF;
                }
            }

            //etype_smac
            if (has_etype_smac) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_mac_set(&conf.frame.etype.smac, etype_smac.addr, has_any_etype_smac);
            }

            //etype_dmac
            if (has_etype_dmac) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_mac_set(&conf.frame.etype.dmac, etype_dmac.addr, has_any_etype_dmac);
            }
            break;
        case VTSS_ACE_TYPE_ARP:
            //arp_sip
            if (has_arp_sip) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ip_set(&conf.frame.arp.sip, arp_sip, has_any_arp_sip);
            }

            //arp_dip
            if (has_arp_dip) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ip_set(&conf.frame.arp.dip, arp_dip, has_any_arp_dip);
            }

            //arp_smac
            if (has_arp_smac) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_mac_set(&conf.frame.arp.smac, arp_smac.addr, has_any_arp_smac);
            }

            //arp_opcode
            if (has_arp_opcode) {
                is_frametype_detail = TRUE;
                if (has_arp_opcode_arp) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_ARP, 1, FALSE);
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_UNKNOWN, 0, FALSE);
                }else if (has_arp_opcode_rarp) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_ARP, 0, FALSE);
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_UNKNOWN, 0, FALSE);
                } else if (has_arp_opcode_other) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_ARP, 0, TRUE);
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_UNKNOWN, 1, FALSE);
                } else if (has_any_arp_opcode) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_ARP, 0, TRUE);
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_UNKNOWN, 0, TRUE);
                }
            }

            //arp_flags
            if (has_arp_flag) {
                is_frametype_detail = TRUE;
                if (has_arp_flag_request) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_REQ, arp_flag_request, has_any_arp_flag_request);
                }
                if (has_arp_flag_smac) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_SMAC, arp_flag_smac, has_any_arp_flag_smac);
                }
                if (has_arp_flag_tmac) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_DMAC, arp_flag_tmac, has_any_arp_flag_tmac);
                }
                if (has_arp_flag_len) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_LEN, arp_flag_len, has_any_arp_flag_len);
                }
                if (has_arp_flag_ip) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_IP, arp_flag_ip, has_any_arp_flag_ip);
                }
                if (has_arp_flag_ether) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_ARP_ETHER, arp_flag_ether, has_any_arp_flag_ether);
                }
            }
            break;
        case VTSS_ACE_TYPE_IPV4:
            //sipv4
            if (has_sipv4 || has_sipv4_icmp || has_sipv4_udp || has_sipv4_tcp) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ip_set(&conf.frame.ipv4.sip,
                                    has_sipv4 ? sipv4 : has_sipv4_icmp ? sipv4_icmp : has_sipv4_udp ? sipv4_udp : sipv4_tcp,
                                    has_sipv4 ? has_any_sipv4 : has_sipv4_icmp ? has_any_sipv4_icmp : has_sipv4_udp ? has_any_sipv4_udp : has_any_sipv4_tcp);
            }

            //dipv4
            if (has_dipv4 || has_dipv4_icmp || has_dipv4_udp || has_dipv4_tcp) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ip_set(&conf.frame.ipv4.dip,
                                    has_dipv4 ? dipv4 : has_dipv4_icmp ? dipv4_icmp : has_dipv4_udp ? dipv4_udp : dipv4_tcp,
                                    has_dipv4 ? has_any_dipv4 : has_dipv4_icmp ? has_any_dipv4_icmp : has_dipv4_udp ? has_any_dipv4_udp : has_any_dipv4_tcp);
            }

            //ipv4_protocol
            if (has_ipv4_protocol) {
                is_frametype_detail = TRUE;
                conf.frame.ipv4.proto.value = has_any_ipv4_protocol ? 0 : ipv4_protocol;
                conf.frame.ipv4.proto.mask = has_any_ipv4_protocol ? 0x0 : 0XFF;
            }
            if (has_frametype_icmp || has_frametype_tcp || has_frametype_udp) {
                    is_frametype_detail = TRUE;
                    conf.frame.ipv4.proto.mask = 0XFF;
                if (has_frametype_icmp) {
                    conf.frame.ipv4.proto.value = 1;
                } else if (has_frametype_tcp) {
                    conf.frame.ipv4.proto.value = 6;
                } else if (has_frametype_udp) {
                    conf.frame.ipv4.proto.value = 17;
                }
            }

            //ipv4_flags
            if (has_ip_flag || has_ip_flag_icmp || has_ip_flag_udp || has_ip_flag_tcp) {
                is_frametype_detail = TRUE;
                //ipv4_flags for ip type
                if (has_ip_flag_ttl) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_TTL, ip_flag_ttl, has_any_ip_flag_ttl);
                }
                if (has_ip_flag_options) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_OPTIONS, ip_flag_options, has_any_ip_flag_options);
                }
                if (has_ip_flag_fragment) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_FRAGMENT, ip_flag_fragment, has_any_ip_flag_fragment);
                }

                //ipv4_flags for icmp type
                if (has_ip_flag_icmp_ttl) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_TTL, ip_flag_icmp_ttl, has_any_ip_flag_icmp_ttl);
                }
                if (has_ip_flag_icmp_options) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_OPTIONS, ip_flag_icmp_options, has_any_ip_flag_icmp_options);
                }
                if (has_ip_flag_icmp_fragment) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_FRAGMENT, ip_flag_icmp_fragment, has_any_ip_flag_icmp_fragment);
                }

                //ipv4_flags for udp type
                if (has_ip_flag_udp_ttl) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_TTL, ip_flag_udp_ttl, has_any_ip_flag_udp_ttl);
                }
                if (has_ip_flag_udp_options) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_OPTIONS, ip_flag_udp_options, has_any_ip_flag_udp_options);
                }
                if (has_ip_flag_udp_fragment) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_FRAGMENT, ip_flag_udp_fragment, has_any_ip_flag_udp_fragment);
                }

                //ipv4_flags for tcp type
                if (has_ip_flag_tcp_ttl) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_TTL, ip_flag_tcp_ttl, has_any_ip_flag_tcp_ttl);
                }
                if (has_ip_flag_tcp_options) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_OPTIONS, ip_flag_tcp_options, has_any_ip_flag_tcp_options);
                }
                if (has_ip_flag_tcp_fragment) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_IP_FRAGMENT, ip_flag_tcp_fragment, has_any_ip_flag_tcp_fragment);
                }
            }

            //icmpv4_type
            if (has_icmpv4_type) {
                is_frametype_detail = TRUE;
                conf.frame.ipv4.data.value[0] = has_any_icmpv4_type ? 0 : icmpv4_type;
                conf.frame.ipv4.data.mask[0] = has_any_icmpv4_type ? 0x0 : 0xFF;
            }

            //icmpv4_code
            if (has_icmpv4_code) {
                is_frametype_detail = TRUE;
                conf.frame.ipv4.data.value[1] = has_any_icmpv4_code ? 0 : icmpv4_code;
                conf.frame.ipv4.data.mask[1] = has_any_icmpv4_code ? 0x0 : 0xFF;
            }

            //sportv4/dportv4
            if (has_sportv4_udp || has_dportv4_udp || has_sportv4_tcp || has_dportv4_tcp) {
                is_frametype_detail = TRUE;
                if (has_sportv4_udp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv4.sport, sportv4_udp_start, has_sportv4_udp_end ? sportv4_udp_end : sportv4_udp_start, has_any_sportv4_udp);
                }
                if (has_dportv4_udp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv4.dport, dportv4_udp_start, has_dportv4_udp_end ? dportv4_udp_end : dportv4_udp_start, has_any_dportv4_udp);
                }
                if (has_sportv4_tcp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv4.sport, sportv4_tcp_start, has_sportv4_tcp_end ? sportv4_tcp_end : sportv4_tcp_start, has_any_sportv4_tcp);
                }
                if (has_dportv4_tcp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv4.dport, dportv4_tcp_start, has_dportv4_tcp_end ? dportv4_tcp_end  : dportv4_tcp_start, has_any_dportv4_tcp);
                }
            }

            //tcpv4_flags
            if (has_tcpv4_flag) {
                is_frametype_detail = TRUE;
                if (has_tcpv4_flag_fin) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_FIN, tcpv4_flag_fin, has_any_tcpv4_flag_fin);
                }
                if (has_tcpv4_flag_syn) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_SYN, tcpv4_flag_syn, has_any_tcpv4_flag_syn);
                }
                if (has_tcpv4_flag_rst) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_RST, tcpv4_flag_rst, has_any_tcpv4_flag_rst);
                }
                if (has_tcpv4_flag_psh) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_PSH, tcpv4_flag_psh, has_any_tcpv4_flag_psh);
                }
                if (has_tcpv4_flag_ack) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_ACK, tcpv4_flag_ack, has_any_tcpv4_flag_ack);
                }
                if (has_tcpv4_flag_urg) {
                    ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_TCP_URG, tcpv4_flag_urg, has_any_tcpv4_flag_urg);
                }
            }
            break;
        case VTSS_ACE_TYPE_IPV6:
            //next_header
            if (has_next_header) {
                is_frametype_detail = TRUE;
                conf.frame.ipv6.proto.value = has_any_next_header ? 0 : next_header;
                conf.frame.ipv6.proto.mask = has_any_next_header ? 0x0 : 0XFF;
            }
            if (has_frametype_ipv6_icmp || has_frametype_ipv6_tcp || has_frametype_ipv6_udp) {
                    is_frametype_detail = TRUE;
                    conf.frame.ipv6.proto.mask = 0XFF;
                if (has_frametype_ipv6_icmp) {
                    conf.frame.ipv6.proto.value = 58;
                } else if (has_frametype_ipv6_tcp) {
                    conf.frame.ipv6.proto.value = 6;
                } else if (has_frametype_ipv6_udp) {
                    conf.frame.ipv6.proto.value = 17;
                }
            }

            //sipv6/bitmask
            if (has_sipv6 || has_sipv6_icmp || has_sipv6_udp || has_sipv6_tcp) {
                vtss_ipv6_t in_sipv6_addr = has_sipv6 ? sipv6 : has_sipv6_icmp ? sipv6_icmp : has_sipv6_udp ? sipv6_udp : sipv6_tcp;
                u32         in_bitmask = 0xFFFFFFFF;
                
                if (has_sipv6_bitmask || has_sipv6_bitmask_icmp || has_sipv6_bitmask_udp || has_sipv6_bitmask_tcp) {
                    in_bitmask = has_sipv6_bitmask ? sipv6_bitmask : has_sipv6_bitmask_icmp ? sipv6_bitmask_icmp : has_sipv6_bitmask_udp ? sipv6_bitmask_udp : sipv6_bitmask_tcp;
                } else if (has_update) {
                    in_bitmask = (conf.frame.ipv6.sip.mask[12] << 24) |
                                 (conf.frame.ipv6.sip.mask[13] << 16) |
                                 (conf.frame.ipv6.sip.mask[14] <<  8) |
                                 conf.frame.ipv6.sip.mask[15];
                    if (!in_bitmask) {
                        in_bitmask = 0xFFFFFFFF;
                    }
                }

                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ipv6_set(&conf.frame.ipv6.sip,
                                      in_sipv6_addr,
                                      in_bitmask,
                                      has_any_sipv6 | has_any_sipv6_icmp | has_any_sipv6_udp | has_any_sipv6_tcp);
            }

            //hop_limit
            if (has_hop_limit) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.ttl, hop_limit, has_any_hop_limit);
            }
            if (has_hop_limit_icmp) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.ttl, hop_limit_icmp, has_any_hop_limit_icmp);
            }
            if (has_hop_limit_udp) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.ttl, hop_limit_udp, has_any_hop_limit_udp);
            }
            if (has_hop_limit_tcp) {
                is_frametype_detail = TRUE;
                ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.ttl, hop_limit_tcp, has_any_hop_limit_tcp);
            }

            //icmpv6_type
            if (has_icmpv6_type) {
                is_frametype_detail = TRUE;
                conf.frame.ipv6.data.value[0] = has_any_icmpv6_type ? 0 : icmpv6_type;
                conf.frame.ipv6.data.mask[0] = has_any_icmpv6_type ? 0x0 : 0xFF;
            }

            //icmpv6_code
            if (has_icmpv6_code) {
                is_frametype_detail = TRUE;
                conf.frame.ipv6.data.value[1] = has_any_icmpv6_code ? 0 : icmpv6_code;
                conf.frame.ipv6.data.mask[1] = has_any_icmpv6_code ? 0x0 : 0xFF;
            }

            //sportv6/dportv6
            if (has_sportv6_udp || has_dportv6_udp || has_sportv6_tcp || has_dportv6_tcp) {
                is_frametype_detail = TRUE;
                if (has_sportv6_udp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv6.sport, sportv6_udp_start, has_sportv6_udp_end ? sportv6_udp_end : sportv6_udp_start, has_any_sportv6_udp);
                }
                if (has_dportv6_udp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv6.dport, dportv6_udp_start, has_dportv6_udp_end ? dportv6_udp_end : dportv6_udp_start, has_any_dportv6_udp);
                }
                if (has_sportv6_tcp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv6.sport, sportv6_tcp_start, has_sportv6_tcp_end ? sportv6_tcp_end : sportv6_tcp_start, has_any_sportv6_tcp);
                }
                if (has_dportv6_tcp) {
                    ACL_ICLI_ace_udp_tcp_port_set(&conf.frame.ipv6.dport, dportv6_tcp_start, has_dportv6_tcp_end ? dportv6_tcp_end  : dportv6_tcp_start, has_any_dportv6_tcp);
                }
            }

            //tcpv6_flags
            if (has_tcpv6_flag) {
                is_frametype_detail = TRUE;
                if (has_tcpv6_flag_fin) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_fin, tcpv6_flag_fin, has_any_tcpv6_flag_fin);
                }
                if (has_tcpv6_flag_syn) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_syn, tcpv6_flag_syn, has_any_tcpv6_flag_syn);
                }
                if (has_tcpv6_flag_rst) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_rst, tcpv6_flag_rst, has_any_tcpv6_flag_rst);
                }
                if (has_tcpv6_flag_psh) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_psh, tcpv6_flag_psh, has_any_tcpv6_flag_psh);
                }
                if (has_tcpv6_flag_ack) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_ack, tcpv6_flag_ack, has_any_tcpv6_flag_ack);
                }
                if (has_tcpv6_flag_urg) {
                    ACL_ICLI_ace_ipv6_flag_set(&conf.frame.ipv6.tcp_urg, tcpv6_flag_urg, has_any_tcpv6_flag_urg);
                }
            }
            break;
        case VTSS_ACE_TYPE_ANY:
            if (has_any_frametype) {
                is_frametype_detail = TRUE;
            }
            break;
        default:
            break;
        }

        //no frametype detail configuration, restore it.
        if (is_frametype_detail == FALSE) {
            acl_entry_conf_t ace_temp;
            if (acl_mgmt_ace_init(ace_type, &ace_temp) != VTSS_OK) {
                ICLI_PRINTF("%% Calling acl_mgmt_ace_init(%u, %u) failed.\n", ace_type, ace_id);
                return ICLI_RC_ERROR;
            }
            conf.frame = ace_temp.frame;
        }
    }

    //ingress_port
    if (has_ingress) {
#if defined(VTSS_FEATURE_ACL_V2)
        if (has_any_ingress) {
            conf.isid = VTSS_ISID_GLOBAL;
            for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
                conf.port_list[port_idx] = TRUE;
            }
        } else if (has_ingress_switch) {
            conf.isid = topo_usid2isid(ingress_switch_id);
            for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
                conf.port_list[port_idx] = TRUE;
            }
        } else if (has_ingress_switchport) {
            conf.isid = VTSS_ISID_GLOBAL;
            if (icli_rangelist2iportlist(ingress_switch_port_list, conf.port_list, VTSS_PORT_ARRAY_SIZE)) {
                ICLI_PRINTF("%% Out of switchport range.\n");
                return ICLI_RC_ERROR;
            }
        } else {
            if (!ingress_port_list) {
                ICLI_PRINTF("%% Internal error: Null point of interface port type list.\n");
                return ICLI_RC_ERROR;
            }

            conf.isid = topo_usid2isid(ingress_port_list->switch_range[0].usid);
            if (icli_porttypelist2iportlist(topo_isid2usid(conf.isid), ingress_port_list, conf.port_list, VTSS_PORT_ARRAY_SIZE)) {
                ICLI_PRINTF("%% Cannot be configured on different switch ID.\n");
                return ICLI_RC_ERROR;
            }
        }
#else
        if (has_any_ingress) {
            conf.isid = VTSS_ISID_GLOBAL;
            conf.port_no = VTSS_PORT_NO_NONE;
        } else if (has_ingress_switch) {
            conf.isid = topo_usid2isid(ingress_switch_id);
            conf.port_no = VTSS_PORT_NO_NONE;
        } else if (has_ingress_switchport) {
            conf.isid = VTSS_ISID_GLOBAL;
            conf.port_no = uport2iport(ingress_switch_port_id);
        } else {
            if (port_isid_port_no_is_stack(topo_usid2isid(ingress_port_id.usid), uport2iport(ingress_port_id.begin_uport))) {
                ICLI_PRINTF("%% Cannot be configured on stacking interface.\n");
                return ICLI_RC_ERROR;
            }
            conf.isid = topo_usid2isid(ingress_port_id.usid);
            conf.port_no = uport2iport(ingress_port_id.begin_uport);
        }
#endif /* VTSS_FEATURE_ACL_V2 */
    }

    //policy
    if (has_policy) {
        conf.policy.value = policy;
        if (has_policy_bitmask) {
            conf.policy.mask = policy_bitmask;
        } else if (!has_update || !conf.policy.mask) {
            /* For adding new ace entry and isn't assigned policy mask, the default value 0xff is given. */
            conf.policy.mask = ACL_POLICIES_BITMASK;
        }
    }

    //tag
#if defined(VTSS_FEATURE_ACL_V2)
    if (has_tag) {
        if (has_any_tag) {
            conf.tagged = VTSS_ACE_BIT_ANY;
        } else if (has_untagged) {
            conf.tagged = VTSS_ACE_BIT_0;
        } else if (has_tagged) {
             conf.tagged = VTSS_ACE_BIT_1;
        }
    }
#endif

    //vid
    if (has_vid) {
        if (has_any_vid) {
            conf.vid.value = 0;
            conf.vid.mask = 0x0;
        } else {
            conf.vid.value = vid;
            conf.vid.mask = 0XFFF;
        }
    }

    //tag_priorty
    if (has_tag_priority) {
        if (has_any_tag_priority) {
            conf.usr_prio.value = 0;
            conf.usr_prio.mask = 0x0;
        } else if (tag_priority_01) {
            conf.usr_prio.value = 1;
            conf.usr_prio.mask = 0x6;
        } else if (tag_priority_23) {
            conf.usr_prio.value = 3;
            conf.usr_prio.mask = 0x6;
        } else if (tag_priority_45) {
            conf.usr_prio.value = 5;
            conf.usr_prio.mask = 0x6;
        } else if (tag_priority_67) {
            conf.usr_prio.value = 7;
            conf.usr_prio.mask = 0x6;
        } else if (tag_priority_03) {
            conf.usr_prio.value = 3;
            conf.usr_prio.mask = 0x4;
        } else if (tag_priority_47) {
            conf.usr_prio.value = 7;
            conf.usr_prio.mask = 0x4;
        } else {
            conf.usr_prio.value = tag_priority;
            conf.usr_prio.mask = 0X7;
        }
    }

    //dmac_type
    if (has_dmac_type) {
        if (has_any_dmac_type) {
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_MC, 0, TRUE);
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_BC, 0, TRUE);
        } else if (has_dmac_type_unicast) {
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_MC, 0, FALSE);
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_BC, 0, FALSE);
        } else if (has_dmac_type_multicast) {
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_MC, 1, FALSE);
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_BC, 0, FALSE);
        } else if (has_dmac_type_broadcast) {
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_MC, 1, FALSE);
            ACL_ICLI_ace_flag_set(&conf, ACE_FLAG_DMAC_BC, 1, FALSE);
        }
    }

    //action
    if (has_action) {
#if defined(VTSS_FEATURE_ACL_V2)
        if (has_permit) {
            if (has_update && !has_redirect && conf.action.port_action == VTSS_ACL_PORT_ACTION_REDIR) {
                // Update command doens't include the redirect change
                ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action.\n");
                return ICLI_RC_ERROR;
            } else {
                conf.action.port_action = VTSS_ACL_PORT_ACTION_NONE;
                for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
                    conf.action.port_list[port_idx] = TRUE;
                }
            }
        } else if (has_deny) {
            if (has_update && !has_redirect && conf.action.port_action == VTSS_ACL_PORT_ACTION_REDIR) {
                // Update command doens't include the redirect change
                // Do nothing here.
            } else {
                conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
                for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
                    conf.action.port_list[port_idx] = FALSE;
                }
            }
        } else if (has_filter_switchport) {
            if (icli_rangelist2iportlist(filter_switch_port_list, conf.action.port_list, VTSS_PORT_ARRAY_SIZE)) {
                ICLI_PRINTF("%% Out of switchport range.\n");
                return ICLI_RC_ERROR;
            }
            conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
        } else if (has_filter_interface) {
            if (icli_porttypelist2iportlist(topo_isid2usid(conf.isid), fliter_port_list, conf.action.port_list, VTSS_PORT_ARRAY_SIZE)) {
                ICLI_PRINTF("%% Cannot be configured on different switch ID.\n");
                return ICLI_RC_ERROR;
            }
            conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
        }
#else
        if (has_permit) {
            conf.action.permit = TRUE;
        } else if (has_deny) {
            conf.action.permit = FALSE;
        }
#endif /* VTSS_FEATURE_ACL_V2 */
    }

    //rate_limter_id
    if (has_rate_limiter) {
        if (has_disable_rate_limiter) {
             conf.action.policer = ACL_POLICER_NONE;
        } else {
            conf.action.policer = upolicer2ipolicer(rate_limiter_id);
        }
    }

#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
    //evc_policer
    if (has_evc_policer) {
        if (has_disable_evc_policer) {
            conf.action.evc_police = FALSE;
            conf.action.evc_policer_id = 0;
        } else {
            conf.action.evc_police = TRUE;
            conf.action.evc_policer_id = uevcpolicer2ievcpolicer(evc_policer_id);
        }
    }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */

    //redirect
#if defined(VTSS_FEATURE_ACL_V2)
    if (has_redirect) {
        if (has_disable_redirect) {
            if (conf.action.port_action == VTSS_ACL_PORT_ACTION_REDIR) {
                conf.action.port_action = VTSS_ACL_PORT_ACTION_FILTER;
                memset(conf.action.port_list, 0, sizeof(conf.action.port_list));
            }
        } else {
            if (conf.action.port_action == VTSS_ACL_PORT_ACTION_NONE) {
                ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action.\n");
                return ICLI_RC_ERROR;
            } else if (conf.action.port_action == VTSS_ACL_PORT_ACTION_FILTER) {
                port_filter_list_cnt = 0;
                for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_END; port_idx++) {
                    if (conf.action.port_list[port_idx]) {
                        port_filter_list_cnt++;
                    }
                }
                if (port_filter_list_cnt) {
                    ICLI_PRINTF("%% Port redirect cannot be configured while filtered action.\n");
                    return ICLI_RC_ERROR;
                }
            }

            conf.action.port_action = VTSS_ACL_PORT_ACTION_REDIR;
            if (has_redirect_switchport) {
                if (icli_rangelist2iportlist(redirect_switch_port_list, conf.action.port_list, VTSS_PORT_ARRAY_SIZE)) {
                    ICLI_PRINTF("%% Out of switchport range.\n");
                    return ICLI_RC_ERROR;
                }
            } else if (has_redirect_interface) {
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
                if (conf.isid ==  VTSS_ISID_GLOBAL) {
                    ICLI_PRINTF("%% Use 'redirect switchport' command instead of 'redirect interface' on global ACE.\n");
                    return ICLI_RC_ERROR;
                }
#endif /* VTSS_SWITCH_STACKABLE && VTSS_SWITCH_STACKABLE */
                if (icli_porttypelist2iportlist(topo_isid2usid(conf.isid), redirect_port_list, conf.action.port_list, VTSS_PORT_ARRAY_SIZE)) {
                    ICLI_PRINTF("%% Port redirect cannot be configured on different switch ID.\n");
                    return ICLI_RC_ERROR;
                }
            }
        }
    }
#else
    if (has_redirect || has_port_copy) {
        if (has_disable_redirect) {
            conf.action.port_no = VTSS_PORT_NO_NONE;
        } else if (has_redirect_switchport) {
            if (conf.isid != VTSS_ISID_GLOBAL) {
                ICLI_PRINTF("%% Cannot be configured on specific switch ID.\n");
                return ICLI_RC_ERROR;
            }
            conf.action.port_no = uport2iport(redirect_switch_port_id);
        } else {
#if defined(VTSS_SWITCH_STACKABLE) && VTSS_SWITCH_STACKABLE
            if (conf.isid == VTSS_ISID_GLOBAL) {
                ICLI_PRINTF("%% Use 'redirect switchport' command instead of 'redirect interface' on global ACE.\n");
                return ICLI_RC_ERROR;
            } else if (conf.isid != topo_usid2isid(redirect_port_id.usid)) {
                ICLI_PRINTF("%% Port redirect cannot be configured on different switch ID.\n");
                return ICLI_RC_ERROR;
            }
#endif /* VTSS_SWITCH_STACKABLE && VTSS_SWITCH_STACKABLE */
            if (port_isid_port_no_is_stack(topo_usid2isid(redirect_port_id.usid), uport2iport(redirect_port_id.begin_uport))) {
                ICLI_PRINTF("%% Cannot be configured on stacking interface.\n");
                return ICLI_RC_ERROR;
            }
#if defined(VTSS_ARCH_JAGUAR_1)
            if (conf.action.permit) {
                ICLI_PRINTF("%% Port redirect cannot be configured while permitted or filtered action.\n");
                return ICLI_RC_ERROR;
            }
#endif /* VTSS_ARCH_JAGUAR_1 */                    
            conf.action.port_no = uport2iport(redirect_port_id.begin_uport);
        }
    }
#endif /* VTSS_FEATURE_ACL_V2 */

#if defined(VTSS_FEATURE_ACL_V2)
    //mirror
    if (has_mirror) {
        if (has_disable_mirror) {
            conf.action.mirror = FALSE;
        } else {
            conf.action.mirror = TRUE;
        }
    }
#endif /* VTSS_FEATURE_ACL_V2 */

    //logging
    if (has_logging) {
        if (has_disable_logging) {
            conf.action.logging = FALSE;
        } else {
            conf.action.logging = TRUE;
        }
    }

    //shutdown
    if (has_shutdown) {
        if (has_disable_shutdown) {
            conf.action.shutdown = FALSE;
        } else {
            conf.action.shutdown = TRUE;
        }
    }

    //chip limitation checking
#if defined(VTSS_ARCH_JAGUAR_1)
    if (conf.action.port_no != VTSS_PORT_NO_NONE && conf.action.permit) {
        ICLI_PRINTF("%% The specific redirect port only works when ACE deny action.\n");
        return ICLI_RC_ERROR;
    }
#endif /* VTSS_ARCH_JAGUAR_1 */

#if defined(VTSS_FEATURE_ACL_V2)
    /* The DMAC type parameter is not supported for VTSS_ACE_TYPE_ANY.
       This is a chip limitation. */
    if (conf.type == VTSS_ACE_TYPE_ANY &&
        (VTSS_BF_GET(conf.flags.mask, ACE_FLAG_DMAC_BC) || VTSS_BF_GET(conf.flags.mask, ACE_FLAG_DMAC_MC))) {
        ICLI_PRINTF("%% The specific DMAC type(unicast, multicast or broadcast) is not supported when ACE any frame type.\n");
        return ICLI_RC_ERROR;
    }

    if (conf.tagged == VTSS_ACE_BIT_0 && (conf.vid.mask || conf.usr_prio.mask)) {
        ICLI_PRINTF("%% The specific VID or tag priority value is not supported when ACE untagged.\n");
        return ICLI_RC_ERROR;
    }
#endif /* VTSS_FEATURE_ACL_V2 */

#if defined(VTSS_ARCH_CARACAL) && defined(VTSS_SW_OPTION_EVC)
    if (conf.action.evc_police && conf.action.policer != ACL_POLICER_NONE) {
        ICLI_PRINTF("%% The ACL rate limiter and EVC policer can not both be enabled.\n");
        return ICLI_RC_ERROR;
    }
#endif /* VTSS_ARCH_CARACAL && VTSS_SW_OPTION_EVC */

#if defined(VTSS_ARCH_SERVAL)
    if (has_lookup) {
        if (has_disable_lookup) {
            conf.lookup = 0;
        } else {
            conf.lookup = 1;
        }
    }
#endif /* VTSS_ARCH_SERVAL */

    //set ACE configuraiton
    if (acl_mgmt_ace_add(ACL_USER_STATIC, next_ace_id, &conf) != VTSS_OK) {
        ICLI_PRINTF("%% Failed to %s ACE ID %u.\n", has_update ? "update": "create", conf.id);
        return ICLI_RC_ERROR;
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = no access-list ace <1~256>

DOC_CMD_DESC    = Use the no access-list ace global configuration command to \
                  delete the access-list ace.
DOC_CMD_DEFAULT = 
DOC_CMD_USAGE   = Delete access-list ace.
DOC_CMD_EXAMPLE = This example shows how to delete access-list the ace ID 1:
DOC_CMD_EXAMPLE = Switch(config)# no access-list ace 1
DOC_CMD_EXAMPLE = You can verify your settings by entering the show access-list ace privileged EXEC command.

FUNC_NAME = icli_acl_ace_del
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_LOOSELY

CMD_MODE = ICLI_CMD_MODE_GLOBAL_CONFIG
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_ace_list

! 1: no
! 2: access-list
! 3: ace
! 4: <ace_list:1~256>

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR = ace_list

HELP = ##ICLI_HELP_NO
HELP = ##HELP_ACL
HELP = ##HELP_ACE
HELP = ##HELP_ACE_ID

BYWORD =
BYWORD =
BYWORD =
BYWORD = <AceList : 1~256>

VARIABLE_BEGIN
    u32             range_idx;
    vtss_ace_id_t   ace_idx;
VARIABLE_END

CODE_BEGIN
    for (range_idx = 0; range_idx < ace_list->cnt; range_idx++) {
        for (ace_idx = ace_list->range[range_idx].min; ace_idx <= ace_list->range[range_idx].max; ace_idx++) {
            if (acl_mgmt_ace_del(ACL_USER_STATIC, ace_idx) != VTSS_OK) {
                ICLI_PRINTF("%% Failed to delete ACE ID %u.\n", ace_idx);
                return ICLI_RC_ERROR;
            }
        }
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = show access-list [ interface [ <port_type_list> ] ] [ rate-limiter [ <1~16> ] ] [ ace statistics [ <1~256> ] ]

DOC_CMD_DESC    = Use the show access-list privilege EXEC command without \
                  keywords to display the access-list configuration, or \
                  particularly the show access-list interface for the \
                  access-list interface configuration, or use the rate-limiter \
                  keyword to display access-list rate-limiter configuration, \
                  or use the ace keyword to display access-list ace configuration.
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = Expressions are case sensitive. For example, if you enter | exclude output, the lines that contain output do not appear, but the lines that contain Output appear.
DOC_CMD_EXAMPLE = This is an example of output from the show access-list command:
DOC_CMD_EXAMPLE = Switch# show access-list
DOC_CMD_EXAMPLE = ID   Policy   Frame  Action Rate L.  Mirror   Counter
DOC_CMD_EXAMPLE = --   -------- -----  ------ -------- -------- -------
DOC_CMD_EXAMPLE = 1    Any      Any    Permit Disabled Disabled    9110
DOC_CMD_EXAMPLE = Switch access-list ace number: 2
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 1 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 2 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 3 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 4 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 5 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 6 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 7 is 1 pps
DOC_CMD_EXAMPLE = Switch access-list rate limiter ID 8 is 1 pps
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 :
DOC_CMD_EXAMPLE = ---------------------
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list action is deny
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list policy ID is 0
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list rate limiter ID is disabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list redirect is disabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list mirror is disabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list logging is disabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list shutdown is disabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list port-state is enabled
DOC_CMD_EXAMPLE = GigabitEthernet 1/1 access-list counter is 0

FUNC_NAME = icli_acl_show
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_rate_limiter_list
RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_ace_list

! 1: show
! 2: access-list
! 3: interface
! 4: <port_type_list>
! 5: rate-limiter
! 6: <rate_limiter_list:1~16>
! 7: ace
! 8: statistics
! 9: <ace_list:1~256>

CMD_VAR =
CMD_VAR =
CMD_VAR = has_interface
CMD_VAR = v_port_type_list
CMD_VAR = has_rate_limiter
CMD_VAR = rate_limiter_list
CMD_VAR = has_ace
CMD_VAR = has_statistics
CMD_VAR = ace_list

HELP = ##ICLI_HELP_SHOW
HELP = ##HELP_ACL
HELP = ##ICLI_HELP_INTERFACE
HELP = ##ICLI_HELP_PORT_TYPE_LIST
HELP = ##HELP_ACL_RATE_LIMITER
HELP = ##HELP_ACL_RATE_LIMITER_ID
HELP = ##HELP_ACE
HELP = ##ICLI_HELP_STATISTICS
HELP = ##HELP_ACE_ID

BYWORD =
BYWORD =
BYWORD = <Interface : option>
BYWORD =
BYWORD = <RateLimiter : option>
BYWORD = <RateLimiterList : 1~16>
BYWORD = <Ace : option>
BYWORD = <Statistics : option>
BYWORD = <AceList : 1~256>

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    if (!has_interface && !has_rate_limiter && !has_ace) {
        //show all configuration
        has_interface = has_rate_limiter = has_ace = TRUE;
    }

    if (has_ace) {
        //show ACEs
        ACL_ICLI_ace_parse(session_id, ace_list, FALSE);
    }

    if (has_rate_limiter) {
        //show acl rate limiter configuration
        if (has_ace) {
            ICLI_PRINTF("\n");
        }
        ACL_ICLI_rate_limiter_parse(session_id, rate_limiter_list);
    }

    if (has_interface) {
        //show port configuration
        if (has_ace || has_rate_limiter) {
            ICLI_PRINTF("\n");
        }
        ACL_ICLI_interface_parse(session_id, v_port_type_list);
    }
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = clear access-list ace statistics

DOC_CMD_DESC    = Use the clear access-list ace statistics privileged EXEC \
                  command to clear the statistics maintained by access-list, \
                  including access-list interface statistics and ACE's statistics.
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = Clear all access-list statistics.
DOC_CMD_EXAMPLE = This example shows how to clear access-list ace statistics:
DOC_CMD_EXAMPLE = Switch# clear access-list ace statistics
DOC_CMD_EXAMPLE = You can verify that the information was deleted by entering the \
                  show access-list ace show access-list ace privileged EXEC command.

FUNC_NAME = icli_acl_stat_clear
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  =

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

RUNTIME =

! 1: clear
! 2: access-list
! 3: ace
! 4: statistics

CMD_VAR =
CMD_VAR =
CMD_VAR =
CMD_VAR =

HELP = ##ICLI_HELP_CLEAR
HELP = ##HELP_ACL
HELP = ##HELP_ACE
HELP = ##ICLI_HELP_STATISTICS

BYWORD =
BYWORD =
BYWORD =
BYWORD =

VARIABLE_BEGIN
VARIABLE_END

CODE_BEGIN
    ICLI_RC_CHECK(acl_mgmt_counters_clear(),
                  "%% Failed to clear access-list statistics\n");
CODE_END

CMD_END

!==============================================================================

CMD_BEGIN

IF_FLAG =

COMMAND = show access-list ace-status [ static ] [ link-oam ] [ loop-protect ] [ dhcp ] [ ptp ] [ upnp ] [ arp-inspection ] [evc] [ mep ] [ ipmc ] [ ip-source-guard ] [ ip-mgmt ] [ conflicts ] [ switch <switch_list> ]

DOC_CMD_DESC    = Use the show access-list ace-status privilege EXEC command without \
                  keywords to display the access-list ace status for all access-list users, \
                  or particularly the access-list user for the access-list ace status. \  
                  Use conflicts keyword to display the access-list ace that doesn't apply on on the hardware.\
                  In other word, it means the specific ACE is not applied to the hardware due to hardware limitations.  
DOC_CMD_DESC    = Note: The parameter of access-list users is depended on these features if supported on the platform.
DOC_CMD_DEFAULT =
DOC_CMD_USAGE   = Expressions are case sensitive. For example, if you enter | exclude output, the lines that contain output do not appear, but the lines that contain Output appear.
DOC_CMD_EXAMPLE = This is an example of output from the show access-list ace-status command:
DOC_CMD_EXAMPLE = Switch# show access-list ace-status
DOC_CMD_EXAMPLE = User
DOC_CMD_EXAMPLE = ----
DOC_CMD_EXAMPLE = S   : Static
DOC_CMD_EXAMPLE = IPSG: IP Source Guard
DOC_CMD_EXAMPLE = IPMC: IPMC
DOC_CMD_EXAMPLE = ARPI: ARP Inspection
DOC_CMD_EXAMPLE = UPnP: UPnP
DOC_CMD_EXAMPLE = DHCP: DHCP
DOC_CMD_EXAMPLE = LOOP: Loop Protect
DOC_CMD_EXAMPLE = User ID   Frame  Action Rate L.  CPU    Counter Conflict
DOC_CMD_EXAMPLE = ---- --   -----  ------ -------- ------ ------- --------
DOC_CMD_EXAMPLE = S    1    Any    Permit Disabled No        3606 No
DOC_CMD_EXAMPLE = S    2    Any    Permit Disabled No           0 No
DOC_CMD_EXAMPLE = Switch 2 access-list ace number: 2

FUNC_NAME = icli_acl_ace_status_show
FUNC_REUSE =

PRIVILEGE = ICLI_PRIVILEGE_15
PROPERTY  = ICLI_CMD_PROP_GREP

CMD_MODE = ICLI_CMD_MODE_EXEC
MODE_VAR =

RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME =
RUNTIME = ACL_ICLI_runtime_vol_link_oam
RUNTIME = ACL_ICLI_runtime_vol_loop_protect
RUNTIME = ACL_ICLI_runtime_vol_dhcp
RUNTIME = ACL_ICLI_runtime_vol_ptp
RUNTIME = ACL_ICLI_runtime_vol_upnp
RUNTIME = ACL_ICLI_runtime_vol_arp_inspection
RUNTIME = ACL_ICLI_runtime_vol_evc
RUNTIME = ACL_ICLI_runtime_vol_mep
RUNTIME = ACL_ICLI_runtime_vol_ipmc
RUNTIME = ACL_ICLI_runtime_vol_ip_source_guard
RUNTIME = ACL_ICLI_runtime_vol_ip_mgmt
RUNTIME =
RUNTIME = ACL_ICLI_runtime_has_stackable
RUNTIME = ACL_ICLI_runtime_has_stackable

! 1: show
! 2: access-list
! 3: ace-status
! 4: static
! 5: link-oam
! 6: loop-protect
! 7: dhcp
! 8: ptp
! 9: upnp
! 10: arp-inspection
! 11: evc
! 12: mep
! 13: ipmc
! 14: ip-source-guard
! 15: ip-mgmt
! 16: conflicts
! 17: switch
! 18: switch_list

CMD_VAR =
CMD_VAR =
CMD_VAR = 
CMD_VAR = has_static
CMD_VAR = has_link_oam
CMD_VAR = has_loop_protect
CMD_VAR = has_dhcp
CMD_VAR = has_ptp
CMD_VAR = has_upnp
CMD_VAR = has_arp_inspection
CMD_VAR = has_evc
CMD_VAR = has_mep
CMD_VAR = has_ipmc
CMD_VAR = has_ip_source_guard
CMD_VAR = has_ip_mgmt
CMD_VAR = has_conflicts
CMD_VAR = has_switch
CMD_VAR = switch_list

HELP = ##ICLI_HELP_SHOW
HELP = ##HELP_ACL
HELP = ##HELP_ACE_STATUS
HELP = ##HELP_ACE_STATIC
HELP = ##HELP_ACE_LINK_OAM
HELP = ##HELP_ACE_LOOP_PROTECT
HELP = ##HELP_ACE_DHCP
HELP = ##HELP_ACE_PTP
HELP = ##HELP_ACE_UPNP
HELP = ##HELP_ACE_ARP_INSPECTION
HELP = ##HELP_ACE_EVC
HELP = ##HELP_ACE_MEP
HELP = ##HELP_ACE_IPMC
HELP = ##HELP_ACE_IPSG
HELP = ##HELP_ACE_IP_MGMT
HELP = ##HELP_ACE_CONFLICT
HELP = ##ICLI_HELP_SWITCH
HELP = ##ICLI_HELP_SWITCH_LIST

BYWORD =
BYWORD =
BYWORD =
BYWORD = <Static : option>
BYWORD = <LinkOam : option>
BYWORD = <LoopProtect : option>
BYWORD = <Dhcp : option>
BYWORD = <Ptp : option>
BYWORD = <Upnp : option>
BYWORD = <ArpInspection : option>
BYWORD = <Evc : option>
BYWORD = <Mep : option>
BYWORD = <Ipmc : option>
BYWORD = <IpSourceGuard : option>
BYWORD = <IpMgmt : option>
BYWORD = <Conflicts : option>
BYWORD = <Switch : option>
BYWORD = <switch_list>

VARIABLE_BEGIN
    BOOL                first = TRUE, show_all_status = FALSE;
    int                 ace_cnt = 0;
    vtss_usid_t         usid_idx;
VARIABLE_END

CODE_BEGIN
    if (!has_static &&
        !has_link_oam &&
        !has_loop_protect &&
        !has_dhcp &&
        !has_ptp &&
        !has_upnp &&
        !has_arp_inspection &&
        !has_evc &&
        !has_mep &&
        !has_ipmc &&
        !has_ip_source_guard &&
        !has_ip_mgmt &&
        !has_conflicts) {   //show all status
            show_all_status = TRUE;
    }

    if (has_switch) {
        u32 i, j;

        //Omit non-existing switches from the switch range database and display the alert message on ICLI session
        (void)icli_cmd_switch_range_exist(session_id, switch_list, TRUE, TRUE);

        for (i = 0; i < switch_list->cnt; i++) {
            for (j = switch_list->range[i].min; j <= switch_list->range[i].max; j++) {
                ace_cnt = 0;
                first = TRUE;
                ACL_ICLI_ace_show_by_isid(session_id,
                                          topo_usid2isid((vtss_usid_t)j),
                                          &first,
                                          &ace_cnt,
                                          show_all_status,
                                          has_static,
                                          has_link_oam,
                                          has_loop_protect,
                                          has_dhcp,
                                          has_ptp,
                                          has_upnp,
                                          has_arp_inspection,
                                          has_evc,
                                          has_mep,
                                          has_ipmc,
                                          has_ip_source_guard,
                                          has_ip_mgmt,
                                          has_conflicts);
                ICLI_PRINTF("Switch %u access-list ace number: %u\n", j, ace_cnt);
            }
        }
    } else {
        for (usid_idx = VTSS_USID_START; usid_idx < VTSS_USID_END; usid_idx++) {
            if (!icli_cmd_switch_exist(session_id, usid_idx, FALSE, FALSE)) {
                continue;
            }
        
            ace_cnt = 0;
            first = TRUE;
                ACL_ICLI_ace_show_by_isid(session_id,
                                          topo_usid2isid(usid_idx),
                                          &first,
                                          &ace_cnt,
                                          show_all_status,
                                          has_static,
                                          has_link_oam,
                                          has_loop_protect,
                                          has_dhcp,
                                          has_ptp,
                                          has_upnp,
                                          has_arp_inspection,
                                          has_evc,
                                          has_mep,
                                          has_ipmc,
                                          has_ip_source_guard,
                                          has_ip_mgmt,
                                          has_conflicts);
            ICLI_PRINTF("Switch %u access-list ace number: %u\n", usid_idx, ace_cnt);
        }
    }
CODE_END

CMD_END

