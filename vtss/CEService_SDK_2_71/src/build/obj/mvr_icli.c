/*

 Vitesse Switch Application software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/

/*
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        This file is automatically generated from script file.
        Please modify the corresponding script file if needed.
        Modifying this file will -NOT- take effect.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

#include <stdio.h>
#include <string.h>
#include "icli_api.h"

//===== INCLUDE_BEGIN ========================================================
/*lint --e{766} */
#line 28 "mvr.icli"
#include "icli_api.h"
#include "icli_porting_util.h"
#include "mgmt_api.h"
#include "misc_api.h"
#include "msg_api.h"
#include "topo_api.h"
#include "mvr.h"
#include "mvr_api.h"
//===== INCLUDE_END ==========================================================

#include "icli_porting_trace.h"

//===== CONSTANT_STRING_DEFINITION_BEGIN =====================================

#define HELP_GRP_DB_DETAIL    "Detail information/statistics of MVR group database"
#define HELP_GRP_DB_INC_SFM    "Including source filter multicast information from MVR"
#define HELP_GRP_DB    "Multicast group database from MVR"
#define HELP_STATISTICS    "Running MVR protocol counters"
#define HELP_STATUS_DETAIL    "Detail running information/statistics of MVR"
#define HELP_MVR_MODE    "MVR mode of operation"
#define HELP_MVR_PORT_ROLE    "MVR port role configuration"
#define HELP_MVR_CHANNEL    "MVR channel configuration"
#define HELP_MVR_VLAN_FRAME    "MVR control frame in TX"
#define HELP_QUERIER_ADR    "MVR address configuration used in IGMP"
#define HELP_MVR_VLAN_NAME    "MVR multicast VLAN name"
#define HELP_MVR_VLAN_LIST    "MVR multicast VLAN list"
#define ICLI_HELP_WIDTH_NUM    "Number of characters on a screen line (0 for unlimited width)"
#define ICLI_HELP_WIDTH    "Set width of the display terminal"
#define ICLI_HELP_SWITCH_LIST    "List of switch ID, ex, 1,3-5,6"
#define ICLI_HELP_SWITCH_ID    "Switch ID"
#define ICLI_HELP_SWITCH    "Switch"
#define ICLI_HELP_SWITCHPORT    "Set switching mode characteristics"
#define ICLI_HELP_SSH    "Secure Shell"
#define ICLI_HELP_STP    "Spanning Tree protocol"
#define ICLI_HELP_STATUS    "Status"
#define ICLI_HELP_STATISTICS    "Traffic statistics"
#define ICLI_HELP_STATELESS    "Obtain IPv6 address using autoconfiguration"
#define ICLI_HELP_SNMP_HOST_NAME    "Name of the host configuration"
#define ICLI_HELP_SNMP_HOST    "Set SNMP host's configurations"
#define ICLI_HELP_SNMP    "Set SNMP server's configurations"
#define ICLI_HELP_SHOW_IP_DHCP    "Show items in the DHCP database"
#define ICLI_HELP_SHOW_IP    "IP information"
#define ICLI_HELP_SHOW_INTERFACE    "Interface status and configuration"
#define ICLI_HELP_SHOW    "Show running system information"
#define ICLI_HELP_SERVICE    "Modify use of network based services"
#define ICLI_HELP_ROUTE6_NH    "Next hop router's IPv6 address"
#define ICLI_HELP_ROUTE4_NH    "Next hop router's IPv4 address"
#define ICLI_HELP_ROUTE    "Configure static routes"
#define ICLI_HELP_PROFILE_NAME    "Profile name in 16 char's"
#define ICLI_HELP_PRIVILEGE_LEVEL    "Assign default privilege level for line"
#define ICLI_HELP_PRIVILEGE    "Change privilege level for line"
#define ICLI_HELP_PORT_TYPE_LIST    "List of port type and port ID, ex, Fast 1/1 Gigabit 2/3-5 Gigabit 3/2-4 Tengigabit 4/6"
#define ICLI_HELP_PORT_TYPE    "Port type in Fast, Gigabit or Tengigabit ethernet"
#define ICLI_HELP_PORT_LIST    "List of port ID, ex, 1/1,3-5;2/2-4,6"
#define ICLI_HELP_PORT_ID    "Port ID in the format of switch-id/port-id, ex, 1/5"
#define ICLI_HELP_PING    "Send ICMP echo messages"
#define ICLI_HELP_NO    "Negate a command or set its defaults"
#define ICLI_HELP_MVR_VLAN    "MVR multicast vlan"
#define ICLI_HELP_MVR_NAME    "MVR multicast name"
#define ICLI_HELP_MVR    "Multicast VLAN Registration configuration"
#define ICLI_HELP_MROUTER    "Multicast router port configuration"
#define ICLI_HELP_MOTD    "Set Message of the Day banner"
#define ICLI_HELP_MLD    "Multicasat Listener Discovery"
#define ICLI_HELP_LOCATION    "Enter terminal location description"
#define ICLI_HELP_LINE    "Configure a terminal line"
#define ICLI_HELP_LENGTH_NUM    "Number of lines on screen (0 for no pausing)"
#define ICLI_HELP_LENGTH    "Set number of lines on a screen"
#define ICLI_HELP_IPV6    "IPv6 configuration commands"
#define ICLI_HELP_IPMC_VID    "VLAN identifier(s): VID"
#define ICLI_HELP_IPMC_RANGE    "A range of IPv4/IPv6 multicast addresses for the profile"
#define ICLI_HELP_IPMC_PROFILE    "IPMC profile configuration"
#define ICLI_HELP_IPMC    "IPv4/IPv6 multicast configuration"
#define ICLI_HELP_IP6_ADRS    "Configure the IPv6 address of an interface"
#define ICLI_HELP_IP4_ADRS    "Configure the IPv4 address of an interface"
#define ICLI_HELP_IP_DHCP    "Configure DHCP server parameters"
#define ICLI_HELP_IP    "Interface Internet Protocol config commands"
#define ICLI_HELP_IMD_LEAVE    "Immediate leave configuration"
#define ICLI_HELP_INTF_URI    "Unsolicited Report Interval in seconds"
#define ICLI_HELP_INTF_LMQI    "Last Member Query Interval in tenths of seconds"
#define ICLI_HELP_INTF_QRI    "Query Response Interval in tenths of seconds"
#define ICLI_HELP_INTF_QI    "Query Interval in seconds"
#define ICLI_HELP_INTF_RV    "Robustness Variable"
#define ICLI_HELP_INTF_PRI    "Interface CoS priority"
#define ICLI_HELP_INTF_COMPAT    "Interface compatibility"
#define ICLI_HELP_INTERFACE    "Select an interface to configure"
#define ICLI_HELP_IGMP    "Internet Group Management Protocol"
#define ICLI_HELP_HTTP    "Hypertext Transfer Protocol "
#define ICLI_HELP_HISTORY_NUM    "Number of history commands, 0 means disable"
#define ICLI_HELP_HISTORY_SIZE    "Set history buffer size"
#define ICLI_HELP_HISTORY    "Control the command history function"
#define ICLI_HELP_EXEC_SEC    "Timeout in seconds"
#define ICLI_HELP_EXEC_MIN    "Timeout in minutes"
#define ICLI_HELP_EXEC_TIMEOUT    "Set the EXEC timeout"
#define ICLI_HELP_END    "Go back to EXEC mode"
#define ICLI_HELP_EDITING    "Enable command line editing"
#define ICLI_HELP_DO_LINE    "Exec Command"
#define ICLI_HELP_DO    "To run exec commands in config mode"
#define ICLI_HELP_DNS    "Domain Name System"
#define ICLI_HELP_DHCP_RELAY    "DHCP relay agent configuration"
#define ICLI_HELP_DHCP_POOL_NAME    "Pool name in 32 characters"
#define ICLI_HELP_DHCP_BINDING    "DHCP address bindings"
#define ICLI_HELP_DHCP    "Dynamic Host Configuration Protocol"
#define ICLI_HELP_DEFAULT_ROUTE    "Establish default route"
#define ICLI_HELP_DEFAULT    "Set a command to its defaults"
#define ICLI_HELP_DEBUG    "Debugging functions"
#define ICLI_HELP_CLEAR_IP_DHCP    "Delete items from the DHCP database"
#define ICLI_HELP_CLEAR_IP    "IP protocol"
#define ICLI_HELP_CLEAR    "Reset functions"
#define ICLI_HELP_BANNER    "Define a login banner"
#define ICLI_HELP_AGGREGATION    "Aggregation mode"
//===== CONSTANT_STRING_DEFINITION_END =======================================


//===== MODULE_IF_FLAG =======================================================
#if defined(VTSS_SW_OPTION_MVR)

//===== FUNCTION_BEGIN =======================================================
#line 39 "mvr.icli"
static BOOL icli_ipmc_mvr_check_present(IN u32 session_id, IN icli_runtime_ask_t ask, OUT icli_runtime_t *runtime)
{
    icli_privilege_t    current_priv;

    switch ( ask ) {
    case ICLI_ASK_PRESENT:
        if (ICLI_PRIVILEGE_GET(&current_priv) == ICLI_RC_OK) {
            if (current_priv < ICLI_PRIVILEGE_15) {
                runtime->present = FALSE;
            } else {
                runtime->present = TRUE;
            }

            return TRUE;
        }

        break;
    case ICLI_ASK_BYWORD:
    case ICLI_ASK_HELP:
    case ICLI_ASK_RANGE:
    default:

        break;
    }

    return FALSE;
}

static BOOL _icli_ipmc_mvr_chk_by_vlan(vtss_vid_t vdx, icli_unsigned_range_t *vlist)
{
    u32         idx;
    vtss_vid_t  vidx, bnd;

    if (!vlist) {
        return FALSE;
    }

    for (idx = 0; idx < vlist->cnt; idx++) {
        bnd = vlist->range[idx].max;
        for (vidx = vlist->range[idx].min; vidx <= bnd; vidx++) {
            if (vdx == vidx) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

static BOOL _icli_ipmc_mvr_chk_by_port_msk(vtss_isid_t isx, u8 *ptx, icli_stack_port_range_t *plist)
{
    u32             rdx;
    u16             idx, bgn, cnt;
    vtss_isid_t     isid;
    vtss_port_no_t  iport;

    if (!ptx || !plist) {
        return FALSE;
    }

    for (rdx = 0; rdx < plist->cnt; rdx++) {
        isid = topo_usid2isid(plist->switch_range[rdx].usid);
        if (isid != isx) {
            continue;
        }

        cnt = plist->switch_range[rdx].port_cnt;
        bgn = plist->switch_range[rdx].begin_uport;
        for (idx = 0; idx < cnt; idx++) {
            iport = uport2iport(bgn + idx);
            if (VTSS_PORT_BF_GET(ptx, iport)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

static BOOL _icli_ipmc_mvr_chk_by_port_val(vtss_isid_t isx, vtss_port_no_t ptx, icli_stack_port_range_t *plist)
{
    u32             rdx;
    u16             idx, bgn, cnt;
    vtss_isid_t     isid;
    vtss_port_no_t  iport;

    if (!plist) {
        return FALSE;
    }

    for (rdx = 0; rdx < plist->cnt; rdx++) {
        isid = topo_usid2isid(plist->switch_range[rdx].usid);
        if (isid != isx) {
            continue;
        }

        cnt = plist->switch_range[rdx].port_cnt;
        bgn = plist->switch_range[rdx].begin_uport;
        for (idx = 0; idx < cnt; idx++) {
            iport = uport2iport(bgn + idx);
            if (ptx == iport) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

static void _icli_ipmc_mvr_db_display(u32 session_id,
                                      ipmc_prot_intf_group_entry_t *grp,
                                      vtss_isid_t isid,
                                      BOOL by_port,
                                      icli_stack_port_range_t *plist,
                                      BOOL inc_sfm, BOOL detail)
{
    icli_switch_port_range_t    icli_port;
    vtss_port_no_t              iport;

    ipmc_ip_version_t           version;
    vtss_vid_t                  vid;
    vtss_ipv6_t                 ip6grp;
    vtss_ipv4_t                 ip4grp, ip4src;
    ipmc_group_db_t             *grp_db;
    ipmc_prot_group_srclist_t   group_srclist_entry;
    ipmc_sfm_srclist_t          *sfm_src;

    BOOL                        deny_found, prted;
    i32                         fto;
    i8                          adrString[40], portString[MGMT_PORT_BUF_SIZE];

    if (!grp || (by_port && !plist)) {
        return;
    }
    version = grp->ipmc_version;
    vid = grp->vid;
    IPMC_LIB_ADRS_CPY(&ip6grp, &grp->group_addr);
    IPMC_LIB_ADRS_6TO4_SET(ip6grp, ip4grp);
    grp_db = &grp->db;

    memset(adrString, 0x0, sizeof(adrString));
    if (version == IPMC_IP_VERSION_IGMP) {
        (void) icli_ipv4_to_str(htonl(ip4grp), adrString);
    } else {
        (void) icli_ipv6_to_str(ip6grp, adrString);
    }
    ICLI_PRINTF("\n\r%s is registered on MVR %u\n", adrString, vid);

    prted = FALSE;
    memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
    icli_port.switch_id = icli_isid2switchid(isid);
    while (icli_switch_port_get_next(&icli_port)) {
        iport = icli_port.begin_iport;
        if (VTSS_PORT_BF_GET(grp_db->port_mask, iport)) {
            memset(portString, 0x0, sizeof(portString));
            ICLI_PRINTF("%s%s",
                        prted ? "," : "Port Members: ",
                        icli_port_info_txt_short(icli_port.usid, icli_port.begin_uport, portString));
            prted = TRUE;
        }
    }
    if (prted) {
        ICLI_PRINTF("\n");
    }

    if (detail) {
        ICLI_PRINTF("Hardware Switch: %s\n", grp_db->asm_in_hw ? "Yes" : "No");
    }

    if (!inc_sfm) {
        return;
    }

    memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
    icli_port.switch_id = icli_isid2switchid(isid);
    while (icli_switch_port_get_next(&icli_port)) {
        iport = icli_port.begin_iport;
        if (by_port && !_icli_ipmc_mvr_chk_by_port_val(isid, iport, plist)) {
            continue;
        }
        if (!IPMC_LIB_GRP_PORT_DO_SFM(grp_db, iport)) {
            continue;
        }

        if (IPMC_LIB_GRP_PORT_SFM_EX(grp_db, iport)) {
            fto = ipmc_lib_mgmt_calc_delta_time(isid, &grp_db->tmr.delta_time.v[iport]);
        } else {
            fto = -1;
        }

        memset(portString, 0x0, sizeof(portString));
        ICLI_PRINTF("%s Mode is %s",
                    icli_port_info_txt_short(icli_port.usid, icli_port.begin_uport, portString),
                    (fto < 0) ? "Include" : "Exclude");
        if (!detail || (fto < 0)) {
            ICLI_PRINTF("\n");
        } else {
            ICLI_PRINTF(" (Filter Timer: %d)\n", fto);
        }

        memset(&group_srclist_entry, 0x0, sizeof(ipmc_prot_group_srclist_t));
        group_srclist_entry.type = TRUE;    /* Allow|Include List */
        while (mvr_mgmt_get_next_group_srclist(isid, version, vid,
                                               &ip6grp,
                                               &group_srclist_entry) == VTSS_OK) {
            if (!group_srclist_entry.cntr) {
                break;
            }

            sfm_src = &group_srclist_entry.srclist;
            if (!VTSS_PORT_BF_GET(sfm_src->port_mask, iport)) {
                continue;
            }

            memset(adrString, 0x0, sizeof(adrString));
            if (version == IPMC_IP_VERSION_IGMP) {
                IPMC_LIB_ADRS_6TO4_SET(sfm_src->src_ip, ip4src);
                (void) icli_ipv4_to_str(htonl(ip4src), adrString);
            } else {
                (void) icli_ipv6_to_str(sfm_src->src_ip, adrString);
            }

            if (fto < 0) {
                ICLI_PRINTF("Allow Source Address  : %s", adrString);
            } else {
                ICLI_PRINTF("Request Source Address: %s", adrString);
            }
            if (detail) {
                ICLI_PRINTF(" (Timer->%d)\n\rHardware Filter: %s\n",
                            ipmc_lib_mgmt_calc_delta_time(isid, &sfm_src->tmr.delta_time.v[iport]),
                            sfm_src->sfm_in_hw ? "Yes" : "No");
            } else {
                ICLI_PRINTF("\n");
            }
        }

        deny_found = FALSE;
        memset(&group_srclist_entry, 0x0, sizeof(ipmc_prot_group_srclist_t));
        group_srclist_entry.type = FALSE;   /* Deny|Exclude List */
        while (mvr_mgmt_get_next_group_srclist(isid, version, vid,
                                               &ip6grp,
                                               &group_srclist_entry) == VTSS_OK) {
            if (!group_srclist_entry.cntr) {
                break;
            }

            sfm_src = &group_srclist_entry.srclist;
            if (!VTSS_PORT_BF_GET(sfm_src->port_mask, iport)) {
                continue;
            }

            deny_found = TRUE;
            memset(adrString, 0x0, sizeof(adrString));
            if (version == IPMC_IP_VERSION_IGMP) {
                IPMC_LIB_ADRS_6TO4_SET(sfm_src->src_ip, ip4src);
                (void) icli_ipv4_to_str(htonl(ip4src), adrString);
            } else {
                (void) icli_ipv6_to_str(sfm_src->src_ip, adrString);
            }

            ICLI_PRINTF("Deny Source Address   : %s\n", adrString);
            if (detail) {
                ICLI_PRINTF(" (Timer->%d)\n\rHardware Filter: %s\n",
                            ipmc_lib_mgmt_calc_delta_time(isid, &sfm_src->tmr.delta_time.v[iport]),
                            sfm_src->sfm_in_hw ? "Yes" : "No");
            } else {
                ICLI_PRINTF("\n");
            }
        }
        if (!deny_found && (fto >= 0)) {
            ICLI_PRINTF("Deny Source Address: None\n");
        }
    }
}

static void _icli_ipmc_mvr_channel_show(u32 session_id,
                                        ipmc_lib_grp_fltr_profile_t *fltr_profile,
                                        BOOL detail)
{
    i8                          adrString[40];
    u32                         pdx;
    ipmc_lib_profile_t          *data;
    ipmc_lib_rule_t             fltr_rule;
    ipmc_lib_grp_fltr_entry_t   fltr_entry;

    if (!detail || !fltr_profile) {
        return;
    }

    data = &fltr_profile->data;
    ICLI_PRINTF(" (In %s Mode)", ipmc_lib_version_txt(data->version, IPMC_TXT_CASE_UPPER));
    ICLI_PRINTF("\n\rDescription: %s", data->desc);

    pdx = data->index;
    if (ipmc_lib_mgmt_fltr_profile_rule_get_first(pdx, &fltr_rule) == VTSS_OK) {
        BOOL    heading = TRUE;

        do {
            fltr_entry.index = fltr_rule.entry_index;
            if (ipmc_lib_mgmt_fltr_entry_get(&fltr_entry, FALSE) == VTSS_OK) {
                if (heading) {
                    heading = FALSE;

                    ICLI_PRINTF("\nHEAD-> %s (%s the following range%s)",
                                fltr_entry.name,
                                ipmc_lib_fltr_action_txt(fltr_rule.action, IPMC_TXT_CASE_CAPITAL),
                                fltr_rule.log ? " and log the matched entry" : "");
                } else {
                    ICLI_PRINTF("\nNEXT-> %s (%s the following range%s)",
                                fltr_entry.name,
                                ipmc_lib_fltr_action_txt(fltr_rule.action, IPMC_TXT_CASE_CAPITAL),
                                fltr_rule.log ? " and log the matched entry" : "");
                }

                if (fltr_entry.version == IPMC_IP_VERSION_IGMP) {
                    vtss_ipv4_t adrs4;

                    memset(adrString, 0x0, sizeof(adrString));
                    IPMC_LIB_ADRS_6TO4_SET(fltr_entry.grp_bgn, adrs4);
                    (void) icli_ipv4_to_str(htonl(adrs4), adrString);
                    ICLI_PRINTF("\nStart Address: %s", adrString);
                    memset(adrString, 0x0, sizeof(adrString));
                    IPMC_LIB_ADRS_6TO4_SET(fltr_entry.grp_end, adrs4);
                    (void) icli_ipv4_to_str(htonl(adrs4), adrString);
                    ICLI_PRINTF("\nEnd Address  : %s", adrString);
                } else {
                    memset(adrString, 0x0, sizeof(adrString));
                    (void) icli_ipv6_to_str(fltr_entry.grp_bgn, adrString);
                    ICLI_PRINTF("\nStart Address: %s", adrString);
                    memset(adrString, 0x0, sizeof(adrString));
                    (void) icli_ipv6_to_str(fltr_entry.grp_end, adrString);
                    ICLI_PRINTF("\nEnd Address  : %s", adrString);
                }
            }
        } while (ipmc_lib_mgmt_fltr_profile_rule_get_next(pdx, &fltr_rule) == VTSS_OK);
    }
}

static BOOL _icli_ipmc_mvr_intf_status_show(ipmc_ip_version_t version,
                                            u32 session_id, vtss_isid_t isid,
                                            BOOL ctrl, BOOL state,
                                            mvr_mgmt_interface_t *mvif,
                                            ipmc_prot_intf_entry_param_t *param,
                                            BOOL detail)
{
    BOOL                    admin;
    vtss_vid_t              vidx;
    mvr_conf_intf_entry_t   *mvrif;
    mvr_conf_port_role_t    *prole;
    ipmc_querier_sm_t       *q;
    ipmc_statistics_t       *s;

    if (!mvif || !param) {
        return FALSE;
    }

    mvrif = &mvif->intf;
    prole = &mvif->role;
    q = &param->querier;
    s = &param->stats;
    vidx = param->vid;
    if (ctrl && state) {
        admin = TRUE;
    } else {
        admin = FALSE;
    }

    ICLI_PRINTF("\n\r%s MVR VLAN %u (Name is %s) interface is %s.\n",
                ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                vidx,
                strlen(mvrif->name) ? (char *)mvrif->name : "not set",
                state ? "enabled" : "disabled");

    /* Querier Status */
    ICLI_PRINTF("Querier status is %s",
                admin ? ((q->state == IPMC_QUERIER_IDLE) ? "IDLE" : "ACTIVE") : "DISABLED");
    if (detail) {
        if (q->querier_enabled) {
            ICLI_PRINTF(" ( %s )\n", "Join Querier-Election");
        } else {
            ICLI_PRINTF(" ( %s )\n", "Forced Non-Querier");
        }

        if (admin) {
            if (q->state == IPMC_QUERIER_ACTIVE) {
                ICLI_PRINTF("Querier Up time: %u second%s; Query Interval: %hu second%s\n",
                            q->QuerierUpTime,
                            (q->QuerierUpTime > 1) ? "s" : "",
                            q->timeout,
                            (q->timeout > 1) ? "s" : "");
            } else if (q->state == IPMC_QUERIER_INIT) {
                ICLI_PRINTF("Startup Query Interval: %hu second%s; Startup Query Count: %u\n",
                            q->timeout,
                            (q->timeout > 1) ? "s" : "",
                            q->StartUpCnt);

            } else {
                ICLI_PRINTF("Querier Expiry Time: %u second%s\n",
                            q->OtherQuerierTimeOut,
                            (q->OtherQuerierTimeOut > 1) ? "s" : "");
            }
        }
    } else {
        ICLI_PRINTF("\n");
    }

    /* Timers & Parameters & Counters */
    if (detail) {
        if (q->QuerierAdrs4) {
            i8  adrString[40];

            memset(adrString, 0x0, sizeof(adrString));
            ICLI_PRINTF("%s address is set to %s\n",
                        ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                        misc_ipv4_txt(q->QuerierAdrs4, adrString));
        } else {
            ICLI_PRINTF("%s address %swill use %s address of this interface.\n",
                        ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                        (version == IPMC_IP_VERSION_IGMP) ?
                        "is not set and " :
                        "",
                        (version == IPMC_IP_VERSION_IGMP) ?
                        "system's IP" :
                        "Link-Local");
        }

        ICLI_PRINTF("Control frames will be sent as %s\n",
                    mvrif->vtag == IPMC_INTF_TAGED ? "Tagged" : "Untagged");

        ICLI_PRINTF("PRI:%u / RV:%u / QI:%u / QRI:%u / LMQI:%u / URI:%u\n",
                    param->priority,
                    q->RobustVari,
                    q->QueryIntvl,
                    q->MaxResTime,
                    q->LastQryItv,
                    q->UnsolicitR);
    }

    if (admin) {
        if (version == IPMC_IP_VERSION_IGMP) {
            ICLI_PRINTF("RX IGMP Query:%u V1Join:%u V2Join:%u V3Join:%u V2Leave:%u\n",
                        s->igmp_queries,
                        s->igmp_v1_membership_join,
                        s->igmp_v2_membership_join,
                        s->igmp_v3_membership_join,
                        s->igmp_v2_membership_leave);
        } else {
            ICLI_PRINTF("RX MLD Query:%u V1Report:%u V2Report:%u V1Done:%u\n",
                        s->mld_queries,
                        s->mld_v1_membership_report,
                        s->mld_v2_membership_report,
                        s->mld_v1_membership_done);
        }
        ICLI_PRINTF("TX %s Query:%u / (Source) Specific Query:%u\n",
                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                    q->ipmc_queries_sent,
                    q->group_queries_sent);

        if (detail) {
            ipmc_prot_intf_group_entry_t    intf_group_entry;
            ipmc_ip_version_t               calc_ver;
            vtss_vid_t                      calc_vid;
            u16                             grpCnt;

            memset(&intf_group_entry, 0x0, sizeof(ipmc_prot_intf_group_entry_t));
            intf_group_entry.ipmc_version = calc_ver = version;
            intf_group_entry.vid = calc_vid = vidx;
            grpCnt = 0;
            while (mvr_mgmt_get_next_intf_group(isid, &calc_ver, &calc_vid, &intf_group_entry) == VTSS_OK ) {
                if ((intf_group_entry.ipmc_version != version) ||
                    (intf_group_entry.vid != vidx)) {
                    break;
                }

                grpCnt++;
            }

            if (version == IPMC_IP_VERSION_IGMP) {
                ICLI_PRINTF("IGMP RX Errors:%u; Group Registration Count:%u\n",
                            s->igmp_error_pkt, grpCnt);
            } else {
                ICLI_PRINTF("MLD RX Errors:%u; Group Registration Count:%u\n",
                            s->mld_error_pkt, grpCnt);
            }
        }
    }

    /* Port Roles */
    if (detail && prole) {
        icli_switch_port_range_t    icli_port;
        vtss_port_no_t              iport;
        BOOL                        psrc[VTSS_PORT_ARRAY_SIZE], fsrc;
        BOOL                        prcv[VTSS_PORT_ARRAY_SIZE], frcv;
        BOOL                        pina[VTSS_PORT_ARRAY_SIZE], fina;
        i8                          portString[MGMT_PORT_BUF_SIZE];

        ICLI_PRINTF("Port Role Setting:");
        fsrc = frcv = fina = FALSE;
        memset(psrc, 0x0, sizeof(psrc));
        memset(prcv, 0x0, sizeof(prcv));
        memset(pina, 0x0, sizeof(pina));
        memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
        icli_port.switch_id = icli_isid2switchid((u16)isid);
        while (icli_switch_port_get_next(&icli_port)) {
            iport = icli_port.begin_iport;

            if (port_isid_port_no_is_stack(isid, iport)) {
                psrc[iport] = prcv[iport] = pina[iport] = FALSE;
                continue;
            }

            if (prole->ports[iport] == MVR_PORT_ROLE_SOURC) {
                fsrc = psrc[iport] = TRUE;
                prcv[iport] = pina[iport] = FALSE;
            } else if (prole->ports[iport] == MVR_PORT_ROLE_RECVR) {
                frcv = prcv[iport] = TRUE;
                psrc[iport] = pina[iport] = FALSE;
            } else {
                fina = pina[iport] = TRUE;
                psrc[iport] = prcv[iport] = FALSE;
            }
        }

        if (!fsrc && !frcv && !fina) {
            ICLI_PRINTF(" <Empty Port Table>");
        } else {
            BOOL    prted;

            prted = FALSE;
            memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
            icli_port.switch_id = icli_isid2switchid(isid);
            while (fsrc && icli_switch_port_get_next(&icli_port)) {
                if (psrc[icli_port.begin_iport]) {
                    memset(portString, 0x0, sizeof(portString));
                    ICLI_PRINTF("%s%s",
                                prted ? "," : "\nSource Port  : ",
                                icli_port_info_txt_short(icli_port.usid, icli_port.begin_uport, portString));
                    prted = TRUE;
                }
            }

            prted = FALSE;
            memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
            icli_port.switch_id = icli_isid2switchid(isid);
            while (frcv && icli_switch_port_get_next(&icli_port)) {
                if (prcv[icli_port.begin_iport]) {
                    memset(portString, 0x0, sizeof(portString));
                    ICLI_PRINTF("%s%s",
                                prted ? "," : "\nReceiver Port: ",
                                icli_port_info_txt_short(icli_port.usid, icli_port.begin_uport, portString));
                    prted = TRUE;
                }
            }

            prted = FALSE;
            memset(&icli_port, 0x0, sizeof(icli_switch_port_range_t));
            icli_port.switch_id = icli_isid2switchid(isid);
            while (fina && icli_switch_port_get_next(&icli_port)) {
                if (pina[icli_port.begin_iport]) {
                    memset(portString, 0x0, sizeof(portString));
                    ICLI_PRINTF("%s%s",
                                prted ? "," : "\nInactive Port: ",
                                icli_port_info_txt_short(icli_port.usid, icli_port.begin_uport, portString));
                    prted = TRUE;
                }
            }
        }
        ICLI_PRINTF("\n\r");
    }

    /* MVR Interface Channel */
    ICLI_PRINTF("Interface Channel Profile:");
    if (mvrif && mvrif->profile_index) {
        ipmc_lib_profile_mem_t  *pfm;

        if (IPMC_MEM_PROFILE_MTAKE(pfm)) {
            ipmc_lib_grp_fltr_profile_t *fltr_profile;

            fltr_profile = &pfm->profile;
            fltr_profile->data.index = mvrif->profile_index;
            if (ipmc_lib_mgmt_fltr_profile_get(fltr_profile, FALSE) != VTSS_OK) {
                ICLI_PRINTF(" <No Such Profile!>");
            } else {
                int pf_strlen = strlen(fltr_profile->data.name);

                if (pf_strlen) {
                    ICLI_PRINTF(" %s", fltr_profile->data.name);

                    _icli_ipmc_mvr_channel_show(session_id, fltr_profile, detail);
                } else {
                    ICLI_PRINTF(" <No Profile Name!>");
                }
            }

            IPMC_MEM_PROFILE_MGIVE(pfm);
        } else {
            ICLI_PRINTF(" <Error Displaying Profile!>");
        }
    } else {
        ICLI_PRINTF(" <No Associated Profile>");
    }
    ICLI_PRINTF("\n\r");

    return TRUE;
}

static void _icli_ipmc_mvr_intf_statistics_display(u32 session_id,
                                                   icli_unsigned_range_t *vlist,
                                                   i8 *vname,
                                                   BOOL detail)
{
    switch_iter_t                   sit;
    vtss_usid_t                     usid;
    vtss_isid_t                     isid;
    ipmc_ip_version_t               version;
    BOOL                            prt_title;
    BOOL                            ctrl;
    mvr_mgmt_interface_t            mvr_icli_intf;
    ipmc_prot_intf_entry_param_t    param;

    if (mvr_mgmt_get_mode(&ctrl) != VTSS_OK) {
        ctrl = FALSE;
    }

    (void) switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_USID);
    while (switch_iter_getnext(&sit)) {
        isid = sit.isid;
        usid = sit.usid;

        if (vlist) {
            u32         idx;
            vtss_vid_t  vidx, bnd;

            prt_title = TRUE;
            for (idx = 0; idx < vlist->cnt; idx++) {
                bnd = vlist->range[idx].max;
                for (vidx = vlist->range[idx].min; vidx <= bnd; vidx++) {
                    version = IPMC_IP_VERSION_IGMP;
                    mvr_icli_intf.vid = vidx;
                    if (mvr_mgmt_get_intf_entry(isid, &mvr_icli_intf) != VTSS_OK) {
                        ICLI_PRINTF("%% Invalid MVR %s VLAN %u.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    vidx);
                        continue;
                    }

                    memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                    param.vid = vidx;
                    if (mvr_mgmt_get_intf_info(isid, version, &param) != VTSS_OK) {
                        continue;
                    }

                    if (prt_title) {
                        ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                    usid,
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        prt_title = FALSE;
                    }

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    vidx);
                    }
                }
            }

            prt_title = TRUE;
            for (idx = 0; idx < vlist->cnt; idx++) {
                bnd = vlist->range[idx].max;
                for (vidx = vlist->range[idx].min; vidx <= bnd; vidx++) {
                    version = IPMC_IP_VERSION_MLD;
                    mvr_icli_intf.vid = vidx;
                    if (mvr_mgmt_get_intf_entry(isid, &mvr_icli_intf) != VTSS_OK) {
                        ICLI_PRINTF("%% Invalid MVR %s VLAN %u.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    vidx);
                        continue;
                    }

                    memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                    param.vid = vidx;
                    if (mvr_mgmt_get_intf_info(isid, version, &param) != VTSS_OK) {
                        continue;
                    }

                    if (prt_title) {
                        ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                    usid,
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        prt_title = FALSE;
                    }

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    vidx);
                    }
                }
            }
        } else if (vname) {
            if (strlen(vname)) {
                memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
                strncpy(mvr_icli_intf.intf.name, vname, strlen(vname));
                if (mvr_mgmt_get_intf_entry_by_name(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid MVR VLAN %s.\n\n", vname);
                    return;
                }

                memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                version = IPMC_IP_VERSION_IGMP;
                param.vid = mvr_icli_intf.vid;
                if (mvr_mgmt_get_intf_info(isid, version, &param) == VTSS_OK) {
                    ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                usid,
                                ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    mvr_icli_intf.vid);
                    }
                }

                memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                version = IPMC_IP_VERSION_MLD;
                param.vid = mvr_icli_intf.vid;
                if (mvr_mgmt_get_intf_info(isid, version, &param) == VTSS_OK) {
                    ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                usid,
                                ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    mvr_icli_intf.vid);
                    }
                }
            } else {
                ICLI_PRINTF("%% Invalid operation.\n\n");
            }
        } else {
            prt_title = TRUE;
            memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
            while (mvr_mgmt_get_next_intf_entry(isid, &mvr_icli_intf) == VTSS_OK) {
                memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                version = IPMC_IP_VERSION_IGMP;
                param.vid = mvr_icli_intf.vid;
                if (mvr_mgmt_get_intf_info(isid, version, &param) == VTSS_OK) {
                    if (prt_title) {
                        ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                    usid,
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        prt_title = FALSE;
                    }

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    mvr_icli_intf.vid);
                    }
                }
            }

            prt_title = TRUE;
            memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
            while (mvr_mgmt_get_next_intf_entry(isid, &mvr_icli_intf) == VTSS_OK) {
                memset(&param, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
                version = IPMC_IP_VERSION_MLD;
                param.vid = mvr_icli_intf.vid;
                if (mvr_mgmt_get_intf_info(isid, version, &param) == VTSS_OK) {
                    if (prt_title) {
                        ICLI_PRINTF("\nSwitch-%u MVR-%s Interface Status\n",
                                    usid,
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        prt_title = FALSE;
                    }

                    if (!_icli_ipmc_mvr_intf_status_show(version, session_id, isid,
                                                         ctrl, TRUE,
                                                         &mvr_icli_intf,
                                                         &param,
                                                         detail)) {
                        ICLI_PRINTF("%% Failed to display MVR %s VLAN %u statistics.\n\n",
                                    ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER),
                                    mvr_icli_intf.vid);
                    }
                }
            }
        }
    }
}

static BOOL _icli_ipmc_mvr_intf_set(mvr_mgmt_interface_t *entry,
                                    BOOL mode, BOOL priv, BOOL adr4, BOOL prit, BOOL lmqi,
                                    i32 val,
                                    i32 atr)
{
    mvr_conf_intf_entry_t   *mvif;

    if (!entry) {
        return FALSE;
    }

    mvif = &entry->intf;
    if (mode) {
        mvif->mode = atr;
    } else if (priv) {
        mvif->priority = (val & 0xFF);
    } else if (adr4) {
        mvif->querier4_address = val;
    } else if (prit) {
        mvif->vtag = atr;
    } else if (lmqi) {
        mvif->last_listener_query_interval = val;
    } else {
        return FALSE;
    }

    return (mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_SET, entry) == VTSS_OK);
}

static BOOL icli_ipmc_mvr_intf_config(u32 session_id,
                                      BOOL chklist,
                                      icli_unsigned_range_t *vlist,
                                      BOOL chkname,
                                      i8 *vname,
                                      BOOL mode, BOOL priv, BOOL adr4, BOOL prit, BOOL lmqi,
                                      i32 val, i32 atr)
{
    mvr_mgmt_interface_t    mvr_icli_intf;

    if ((chklist && !vlist) ||
        (chkname && !vname)) {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    if (chklist && vlist) {
        u32         idx;
        vtss_vid_t  vidx, bnd;

        for (idx = 0; idx < vlist->cnt; idx++) {
            bnd = vlist->range[idx].max;
            for (vidx = vlist->range[idx].min; vidx <= bnd; vidx++) {
                mvr_icli_intf.vid = vidx;
                if (mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid MVR VLAN ID %u.\n\n", vidx);
                    continue;
                }

                if (!_icli_ipmc_mvr_intf_set(&mvr_icli_intf, mode, priv, adr4, prit, lmqi, val, atr)) {
                    ICLI_PRINTF("%% Invalid parameter operation on MVR VLAN %u.\n\n", vidx);
                }
            }
        }
    } else if (chkname && vname && strlen(vname)) {
        memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
        strncpy(mvr_icli_intf.intf.name, vname, strlen(vname));
        if (mvr_mgmt_get_intf_entry_by_name(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
            ICLI_PRINTF("%% Invalid MVR VLAN %s.\n\n", vname);
            return FALSE;
        }

        if (!_icli_ipmc_mvr_intf_set(&mvr_icli_intf, mode, priv, adr4, prit, lmqi, val, atr)) {
            ICLI_PRINTF("%% Invalid parameter operation on MVR VLAN %s.\n\n", vname);
            return FALSE;
        }
    } else {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    return TRUE;
}

static BOOL icli_ipmc_mvr_channel_config(u32 session_id,
                                         BOOL do_del,
                                         BOOL chklist,
                                         icli_unsigned_range_t *vlist,
                                         BOOL chkvid,
                                         vtss_vid_t mvid,
                                         BOOL chkname,
                                         i8 *vname,
                                         i8 *channel)
{
    vtss_rc                     mvr_icli_rc;
    mvr_mgmt_interface_t        mvr_icli_intf;
    mvr_conf_intf_entry_t       *mvif;
    ipmc_lib_profile_mem_t      *pfm;
    ipmc_lib_grp_fltr_profile_t *fltr_profile;

    if ((chklist && !vlist) ||
        (chkname && !vname) ||
        (!do_del && !channel)) {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    if (chklist && vlist) {
        u32         idx;
        vtss_vid_t  vidx, bnd;

        for (idx = 0; idx < vlist->cnt; idx++) {
            bnd = vlist->range[idx].max;
            for (vidx = vlist->range[idx].min; vidx <= bnd; vidx++) {
                mvr_icli_intf.vid = vidx;
                if (mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid MVR VLAN ID %u.\n\n", vidx);
                    continue;
                }

                mvif = &mvr_icli_intf.intf;
                if (do_del) {
                    mvif->profile_index = MVR_CONF_DEF_INTF_PROFILE;
                } else {
                    if (channel && strlen(channel) && IPMC_MEM_PROFILE_MTAKE(pfm)) {
                        fltr_profile = &pfm->profile;
                        memset(fltr_profile, 0x0, sizeof(ipmc_lib_grp_fltr_profile_t));
                        strncpy(fltr_profile->data.name, channel, strlen(channel));
                        if (ipmc_lib_mgmt_fltr_profile_get(fltr_profile, TRUE) != VTSS_OK) {
                            ICLI_PRINTF("%% Please specify correct filter profile name.\n\n");
                            IPMC_MEM_PROFILE_MGIVE(pfm);
                            return FALSE;
                        }

                        mvif->profile_index = fltr_profile->data.index;
                        IPMC_MEM_PROFILE_MGIVE(pfm);
                    } else {
                        ICLI_PRINTF("%% Invalid channel operation on MVR VLAN %u.\n\n", vidx);
                        continue;
                    }
                }

                mvr_icli_rc = mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_SET, &mvr_icli_intf);
                if (mvr_icli_rc != VTSS_OK) {
                    if (mvr_icli_rc == IPMC_ERROR_ENTRY_OVERLAPPED) {
                        ICLI_PRINTF("%% Expected profile has overlapped addresses used in other MVR VLAN.\n\n");
                    } else {
                        if (mvr_icli_rc == IPMC_ERROR_ENTRY_NOT_FOUND) {
                            ICLI_PRINTF("%% Expected profile does not exist.\n\n");
                        }
                    }

                    return FALSE;
                }
            }
        }
    } else if ((chkname && vname) || (chkvid && (mvid != VTSS_IPMC_VID_NULL))) {
        if (chkname && vname && strlen(vname)) {
            memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
            strncpy(mvr_icli_intf.intf.name, vname, strlen(vname));
            mvr_icli_rc = mvr_mgmt_get_intf_entry_by_name(VTSS_ISID_GLOBAL, &mvr_icli_intf);
        } else if (chkvid && (mvid != VTSS_IPMC_VID_NULL)) {
            mvr_icli_intf.vid = mvid;
            mvr_icli_rc = mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf);
        } else {
            mvr_icli_rc = VTSS_RC_ERROR;
        }
        if (mvr_icli_rc != VTSS_OK) {
            ICLI_PRINTF("%% Invalid operation.\n\n");
            return FALSE;
        }

        mvif = &mvr_icli_intf.intf;
        if (do_del) {
            mvif->profile_index = MVR_CONF_DEF_INTF_PROFILE;
        } else {
            if (channel && strlen(channel) && IPMC_MEM_PROFILE_MTAKE(pfm)) {
                fltr_profile = &pfm->profile;
                memset(fltr_profile, 0x0, sizeof(ipmc_lib_grp_fltr_profile_t));
                strncpy(fltr_profile->data.name, channel, strlen(channel));
                if (ipmc_lib_mgmt_fltr_profile_get(fltr_profile, TRUE) != VTSS_OK) {
                    ICLI_PRINTF("%% Please specify correct filter profile name.\n\n");
                    IPMC_MEM_PROFILE_MGIVE(pfm);
                    return FALSE;
                }

                mvif->profile_index = fltr_profile->data.index;
                IPMC_MEM_PROFILE_MGIVE(pfm);
            } else {
                ICLI_PRINTF("%% Invalid channel operation on MVR VLAN %u.\n\n", mvif->vid);
                return FALSE;
            }
        }

        mvr_icli_rc = mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_SET, &mvr_icli_intf);
        if (mvr_icli_rc != VTSS_OK) {
            if (mvr_icli_rc == IPMC_ERROR_ENTRY_OVERLAPPED) {
                ICLI_PRINTF("%% Expected profile has overlapped addresses used in other MVR VLAN.\n\n");
            } else {
                if (mvr_icli_rc == IPMC_ERROR_ENTRY_NOT_FOUND) {
                    ICLI_PRINTF("%% Expected profile does not exist.\n\n");
                }
            }

            return FALSE;
        }
    } else {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    return TRUE;
}

static BOOL icli_ipmc_mvr_vlan_port_role_set(u32 session_id,
                                             icli_stack_port_range_t *plist,
                                             mvr_port_role_t val,
                                             BOOL chklist,
                                             icli_unsigned_range_t *vlist,
                                             BOOL chkname,
                                             i8 *vname)
{
    u32                         rdx;
    u16                         idx, bgn, cnt;
    vtss_isid_t                 isid;
    vtss_uport_no_t             uport;
    vtss_port_no_t              iport;
    mvr_mgmt_interface_t        mvr_icli_intf;
    mvr_conf_port_role_t        *mvpr;

    if (!plist) {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    for (rdx = 0; rdx < plist->cnt; rdx++) {
        isid = topo_usid2isid(plist->switch_range[rdx].usid);
        cnt = plist->switch_range[rdx].port_cnt;
        bgn = plist->switch_range[rdx].begin_uport;
        for (idx = 0; idx < cnt; idx++) {
            uport = bgn + idx;
            iport = uport2iport(uport);
            if (port_isid_port_no_is_stack(isid, iport)) {
                continue;
            }

            if (chklist && vlist) {
                u32         mdx;
                vtss_vid_t  vidx, bnd;

                for (mdx = 0; mdx < vlist->cnt; mdx++) {
                    bnd = vlist->range[mdx].max;
                    for (vidx = vlist->range[mdx].min; vidx <= bnd; vidx++) {
                        mvr_icli_intf.vid = vidx;
                        if (mvr_mgmt_get_intf_entry(isid, &mvr_icli_intf) != VTSS_OK) {
                            ICLI_PRINTF("%% Invalid MVR VLAN ID %u.\n\n", vidx);
                            continue;
                        }

                        mvpr = &mvr_icli_intf.role;
                        mvpr->ports[iport] = val;

                        if (mvr_mgmt_set_intf_entry(isid, IPMC_OP_SET, &mvr_icli_intf) != VTSS_OK) {
                            ICLI_PRINTF("%% Invalid operation on setting MVR port %u role.\n\n", uport);
                        }
                    }
                }
            } else if (chkname && vname && strlen(vname)) {
                memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
                strncpy(mvr_icli_intf.intf.name, vname, strlen(vname));
                if (mvr_mgmt_get_intf_entry_by_name(isid, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid MVR VLAN %s.\n\n", vname);
                    return FALSE;
                }

                mvpr = &mvr_icli_intf.role;
                mvpr->ports[iport] = val;

                if (mvr_mgmt_set_intf_entry(isid, IPMC_OP_SET, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid operation on setting MVR port %u role.\n\n", uport);
                }
            } else {
                ICLI_PRINTF("%% Invalid operation.\n\n");
                return FALSE;
            }
        }
    }

    return TRUE;
}

static BOOL _icli_ipmc_mvr_immediate_leave_set(u32 session_id, icli_stack_port_range_t *plist, BOOL state)
{
    u32                         rdx;
    u16                         idx, bgn, cnt;
    vtss_isid_t                 isid;
    vtss_port_no_t              iport;
    mvr_conf_fast_leave_t       icli_ipmcmvr_imd_leave;

    if (!plist) {
        ICLI_PRINTF("%% Invalid operation.\n\n");
        return FALSE;
    }

    for (rdx = 0; rdx < plist->cnt; rdx++) {
        isid = topo_usid2isid(plist->switch_range[rdx].usid);
        if (mvr_mgmt_get_fast_leave_port(isid, &icli_ipmcmvr_imd_leave) != VTSS_OK) {
            continue;
        }

        cnt = plist->switch_range[rdx].port_cnt;
        bgn = plist->switch_range[rdx].begin_uport;
        for (idx = 0; idx < cnt; idx++) {
            iport = uport2iport(bgn + idx);
            if (port_isid_port_no_is_stack(isid, iport)) {
                continue;
            }

            VTSS_PORT_BF_SET(icli_ipmcmvr_imd_leave.ports, iport, state);
        }

        (void) mvr_mgmt_set_fast_leave_port(isid, &icli_ipmcmvr_imd_leave);
    }

    return TRUE;
}
//===== FUNCTION_END =========================================================

/*
******************************************************************************

    < auto-generation >
    strings of command, alias and help for each command

******************************************************************************
*/

//----- Command -----
static char icli_ipmc_mvr_vlan_port_role_config_idx_cmd[] =
    " mvr vlan <vlan_list> type { source | receiver } ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_port_role_config_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_port_role_config_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Source : option>", 0, {0, 0}},
    {"<Receiver : option>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_port_role_config_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_PORT_ROLE,
    "MVR source port",
    "MVR receiver port"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_port_role_config_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1211 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_port_role_config_idx_byword,
    icli_ipmc_mvr_vlan_port_role_config_idx_help,
    icli_ipmc_mvr_vlan_port_role_config_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_port_role_config_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_port_role_config_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_port_role_config_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_port_role_config_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_port_role_config_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_port_role_config_idx_register = {
    icli_ipmc_mvr_vlan_port_role_config_idx_cmd,
    "mvr vlan <vlan_list> type { source | receiver }", // original_cmd
    "mvr vlan <v_vlan_list> type { source | receiver } ", // var_cmd
    icli_ipmc_mvr_vlan_port_role_config_idx_node,
    6,
    &icli_ipmc_mvr_vlan_port_role_config_idx_property,
    &icli_ipmc_mvr_vlan_port_role_config_idx_execution,
#line 1214 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_port_role_config_nme_cmd[] =
    " mvr name <word16> type { source | receiver } ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_port_role_config_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_port_role_config_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_port_role_config_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Source : option>", 0, {0, 0}},
    {"<Receiver : option>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_port_role_config_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_PORT_ROLE,
    "MVR source port",
    "MVR receiver port"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_port_role_config_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1288 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_port_role_config_nme_byword,
    icli_ipmc_mvr_vlan_port_role_config_nme_help,
    icli_ipmc_mvr_vlan_port_role_config_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_port_role_config_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_port_role_config_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_port_role_config_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_port_role_config_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_port_role_config_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_port_role_config_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_port_role_config_nme_register = {
    icli_ipmc_mvr_vlan_port_role_config_nme_cmd,
    "mvr name <word16> type { source | receiver }", // original_cmd
    "mvr name <mvr_name> type { source | receiver } ", // var_cmd
    icli_ipmc_mvr_vlan_port_role_config_nme_node,
    6,
    &icli_ipmc_mvr_vlan_port_role_config_nme_property,
    &icli_ipmc_mvr_vlan_port_role_config_nme_execution,
#line 1291 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_port_role_clear_idx_cmd[] =
    " no mvr vlan <vlan_list> type ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_port_role_clear_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_port_role_clear_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_port_role_clear_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_PORT_ROLE
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_port_role_clear_idx_property = {
    0, // command ID, assigned when register
#line 1366 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 1365 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_port_role_clear_idx_byword,
    icli_ipmc_mvr_vlan_port_role_clear_idx_help,
    icli_ipmc_mvr_vlan_port_role_clear_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_port_role_clear_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_port_role_clear_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_port_role_clear_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_port_role_clear_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_port_role_clear_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_port_role_clear_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_port_role_clear_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_port_role_clear_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_port_role_clear_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_port_role_clear_idx_register = {
    icli_ipmc_mvr_vlan_port_role_clear_idx_cmd,
    "no mvr vlan <vlan_list> type", // original_cmd
    "no mvr vlan <v_vlan_list> type ", // var_cmd
    icli_ipmc_mvr_vlan_port_role_clear_idx_node,
    5,
    &icli_ipmc_mvr_vlan_port_role_clear_idx_property,
    &icli_ipmc_mvr_vlan_port_role_clear_idx_execution,
#line 1368 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_port_role_clear_nme_cmd[] =
    " no mvr name <word16> type ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_port_role_clear_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_port_role_clear_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_port_role_clear_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_port_role_clear_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_PORT_ROLE
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_port_role_clear_nme_property = {
    0, // command ID, assigned when register
#line 1429 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 1428 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_port_role_clear_nme_byword,
    icli_ipmc_mvr_vlan_port_role_clear_nme_help,
    icli_ipmc_mvr_vlan_port_role_clear_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_port_role_clear_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_port_role_clear_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_port_role_clear_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_port_role_clear_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_port_role_clear_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_port_role_clear_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_port_role_clear_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_port_role_clear_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_port_role_clear_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_port_role_clear_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_port_role_clear_nme_register = {
    icli_ipmc_mvr_vlan_port_role_clear_nme_cmd,
    "no mvr name <word16> type", // original_cmd
    "no mvr name <mvr_name> type ", // var_cmd
    icli_ipmc_mvr_vlan_port_role_clear_nme_node,
    5,
    &icli_ipmc_mvr_vlan_port_role_clear_nme_property,
    &icli_ipmc_mvr_vlan_port_role_clear_nme_execution,
#line 1431 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_immediate_leave_set_cmd[] =
    " mvr immediate-leave ";
static icli_runtime_cb_t *icli_ipmc_mvr_immediate_leave_set_runtime[] = {
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_immediate_leave_set_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_immediate_leave_set_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_IMD_LEAVE
};
static icli_cmd_property_t icli_ipmc_mvr_immediate_leave_set_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1496 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_immediate_leave_set_byword,
    icli_ipmc_mvr_immediate_leave_set_help,
    icli_ipmc_mvr_immediate_leave_set_runtime
};
static i32 icli_ipmc_mvr_immediate_leave_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_immediate_leave_set_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_immediate_leave_set, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_immediate_leave_set_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_immediate_leave_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_immediate_leave_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_immediate_leave_set_register = {
    icli_ipmc_mvr_immediate_leave_set_cmd,
    "mvr immediate-leave", // original_cmd
    "mvr immediate-leave ", // var_cmd
    icli_ipmc_mvr_immediate_leave_set_node,
    2,
    &icli_ipmc_mvr_immediate_leave_set_property,
    &icli_ipmc_mvr_immediate_leave_set_execution,
#line 1499 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_immediate_leave_set_no_cmd[] =
    " no mvr immediate-leave ";
static icli_runtime_cb_t *icli_ipmc_mvr_immediate_leave_set_no_runtime[] = {
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_immediate_leave_set_no_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_immediate_leave_set_no_help[] = {
    "Negate a command or set its defaults",
    ICLI_HELP_MVR,
    ICLI_HELP_IMD_LEAVE
};
static icli_cmd_property_t icli_ipmc_mvr_immediate_leave_set_no_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_LOOSELY, // command property
#line 1496 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_immediate_leave_set_no_byword,
    icli_ipmc_mvr_immediate_leave_set_no_help,
    icli_ipmc_mvr_immediate_leave_set_no_runtime
};
static i32 icli_ipmc_mvr_immediate_leave_set_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_immediate_leave_set_no_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_immediate_leave_set_no, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_immediate_leave_set_no_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_immediate_leave_set_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_immediate_leave_set_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_immediate_leave_set_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_immediate_leave_set_no_register = {
    icli_ipmc_mvr_immediate_leave_set_no_cmd,
    "no mvr immediate-leave", // original_cmd
    "no mvr immediate-leave ", // var_cmd
    icli_ipmc_mvr_immediate_leave_set_no_node,
    3,
    &icli_ipmc_mvr_immediate_leave_set_no_property,
    &icli_ipmc_mvr_immediate_leave_set_no_execution,
#line 1499 "mvr.icli"
    ICLI_CMD_MODE_INTERFACE_PORT_LIST // command mode
};


//----- Command -----
static char icli_ipmc_mvr_clear_statistics_cmd[] =
    " clear mvr [ vlan <vlan_list> | name <word16> ] statistics ";
static icli_runtime_cb_t *icli_ipmc_mvr_clear_statistics_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_clear_statistics_range_5 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_clear_statistics_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Vlan : option>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Name : option>", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"<Statistics : option>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_clear_statistics_help[] = {
    ICLI_HELP_CLEAR,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_STATISTICS
};
static icli_cmd_property_t icli_ipmc_mvr_clear_statistics_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1554 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_clear_statistics_byword,
    icli_ipmc_mvr_clear_statistics_help,
    icli_ipmc_mvr_clear_statistics_runtime
};
static i32 icli_ipmc_mvr_clear_statistics(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_clear_statistics_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_clear_statistics, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_clear_statistics_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_clear_statistics_range_5, // range
        {5, &icli_ipmc_mvr_clear_statistics_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        6, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 6, &icli_ipmc_mvr_clear_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_clear_statistics_register = {
    icli_ipmc_mvr_clear_statistics_cmd,
    "clear mvr [ vlan <vlan_list> | name <word16> ] statistics", // original_cmd
    "clear mvr [ vlan <v_vlan_list> | name <mvr_name> ] statistics ", // var_cmd
    icli_ipmc_mvr_clear_statistics_node,
    7,
    &icli_ipmc_mvr_clear_statistics_property,
    &icli_ipmc_mvr_clear_statistics_execution,
#line 1557 "mvr.icli"
    ICLI_CMD_MODE_EXEC // command mode
};


//----- Command -----
static char icli_ipmc_mvr_display_statistics_cmd[] =
    " show mvr [ vlan <vlan_list> | name <word16> ] [ group-database [ interface ( <port_type> [ <port_type_list> ] ) ] [ sfm-information ] ] [ detail ] { [ <grep> { <grep_begin> | <grep_include> | <grep_exclude> } <grep_string> ] } ";
static icli_runtime_cb_t *icli_ipmc_mvr_display_statistics_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
#line 1670 "mvr.icli"
    icli_ipmc_mvr_check_present,
#line 1671 "mvr.icli"
    icli_ipmc_mvr_check_present,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_display_statistics_range_5 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_display_statistics_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Vlan : option>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Name : option>", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"<GroupDatabase : option>", 0, {0, 0}},
    {"<Interface : option>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"PORT_LIST", 0, {0, 0}},
    {"<SfmInformation : option>", 0, {0, 0}},
    {"<Detail : option>", 0, {0, 0}},
    {"|", 0, {0, 0}},
    {"begin", 0, {0, 0}},
    {"include", 0, {0, 0}},
    {"exclude", 0, {0, 0}},
    {"LINE", 0, {0, 0}}
};
static char *icli_ipmc_mvr_display_statistics_help[] = {
    ICLI_HELP_SHOW,
    ICLI_HELP_MVR,
    "Search by VLAN",
    HELP_MVR_VLAN_LIST,
    "Search by MVR name",
    HELP_MVR_VLAN_NAME,
    HELP_GRP_DB,
    "Search by port",
    "Port type in Fast, Giga or Tengiga ethernet",
    "List of Port ID, ex, 1/1,3-5;2/2-4,6",
    HELP_GRP_DB_INC_SFM,
    HELP_GRP_DB_DETAIL,
    "Output modifiers",
    "Begin with the line that matches",
    "Include lines that match",
    "Exclude lines that match",
    "String to match output lines"
};
static icli_cmd_property_t icli_ipmc_mvr_display_statistics_property = {
    0, // command ID, assigned when register
#line 1656 "mvr.icli"
    ICLI_CMD_PROP_GREP, // command property
#line 1655 "mvr.icli"
    ICLI_PRIVILEGE_0, // privilege
    ICLI_PRIVILEGE_0, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_display_statistics_byword,
    icli_ipmc_mvr_display_statistics_help,
    icli_ipmc_mvr_display_statistics_runtime
};
static i32 icli_ipmc_mvr_display_statistics(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_display_statistics_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_display_statistics, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_display_statistics_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_display_statistics_range_5, // range
        {5, &icli_ipmc_mvr_display_statistics_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        6, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 6, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        7, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 7, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        8, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_PORT_TYPE, // type
        NULL, // range
        { 8, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        9, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_PORT_TYPE_LIST, // type
        NULL, // range
        { 9, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        10, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 10, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        11, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 11, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        12, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_GREP, // type
        NULL, // range
        { 12, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        13, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_GREP_BEGIN, // type
        NULL, // range
        { 13, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        14, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_GREP_INCLUDE, // type
        NULL, // range
        { 14, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        15, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_GREP_EXCLUDE, // type
        NULL, // range
        { 15, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        16, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_GREP_STRING, // type
        NULL, // range
        { 16, &icli_ipmc_mvr_display_statistics_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_display_statistics_register = {
    icli_ipmc_mvr_display_statistics_cmd,
    "show mvr [ vlan <vlan_list> | name <word16> ] [ group-database [ interface <port_type_list> ] [ sfm-information ] ] [ detail ]", // original_cmd
    "show mvr [ vlan <v_vlan_list> | name <mvr_name> ] [ group-database [ interface ( <port_type> [ <v_port_type_list> ] ) ] [ sfm-information ] ] [ detail ] ", // var_cmd
    icli_ipmc_mvr_display_statistics_node,
    17,
    &icli_ipmc_mvr_display_statistics_property,
    &icli_ipmc_mvr_display_statistics_execution,
#line 1658 "mvr.icli"
    ICLI_CMD_MODE_EXEC // command mode
};


//----- Command -----
static char icli_ipmc_mvr_ctrl_set_cmd[] =
    " mvr ";
static icli_runtime_cb_t *icli_ipmc_mvr_ctrl_set_runtime[] = {
    NULL
};
static icli_byword_t icli_ipmc_mvr_ctrl_set_byword[] = {
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_ctrl_set_help[] = {
    ICLI_HELP_MVR
};
static icli_cmd_property_t icli_ipmc_mvr_ctrl_set_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1861 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_ctrl_set_byword,
    icli_ipmc_mvr_ctrl_set_help,
    icli_ipmc_mvr_ctrl_set_runtime
};
static i32 icli_ipmc_mvr_ctrl_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_ctrl_set_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_ctrl_set, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_ctrl_set_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_ctrl_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_ctrl_set_register = {
    icli_ipmc_mvr_ctrl_set_cmd,
    "mvr", // original_cmd
    "mvr ", // var_cmd
    icli_ipmc_mvr_ctrl_set_node,
    1,
    &icli_ipmc_mvr_ctrl_set_property,
    &icli_ipmc_mvr_ctrl_set_execution,
#line 1864 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_ctrl_set_no_cmd[] =
    " no mvr ";
static icli_runtime_cb_t *icli_ipmc_mvr_ctrl_set_no_runtime[] = {
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_ctrl_set_no_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_ctrl_set_no_help[] = {
    "Negate a command or set its defaults",
    ICLI_HELP_MVR
};
static icli_cmd_property_t icli_ipmc_mvr_ctrl_set_no_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_LOOSELY, // command property
#line 1861 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_ctrl_set_no_byword,
    icli_ipmc_mvr_ctrl_set_no_help,
    icli_ipmc_mvr_ctrl_set_no_runtime
};
static i32 icli_ipmc_mvr_ctrl_set_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_ctrl_set_no_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_ctrl_set_no, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_ctrl_set_no_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_ctrl_set_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_ctrl_set_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_ctrl_set_no_register = {
    icli_ipmc_mvr_ctrl_set_no_cmd,
    "no mvr", // original_cmd
    "no mvr ", // var_cmd
    icli_ipmc_mvr_ctrl_set_no_node,
    2,
    &icli_ipmc_mvr_ctrl_set_no_property,
    &icli_ipmc_mvr_ctrl_set_no_execution,
#line 1864 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_intf_set_cmd[] =
    " mvr vlan <vlan_list> [ name <word16> ] ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_intf_set_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_intf_set_range_4 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_intf_set_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Name : option>", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_intf_set_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_intf_set_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 1919 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_intf_set_byword,
    icli_ipmc_mvr_vlan_intf_set_help,
    icli_ipmc_mvr_vlan_intf_set_runtime
};
static i32 icli_ipmc_mvr_vlan_intf_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_intf_set_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_intf_set, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_intf_set_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_intf_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_intf_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_intf_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_intf_set_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_intf_set_range_4, // range
        {4, &icli_ipmc_mvr_vlan_intf_set_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_intf_set_register = {
    icli_ipmc_mvr_vlan_intf_set_cmd,
    "mvr vlan <vlan_list> [ name <word16> ]", // original_cmd
    "mvr vlan <v_vlan_list> [ name <mvr_name> ] ", // var_cmd
    icli_ipmc_mvr_vlan_intf_set_node,
    5,
    &icli_ipmc_mvr_vlan_intf_set_property,
    &icli_ipmc_mvr_vlan_intf_set_execution,
#line 1922 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_intf_delete_cmd[] =
    " no mvr vlan <vlan_list> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_intf_delete_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_intf_delete_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_intf_delete_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_intf_delete_property = {
    0, // command ID, assigned when register
#line 2040 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2039 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_intf_delete_byword,
    icli_ipmc_mvr_vlan_intf_delete_help,
    icli_ipmc_mvr_vlan_intf_delete_runtime
};
static i32 icli_ipmc_mvr_vlan_intf_delete(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_intf_delete_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_intf_delete, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_intf_delete_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_intf_delete_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_intf_delete_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_intf_delete_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_intf_delete_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_intf_delete_register = {
    icli_ipmc_mvr_vlan_intf_delete_cmd,
    "no mvr vlan <vlan_list>", // original_cmd
    "no mvr vlan <v_vlan_list> ", // var_cmd
    icli_ipmc_mvr_vlan_intf_delete_node,
    4,
    &icli_ipmc_mvr_vlan_intf_delete_property,
    &icli_ipmc_mvr_vlan_intf_delete_execution,
#line 2042 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_mode_set_idx_cmd[] =
    " mvr vlan <vlan_list> mode { dynamic | compatible } ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_mode_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_mode_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Dynamic : option>", 0, {0, 0}},
    {"<Compatible : option>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_mode_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_MODE,
    "Dynamic MVR operation mode",
    "Compatible MVR operation mode"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_mode_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2112 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_mode_set_idx_byword,
    icli_ipmc_mvr_vlan_mode_set_idx_help,
    icli_ipmc_mvr_vlan_mode_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_mode_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_mode_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_mode_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_mode_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_mode_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_mode_set_idx_register = {
    icli_ipmc_mvr_vlan_mode_set_idx_cmd,
    "mvr vlan <vlan_list> mode { dynamic | compatible }", // original_cmd
    "mvr vlan <v_vlan_list> mode { dynamic | compatible } ", // var_cmd
    icli_ipmc_mvr_vlan_mode_set_idx_node,
    6,
    &icli_ipmc_mvr_vlan_mode_set_idx_property,
    &icli_ipmc_mvr_vlan_mode_set_idx_execution,
#line 2115 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_mode_set_nme_cmd[] =
    " mvr name <word16> mode { dynamic | compatible } ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_mode_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_mode_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_mode_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<Dynamic : option>", 0, {0, 0}},
    {"<Compatible : option>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_mode_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_MODE,
    "Dynamic MVR operation mode",
    "Compatible MVR operation mode"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_mode_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2190 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_mode_set_nme_byword,
    icli_ipmc_mvr_vlan_mode_set_nme_help,
    icli_ipmc_mvr_vlan_mode_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_mode_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_mode_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_mode_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_mode_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_mode_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_mode_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_mode_set_nme_register = {
    icli_ipmc_mvr_vlan_mode_set_nme_cmd,
    "mvr name <word16> mode { dynamic | compatible }", // original_cmd
    "mvr name <mvr_name> mode { dynamic | compatible } ", // var_cmd
    icli_ipmc_mvr_vlan_mode_set_nme_node,
    6,
    &icli_ipmc_mvr_vlan_mode_set_nme_property,
    &icli_ipmc_mvr_vlan_mode_set_nme_execution,
#line 2193 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_mode_default_idx_cmd[] =
    " no mvr vlan <vlan_list> mode ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_mode_default_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_mode_default_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_mode_default_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_MODE
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_mode_default_idx_property = {
    0, // command ID, assigned when register
#line 2269 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2268 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_mode_default_idx_byword,
    icli_ipmc_mvr_vlan_mode_default_idx_help,
    icli_ipmc_mvr_vlan_mode_default_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_mode_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_mode_default_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_mode_default_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_mode_default_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_mode_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_mode_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_mode_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_mode_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_mode_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_mode_default_idx_register = {
    icli_ipmc_mvr_vlan_mode_default_idx_cmd,
    "no mvr vlan <vlan_list> mode", // original_cmd
    "no mvr vlan <v_vlan_list> mode ", // var_cmd
    icli_ipmc_mvr_vlan_mode_default_idx_node,
    5,
    &icli_ipmc_mvr_vlan_mode_default_idx_property,
    &icli_ipmc_mvr_vlan_mode_default_idx_execution,
#line 2271 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_mode_default_nme_cmd[] =
    " no mvr name <word16> mode ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_mode_default_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_mode_default_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_mode_default_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_mode_default_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_MODE
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_mode_default_nme_property = {
    0, // command ID, assigned when register
#line 2333 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2332 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_mode_default_nme_byword,
    icli_ipmc_mvr_vlan_mode_default_nme_help,
    icli_ipmc_mvr_vlan_mode_default_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_mode_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_mode_default_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_mode_default_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_mode_default_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_mode_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_mode_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_mode_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_mode_default_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_mode_default_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_mode_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_mode_default_nme_register = {
    icli_ipmc_mvr_vlan_mode_default_nme_cmd,
    "no mvr name <word16> mode", // original_cmd
    "no mvr name <mvr_name> mode ", // var_cmd
    icli_ipmc_mvr_vlan_mode_default_nme_node,
    5,
    &icli_ipmc_mvr_vlan_mode_default_nme_property,
    &icli_ipmc_mvr_vlan_mode_default_nme_execution,
#line 2335 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_querier_adrs_set_idx_cmd[] =
    " mvr vlan <vlan_list> igmp-address <ipv4_ucast> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_querier_adrs_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_querier_adrs_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_querier_adrs_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_QUERIER_ADR,
    "A valid IPv4 unicast address"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_querier_adrs_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2396 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_querier_adrs_set_idx_byword,
    icli_ipmc_mvr_vlan_querier_adrs_set_idx_help,
    icli_ipmc_mvr_vlan_querier_adrs_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_querier_adrs_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_querier_adrs_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_querier_adrs_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_querier_adrs_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_IPV4_UCAST, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_querier_adrs_set_idx_register = {
    icli_ipmc_mvr_vlan_querier_adrs_set_idx_cmd,
    "mvr vlan <vlan_list> igmp-address <ipv4_ucast>", // original_cmd
    "mvr vlan <v_vlan_list> igmp-address <v_ipv4_ucast> ", // var_cmd
    icli_ipmc_mvr_vlan_querier_adrs_set_idx_node,
    5,
    &icli_ipmc_mvr_vlan_querier_adrs_set_idx_property,
    &icli_ipmc_mvr_vlan_querier_adrs_set_idx_execution,
#line 2399 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_querier_adrs_set_nme_cmd[] =
    " mvr name <word16> igmp-address <ipv4_ucast> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_querier_adrs_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_querier_adrs_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_querier_adrs_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_querier_adrs_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_QUERIER_ADR,
    "A valid IPv4 unicast address"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_querier_adrs_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2460 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_querier_adrs_set_nme_byword,
    icli_ipmc_mvr_vlan_querier_adrs_set_nme_help,
    icli_ipmc_mvr_vlan_querier_adrs_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_querier_adrs_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_querier_adrs_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_querier_adrs_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_querier_adrs_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_querier_adrs_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_IPV4_UCAST, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_querier_adrs_set_nme_register = {
    icli_ipmc_mvr_vlan_querier_adrs_set_nme_cmd,
    "mvr name <word16> igmp-address <ipv4_ucast>", // original_cmd
    "mvr name <mvr_name> igmp-address <v_ipv4_ucast> ", // var_cmd
    icli_ipmc_mvr_vlan_querier_adrs_set_nme_node,
    5,
    &icli_ipmc_mvr_vlan_querier_adrs_set_nme_property,
    &icli_ipmc_mvr_vlan_querier_adrs_set_nme_execution,
#line 2463 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_querier_adrs_default_idx_cmd[] =
    " no mvr vlan <vlan_list> igmp-address ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_querier_adrs_default_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_querier_adrs_default_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_querier_adrs_default_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_QUERIER_ADR
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_querier_adrs_default_idx_property = {
    0, // command ID, assigned when register
#line 2525 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2524 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_querier_adrs_default_idx_byword,
    icli_ipmc_mvr_vlan_querier_adrs_default_idx_help,
    icli_ipmc_mvr_vlan_querier_adrs_default_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_querier_adrs_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_querier_adrs_default_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_querier_adrs_default_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_querier_adrs_default_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_querier_adrs_default_idx_register = {
    icli_ipmc_mvr_vlan_querier_adrs_default_idx_cmd,
    "no mvr vlan <vlan_list> igmp-address", // original_cmd
    "no mvr vlan <v_vlan_list> igmp-address ", // var_cmd
    icli_ipmc_mvr_vlan_querier_adrs_default_idx_node,
    5,
    &icli_ipmc_mvr_vlan_querier_adrs_default_idx_property,
    &icli_ipmc_mvr_vlan_querier_adrs_default_idx_execution,
#line 2527 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_querier_adrs_default_nme_cmd[] =
    " no mvr name <word16> igmp-address ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_querier_adrs_default_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_querier_adrs_default_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_querier_adrs_default_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_querier_adrs_default_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_QUERIER_ADR
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_querier_adrs_default_nme_property = {
    0, // command ID, assigned when register
#line 2589 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2588 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_querier_adrs_default_nme_byword,
    icli_ipmc_mvr_vlan_querier_adrs_default_nme_help,
    icli_ipmc_mvr_vlan_querier_adrs_default_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_querier_adrs_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_querier_adrs_default_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_querier_adrs_default_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_querier_adrs_default_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_querier_adrs_default_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_querier_adrs_default_nme_register = {
    icli_ipmc_mvr_vlan_querier_adrs_default_nme_cmd,
    "no mvr name <word16> igmp-address", // original_cmd
    "no mvr name <mvr_name> igmp-address ", // var_cmd
    icli_ipmc_mvr_vlan_querier_adrs_default_nme_node,
    5,
    &icli_ipmc_mvr_vlan_querier_adrs_default_nme_property,
    &icli_ipmc_mvr_vlan_querier_adrs_default_nme_execution,
#line 2591 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_priority_set_idx_cmd[] =
    " mvr vlan <vlan_list> frame priority <0-7> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_priority_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_frame_priority_set_idx_range_5 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 7 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_priority_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<CosPriority : 0-7>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_priority_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_VLAN_FRAME,
    ICLI_HELP_INTF_PRI,
    "CoS priority ranges from 0 to 7"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_priority_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2652 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_priority_set_idx_byword,
    icli_ipmc_mvr_vlan_frame_priority_set_idx_help,
    icli_ipmc_mvr_vlan_frame_priority_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_priority_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_priority_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_priority_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_priority_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_UINT, // type
        &icli_ipmc_mvr_vlan_frame_priority_set_idx_range_5, // range
        {5, &icli_ipmc_mvr_vlan_frame_priority_set_idx_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_priority_set_idx_register = {
    icli_ipmc_mvr_vlan_frame_priority_set_idx_cmd,
    "mvr vlan <vlan_list> frame priority <0-7>", // original_cmd
    "mvr vlan <v_vlan_list> frame priority <cos_priority> ", // var_cmd
    icli_ipmc_mvr_vlan_frame_priority_set_idx_node,
    6,
    &icli_ipmc_mvr_vlan_frame_priority_set_idx_property,
    &icli_ipmc_mvr_vlan_frame_priority_set_idx_execution,
#line 2655 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_tagged_set_idx_cmd[] =
    " mvr vlan <vlan_list> frame tagged ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_tagged_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_tagged_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_VLAN_FRAME,
    "Tagged IGMP/MLD frames will be sent"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2725 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_byword,
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_help,
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_tagged_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_tagged_set_idx_register = {
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_cmd,
    "mvr vlan <vlan_list> frame tagged", // original_cmd
    "mvr vlan <v_vlan_list> frame tagged ", // var_cmd
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_node,
    5,
    &icli_ipmc_mvr_vlan_frame_tagged_set_idx_property,
    &icli_ipmc_mvr_vlan_frame_tagged_set_idx_execution,
#line 2728 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_cmd[] =
    " no mvr vlan <vlan_list> frame tagged ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_help[] = {
    "Negate a command or set its defaults",
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_VLAN_FRAME,
    "Tagged IGMP/MLD frames will be sent"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2725 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_byword,
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_help,
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_idx_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_register = {
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_cmd,
    "no mvr vlan <vlan_list> frame tagged", // original_cmd
    "no mvr vlan <v_vlan_list> frame tagged ", // var_cmd
    icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_node,
    6,
    &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_property,
    &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_execution,
#line 2728 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_priority_set_nme_cmd[] =
    " mvr name <word16> frame priority <0-7> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_priority_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_frame_priority_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_range_t icli_ipmc_mvr_vlan_frame_priority_set_nme_range_5 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 7 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_priority_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<CosPriority : 0-7>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_priority_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_VLAN_FRAME,
    ICLI_HELP_INTF_PRI,
    "CoS priority ranges from 0 to 7"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_priority_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2803 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_priority_set_nme_byword,
    icli_ipmc_mvr_vlan_frame_priority_set_nme_help,
    icli_ipmc_mvr_vlan_frame_priority_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_priority_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_priority_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_priority_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_priority_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_frame_priority_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_UINT, // type
        &icli_ipmc_mvr_vlan_frame_priority_set_nme_range_5, // range
        {5, &icli_ipmc_mvr_vlan_frame_priority_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_priority_set_nme_register = {
    icli_ipmc_mvr_vlan_frame_priority_set_nme_cmd,
    "mvr name <word16> frame priority <0-7>", // original_cmd
    "mvr name <mvr_name> frame priority <cos_priority> ", // var_cmd
    icli_ipmc_mvr_vlan_frame_priority_set_nme_node,
    6,
    &icli_ipmc_mvr_vlan_frame_priority_set_nme_property,
    &icli_ipmc_mvr_vlan_frame_priority_set_nme_execution,
#line 2806 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_tagged_set_nme_cmd[] =
    " mvr name <word16> frame tagged ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_tagged_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_tagged_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_VLAN_FRAME,
    "Tagged IGMP/MLD frames will be sent"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 2876 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_byword,
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_help,
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_tagged_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_frame_tagged_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_tagged_set_nme_register = {
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_cmd,
    "mvr name <word16> frame tagged", // original_cmd
    "mvr name <mvr_name> frame tagged ", // var_cmd
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_node,
    5,
    &icli_ipmc_mvr_vlan_frame_tagged_set_nme_property,
    &icli_ipmc_mvr_vlan_frame_tagged_set_nme_execution,
#line 2879 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_cmd[] =
    " no mvr name <word16> frame tagged ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_help[] = {
    "Negate a command or set its defaults",
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_VLAN_FRAME,
    "Tagged IGMP/MLD frames will be sent"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2876 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_byword,
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_help,
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_nme_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_range_3, // range
        {3, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_register = {
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_cmd,
    "no mvr name <word16> frame tagged", // original_cmd
    "no mvr name <mvr_name> frame tagged ", // var_cmd
    icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_node,
    6,
    &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_property,
    &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_execution,
#line 2879 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_priroity_default_idx_cmd[] =
    " no mvr vlan <vlan_list> frame priority ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_priroity_default_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_priroity_default_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_priroity_default_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_VLAN_FRAME,
    ICLI_HELP_INTF_PRI
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_priroity_default_idx_property = {
    0, // command ID, assigned when register
#line 2955 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 2954 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_priroity_default_idx_byword,
    icli_ipmc_mvr_vlan_frame_priroity_default_idx_help,
    icli_ipmc_mvr_vlan_frame_priroity_default_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_priroity_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_priroity_default_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_priroity_default_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_priroity_default_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_priroity_default_idx_register = {
    icli_ipmc_mvr_vlan_frame_priroity_default_idx_cmd,
    "no mvr vlan <vlan_list> frame priority", // original_cmd
    "no mvr vlan <v_vlan_list> frame priority ", // var_cmd
    icli_ipmc_mvr_vlan_frame_priroity_default_idx_node,
    6,
    &icli_ipmc_mvr_vlan_frame_priroity_default_idx_property,
    &icli_ipmc_mvr_vlan_frame_priroity_default_idx_execution,
#line 2957 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_frame_priroity_default_nme_cmd[] =
    " no mvr name <word16> frame priority ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_frame_priroity_default_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_frame_priroity_default_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_frame_priroity_default_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_frame_priroity_default_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_VLAN_FRAME,
    ICLI_HELP_INTF_PRI
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_frame_priroity_default_nme_property = {
    0, // command ID, assigned when register
#line 3023 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 3022 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_frame_priroity_default_nme_byword,
    icli_ipmc_mvr_vlan_frame_priroity_default_nme_help,
    icli_ipmc_mvr_vlan_frame_priroity_default_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_frame_priroity_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_frame_priroity_default_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_frame_priroity_default_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_frame_priroity_default_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_frame_priroity_default_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        5, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 5, &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_frame_priroity_default_nme_register = {
    icli_ipmc_mvr_vlan_frame_priroity_default_nme_cmd,
    "no mvr name <word16> frame priority", // original_cmd
    "no mvr name <mvr_name> frame priority ", // var_cmd
    icli_ipmc_mvr_vlan_frame_priroity_default_nme_node,
    6,
    &icli_ipmc_mvr_vlan_frame_priroity_default_nme_property,
    &icli_ipmc_mvr_vlan_frame_priroity_default_nme_execution,
#line 3025 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_lmqi_set_idx_cmd[] =
    " mvr vlan <vlan_list> last-member-query-interval <0-31744> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_lmqi_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_lmqi_set_idx_range_4 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 31744 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_lmqi_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<IpmcLmqi : 0-31744>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_lmqi_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    ICLI_HELP_INTF_LMQI,
    "0 - 31744 tenths of seconds"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_lmqi_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 3090 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_lmqi_set_idx_byword,
    icli_ipmc_mvr_vlan_lmqi_set_idx_help,
    icli_ipmc_mvr_vlan_lmqi_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_lmqi_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_lmqi_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_lmqi_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_lmqi_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_lmqi_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_lmqi_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_lmqi_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_lmqi_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_UINT, // type
        &icli_ipmc_mvr_vlan_lmqi_set_idx_range_4, // range
        {4, &icli_ipmc_mvr_vlan_lmqi_set_idx_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_lmqi_set_idx_register = {
    icli_ipmc_mvr_vlan_lmqi_set_idx_cmd,
    "mvr vlan <vlan_list> last-member-query-interval <0-31744>", // original_cmd
    "mvr vlan <v_vlan_list> last-member-query-interval <ipmc_lmqi> ", // var_cmd
    icli_ipmc_mvr_vlan_lmqi_set_idx_node,
    5,
    &icli_ipmc_mvr_vlan_lmqi_set_idx_property,
    &icli_ipmc_mvr_vlan_lmqi_set_idx_execution,
#line 3093 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_lmqi_set_nme_cmd[] =
    " mvr name <word16> last-member-query-interval <0-31744> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_lmqi_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_lmqi_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_range_t icli_ipmc_mvr_vlan_lmqi_set_nme_range_4 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 31744 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_lmqi_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<IpmcLmqi : 0-31744>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_lmqi_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    ICLI_HELP_INTF_LMQI,
    "0 - 31744 tenths of seconds"
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_lmqi_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 3154 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_lmqi_set_nme_byword,
    icli_ipmc_mvr_vlan_lmqi_set_nme_help,
    icli_ipmc_mvr_vlan_lmqi_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_lmqi_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_lmqi_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_lmqi_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_lmqi_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_lmqi_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_lmqi_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_lmqi_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_lmqi_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_lmqi_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_UINT, // type
        &icli_ipmc_mvr_vlan_lmqi_set_nme_range_4, // range
        {4, &icli_ipmc_mvr_vlan_lmqi_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_lmqi_set_nme_register = {
    icli_ipmc_mvr_vlan_lmqi_set_nme_cmd,
    "mvr name <word16> last-member-query-interval <0-31744>", // original_cmd
    "mvr name <mvr_name> last-member-query-interval <ipmc_lmqi> ", // var_cmd
    icli_ipmc_mvr_vlan_lmqi_set_nme_node,
    5,
    &icli_ipmc_mvr_vlan_lmqi_set_nme_property,
    &icli_ipmc_mvr_vlan_lmqi_set_nme_execution,
#line 3157 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_lmqi_default_idx_cmd[] =
    " no mvr vlan <vlan_list> last-member-query-interval ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_lmqi_default_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_lmqi_default_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_lmqi_default_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    ICLI_HELP_INTF_LMQI
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_lmqi_default_idx_property = {
    0, // command ID, assigned when register
#line 3219 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 3218 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_lmqi_default_idx_byword,
    icli_ipmc_mvr_vlan_lmqi_default_idx_help,
    icli_ipmc_mvr_vlan_lmqi_default_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_lmqi_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_lmqi_default_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_lmqi_default_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_lmqi_default_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_lmqi_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_lmqi_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_lmqi_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_lmqi_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_lmqi_default_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_lmqi_default_idx_register = {
    icli_ipmc_mvr_vlan_lmqi_default_idx_cmd,
    "no mvr vlan <vlan_list> last-member-query-interval", // original_cmd
    "no mvr vlan <v_vlan_list> last-member-query-interval ", // var_cmd
    icli_ipmc_mvr_vlan_lmqi_default_idx_node,
    5,
    &icli_ipmc_mvr_vlan_lmqi_default_idx_property,
    &icli_ipmc_mvr_vlan_lmqi_default_idx_execution,
#line 3221 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_lmqi_default_nme_cmd[] =
    " no mvr name <word16> last-member-query-interval ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_lmqi_default_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_lmqi_default_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_lmqi_default_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_lmqi_default_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    ICLI_HELP_INTF_LMQI
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_lmqi_default_nme_property = {
    0, // command ID, assigned when register
#line 3283 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 3282 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_lmqi_default_nme_byword,
    icli_ipmc_mvr_vlan_lmqi_default_nme_help,
    icli_ipmc_mvr_vlan_lmqi_default_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_lmqi_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_lmqi_default_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_lmqi_default_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_lmqi_default_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_lmqi_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_lmqi_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_lmqi_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_lmqi_default_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_lmqi_default_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_lmqi_default_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_lmqi_default_nme_register = {
    icli_ipmc_mvr_vlan_lmqi_default_nme_cmd,
    "no mvr name <word16> last-member-query-interval", // original_cmd
    "no mvr name <mvr_name> last-member-query-interval ", // var_cmd
    icli_ipmc_mvr_vlan_lmqi_default_nme_node,
    5,
    &icli_ipmc_mvr_vlan_lmqi_default_nme_property,
    &icli_ipmc_mvr_vlan_lmqi_default_nme_execution,
#line 3285 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_channel_set_idx_cmd[] =
    " mvr vlan <vlan_list> channel <word16> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_channel_set_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_channel_set_idx_range_4 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_channel_set_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<ProfileName : word16>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_channel_set_idx_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_CHANNEL,
    ICLI_HELP_PROFILE_NAME
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_channel_set_idx_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 3346 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_channel_set_idx_byword,
    icli_ipmc_mvr_vlan_channel_set_idx_help,
    icli_ipmc_mvr_vlan_channel_set_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_channel_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_channel_set_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_channel_set_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_channel_set_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_channel_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_channel_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_channel_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_channel_set_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_channel_set_idx_range_4, // range
        {4, &icli_ipmc_mvr_vlan_channel_set_idx_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_channel_set_idx_register = {
    icli_ipmc_mvr_vlan_channel_set_idx_cmd,
    "mvr vlan <vlan_list> channel <word16>", // original_cmd
    "mvr vlan <v_vlan_list> channel <profile_name> ", // var_cmd
    icli_ipmc_mvr_vlan_channel_set_idx_node,
    5,
    &icli_ipmc_mvr_vlan_channel_set_idx_property,
    &icli_ipmc_mvr_vlan_channel_set_idx_execution,
#line 3349 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_channel_set_nme_cmd[] =
    " mvr name <word16> channel <word16> ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_channel_set_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_channel_set_nme_range_2 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_range_t icli_ipmc_mvr_vlan_channel_set_nme_range_4 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_channel_set_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<ProfileName : word16>", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_channel_set_nme_help[] = {
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_CHANNEL,
    ICLI_HELP_PROFILE_NAME
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_channel_set_nme_property = {
    0, // command ID, assigned when register
    ICLI_CMD_PROP_ENABLE|ICLI_CMD_PROP_VISIBLE, // command property
#line 3429 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_channel_set_nme_byword,
    icli_ipmc_mvr_vlan_channel_set_nme_help,
    icli_ipmc_mvr_vlan_channel_set_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_channel_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_channel_set_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_channel_set_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_channel_set_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_channel_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_channel_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_channel_set_nme_range_2, // range
        {2, &icli_ipmc_mvr_vlan_channel_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_channel_set_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_channel_set_nme_range_4, // range
        {4, &icli_ipmc_mvr_vlan_channel_set_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_channel_set_nme_register = {
    icli_ipmc_mvr_vlan_channel_set_nme_cmd,
    "mvr name <word16> channel <word16>", // original_cmd
    "mvr name <mvr_name> channel <profile_name> ", // var_cmd
    icli_ipmc_mvr_vlan_channel_set_nme_node,
    5,
    &icli_ipmc_mvr_vlan_channel_set_nme_property,
    &icli_ipmc_mvr_vlan_channel_set_nme_execution,
#line 3432 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_channel_del_idx_cmd[] =
    " no mvr vlan <vlan_list> channel ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_channel_del_idx_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_byword_t icli_ipmc_mvr_vlan_channel_del_idx_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_channel_del_idx_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_VLAN,
    HELP_MVR_VLAN_LIST,
    HELP_MVR_CHANNEL
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_channel_del_idx_property = {
    0, // command ID, assigned when register
#line 3494 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 3493 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_channel_del_idx_byword,
    icli_ipmc_mvr_vlan_channel_del_idx_help,
    icli_ipmc_mvr_vlan_channel_del_idx_runtime
};
static i32 icli_ipmc_mvr_vlan_channel_del_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_channel_del_idx_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_channel_del_idx, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_channel_del_idx_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_channel_del_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_channel_del_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_channel_del_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_VLAN_LIST, // type
        NULL, // range
        { 3, &icli_ipmc_mvr_vlan_channel_del_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_channel_del_idx_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_channel_del_idx_register = {
    icli_ipmc_mvr_vlan_channel_del_idx_cmd,
    "no mvr vlan <vlan_list> channel", // original_cmd
    "no mvr vlan <v_vlan_list> channel ", // var_cmd
    icli_ipmc_mvr_vlan_channel_del_idx_node,
    5,
    &icli_ipmc_mvr_vlan_channel_del_idx_property,
    &icli_ipmc_mvr_vlan_channel_del_idx_execution,
#line 3496 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};


//----- Command -----
static char icli_ipmc_mvr_vlan_channel_del_nme_cmd[] =
    " no mvr name <word16> channel ";
static icli_runtime_cb_t *icli_ipmc_mvr_vlan_channel_del_nme_runtime[] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};
static icli_range_t icli_ipmc_mvr_vlan_channel_del_nme_range_3 = {
    ICLI_RANGE_TYPE_UNSIGNED,
    {{   1,
        {
            { 0, 16 }
        }
    }}
};
static icli_byword_t icli_ipmc_mvr_vlan_channel_del_nme_byword[] = {
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"", 0, {0, 0}},
    {"<MvrName : word16>", 0, {0, 0}},
    {"", 0, {0, 0}}
};
static char *icli_ipmc_mvr_vlan_channel_del_nme_help[] = {
    ICLI_HELP_NO,
    ICLI_HELP_MVR,
    ICLI_HELP_MVR_NAME,
    HELP_MVR_VLAN_NAME,
    HELP_MVR_CHANNEL
};
static icli_cmd_property_t icli_ipmc_mvr_vlan_channel_del_nme_property = {
    0, // command ID, assigned when register
#line 3558 "mvr.icli"
    ICLI_CMD_PROP_LOOSELY, // command property
#line 3557 "mvr.icli"
    ICLI_PRIVILEGE_15, // privilege
    ICLI_PRIVILEGE_15, // orig_priv
    ICLI_CMD_MODE_MAX, // mode goto
    ICLI_CMD_MODE_MAX, // mode destroy
    icli_ipmc_mvr_vlan_channel_del_nme_byword,
    icli_ipmc_mvr_vlan_channel_del_nme_help,
    icli_ipmc_mvr_vlan_channel_del_nme_runtime
};
static i32 icli_ipmc_mvr_vlan_channel_del_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
);
static icli_cmd_execution_t icli_ipmc_mvr_vlan_channel_del_nme_execution = {
    0, // command ID, assigned when register
    icli_ipmc_mvr_vlan_channel_del_nme, // command callback
    0  // user option
};
static icli_parsing_node_t icli_ipmc_mvr_vlan_channel_del_nme_node[] = {
    {
        0, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 0, &icli_ipmc_mvr_vlan_channel_del_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        1, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 1, &icli_ipmc_mvr_vlan_channel_del_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        2, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 2, &icli_ipmc_mvr_vlan_channel_del_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    },
    {
        3, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_RANGE_WORD, // type
        &icli_ipmc_mvr_vlan_channel_del_nme_range_3, // range
        {3, &icli_ipmc_mvr_vlan_channel_del_nme_property, 0}, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
        0,     // or_head
    },
    {
        4, // word id
        NULL, // word, re-use command string buffer
        ICLI_VARIABLE_KEYWORD, // type
        NULL, // range
        { 4, &icli_ipmc_mvr_vlan_channel_del_nme_property, 0 }, // node property
        NULL, // execution, assigned when register
        0, // optional_begin
        0, // optional_end
        0, // parent_cnt
        NULL, // parent
        NULL, // child
        NULL, // sibling
        NULL, // loop
        {NULL, NULL, NULL}, // random_optional
        {0,    0,    0}, // random_optional_level
        NULL,  // must_head
        0,     // must_number
        0,     // must_level
        FALSE, // must_begin
        FALSE, // must_end
    }
};
static icli_cmd_register_t  icli_ipmc_mvr_vlan_channel_del_nme_register = {
    icli_ipmc_mvr_vlan_channel_del_nme_cmd,
    "no mvr name <word16> channel", // original_cmd
    "no mvr name <mvr_name> channel ", // var_cmd
    icli_ipmc_mvr_vlan_channel_del_nme_node,
    5,
    &icli_ipmc_mvr_vlan_channel_del_nme_property,
    &icli_ipmc_mvr_vlan_channel_del_nme_execution,
#line 3560 "mvr.icli"
    ICLI_CMD_MODE_GLOBAL_CONFIG // command mode
};

/* nummber of commands */
#define ___ICLI_CMD_CNT     36

/* database of command ID */
static i32  g_cmd_id[___ICLI_CMD_CNT];

/*
******************************************************************************

    < auto-generation >
    callbacks for each command

******************************************************************************
*/
static i32 icli_ipmc_mvr_vlan_port_role_config_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    BOOL                  has_source = FALSE;
    BOOL                  has_receiver = FALSE;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1248 "mvr.icli"
    mvr_port_role_t prole;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

    // COMMAND
    // mvr vlan <vlan_list> type { source | receiver }
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* type */
            break;
        case  4: /* source */
            has_source = TRUE;
            break;
        case  5: /* receiver */
            has_receiver = TRUE;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1252 "mvr.icli"
    prole = MVR_CONF_DEF_PORT_ROLE;
    if (has_source) {
        prole = MVR_PORT_ROLE_SOURC;
    } else {
        if (has_receiver) {
            prole = MVR_PORT_ROLE_RECVR;
        }
    }

    if (!icli_ipmc_mvr_vlan_port_role_set(session_id,
                                          plist, prole,
                                          TRUE, v_vlan_list,
                                          FALSE, NULL)) {
        ICLI_PRINTF("%% Failed to set MVR port role.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_port_role_config_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    // CMD_VAR
    char*                 mvr_name = NULL;
    BOOL                  has_source = FALSE;
    BOOL                  has_receiver = FALSE;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1325 "mvr.icli"
    mvr_port_role_t prole;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

    // COMMAND
    // mvr name <word16> type { source | receiver }
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* type */
            break;
        case  4: /* source */
            has_source = TRUE;
            break;
        case  5: /* receiver */
            has_receiver = TRUE;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1329 "mvr.icli"
    prole = MVR_CONF_DEF_PORT_ROLE;
    if (has_source) {
        prole = MVR_PORT_ROLE_SOURC;
    } else {
        if (has_receiver) {
            prole = MVR_PORT_ROLE_RECVR;
        }
    }

    if (!icli_ipmc_mvr_vlan_port_role_set(session_id,
                                          plist, prole,
                                          FALSE, NULL,
                                          TRUE, mvr_name)) {
        ICLI_PRINTF("%% Failed to set MVR port role.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_port_role_clear_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

    // COMMAND
    // no mvr vlan <vlan_list> type
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* type */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1401 "mvr.icli"
    if (!icli_ipmc_mvr_vlan_port_role_set(session_id,
                                          plist, MVR_PORT_ROLE_INACT,
                                          TRUE, v_vlan_list,
                                          FALSE, NULL)) {
        ICLI_PRINTF("%% Failed to inactivate MVR port role.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_port_role_clear_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

    // COMMAND
    // no mvr name <word16> type
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* type */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1464 "mvr.icli"
    if (!icli_ipmc_mvr_vlan_port_role_set(session_id,
                                          plist, MVR_PORT_ROLE_INACT,
                                          FALSE, NULL,
                                          TRUE, mvr_name)) {
        ICLI_PRINTF("%% Failed to inactivate MVR port role.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_immediate_leave_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

//===== CODE_BEGIN ==========
#line 1523 "mvr.icli"
    if (!_icli_ipmc_mvr_immediate_leave_set(session_id, plist, TRUE)) {
        ICLI_PRINTF("%% Failed to enable immediate leave.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_immediate_leave_set_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // MODE_VAR
    icli_stack_port_range_t* plist = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // MODE command
    // interface <port_type> <port_type_list>
    while ( mode_var ) {
        switch ( mode_var->word_id ) {
        case  0: /* interface */
            break;
        case  1: /* <port_type> */
            break;
        case  2: /* <port_type_list> */
            plist = &( mode_var->value.u.u_port_type_list );
            break;
        default: /* unknown variable */
            return ICLI_RC_ERROR;
        }
        mode_var = mode_var->next;
    }

//===== CODE_BEGIN ==========
#line 1530 "mvr.icli"
    if (!_icli_ipmc_mvr_immediate_leave_set(session_id, plist, FALSE)) {
        ICLI_PRINTF("%% Failed to disable immediate leave.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_clear_statistics(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    BOOL                  has_vlan = FALSE;
    icli_unsigned_range_t* v_vlan_list = NULL;
    BOOL                  has_name = FALSE;
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1595 "mvr.icli"
    mvr_mgmt_interface_t    mvr_icli_intf;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // clear mvr [ vlan <vlan_list> | name <word16> ] statistics
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* clear */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            has_vlan = TRUE;
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* name */
            has_name = TRUE;
            break;
        case  5: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  6: /* statistics */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1599 "mvr.icli"
    if (has_vlan && v_vlan_list) {
        u32         idx;
        vtss_vid_t  vidx, bnd;

        for (idx = 0; idx < v_vlan_list->cnt; idx++) {
            bnd = v_vlan_list->range[idx].max;
            for (vidx = v_vlan_list->range[idx].min; vidx <= bnd; vidx++) {
                mvr_icli_intf.vid = vidx;
                if (mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid MVR VLAN ID %u.\n\n", vidx);
                    continue;
                }

                if (mvr_mgmt_clear_stat_counter(VTSS_ISID_GLOBAL, vidx) != VTSS_OK) {
                    ICLI_PRINTF("%% Invalid operation on clearing MVR VLAN %u counters.\n\n", vidx);
                }
            }
        }
    } else if (has_name && mvr_name && strlen(mvr_name)) {
        memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
        strncpy(mvr_icli_intf.intf.name, mvr_name, strlen(mvr_name));
        if (mvr_mgmt_get_intf_entry_by_name(VTSS_ISID_GLOBAL, &mvr_icli_intf) != VTSS_OK) {
            ICLI_PRINTF("%% Invalid MVR VLAN %s.\n\n", mvr_name);
            return ICLI_RC_ERROR;
        }

        if (mvr_mgmt_clear_stat_counter(VTSS_ISID_GLOBAL, mvr_icli_intf.vid) != VTSS_OK) {
            ICLI_PRINTF("%% Invalid operation on clearing MVR VLAN %u counters.\n\n", mvr_icli_intf.vid);
            return ICLI_RC_ERROR;
        }
    } else {
        if (mvr_mgmt_clear_stat_counter(VTSS_ISID_GLOBAL, VTSS_IPMC_VID_ALL) != VTSS_OK) {
            ICLI_PRINTF("%% Invalid operation on clearing MVR VLAN counters.\n\n");
            return ICLI_RC_ERROR;
        }
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_display_statistics(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    BOOL                  has_vlan = FALSE;
    icli_unsigned_range_t* v_vlan_list = NULL;
    BOOL                  has_name = FALSE;
    char*                 mvr_name = NULL;
    BOOL                  has_group_database = FALSE;
    BOOL                  has_interface = FALSE;
    icli_stack_port_range_t* v_port_type_list = NULL;
    BOOL                  has_sfm_information = FALSE;
    BOOL                  has_detail = FALSE;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1722 "mvr.icli"
    BOOL                            global_state;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // show mvr [ vlan <vlan_list> | name <word16> ] [ group-database [ interface  ( <port_type> [ <port_type_list> ] )  ] [ sfm-information ] ] [ detail ] { [ <grep> { <grep_begin> | <grep_include> | <grep_exclude> } <grep_string> ] } 
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* show */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            has_vlan = TRUE;
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* name */
            has_name = TRUE;
            break;
        case  5: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  6: /* group-database */
            has_group_database = TRUE;
            break;
        case  7: /* interface */
            has_interface = TRUE;
            break;
        case  8: /* <port_type> */
            break;
        case  9: /* <port_type_list> */
            v_port_type_list = &( cmd_var->value.u.u_port_type_list );
            break;
        case  10: /* sfm-information */
            has_sfm_information = TRUE;
            break;
        case  11: /* detail */
            has_detail = TRUE;
            break;
        case  12: /* <grep> */
            break;
        case  13: /* <grep_begin> */
            break;
        case  14: /* <grep_include> */
            break;
        case  15: /* <grep_exclude> */
            break;
        case  16: /* <grep_string> */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1726 "mvr.icli"
    if (mvr_mgmt_get_mode(&global_state) != VTSS_OK) {
        global_state = FALSE;
    }
    ICLI_PRINTF("\n\rMVR is %s.\n\r",
                global_state ?
                "now enabled to start group registration" :
                "currently disabled, please enable MVR to start group registration");

    if (has_group_database) {
        icli_switch_port_range_t        switch_range;
        vtss_usid_t                     usid;
        vtss_isid_t                     isid;

        BOOL                            bypassing;
        mvr_mgmt_interface_t            mvr_icli_intf;
        vtss_vid_t                      vid;
        ipmc_ip_version_t               version;
        ipmc_prot_intf_group_entry_t    intf_group_entry;
        ipmc_group_db_t                 *grp_db;
        u32                             grp4Cnt, grp6Cnt;

        ICLI_PRINTF("\nMVR Group Database\n");

        if (has_interface && v_port_type_list) {
            if (!icli_cmd_port_range_exist(session_id, v_port_type_list, TRUE, TRUE) &&
                v_port_type_list->cnt == 0) {
                //Stop process since the port list counter is zero
                return TRUE;
            }
        }

        bypassing = FALSE;
        memset(&switch_range, 0, sizeof(switch_range));
        while (icli_switch_get_next(&switch_range)) {
            if (!msg_switch_exists(switch_range.isid)) {
                continue;
            }
            isid = switch_range.isid;
            usid = switch_range.usid;

            grp4Cnt = grp6Cnt = 0;
            memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
            while (mvr_mgmt_get_next_intf_entry(isid, &mvr_icli_intf) == VTSS_OK) {
                if (has_name && mvr_name && strlen(mvr_name)) {
                    if (strncmp(mvr_icli_intf.intf.name, mvr_name, strlen(mvr_name))) {
                        continue;
                    }
                }
                vid = mvr_icli_intf.vid;
                if (has_vlan && !_icli_ipmc_mvr_chk_by_vlan(vid, v_vlan_list)) {
                    continue;
                }

                version = IPMC_IP_VERSION_IGMP;
                memset(&intf_group_entry, 0x0, sizeof(ipmc_prot_intf_group_entry_t));
                while (mvr_mgmt_get_next_intf_group(isid, &version, &vid, &intf_group_entry) == VTSS_OK ) {
                    if (mvr_icli_intf.vid != intf_group_entry.vid) {
                        continue;
                    }

                    grp_db = &intf_group_entry.db;
                    if (has_interface && !_icli_ipmc_mvr_chk_by_port_msk(isid, grp_db->port_mask, v_port_type_list)) {
                        continue;
                    }
                    if (version == IPMC_IP_VERSION_IGMP) {
                        if (!grp4Cnt) {
                            ICLI_PRINTF("\nSwitch-%u MVR-%s Group Table\n",
                                        usid,
                                        ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        }
                        grp4Cnt++;
                    } else {
                        if (!grp6Cnt) {
                            ICLI_PRINTF("\nSwitch-%u MVR-%s Group Table\n",
                                        usid,
                                        ipmc_lib_version_txt(version, IPMC_TXT_CASE_UPPER));
                        }
                        grp6Cnt++;
                    }

                    _icli_ipmc_mvr_db_display(session_id, &intf_group_entry, isid,
                                              has_interface, v_port_type_list,
                                              has_sfm_information, has_detail);

                    bypassing = (icli_session_printf(session_id, "%s", "") == ICLI_RC_ERR_BYPASS);
                    if (bypassing) {
                        break;
                    }
                }

                if (bypassing) {
                    break;
                }
            }

            if (bypassing) {
                break;
            }

            ICLI_PRINTF("\nSwitch-%u MVR Group Count: %u\n", usid, (grp4Cnt + grp6Cnt));
        }
    } else {
        if (has_vlan && v_vlan_list) {
            _icli_ipmc_mvr_intf_statistics_display(session_id, v_vlan_list, NULL, has_detail);
        } else if (has_name && mvr_name) {
            _icli_ipmc_mvr_intf_statistics_display(session_id, NULL, mvr_name, has_detail);
        } else {
            _icli_ipmc_mvr_intf_statistics_display(session_id, NULL, NULL, has_detail);
        }
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_ctrl_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1878 "mvr.icli"
    BOOL    icli_ipmcmvr_state_enable;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

//===== CODE_BEGIN ==========
#line 1886 "mvr.icli"
    icli_ipmcmvr_state_enable = TRUE;
    if (mvr_mgmt_set_mode(&icli_ipmcmvr_state_enable) != VTSS_OK) {
        ICLI_PRINTF("%% Failed to enable MVR.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_ctrl_set_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1882 "mvr.icli"
    BOOL    icli_ipmcmvr_state_disable;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

//===== CODE_BEGIN ==========
#line 1894 "mvr.icli"
    icli_ipmcmvr_state_disable = FALSE;
    if (mvr_mgmt_set_mode(&icli_ipmcmvr_state_disable) != VTSS_OK) {
        ICLI_PRINTF("%% Failed to disable MVR.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_intf_set(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    BOOL                  has_name = FALSE;
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 1952 "mvr.icli"
    vtss_rc                 mvr_icli_rc;
    int                     str_len;
    mvr_mgmt_interface_t    mvr_icli_intf;
    mvr_conf_intf_entry_t   *mvif;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> [ name <word16> ]
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* name */
            has_name = TRUE;
            break;
        case  4: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 1959 "mvr.icli"
    if ((has_name && mvr_name) &&
        !IPMC_LIB_NAME_IDX_CHECK(mvr_name, MVR_NAME_MAX_LEN)) {
        ICLI_PRINTF("%% Invalid given MVR name.\n\n");
        return ICLI_RC_ERROR;
    }

    if (v_vlan_list) {
        u32         idx;
        vtss_vid_t  vidx, bnd, vlan_cnt;

        vlan_cnt = 0;
        for (idx = 0; idx < v_vlan_list->cnt; idx++) {
            bnd = v_vlan_list->range[idx].max;
            for (vidx = v_vlan_list->range[idx].min; vidx <= bnd; vidx++) {
                if (!vlan_cnt) {
                    memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
                    mvr_icli_intf.vid = vidx;
                    mvif = &mvr_icli_intf.intf;
                    str_len = 0;
                    if (has_name && mvr_name) {
                        str_len = strlen(mvr_name);
                    }
                    if (mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf) == VTSS_OK) {
                        if (str_len && mvr_name) {
                            strncpy(mvif->name, mvr_name, str_len);
                        }

                        mvr_icli_rc = mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_SET, &mvr_icli_intf);
                    } else {
                        if (str_len && mvr_name) {
                            strncpy(mvif->name, mvr_name, str_len);
                        }
                        mvif->mode = MVR_CONF_DEF_INTF_MODE;
                        mvif->vtag = MVR_CONF_DEF_INTF_VTAG;
                        mvif->querier4_address = MVR_CONF_DEF_INTF_ADRS4;
                        mvif->priority = MVR_CONF_DEF_INTF_PRIO;
                        mvif->last_listener_query_interval = MVR_CONF_DEF_INTF_LLQI;

                        mvr_icli_rc = mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_ADD, &mvr_icli_intf);
                    }

                    if (mvr_icli_rc != VTSS_OK) {
                        if (str_len && mvr_name &&
                            mvr_icli_rc == IPMC_ERROR_ENTRY_NAME_DUPLICATED) {
                            ICLI_PRINTF("%% Duplicate given MVR name: %s\n", mvr_name);
                        }

                        ICLI_PRINTF("%% Failed to set MVR VLAN interface.\n\n");
                        return ICLI_RC_ERROR;
                    }
                }

                ++vlan_cnt;
            }
        }

        if (vlan_cnt > 1) {
            ICLI_PRINTF("%% Only the first given MVR VLAN applies interface configuration.\n\n");
        }
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_intf_delete(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 2068 "mvr.icli"
    mvr_mgmt_interface_t    mvr_icli_intf;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2072 "mvr.icli"
    if (v_vlan_list) {
        u32         idx;
        vtss_vid_t  vidx, bnd;

        for (idx = 0; idx < v_vlan_list->cnt; idx++) {
            bnd = v_vlan_list->range[idx].max;
            for (vidx = v_vlan_list->range[idx].min; vidx <= bnd; vidx++) {
                memset(&mvr_icli_intf, 0x0, sizeof(mvr_mgmt_interface_t));
                mvr_icli_intf.vid = vidx;
                if (mvr_mgmt_get_intf_entry(VTSS_ISID_GLOBAL, &mvr_icli_intf) == VTSS_OK) {
                    if (mvr_mgmt_set_intf_entry(VTSS_ISID_GLOBAL, IPMC_OP_DEL, &mvr_icli_intf) != VTSS_OK) {
                        ICLI_PRINTF("%% Failed to delete MVR VLAN interface.\n\n");
                        return ICLI_RC_ERROR;
                    }
                } else {
                    ICLI_PRINTF("%% MVR VLAN %u doesn't exist.\n\n", vidx);
                }
            }
        }
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_mode_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    BOOL                  has_dynamic = FALSE;
    BOOL                  has_compatible = FALSE;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 2149 "mvr.icli"
    mvr_intf_mode_t vmode;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> mode { dynamic | compatible }
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* mode */
            break;
        case  4: /* dynamic */
            has_dynamic = TRUE;
            break;
        case  5: /* compatible */
            has_compatible = TRUE;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2153 "mvr.icli"
    vmode = MVR_CONF_DEF_INTF_MODE;
    if (has_dynamic) {
        vmode = MVR_INTF_MODE_DYNA;
    } else {
        if (has_compatible) {
            vmode = MVR_INTF_MODE_COMP;
        }
    }

    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   1, 0, 0, 0, 0,
                                   0, vmode)) {
        ICLI_PRINTF("%% Failed to set MVR interface mode setting.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_mode_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;
    BOOL                  has_dynamic = FALSE;
    BOOL                  has_compatible = FALSE;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
#line 2227 "mvr.icli"
    mvr_intf_mode_t vmode;
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> mode { dynamic | compatible }
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* mode */
            break;
        case  4: /* dynamic */
            has_dynamic = TRUE;
            break;
        case  5: /* compatible */
            has_compatible = TRUE;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2231 "mvr.icli"
    vmode = MVR_CONF_DEF_INTF_MODE;
    if (has_dynamic) {
        vmode = MVR_INTF_MODE_DYNA;
    } else {
        if (has_compatible) {
            vmode = MVR_INTF_MODE_COMP;
        }
    }

    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   1, 0, 0, 0, 0,
                                   0, vmode)) {
        ICLI_PRINTF("%% Failed to set MVR interface mode setting.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_mode_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> mode
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* mode */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2304 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   1, 0, 0, 0, 0,
                                   0, MVR_CONF_DEF_INTF_MODE)) {
        ICLI_PRINTF("%% Failed to default MVR interface mode setting.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_mode_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> mode
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* mode */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2368 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   1, 0, 0, 0, 0,
                                   0, MVR_CONF_DEF_INTF_MODE)) {
        ICLI_PRINTF("%% Failed to default MVR interface mode setting.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_querier_adrs_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    vtss_ip_t             v_ipv4_ucast = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> igmp-address <ipv4_ucast>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* igmp-address */
            break;
        case  4: /* <ipv4_ucast> */
            v_ipv4_ucast = cmd_var->value.u.u_ipv4_ucast;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2432 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 1, 0, 0,
                                   v_ipv4_ucast, 0)) {
        ICLI_PRINTF("%% Failed to set MVR IGMP address settings for IGMP.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_querier_adrs_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;
    vtss_ip_t             v_ipv4_ucast = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> igmp-address <ipv4_ucast>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* igmp-address */
            break;
        case  4: /* <ipv4_ucast> */
            v_ipv4_ucast = cmd_var->value.u.u_ipv4_ucast;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2496 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 1, 0, 0,
                                   v_ipv4_ucast, 0)) {
        ICLI_PRINTF("%% Failed to set MVR IGMP address settings for IGMP.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_querier_adrs_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> igmp-address
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* igmp-address */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2560 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 1, 0, 0,
                                   MVR_CONF_DEF_INTF_ADRS4, 0)) {
        ICLI_PRINTF("%% Failed to clear MVR IGMP address settings for IGMP.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_querier_adrs_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> igmp-address
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* igmp-address */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2624 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 1, 0, 0,
                                   MVR_CONF_DEF_INTF_ADRS4, 0)) {
        ICLI_PRINTF("%% Failed to clear MVR IGMP address settings for IGMP.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_priority_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    u32                   cos_priority = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> frame priority <0-7>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* frame */
            break;
        case  4: /* priority */
            break;
        case  5: /* <0-7> */
            cos_priority = cmd_var->value.u.u_range_uint;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2692 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 1, 0, 0, 0,
                                   cos_priority, 0)) {
        ICLI_PRINTF("%% Failed to set MVR interface priority settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> frame tagged
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* frame */
            break;
        case  4: /* tagged */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2764 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 0, 1, 0,
                                   0, IPMC_INTF_TAGED)) {
        ICLI_PRINTF("%% Failed to set MVR frame tagged settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_idx_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> frame tagged
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* frame */
            break;
        case  5: /* tagged */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2775 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 0, 1, 0,
                                   0, IPMC_INTF_UNTAG)) {
        ICLI_PRINTF("%% Failed to set MVR frame untagged settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_priority_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;
    u32                   cos_priority = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> frame priority <0-7>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* frame */
            break;
        case  4: /* priority */
            break;
        case  5: /* <0-7> */
            cos_priority = cmd_var->value.u.u_range_uint;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2843 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 1, 0, 0, 0,
                                   cos_priority, 0)) {
        ICLI_PRINTF("%% Failed to set MVR interface priority settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> frame tagged
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* frame */
            break;
        case  4: /* tagged */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2915 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 0, 1, 0,
                                   0, IPMC_INTF_TAGED)) {
        ICLI_PRINTF("%% Failed to set MVR frame tagged settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_tagged_set_nme_no(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> frame tagged
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* frame */
            break;
        case  5: /* tagged */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2926 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 0, 1, 0,
                                   0, IPMC_INTF_UNTAG)) {
        ICLI_PRINTF("%% Failed to set MVR frame untagged settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_priroity_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> frame priority
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* frame */
            break;
        case  5: /* priority */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 2994 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 1, 0, 0, 0,
                                   MVR_CONF_DEF_INTF_PRIO, 0)) {
        ICLI_PRINTF("%% Failed to default MVR interface priority settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_frame_priroity_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> frame priority
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* frame */
            break;
        case  5: /* priority */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3062 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 1, 0, 0, 0,
                                   MVR_CONF_DEF_INTF_PRIO, 0)) {
        ICLI_PRINTF("%% Failed to default MVR interface priority settings.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_lmqi_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    u32                   ipmc_lmqi = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> last-member-query-interval <0-31744>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* last-member-query-interval */
            break;
        case  4: /* <0-31744> */
            ipmc_lmqi = cmd_var->value.u.u_range_uint;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3126 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 0, 0, 1,
                                   ipmc_lmqi, 0)) {
        ICLI_PRINTF("%% Failed to set MVR interface LMQI.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_lmqi_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;
    u32                   ipmc_lmqi = 0;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> last-member-query-interval <0-31744>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* last-member-query-interval */
            break;
        case  4: /* <0-31744> */
            ipmc_lmqi = cmd_var->value.u.u_range_uint;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3190 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 0, 0, 1,
                                   ipmc_lmqi, 0)) {
        ICLI_PRINTF("%% Failed to set MVR interface LMQI.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_lmqi_default_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> last-member-query-interval
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* last-member-query-interval */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3254 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   TRUE, v_vlan_list,
                                   FALSE, NULL,
                                   0, 0, 0, 0, 1,
                                   MVR_CONF_DEF_INTF_LLQI, 0)) {
        ICLI_PRINTF("%% Failed to default MVR interface LMQI.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_lmqi_default_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> last-member-query-interval
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* last-member-query-interval */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3318 "mvr.icli"
    if (!icli_ipmc_mvr_intf_config(session_id,
                                   FALSE, NULL,
                                   TRUE, mvr_name,
                                   0, 0, 0, 0, 1,
                                   MVR_CONF_DEF_INTF_LLQI, 0)) {
        ICLI_PRINTF("%% Failed to default MVR interface LMQI.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_channel_set_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;
    char*                 profile_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr vlan <vlan_list> channel <word16>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* vlan */
            break;
        case  2: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  3: /* channel */
            break;
        case  4: /* <word16> */
            profile_name = cmd_var->value.u.u_range_word;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3382 "mvr.icli"
    if (v_vlan_list) {
        u32         idx;
        vtss_vid_t  vidx, bnd, vlan_cnt;

        vlan_cnt = 0;
        for (idx = 0; idx < v_vlan_list->cnt; idx++) {
            bnd = v_vlan_list->range[idx].max;
            for (vidx = v_vlan_list->range[idx].min; vidx <= bnd; vidx++) {
                if (!vlan_cnt) {
                    if (!icli_ipmc_mvr_channel_config(session_id, FALSE,
                                                      FALSE, NULL,
                                                      TRUE, vidx,
                                                      FALSE, NULL,
                                                      profile_name)) {
                        ICLI_PRINTF("%% Failed to set MVR interface channel.\n\n");
                        return ICLI_RC_ERROR;
                    }
                }

                ++vlan_cnt;
            }
        }

        if (vlan_cnt > 1) {
            ICLI_PRINTF("%% Only the first given MVR VLAN applies interface channel setting.\n\n");
        }
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_channel_set_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;
    char*                 profile_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // mvr name <word16> channel <word16>
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* mvr */
            break;
        case  1: /* name */
            break;
        case  2: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  3: /* channel */
            break;
        case  4: /* <word16> */
            profile_name = cmd_var->value.u.u_range_word;
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3465 "mvr.icli"
    if (!icli_ipmc_mvr_channel_config(session_id, FALSE,
                                      FALSE, NULL,
                                      FALSE, VTSS_IPMC_VID_NULL,
                                      TRUE, mvr_name,
                                      profile_name)) {
        ICLI_PRINTF("%% Failed to set MVR interface channel.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_channel_del_idx(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    icli_unsigned_range_t* v_vlan_list = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr vlan <vlan_list> channel
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* vlan */
            break;
        case  3: /* <vlan_list> */
            v_vlan_list = &( cmd_var->value.u.u_vlan_list );
            break;
        case  4: /* channel */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3529 "mvr.icli"
    if (!icli_ipmc_mvr_channel_config(session_id, TRUE,
                                      TRUE, v_vlan_list,
                                      FALSE, VTSS_IPMC_VID_NULL,
                                      FALSE, NULL,
                                      NULL)) {
        ICLI_PRINTF("%% Failed to delete MVR interface channel.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/****************************************************************************/
static i32 icli_ipmc_mvr_vlan_channel_del_nme(
    u32                 session_id,
    icli_parameter_t    *mode_var,
    icli_parameter_t    *cmd_var,
    i32                 usr_opt
)
{
    // CMD_VAR
    char*                 mvr_name = NULL;

    //Disable lint's warning about use of possibly-NULL pointers:
    /*lint --e{613} */

//===== VARIABLE_BEGIN ======
//===== VARIABLE_END ========

    // avoid compile warning
    if ( session_id ){}
    if ( mode_var ){}
    if ( cmd_var ){}
    if ( usr_opt ){}

    // COMMAND
    // no mvr name <word16> channel
    while ( cmd_var ) {
        switch ( cmd_var->word_id ) {
        case  0: /* no */
            break;
        case  1: /* mvr */
            break;
        case  2: /* name */
            break;
        case  3: /* <word16> */
            mvr_name = cmd_var->value.u.u_range_word;
            break;
        case  4: /* channel */
            break;
        default: /* unknown parameter */
            return ICLI_RC_ERROR;
        }
        cmd_var = cmd_var->next;
    }

//===== CODE_BEGIN ==========
#line 3593 "mvr.icli"
    if (!icli_ipmc_mvr_channel_config(session_id, TRUE,
                                      FALSE, NULL,
                                      FALSE, VTSS_IPMC_VID_NULL,
                                      TRUE, mvr_name,
                                      NULL)) {
        ICLI_PRINTF("%% Failed to delete MVR interface channel.\n\n");
        return ICLI_RC_ERROR;
    }
//===== CODE_END ============

    // successful
    return ICLI_RC_OK;
}

/*
******************************************************************************

    < auto-generation >
    global API for command registration
    return value -
        ICLI_RC_OK    : successful
        ICLI_RC_ERROR : failed

******************************************************************************
*/
i32 mvr_icli_cmd_register(void)
{
    i32     cmd_id = 0, cmd_seq = 0;

    // to avoid warning for ths case of un-used
    if ( cmd_id | cmd_seq ){}

    // init database of command id
    memset(g_cmd_id, 0xff, sizeof(g_cmd_id));

    /*
        mvr vlan <vlan_list> type { source | receiver }
    */
    cmd_seq = 0;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_port_role_config_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> type { source | receiver }\"\n");
    }

    /*
        mvr name <word16> type { source | receiver }
    */
    cmd_seq = 1;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_port_role_config_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> type { source | receiver }\"\n");
    }

    /*
        no mvr vlan <vlan_list> type
    */
    cmd_seq = 2;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_port_role_clear_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> type\"\n");
    }

    /*
        no mvr name <word16> type
    */
    cmd_seq = 3;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_port_role_clear_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> type\"\n");
    }

    /*
        mvr immediate-leave
    */
    cmd_seq = 4;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_immediate_leave_set_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr immediate-leave\"\n");
    }

    /*
        no mvr immediate-leave
    */
    cmd_seq = 5;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_immediate_leave_set_no_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr immediate-leave\"\n");
    }

    /*
        clear mvr [ vlan <vlan_list> | name <word16> ] statistics
    */
    cmd_seq = 6;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_clear_statistics_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"clear mvr [ vlan <vlan_list> | name <word16> ] statistics\"\n");
    }

    /*
        show mvr [ vlan <vlan_list> | name <word16> ] [ group-database [ interface  ( <port_type> [ <port_type_list> ] )  ] [ sfm-information ] ] [ detail ] { [ <grep> { <grep_begin> | <grep_include> | <grep_exclude> } <grep_string> ] } 
    */
    cmd_seq = 7;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_display_statistics_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"show mvr [ vlan <vlan_list> | name <word16> ] [ group-database [ interface  ( <port_type> [ <port_type_list> ] )  ] [ sfm-information ] ] [ detail ] { [ <grep> { <grep_begin> | <grep_include> | <grep_exclude> } <grep_string> ] } \"\n");
    }

    /*
        mvr
    */
    cmd_seq = 8;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_ctrl_set_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr\"\n");
    }

    /*
        no mvr
    */
    cmd_seq = 9;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_ctrl_set_no_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr\"\n");
    }

    /*
        mvr vlan <vlan_list> [ name <word16> ]
    */
    cmd_seq = 10;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_intf_set_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> [ name <word16> ]\"\n");
    }

    /*
        no mvr vlan <vlan_list>
    */
    cmd_seq = 11;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_intf_delete_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list>\"\n");
    }

    /*
        mvr vlan <vlan_list> mode { dynamic | compatible }
    */
    cmd_seq = 12;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_mode_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> mode { dynamic | compatible }\"\n");
    }

    /*
        mvr name <word16> mode { dynamic | compatible }
    */
    cmd_seq = 13;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_mode_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> mode { dynamic | compatible }\"\n");
    }

    /*
        no mvr vlan <vlan_list> mode
    */
    cmd_seq = 14;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_mode_default_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> mode\"\n");
    }

    /*
        no mvr name <word16> mode
    */
    cmd_seq = 15;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_mode_default_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> mode\"\n");
    }

    /*
        mvr vlan <vlan_list> igmp-address <ipv4_ucast>
    */
    cmd_seq = 16;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_querier_adrs_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> igmp-address <ipv4_ucast>\"\n");
    }

    /*
        mvr name <word16> igmp-address <ipv4_ucast>
    */
    cmd_seq = 17;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_querier_adrs_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> igmp-address <ipv4_ucast>\"\n");
    }

    /*
        no mvr vlan <vlan_list> igmp-address
    */
    cmd_seq = 18;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_querier_adrs_default_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> igmp-address\"\n");
    }

    /*
        no mvr name <word16> igmp-address
    */
    cmd_seq = 19;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_querier_adrs_default_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> igmp-address\"\n");
    }

    /*
        mvr vlan <vlan_list> frame priority <0-7>
    */
    cmd_seq = 20;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_priority_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> frame priority <0-7>\"\n");
    }

    /*
        mvr vlan <vlan_list> frame tagged
    */
    cmd_seq = 21;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_tagged_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> frame tagged\"\n");
    }

    /*
        no mvr vlan <vlan_list> frame tagged
    */
    cmd_seq = 22;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_tagged_set_idx_no_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> frame tagged\"\n");
    }

    /*
        mvr name <word16> frame priority <0-7>
    */
    cmd_seq = 23;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_priority_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> frame priority <0-7>\"\n");
    }

    /*
        mvr name <word16> frame tagged
    */
    cmd_seq = 24;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_tagged_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> frame tagged\"\n");
    }

    /*
        no mvr name <word16> frame tagged
    */
    cmd_seq = 25;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_tagged_set_nme_no_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> frame tagged\"\n");
    }

    /*
        no mvr vlan <vlan_list> frame priority
    */
    cmd_seq = 26;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_priroity_default_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> frame priority\"\n");
    }

    /*
        no mvr name <word16> frame priority
    */
    cmd_seq = 27;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_frame_priroity_default_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> frame priority\"\n");
    }

    /*
        mvr vlan <vlan_list> last-member-query-interval <0-31744>
    */
    cmd_seq = 28;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_lmqi_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> last-member-query-interval <0-31744>\"\n");
    }

    /*
        mvr name <word16> last-member-query-interval <0-31744>
    */
    cmd_seq = 29;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_lmqi_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> last-member-query-interval <0-31744>\"\n");
    }

    /*
        no mvr vlan <vlan_list> last-member-query-interval
    */
    cmd_seq = 30;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_lmqi_default_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> last-member-query-interval\"\n");
    }

    /*
        no mvr name <word16> last-member-query-interval
    */
    cmd_seq = 31;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_lmqi_default_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> last-member-query-interval\"\n");
    }

    /*
        mvr vlan <vlan_list> channel <word16>
    */
    cmd_seq = 32;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_channel_set_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr vlan <vlan_list> channel <word16>\"\n");
    }

    /*
        mvr name <word16> channel <word16>
    */
    cmd_seq = 33;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_channel_set_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"mvr name <word16> channel <word16>\"\n");
    }

    /*
        no mvr vlan <vlan_list> channel
    */
    cmd_seq = 34;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_channel_del_idx_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr vlan <vlan_list> channel\"\n");
    }

    /*
        no mvr name <word16> channel
    */
    cmd_seq = 35;
    cmd_id = icli_cmd_register( &icli_ipmc_mvr_vlan_channel_del_nme_register );
    if ( cmd_id >= 0 ) {
        // update command id
        g_cmd_id[cmd_seq] = cmd_id;
    } else {
        T_E("register command \"no mvr name <word16> channel\"\n");
    }

    return ICLI_RC_OK;
}

/*
******************************************************************************

    < auto-generation >
    global API for command ID retrieval
    return value -
        >= 0 : valid command ID
        < 0  : failed, cmd_seq is out of boundary or cmd not registered

******************************************************************************
*/
i32 mvr_icli_cmd_id_get(
    IN i32 cmd_seq
)
{
    return (cmd_seq < ___ICLI_CMD_CNT) ? g_cmd_id[cmd_seq] : ICLI_RC_ERR_PARAMETER;
}

//===== MODULE_IF_FLAG =======================================================
#endif // defined(VTSS_SW_OPTION_MVR)
