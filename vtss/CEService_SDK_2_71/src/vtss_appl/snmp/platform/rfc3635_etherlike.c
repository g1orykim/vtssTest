/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc3635_etherlike.h"
#if VTSS_SWITCH_STACKABLE

#include "topo_api.h"
#endif

#include "msg_api.h"

#ifdef VTSS_SW_OPTION_LACP
#include "lacp_api.h"
#endif                          /* VTSS_SW_OPTION_LACP */

/*
 * +++ Start (Internal implementation declarations)
 */
#include "mibContextTable.h"  //mibContextTable_register

#if RFC3635_SUPPORTED_TRANSMISSION
/* transmission ----------------------------------------------------------*/
#include "ifIndex_api.h"

/* Define the OID pointer to the top of the mib tree that we're
   registering underneath */
static oid    mib2_ifTable_ifIndex_oid[]    = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 1};
static size_t mib2_ifTable_ifIndex_oid_len  = sizeof(mib2_ifTable_ifIndex_oid) / sizeof(oid);

typedef struct {
    u_long dot3StatsIndex;
    u_long dot3StatsAlignmentErrors;
    u_long dot3StatsFCSErrors;
    u_long dot3StatsSingleCollisionFrames;
    u_long dot3StatsMultipleCollsionFrames;
    u_long dot3StatsSQETestErrors;
    u_long dot3StatsDeferredTransmissions;
    u_long dot3StatsLateCollisions;
    u_long dot3StatsExcessiveCollisions;
    u_long dot3StatsInternalMacTransmitErrors;
    u_long dot3StatsCarrierSenseErrors;
    u_long dot3StatsFrameTooLongs;
    u_long dot3StatsInternalMacReceiveErrors;
    oid    dot3StatsEtherChipSet[MAX_OID_LEN];
    size_t dot3StatsEtherChipSet_len;
    u_long dot3StatsSymbolErrors;
    u_long dot3StatsDuplexStatus;
    u_long dot3StatsRatecontrolAbility;
    /* The current Rate Control mode of operation of the MAC sublayer of this interface. */
    /* Not supported in E-StaX34 project
    u_long dot3StatsRatecontrolStatus; */
} dot3StatsTable_entry_t;

static BOOL update_dot3StatsTable_entry(vtss_isid_t isid, vtss_port_no_t port_idx, dot3StatsTable_entry_t *table_entry_p)
{
    port_conf_t              port_conf;
    port_status_t            port_status;
    vtss_port_counters_t     counters;

    if (port_mgmt_conf_get(isid, port_idx, &port_conf) != VTSS_OK) {
        return FALSE;
    }
    if (port_mgmt_status_get(isid, port_idx, &port_status) != VTSS_OK) {
        return FALSE;
    }
    if (port_mgmt_counters_get(isid, port_idx, &counters) != VTSS_OK) {
        return FALSE;
    }

#if defined(VTSS_FEATURE_PORT_CNT_ETHER_LIKE)
    table_entry_p->dot3StatsAlignmentErrors           += counters.ethernet_like.dot3StatsAlignmentErrors;
    table_entry_p->dot3StatsFCSErrors                 += counters.ethernet_like.dot3StatsFCSErrors;
    table_entry_p->dot3StatsSingleCollisionFrames     += counters.ethernet_like.dot3StatsSingleCollisionFrames;
    table_entry_p->dot3StatsMultipleCollsionFrames    += counters.ethernet_like.dot3StatsMultipleCollisionFrames;
    table_entry_p->dot3StatsSQETestErrors             += 0;
    table_entry_p->dot3StatsDeferredTransmissions     += counters.ethernet_like.dot3StatsDeferredTransmissions;
    table_entry_p->dot3StatsLateCollisions            += counters.ethernet_like.dot3StatsLateCollisions;
    table_entry_p->dot3StatsExcessiveCollisions       += counters.ethernet_like.dot3StatsExcessiveCollisions;
    table_entry_p->dot3StatsInternalMacTransmitErrors += 0;
    table_entry_p->dot3StatsCarrierSenseErrors        += counters.ethernet_like.dot3StatsCarrierSenseErrors;
    table_entry_p->dot3StatsFrameTooLongs             += counters.ethernet_like.dot3StatsFrameTooLongs;
    table_entry_p->dot3StatsSymbolErrors              += counters.ethernet_like.dot3StatsSymbolErrors;
#endif /* VTSS_FEATURE_PORT_CNT_ETHER_LIKE */

    table_entry_p->dot3StatsInternalMacReceiveErrors  += 0;
    memcpy(table_entry_p->dot3StatsEtherChipSet, mib2_ifTable_ifIndex_oid, mib2_ifTable_ifIndex_oid_len * sizeof(oid));
    table_entry_p->dot3StatsEtherChipSet_len           = mib2_ifTable_ifIndex_oid_len;

    if (port_status.status.link) {
        table_entry_p->dot3StatsDuplexStatus           = port_status.status.fdx ? 3 : 2;
    } else if (port_conf.autoneg) {
        table_entry_p->dot3StatsDuplexStatus           = 1; //unknown
    } else {
        table_entry_p->dot3StatsDuplexStatus           = port_conf.fdx ? 3 : 2;
    }
    table_entry_p->dot3StatsRatecontrolAbility         = 2;
    //table_entry_p->dot3StatsRatecontrolStatus          = 1;

    return TRUE;
}

BOOL get_dot3StatsTable_entry(iftable_info_t *table_info, dot3StatsTable_entry_t *table_entry_p)
{
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    switch_iter_t            sit;


    memset(table_entry_p, 0x0, sizeof(dot3StatsTable_entry_t));
    table_entry_p->dot3StatsIndex = table_info->ifIndex;

    switch (table_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (update_dot3StatsTable_entry(table_info->isid, table_info->if_id, table_entry_p) == FALSE) {
            return FALSE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(table_info->isid, table_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(table_info->isid, table_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

        (void)port_iter_init(&pit, NULL, table_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            if (update_dot3StatsTable_entry(table_info->isid, pit.iport, table_entry_p) == FALSE) {
                return FALSE;
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        (void)switch_iter_init(&sit, VTSS_ISID_START, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {

            if (aggr_mgmt_port_members_get(sit.isid, table_info->if_id, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, table_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_dot3StatsTable_entry(sit.isid, pit.iport, table_entry_p) == FALSE) {
                    return FALSE;
                }
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
    default:
        return FALSE;
    }

    table_entry_p->dot3StatsEtherChipSet[table_entry_p->dot3StatsEtherChipSet_len - 1] = table_info->ifIndex;
    return TRUE;
}
#endif /* RFC3635_SUPPORTED_TRANSMISSION */

/*
 * --- End (Internal implementation declarations)
 */

#if RFC3635_SUPPORTED_TRANSMISSION
/* transmission ----------------------------------------------------------*/
/*
 * transmission_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             transmission_variables_oid[] = { 1, 3, 6, 1, 2, 1, 10 };

/*
 * variable4 transmission_variables:
 *   this variable defines function callbacks and type return information
 *   for the transmission mib section
 */

struct variable4 transmission_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3STATSINDEX                          1
    {DOT3STATSINDEX, ASN_INTEGER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 1}},
#define DOT3STATSALIGNMENTERRORS                2
    {DOT3STATSALIGNMENTERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 2}},
#define DOT3STATSFCSERRORS                      3
    {DOT3STATSFCSERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 3}},
#define DOT3STATSSINGLECOLLISIONFRAMES          4
    {DOT3STATSSINGLECOLLISIONFRAMES, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 4}},
#define DOT3STATSMULTIPLECOLLISIONFRAMES        5
    {DOT3STATSMULTIPLECOLLISIONFRAMES, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 5}},
#define DOT3STATSSQETESTERRORS                  6
    {DOT3STATSSQETESTERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 6}},
#define DOT3STATSDEFERREDTRANSMISSIONS          7
    {DOT3STATSDEFERREDTRANSMISSIONS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 7}},
#define DOT3STATSLATECOLLISIONS                 8
    {DOT3STATSLATECOLLISIONS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 8}},
#define DOT3STATSEXCESSIVECOLLISIONS            9
    {DOT3STATSEXCESSIVECOLLISIONS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 9}},
#define DOT3STATSINTERNALMACTRANSMITERRORS      10
    {DOT3STATSINTERNALMACTRANSMITERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 10}},
#define DOT3STATSCARRIERSENSEERRORS             11
    {DOT3STATSCARRIERSENSEERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 11}},
#define DOT3STATSFRAMETOOLONGS                  12
    {DOT3STATSFRAMETOOLONGS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 13}},
#define DOT3STATSINTERNALMACRECEIVEERRORS       13
    {DOT3STATSINTERNALMACRECEIVEERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 16}},
#define DOT3STATSETHERCHIPSET                   14
    {DOT3STATSETHERCHIPSET, ASN_OBJECT_ID, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 17}},
#define DOT3STATSSYMBOLERRORS                   15
    {DOT3STATSSYMBOLERRORS, ASN_COUNTER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 18}},
#define DOT3STATSDUPLEXSTATUS                   16
    {DOT3STATSDUPLEXSTATUS, ASN_INTEGER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 19}},
#define DOT3STATSRATECONTROLABILITY             17
    {DOT3STATSRATECONTROLABILITY, ASN_INTEGER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 20}},
    /* Not supported in E-StaX34 project
    #define DOT3STATSRATECONTROLSTATUS              18
        {DOT3STATSRATECONTROLSTATUS, ASN_INTEGER, RONLY, var_dot3StatsTable, 4, {7, 2, 1, 21}},
    #define DOT3COLLCOUNT                           19
        {DOT3COLLCOUNT, ASN_INTEGER, RONLY, var_dot3CollTable, 4, {7, 5, 1, 2}},
    #define DOT3COLLFREQUENCIES                     20
        {DOT3COLLFREQUENCIES, ASN_COUNTER, RONLY, var_dot3CollTable, 4, {7, 5, 1, 3}},
    #define DOT3PAUSEADMINMODE                      21
        {DOT3PAUSEADMINMODE, ASN_INTEGER, RWRITE, var_dot3PauseTable, 4, {7, 10, 1, 1}},
    #define DOT3PAUSEOPERMODE                       22
        {DOT3PAUSEOPERMODE, ASN_INTEGER, RONLY, var_dot3PauseTable, 4, {7, 10, 1, 2}},
    #define DOT3INPAUSEFRAMES                       23
        {DOT3INPAUSEFRAMES, ASN_COUNTER, RONLY, var_dot3PauseTable, 4, {7, 10, 1, 3}},
    #define DOT3OUTPAUSEFRAMES                      24
        {DOT3OUTPAUSEFRAMES, ASN_COUNTER, RONLY, var_dot3PauseTable, 4, {7, 10, 1, 4}},
    #define DOT3HCINPAUSEFRAMES                     25
        {DOT3HCINPAUSEFRAMES, ASN_COUNTER64, RONLY, var_dot3PauseTable, 4, {7, 10, 1, 5}},
    #define DOT3HCOUTPAUSEFRAMES                    26
        {DOT3HCOUTPAUSEFRAMES, ASN_COUNTER64, RONLY, var_dot3PauseTable, 4, {7, 10, 1, 6}},
    #define DOT3HCSTATSALIGNMENTERRORS              27
        {DOT3HCSTATSALIGNMENTERRORS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 1}},
    #define DOT3HCSTATSFCSERRORS                    28
        {DOT3HCSTATSFCSERRORS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 2}},
    #define DOT3HCSTATSINTERNALMACTRANSMITERRORS    28
        {DOT3HCSTATSINTERNALMACTRANSMITERRORS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 3}},
    #define DOT3HCSTATSFRAMETOOLONGS                30
        {DOT3HCSTATSFRAMETOOLONGS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 4}},
    #define DOT3HCSTATSINTERNALMACRECEIVEERRORS     31
        {DOT3HCSTATSINTERNALMACRECEIVEERRORS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 5}},
    #define DOT3HCSTATSSYMBOLERRORS                 32
        {DOT3HCSTATSSYMBOLERRORS, ASN_COUNTER64, RONLY, var_dot3HCStatsTable, 4, {7, 11, 1, 6}},
    #define DOT3CONTROLFUNCTIONSSUPPORTED           33
        {DOT3CONTROLFUNCTIONSSUPPORTED, ASN_OCTET_STR, RONLY, var_dot3ControlTable, 4, {7, 9, 1, 1}},
    #define DOT3CONTROLINUNKNOWNOPCODES             34
        {DOT3CONTROLINUNKNOWNOPCODES, ASN_COUNTER, RONLY, var_dot3ControlTable, 4, {7, 9, 1, 2}},
    #define DOT3HCCONTROLINUNKNOWNOPCODES           35
        {DOT3HCCONTROLINUNKNOWNOPCODES, ASN_COUNTER64, RONLY, var_dot3ControlTable, 4, {7, 9, 1, 3}}, */
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the transmission module
 */
void
init_transmission(void)
{
    // Register mibContextTable
    mibContextTable_register(transmission_variables_oid,
                             sizeof(transmission_variables_oid) / sizeof(oid),
                             "EtherLike-MIB : transmission");

    DEBUGMSGTL(("transmission", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("transmission", transmission_variables, variable4,
                 transmission_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_transmission():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_transmission(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_transmission\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3HCStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_transmission above.
 */
u_char         *
var_dot3HCStatsTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //dot3HCStatsTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_dot3HCStatsTableIndex(idx_num); /* FIXME */
    //if (!get_dot3HCStatsTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3HCSTATSALIGNMENTERRORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCSTATSFCSERRORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCSTATSINTERNALMACTRANSMITERRORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCSTATSFRAMETOOLONGS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCSTATSINTERNALMACRECEIVEERRORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCSTATSSYMBOLERRORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3HCStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3ControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_transmission above.
 */
u_char         *
var_dot3ControlTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //dot3ControlTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_dot3ControlTableIndex(idx_num); /* FIXME */
    //if (!get_dot3ControlTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3CONTROLFUNCTIONSSUPPORTED: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3CONTROLINUNKNOWNOPCODES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCCONTROLINUNKNOWNOPCODES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3ControlTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* Not supported in E-StaX34 project */

/*
 * var_dot3StatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_transmission above.
 */
u_char         *
var_dot3StatsTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                     table_index;
    int                     table_size;
    dot3StatsTable_entry_t  table_entry;
    int                     idx_num;
    static u_long           ulong_ret;
    static oid              objid[MAX_OID_LEN];
    iftable_info_t          table_info;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];

    table_info.ifIndex = exact ? idx_num : idx_num - 1;

    if (exact && FALSE == ifIndex_get(&table_info) && !msg_switch_exists(table_info.isid)) {
        return NULL;
    }

    if (!exact && FALSE == ifIndex_get_next(&table_info)) {
        return NULL;
    } else if ( !exact ) {
        while ((table_info.type == IFTABLE_IFINDEX_TYPE_PORT ||
                table_info.type ==  IFTABLE_IFINDEX_TYPE_LLAG) && !msg_switch_exists(table_info.isid) ) {
            if ( FALSE == ifIndex_get_next(&table_info)) {
                return FALSE;
            }
        }
    }

    if (!get_dot3StatsTable_entry(&table_info, &table_entry)) {
        return NULL;
    }

    table_index = table_info.ifIndex;
    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3STATSINDEX: {
        ulong_ret = table_entry.dot3StatsIndex;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSALIGNMENTERRORS: {
        ulong_ret = table_entry.dot3StatsAlignmentErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSFCSERRORS: {
        ulong_ret = table_entry.dot3StatsFCSErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSSINGLECOLLISIONFRAMES: {
        ulong_ret = table_entry.dot3StatsSingleCollisionFrames;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSMULTIPLECOLLISIONFRAMES: {
        ulong_ret = table_entry.dot3StatsMultipleCollsionFrames;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSSQETESTERRORS: {
        ulong_ret = table_entry.dot3StatsSQETestErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSDEFERREDTRANSMISSIONS: {
        ulong_ret = table_entry.dot3StatsDeferredTransmissions;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSLATECOLLISIONS: {
        ulong_ret = table_entry.dot3StatsLateCollisions;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSEXCESSIVECOLLISIONS: {
        ulong_ret = table_entry.dot3StatsExcessiveCollisions;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSINTERNALMACTRANSMITERRORS: {
        ulong_ret = table_entry.dot3StatsInternalMacTransmitErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSCARRIERSENSEERRORS: {
        ulong_ret = table_entry.dot3StatsCarrierSenseErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSFRAMETOOLONGS: {
        ulong_ret = table_entry.dot3StatsFrameTooLongs;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSINTERNALMACRECEIVEERRORS: {
        ulong_ret = table_entry.dot3StatsInternalMacReceiveErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSETHERCHIPSET: {
        memcpy(objid, table_entry.dot3StatsEtherChipSet, table_entry.dot3StatsEtherChipSet_len * sizeof(oid));
        *var_len = table_entry.dot3StatsEtherChipSet_len * sizeof(oid);
        return (u_char *) objid;
    }
    case DOT3STATSSYMBOLERRORS: {
        ulong_ret = table_entry.dot3StatsSymbolErrors;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSDUPLEXSTATUS: {
        ulong_ret = table_entry.dot3StatsDuplexStatus;
        return (u_char *) &ulong_ret;
    }
    case DOT3STATSRATECONTROLABILITY: {
        ulong_ret = table_entry.dot3StatsRatecontrolAbility;
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3STATSRATECONTROLSTATUS: {
        ulong_ret = table_entry.dot3StatsRatecontrolStatus;
        return (u_char *) &ulong_ret;
    }
#endif /* Not supported in E-StaX34 project */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3StatsTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_dot3CollTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_transmission above.
 */
u_char         *
var_dot3CollTable(struct variable *vp,
                  oid *name,
                  size_t *length,
                  int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //dot3CollTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_dot3CollTableIndex(idx_num); /* FIXME */
    //if (!get_dot3CollTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3COLLCOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3COLLFREQUENCIES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3CollTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3PauseTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_transmission above.
 */
u_char         *
var_dot3PauseTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //dot3PauseTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_dot3PauseTableIndex(idx_num); /* FIXME */
    //if (!get_dot3PauseTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3PAUSEADMINMODE: {
        *write_method = write_dot3PauseAdminMode;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3PAUSEOPERMODE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3INPAUSEFRAMES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3OUTPAUSEFRAMES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCINPAUSEFRAMES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3HCOUTPAUSEFRAMES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3PauseTable\n",
                    vp->magic));
    }
    return NULL;
}


int
write_dot3PauseAdminMode(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3PauseAdminMode: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3PauseAdminMode: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3PauseAdminMode: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not supported in E-StaX34 project */
#endif /* RFC3635_SUPPORTED_TRANSMISSION */

