/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc3636_mau.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"
#include "sysutil_api.h"

/*
 * +++ Start (Internal implementation declarations)
 */
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#if RFC3636_SUPPORTED_MAU

typedef struct {
    u_long          ifIndex;
    oid                 ifMauType[MAX_OID_LEN];
    u_long          ifMauStatus;
    u_long          ifMauMediaAvailable;
    u_long          ifMauMediaAvailableStateExits;
    oid                 ifMauDefaultType[MAX_OID_LEN];
    BOOL            ifMauAutoNegSupported;
    u_long          ifMauTypeListBits;
} ifMauTable_entry_t;

u_long          linkdown_counter[VTSS_ISID_CNT][VTSS_PORT_COUNT] = {{0}};

BOOL get_ifMauTable_entry(int table_index, ifMauTable_entry_t *table_entry_p)
{
    iftable_info_t          table_info;
    port_conf_t             port_conf;
    port_status_t         port_status;
    oid                             mau_type_oid[9] = { 1, 3, 6, 1, 2, 1, 26 , 4, 0};
    oid                             mau_Def_type_oid[9] = { 1, 3, 6, 1, 2, 1, 26 , 4, 1};

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(ifMauTable_entry_t));
    table_entry_p->ifIndex = table_index;

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (port_mgmt_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
            return FALSE;
        }
        if (port_mgmt_status_get(table_info.isid, table_info.if_id, &port_status) != VTSS_OK) {
            return FALSE;
        }

        /*ifMauType:bOther ( 0 ) , bAUI ( 1 ) , b10base5 ( 2 ) , bFoirl ( 3 ) , b10base2 ( 4 ) , b10baseT ( 5 ) ,
        b10baseFP ( 6 ) , b10baseFB ( 7 ) , b10baseFL ( 8 ) , b10broad36 ( 9 ) , b10baseTHD ( 10 ) ,
        b10baseTFD ( 11 ) , b10baseFLHD ( 12 ) , b10baseFLFD ( 13 ) , b100baseT4 ( 14 ) , b100baseTXHD ( 15 ) ,
        b100baseTXFD ( 16 ) , b100baseFXHD ( 17 ) , b100baseFXFD ( 18 ) , b100baseT2HD ( 19 ) ,
        b100baseT2FD ( 20 ) , b1000baseXHD ( 21 ) , b1000baseXFD ( 22 ) , b1000baseLXHD ( 23 ) ,
        b1000baseLXFD ( 24 ) , b1000baseSXHD ( 25 ) , b1000baseSXFD ( 26 ) , b1000baseCXHD ( 27 ) ,
        b1000baseCXFD ( 28 ) , b1000baseTHD ( 29 ) , b1000baseTFD ( 30 ) , b10GbaseX ( 31 ) , b10GbaseLX4 ( 32 )
        , b10GbaseR ( 33 ) , b10GbaseER ( 34 ) , b10GbaseLR ( 35 ) , b10GbaseSR ( 36 ) , b10GbaseW ( 37 ) ,
        b10GbaseEW ( 38 ) , b10GbaseLW ( 39 ) , b10GbaseSW ( 40 ) */
        if (port_status.status.link) {
            if (port_status.status.speed == VTSS_SPEED_1G) {
                if ( port_status.status.fdx ) {
                    if ( port_status.fiber) {
                        mau_type_oid [8] = 22;
                    } else {
                        mau_type_oid [8] = 30;
                    }
                } else {
                    if ( port_status.fiber) {
                        mau_type_oid [8] = 21;
                    } else {
                        mau_type_oid [8] = 29;
                    }
                }
            } else if (port_status.status.speed == VTSS_SPEED_100M) {
                if ( port_status.status.fdx ) {
                    mau_type_oid [8] = 16;
                } else {
                    mau_type_oid [8] = 15;
                }
            } else if (port_status.status.speed == VTSS_SPEED_10M) {
                if ( port_status.status.fdx ) {
                    mau_type_oid [8] = 11;
                } else {
                    mau_type_oid [8] = 5;
                }
            }
            memcpy(table_entry_p->ifMauType, mau_type_oid, 9 * sizeof(oid));
        } else {
            memset(table_entry_p->ifMauType, 0, 9 * sizeof(oid));
        }

        /*ifMauStatus */
        if (port_conf.enable) {
            table_entry_p->ifMauStatus = 3;    /*other ( 1 ) , unknown ( 2 ) , operational ( 3 ) , standby ( 4 ) , shutdown ( 5 ) , reset ( 6 )*/
        } else {
            table_entry_p->ifMauStatus = 5;
        }

        /*ifMauMediaAvailable:other ( 1 ) , unknown ( 2 ) , available ( 3 ) , notAvailable ( 4 ) , remoteFault ( 5 ) ,
        invalidSignal ( 6 ) , remoteJabber ( 7 ) , remoteLinkLoss ( 8 ) , remoteTest ( 9 ) ,
        offline ( 10 ) , autoNegError ( 11 ) , pmdLinkFault ( 12 ) , wisFrameLoss ( 13 ) ,
        wisSignalLoss ( 14 ) , pcsLinkFault ( 15 ) , excessiveBER ( 16 ) , dxsLinkFault ( 17 ) ,
        pxsLinkFault ( 18 )*/
        if (port_status.status.link) {
            table_entry_p->ifMauMediaAvailable = 3;    /*??? need to improve */
        } else {
            table_entry_p->ifMauMediaAvailable = 4;    /*??? need to improve */
        }

        /*ifMauMediaAvailableStateExits*/
        table_entry_p->ifMauMediaAvailableStateExits = linkdown_counter[table_info.isid - VTSS_ISID_START][table_info.if_id];

        /*ifMauDefaultType: value same as ifMauType*/
        if (port_conf.speed == VTSS_SPEED_1G) {
            if ( port_conf.fdx ) {
                if ( port_status.fiber) {
                    mau_Def_type_oid [8] = 22;
                } else {
                    mau_Def_type_oid [8] = 30;
                }
            } else {
                if ( port_status.fiber) {
                    mau_Def_type_oid [8] = 21;
                } else {
                    mau_Def_type_oid [8] = 29;
                }
            }
        } else if (port_conf.speed == VTSS_SPEED_100M) {
            if ( port_conf.fdx ) {
                mau_Def_type_oid [8] = 16;
            } else {
                mau_Def_type_oid [8] = 15;
            }
        } else if (port_conf.speed == VTSS_SPEED_10M) {
            if ( port_conf.fdx ) {
                mau_Def_type_oid [8] = 11;
            } else {
                mau_Def_type_oid [8] = 5;
            }
        }
        memcpy(table_entry_p->ifMauDefaultType, mau_Def_type_oid, 9 * sizeof(oid));

        /*ifMauAutoNegSupported*/
        if (port_conf.autoneg) {
            table_entry_p->ifMauAutoNegSupported = 1;
        } else {
            table_entry_p->ifMauAutoNegSupported = 2;
        }

        /*ifMauTypeListBits: value same as ifMauType*/
        if (port_conf.autoneg) {
            if ( port_status.cap & PORT_CAP_1G_FDX ) {
                if ( port_status.cap & PORT_CAP_FIBER ) {
                    table_entry_p->ifMauTypeListBits |= 0x1 << 22;
                } else {
                    table_entry_p->ifMauTypeListBits |= 0x1 << 30;
                }
            }
            if ( port_status.cap & PORT_CAP_100M_FDX ) {
                table_entry_p->ifMauTypeListBits |= 0x1 << 16;
            }
            if ( port_status.cap & PORT_CAP_100M_HDX ) {
                table_entry_p->ifMauTypeListBits |= 0x1 << 15;
            }
            if ( port_status.cap & PORT_CAP_10M_FDX ) {
                table_entry_p->ifMauTypeListBits |= 0x1 << 11;
            }
            if ( port_status.cap & PORT_CAP_10M_HDX ) {
                table_entry_p->ifMauTypeListBits |= 0x1 << 5;
            }
        } else {
            if (port_conf.speed == VTSS_SPEED_1G) {
                if ( port_conf.fdx ) {
                    if ( port_status.fiber) {
                        table_entry_p->ifMauTypeListBits = 0x1 << 22;
                    } else {
                        table_entry_p->ifMauTypeListBits = 0x1 << 30;
                    }
                } else {
                    if ( port_status.fiber) {
                        table_entry_p->ifMauTypeListBits = 0x1 << 21;
                    } else {
                        table_entry_p->ifMauTypeListBits = 0x1 << 29;
                    }
                }
            } else if (port_conf.speed == VTSS_SPEED_100M) {
                if ( port_conf.fdx ) {
                    table_entry_p->ifMauTypeListBits = 0x1 << 16;
                } else {
                    table_entry_p->ifMauTypeListBits = 0x1 << 15;
                }
            } else if (port_conf.speed == VTSS_SPEED_10M) {
                if ( port_conf.fdx ) {
                    table_entry_p->ifMauTypeListBits = 0x1 << 11;
                } else {
                    table_entry_p->ifMauTypeListBits = 0x1 << 5;
                }
            }
        }

        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
    default:
        return FALSE;
    }

    return TRUE;
}


#if RFC3636_SUPPORTED_ifMAU_AUTONEG
#include "misc_api.h"
#include "port_custom_api.h"
#include "vtss_api_if_api.h"

typedef struct {
    u_long          ifMauAutoNegAdminStatus;
    u_long          ifMauAutoNegRemoteSignaling;
    u_long          ifMauAutoNegConfig;
    u_long          ifMauAutoNegRestart;
    u_long          ifMauAutoNegCapabilityBits;
    u_long          ifMauAutoNegCapAdvertisedBits;
    u_long          ifMauAutoNegCapReceivedBits;
    u_long          ifMauAutoNegRemoteFaultAdvertised;
    u_long          ifMauAutoNegRemoteFaultReceived;
} ifMauAutoNegTable_entry_t;

BOOL get_ifMauAutoNegTable_entry(int table_index, ifMauAutoNegTable_entry_t *table_entry_p)
{
    iftable_info_t          table_info;
    port_conf_t             port_conf;
    port_status_t           port_status;
    ushort                  staus_reg, autoneg_adver, autoneg_partner, thoundbaseT_control, thoundbaseT_status;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(ifMauAutoNegTable_entry_t));

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (port_mgmt_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
            return FALSE;
        }
        if (port_mgmt_status_get(table_info.isid, table_info.if_id, &port_status) != VTSS_OK) {
            return FALSE;
        }

#if 1 /* CP, 08/21/2013 13:57, Bugzilla#11153, walk MAU MIB will cause error messages */
        /*
            misc_debug_phy_read() can *NOT* read/write 10G port, so skip it
            to avoid error messages.

            If misc_debug_phy_read() is fixed then this check should be
            removed.
        */
        /* if MAC interface is SGMII or QSGMII, the MII command is executable */
        if ( VTSS_PORT_INTERFACE_SGMII != port_status.mac_if && VTSS_PORT_INTERFACE_QSGMII != port_status.mac_if ) {
            staus_reg           = 0;
            autoneg_adver       = 0;
            autoneg_partner     = 0;
            thoundbaseT_control = 0;
            thoundbaseT_status  = 0;
        } else {
            if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x1, 0, &staus_reg, 0, 0) != VTSS_OK) {
                return FALSE;
            }
            if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x4, 0, &autoneg_adver, 0, 0) != VTSS_OK) {
                return FALSE;
            }
            if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x5, 0, &autoneg_partner, 0, 0) != VTSS_OK ) {
                return FALSE;
            }
            if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x9, 0, &thoundbaseT_control, 0, 0) != VTSS_OK ) {
                return FALSE;
            }
            if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0xA, 0, &thoundbaseT_status, 0, 0) != VTSS_OK ) {
                return FALSE;
            }
        }
#else
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x1, 0, &staus_reg, 0, 0) != VTSS_OK) {
            return FALSE;
        }
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x4, 0, &autoneg_adver, 0, 0) != VTSS_OK) {
            return FALSE;
        }
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x5, 0, &autoneg_partner, 0, 0) != VTSS_OK ) {
            return FALSE;
        }
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x9, 0, &thoundbaseT_control, 0, 0) != VTSS_OK ) {
            return FALSE;
        }
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0xA, 0, &thoundbaseT_status, 0, 0) != VTSS_OK ) {
            return FALSE;
        }
#endif

        if (port_conf.autoneg) {
            table_entry_p->ifMauAutoNegAdminStatus = 1;    //enable
        } else {
            table_entry_p->ifMauAutoNegAdminStatus = 2;    //disable
        }

        if ( staus_reg & 0x0020 ) {
            table_entry_p->ifMauAutoNegRemoteSignaling = 1;    //detect
        } else {
            table_entry_p->ifMauAutoNegRemoteSignaling = 2;    //not detected
        }

        /* ifMauAutoNegConfig: other ( 1 ) , configuring ( 2 ) , complete ( 3 ) , disabled ( 4 ) , parallelDetectFail ( 5 )*/
        if ( ! port_conf.autoneg) {
            table_entry_p->ifMauAutoNegConfig = 4;    //disable
        } else if (staus_reg & 0x0020) { //Auto-Negotiation compelete
            table_entry_p->ifMauAutoNegConfig = 3;    //disable
        } else if (staus_reg & 0x0010) { //Remote fault
            table_entry_p->ifMauAutoNegConfig = 5;    //disable
        } else {
            table_entry_p->ifMauAutoNegConfig = 1;    //disable
        }

        table_entry_p->ifMauAutoNegRestart = 2;//not restart

        /* ifMauAutoNegCapabilityBits: bOther ( 0 ) , b10baseT ( 1 ) , b10baseTFD ( 2 ) , b100baseT4 ( 3 ) ,
        b100baseTX ( 4 ) , b100baseTXFD ( 5 ) , b100baseT2 ( 6 ) , b100baseT2FD ( 7 ) , bfdxPause ( 8 ) ,
        bfdxAPause ( 9 ) , bfdxSPause ( 10 ) , bfdxBPause ( 11 ) , b1000baseX ( 12 ) , b1000baseXFD ( 13 ) ,
        b1000baseT ( 14 ) , b1000baseTFD ( 15 ) */
        if ( port_status.cap & PORT_CAP_1G_FDX ) {
            if ( port_status.cap & PORT_CAP_FIBER ) {
                table_entry_p->ifMauAutoNegCapabilityBits |= 0x00002000;    //b1000baseXFD
            } else {
                table_entry_p->ifMauAutoNegCapabilityBits |= 0x00008000;    //b1000baseTFD
            }
        }
        if ( port_status.cap & PORT_CAP_100M_FDX ) {
            table_entry_p->ifMauAutoNegCapabilityBits |= 0x00000020;    //b100baseTXFD
        }
        if ( port_status.cap & PORT_CAP_100M_HDX ) {
            table_entry_p->ifMauAutoNegCapabilityBits |= 0x00000010;    //b100baseTX
        }
        if ( port_status.cap & PORT_CAP_10M_FDX ) {
            table_entry_p->ifMauAutoNegCapabilityBits |= 0x00000004;    //b10baseTFD
        }
        if ( port_status.cap & PORT_CAP_10M_HDX ) {
            table_entry_p->ifMauAutoNegCapabilityBits |= 0x00000002;    //b10baseT
        }
        if ( port_status.cap & PORT_CAP_FLOW_CTRL ) {
            table_entry_p->ifMauAutoNegCapabilityBits |= 0x00000100;    //bfdxPause
        }

        /* ifMauAutoNegCapAdvertisedBits: bOther ( 0 ) , b10baseT ( 1 ) , b10baseTFD ( 2 ) , b100baseT4 ( 3 ) ,
        b100baseTX ( 4 ) , b100baseTXFD ( 5 ) , b100baseT2 ( 6 ) , b100baseT2FD ( 7 ) , bfdxPause ( 8 ) ,
        bfdxAPause ( 9 ) , bfdxSPause ( 10 ) , bfdxBPause ( 11 ) , b1000baseX ( 12 ) , b1000baseXFD ( 13 ) ,
        b1000baseT ( 14 ) , b1000baseTFD ( 15 ) */
        if ( thoundbaseT_control & 0x100 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00004000;    //b1000baseT
        }
        if ( thoundbaseT_control & 0x200 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00008000;    //b1000baseTFD
        }
        if ( autoneg_adver & 0x200 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00000008;    //b100baseT4
        }
        if ( autoneg_adver & 0x100 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00000020;    //b100baseTXFD
        }
        if ( autoneg_adver & 0x80 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00000010;    //b100baseTX
        }
        if ( autoneg_adver & 0x40 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00000004;    //b10baseTFD
        }
        if ( autoneg_adver & 0x20 ) {
            table_entry_p->ifMauAutoNegCapAdvertisedBits |= 0x00000002;    //b10baseT
        }

        /* ifMauAutoNegCapReceivedBits: bOther ( 0 ) , b10baseT ( 1 ) , b10baseTFD ( 2 ) , b100baseT4 ( 3 ) ,
        b100baseTX ( 4 ) , b100baseTXFD ( 5 ) , b100baseT2 ( 6 ) , b100baseT2FD ( 7 ) , bfdxPause ( 8 ) ,
        bfdxAPause ( 9 ) , bfdxSPause ( 10 ) , bfdxBPause ( 11 ) , b1000baseX ( 12 ) , b1000baseXFD ( 13 ) ,
        b1000baseT ( 14 ) , b1000baseTFD ( 15 ) */
        if ( thoundbaseT_status & 0x400 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00004000;    //b1000baseT
        }
        if ( thoundbaseT_status & 0x800 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00008000;    //b1000baseTFD
        }
        if ( autoneg_partner & 0x200 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00000008;    //b100baseT4
        }
        if ( autoneg_partner & 0x100 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00000020;    //b100baseTXFD
        }
        if ( autoneg_partner & 0x80 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00000010;    //b100baseTX
        }
        if ( autoneg_partner & 0x40 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00000004;    //b10baseTFD
        }
        if ( autoneg_partner & 0x20 ) {
            table_entry_p->ifMauAutoNegCapReceivedBits |= 0x00000002;    //b10baseT
        }

        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
    default:
        return FALSE;
    }

    return TRUE;
}
#endif /*RFC3636_SUPPORTED_ifMAU_AUTONEG*/

#endif /* RFC3636_SUPPORTED_MAU */
/*
 * --- End (Internal implementation declarations)
 */

/*
 * snmpDot3MauMgt_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             snmpDot3MauMgt_variables_oid[] = { 1, 3, 6, 1, 2, 1, 26 };

/*
 * variable4 snmpDot3MauMgt_variables:
 *   this variable defines function callbacks and type return information
 *   for the snmpDot3MauMgt mib section
 */

struct variable4 snmpDot3MauMgt_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#if RFC3636_SUPPORTED_rpMAU
#define RPMAUGROUPINDEX     1
    {RPMAUGROUPINDEX, ASN_INTEGER, RONLY, var_rpMauTable, 4, {1, 1, 1, 1}},
#define RPMAUPORTINDEX      2
    {RPMAUPORTINDEX, ASN_INTEGER, RONLY, var_rpMauTable, 4, {1, 1, 1, 2}},
#define RPMAUINDEX      3
    {RPMAUINDEX, ASN_INTEGER, RONLY, var_rpMauTable, 4, {1, 1, 1, 3}},
#define RPMAUTYPE       4
    {RPMAUTYPE, ASN_OBJECT_ID, RONLY, var_rpMauTable, 4, {1, 1, 1, 4}},
#define RPMAUSTATUS     5
    {RPMAUSTATUS, ASN_INTEGER, RWRITE, var_rpMauTable, 4, {1, 1, 1, 5}},
#define RPMAUMEDIAAVAILABLE     6
    {RPMAUMEDIAAVAILABLE, ASN_INTEGER, RONLY, var_rpMauTable, 4, {1, 1, 1, 6}},
#define RPMAUMEDIAAVAILABLESTATEEXITS       7
    {RPMAUMEDIAAVAILABLESTATEEXITS, ASN_COUNTER, RONLY, var_rpMauTable, 4, {1, 1, 1, 7}},
#define RPMAUJABBERSTATE        8
    {RPMAUJABBERSTATE, ASN_INTEGER, RONLY, var_rpMauTable, 4, {1, 1, 1, 8}},
#define RPMAUJABBERINGSTATEENTERS       9
    {RPMAUJABBERINGSTATEENTERS, ASN_COUNTER, RONLY, var_rpMauTable, 4, {1, 1, 1, 9}},
#define RPMAUFALSECARRIERS      10
    {RPMAUFALSECARRIERS, ASN_COUNTER, RONLY, var_rpMauTable, 4, {1, 1, 1, 10}},
#define RPJACKINDEX     11
    {RPJACKINDEX, ASN_INTEGER, RONLY, var_rpJackTable, 4, {1, 2, 1, 1}},
#define RPJACKTYPE      12
    {RPJACKTYPE, ASN_INTEGER, RONLY, var_rpJackTable, 4, {1, 2, 1, 2}},
#endif      /*RFC3636_SUPPORTED_rpMAU*/

#if RFC3636_SUPPORTED_ifMAU
#define IFMAUIFINDEX        13
    {IFMAUIFINDEX, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 1}},
#define IFMAUINDEX      14
    {IFMAUINDEX, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 2}},
#define IFMAUTYPE       15
    {IFMAUTYPE, ASN_OBJECT_ID, RONLY, var_ifMauTable, 4, {2, 1, 1, 3}},
#define IFMAUSTATUS     16
    {IFMAUSTATUS, ASN_INTEGER, RWRITE, var_ifMauTable, 4, {2, 1, 1, 4}},
#define IFMAUMEDIAAVAILABLE     17
    {IFMAUMEDIAAVAILABLE, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 5}},
#define IFMAUMEDIAAVAILABLESTATEEXITS       18
    {IFMAUMEDIAAVAILABLESTATEEXITS, ASN_COUNTER, RONLY, var_ifMauTable, 4, {2, 1, 1, 6}},
#define IFMAUJABBERSTATE        19
    {IFMAUJABBERSTATE, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 7}},
#define IFMAUJABBERINGSTATEENTERS       20
    {IFMAUJABBERINGSTATEENTERS, ASN_COUNTER, RONLY, var_ifMauTable, 4, {2, 1, 1, 8}},
#define IFMAUFALSECARRIERS      21
    {IFMAUFALSECARRIERS, ASN_COUNTER, RONLY, var_ifMauTable, 4, {2, 1, 1, 9}},
#define IFMAUTYPELIST       22
    {IFMAUTYPELIST, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 10}},
#define IFMAUDEFAULTTYPE        23
    {IFMAUDEFAULTTYPE, ASN_OBJECT_ID, RWRITE, var_ifMauTable, 4, {2, 1, 1, 11}},
#define IFMAUAUTONEGSUPPORTED       24
    {IFMAUAUTONEGSUPPORTED, ASN_INTEGER, RONLY, var_ifMauTable, 4, {2, 1, 1, 12}},
#define IFMAUTYPELISTBITS       25
    {IFMAUTYPELISTBITS, ASN_OCTET_STR, RONLY, var_ifMauTable, 4, {2, 1, 1, 13}},
#define IFMAUHCFALSECARRIERS        26
    {IFMAUHCFALSECARRIERS, ASN_COUNTER64, RONLY, var_ifMauTable, 4, {2, 1, 1, 14}},
#define IFJACKINDEX     27
    {IFJACKINDEX, ASN_INTEGER, RONLY, var_ifJackTable, 4, {2, 2, 1, 1}},
#define IFJACKTYPE      28
    {IFJACKTYPE, ASN_INTEGER, RONLY, var_ifJackTable, 4, {2, 2, 1, 2}},
#endif      /*RFC3636_SUPPORTED_ifMAU*/

#if RFC3636_SUPPORTED_BROAD_MAU
#define BROADMAUIFINDEX     29
    {BROADMAUIFINDEX, ASN_INTEGER, RONLY, var_broadMauBasicTable, 4, {3, 1, 1, 1}},
#define BROADMAUINDEX       30
    {BROADMAUINDEX, ASN_INTEGER, RONLY, var_broadMauBasicTable, 4, {3, 1, 1, 2}},
#define BROADMAUXMTRCVSPLITTYPE     31
    {BROADMAUXMTRCVSPLITTYPE, ASN_INTEGER, RONLY, var_broadMauBasicTable, 4, {3, 1, 1, 3}},
#define BROADMAUXMTCARRIERFREQ      32
    {BROADMAUXMTCARRIERFREQ, ASN_INTEGER, RONLY, var_broadMauBasicTable, 4, {3, 1, 1, 4}},
#define BROADMAUTRANSLATIONFREQ     33
    {BROADMAUTRANSLATIONFREQ, ASN_INTEGER, RONLY, var_broadMauBasicTable, 4, {3, 1, 1, 5}},
#endif      /*RFC3636_SUPPORTED_BROAD_MAU*/

#if RFC3636_SUPPORTED_ifMAU_AUTONEG
#define IFMAUAUTONEGADMINSTATUS     34
    {IFMAUAUTONEGADMINSTATUS, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable, 4, {5, 1, 1, 1}},
#define IFMAUAUTONEGREMOTESIGNALING     35
    {IFMAUAUTONEGREMOTESIGNALING, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 2}},
#define IFMAUAUTONEGCONFIG      36
    {IFMAUAUTONEGCONFIG, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 4}},
#define IFMAUAUTONEGCAPABILITY      37
    {IFMAUAUTONEGCAPABILITY, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 5}},
#define IFMAUAUTONEGCAPADVERTISED       38
    {IFMAUAUTONEGCAPADVERTISED, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable, 4, {5, 1, 1, 6}},
#define IFMAUAUTONEGCAPRECEIVED     40
    {IFMAUAUTONEGCAPRECEIVED, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 7}},
#define IFMAUAUTONEGRESTART     41
    {IFMAUAUTONEGRESTART, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable, 4, {5, 1, 1, 8}},
#define IFMAUAUTONEGCAPABILITYBITS      42
    {IFMAUAUTONEGCAPABILITYBITS, ASN_OCTET_STR, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 9}},
#define IFMAUAUTONEGCAPADVERTISEDBITS       43
    {IFMAUAUTONEGCAPADVERTISEDBITS, ASN_OCTET_STR, RWRITE, var_ifMauAutoNegTable, 4, {5, 1, 1, 10}},
#define IFMAUAUTONEGCAPRECEIVEDBITS     44
    {IFMAUAUTONEGCAPRECEIVEDBITS, ASN_OCTET_STR, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 11}},
#define IFMAUAUTONEGREMOTEFAULTADVERTISED       45
    {IFMAUAUTONEGREMOTEFAULTADVERTISED, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable, 4, {5, 1, 1, 12}},
#define IFMAUAUTONEGREMOTEFAULTRECEIVED     46
    {IFMAUAUTONEGREMOTEFAULTRECEIVED, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 4, {5, 1, 1, 13}},
#endif      /*RFC3636_SUPPORTED_ifMAU_AUTONEG*/
};

/*
 * (L = length of the oidsuffix)
 */

#if RFC3636_SUPPORTED_MAU
/*
 * Initializes the snmpDot3MauMgt module
 */
void
init_snmpDot3MauMgt(void)
{
    // Register mibContextTable
    mibContextTable_register(snmpDot3MauMgt_variables_oid,
                             sizeof(snmpDot3MauMgt_variables_oid) / sizeof(oid),
                             "MAU-MIB : snmpDot3MauMgt");

    DEBUGMSGTL(("snmpDot3MauMgt", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("snmpDot3MauMgt", snmpDot3MauMgt_variables, variable4,
                 snmpDot3MauMgt_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_snmpDot3MauMgt():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_snmpDot3MauMgt(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_snmpDot3MauMgt\n",
                    vp->magic));
    }
    return NULL;
}
#endif      /*RFC3636_SUPPORTED_MAU*/

#if RFC3636_SUPPORTED_rpMAU
/*
 * var_rpJackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_rpJackTable(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //rpJackTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_rpJackTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_rpJackTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RPJACKINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPJACKTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_rpJackTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_rpMauTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_rpMauTable(struct variable *vp,
               oid *name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //rpMauTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_rpMauTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_rpMauTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RPMAUGROUPINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUPORTINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUSTATUS: {
        *write_method = write_rpMauStatus;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUMEDIAAVAILABLE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUMEDIAAVAILABLESTATEEXITS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUJABBERSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUJABBERINGSTATEENTERS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RPMAUFALSECARRIERS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_rpMauTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif      /*RFC3636_SUPPORTED_rpMAU*/

#if RFC3636_SUPPORTED_ifMAU
/*
 * var_ifMauTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_ifMauTable(struct variable *vp,
               oid *name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                 table_index;
    u_long              mau_ifIndex, mau_index;
    static u_long       ulong_ret;
    static oid          objid[MAX_OID_LEN];
    static u_char       string[SPRINT_MAX_LEN];
    ifMauTable_entry_t  table_entry;
    oid                 *op = NULL;
    int                 len;

    *write_method = 0;              /* assume it isnt writable for the time being */
    *var_len = sizeof(ulong_ret);   /* assume an integer and change later if not */
    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length != 13) {
            return NULL;
        }

        mau_ifIndex = name[11];
        mau_index = name[12];
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (table_index != mau_ifIndex && mau_index != 1) {
            return NULL;
        }
        if (!get_ifMauTable_entry(table_index, &table_entry)) {
            return NULL;
        }
    } else {
        mau_ifIndex = *length > 11 ? name[11] : 1;
        mau_index = *length > 12 ? name[12] : 0;
        op = name + 12;
        len = *length - 12;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
        }

        if (mau_index >= 1) {
            mau_ifIndex++;
        }
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (!get_ifMauTable_entry(table_index, &table_entry)) {
            return NULL;
        }

        name[11] = table_index;
        name[12] = 1;
        *length = 13;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFMAUIFINDEX: {
        ulong_ret = table_index;
        return (u_char *) &ulong_ret;
    }
    case IFMAUINDEX: {
        ulong_ret = 1;
        return (u_char *) &ulong_ret;
    }
    case IFMAUTYPE: {
        if ( table_entry.ifMauType[0] ) {
            *var_len = 9 * sizeof(oid);
        } else {
            *var_len = 2 * sizeof(oid);
        }
        memcpy(objid, table_entry.ifMauType, *var_len );
        return (u_char *) objid;
    }
    case IFMAUSTATUS: {
#if 0   /* not support write function now */
        *write_method = write_ifMauStatus;
#endif
        ulong_ret = table_entry.ifMauStatus;
        return (u_char *) &ulong_ret;
    }
    case IFMAUMEDIAAVAILABLE: {
        ulong_ret = table_entry.ifMauMediaAvailable;
        return (u_char *) &ulong_ret;
    }
    case IFMAUMEDIAAVAILABLESTATEEXITS: {
        ulong_ret = table_entry.ifMauMediaAvailableStateExits;
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFMAUJABBERSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFMAUJABBERINGSTATEENTERS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFMAUFALSECARRIERS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
#if 0 /* DEPRECATED */
    case IFMAUTYPELIST: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case IFMAUDEFAULTTYPE: {
        *write_method = write_ifMauDefaultType;
        *var_len = 9 * sizeof(oid);
        memcpy(objid, table_entry.ifMauDefaultType, *var_len);
        return (u_char *) objid;
    }
    case IFMAUAUTONEGSUPPORTED: {
        ulong_ret = table_entry.ifMauAutoNegSupported;
        return (u_char *) &ulong_ret;
    }
    case IFMAUTYPELISTBITS: {
        int i;

        memset(string, 0, 6);
        *var_len = 6;
        for (i = 0; i <= 40; i++) {
            if (table_entry.ifMauTypeListBits & (0x1 << i) ) {
                string[i / 8] |= 0x1 << (7 - (i % 8));
            }
        }
        return (u_char *) string;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFMAUHCFALSECARRIERS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifMauTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_ifJackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_ifJackTable(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_index;
    u_long          mau_ifIndex, mau_index, ifJackIndex;
    static u_long   ulong_ret;
    iftable_info_t  table_info;
    port_status_t   port_status;
    oid             *op = NULL;
    int             len;

    *write_method = 0;              /* assume it isnt writable for the time being */
    *var_len = sizeof(ulong_ret);   /* assume an integer and change later if not */
    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length != 14) {
            return NULL;
        }

        mau_ifIndex = name[11];
        mau_index = name[12];
        ifJackIndex = name[13];
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (table_index != mau_ifIndex && mau_index != 1 && ifJackIndex != 1) {
            return NULL;
        }
        if (!get_ifTableIndex_info(table_index, &table_info)) {
            return NULL;
        }

        switch (table_info.type) {
        case IFTABLE_IFINDEX_TYPE_PORT:
            break;
        case IFTABLE_IFINDEX_TYPE_LLAG:
        case IFTABLE_IFINDEX_TYPE_GLAG:
        case IFTABLE_IFINDEX_TYPE_VLAN:
        case IFTABLE_IFINDEX_TYPE_IP:
        default:
            return NULL;
        }
    } else {
        mau_ifIndex = *length > 11 ? name[11] : 1;
        mau_index = *length > 12 ? name[12] : 0;
        ifJackIndex = *length > 13 ? name[13] : 0;
        op = name + 13;
        len = *length - 13;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
        }

        if (mau_index >= 1 && ifJackIndex >= 1) {
            mau_ifIndex++;
        }
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (!get_ifTableIndex_info(table_index, &table_info)) {
            return NULL;
        }

        switch (table_info.type) {
        case IFTABLE_IFINDEX_TYPE_PORT:
            break;
        case IFTABLE_IFINDEX_TYPE_LLAG:
        case IFTABLE_IFINDEX_TYPE_GLAG:
        case IFTABLE_IFINDEX_TYPE_VLAN:
        case IFTABLE_IFINDEX_TYPE_IP:
        default:
            return NULL;
        }

        name[11] = table_index;
        name[12] = 1;
        name[13] = 1;
        *length = 14;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if 0   /* IFJACKINDEX is not-accessiable*/
    case IFJACKINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case IFJACKTYPE: { /*other ( 1 ) , rj45 ( 2 ) , rj45S ( 3 ) , db9 ( 4 ) , bnc ( 5 ) , fAUI ( 6 ) , mAUI ( 7 ) , fiberSC ( 8 ) , fiberMIC ( 9 ) , fiberST ( 10 ) , telco ( 11 ) , mtrj ( 12 ) , hssdc ( 13 ) , fiberLC ( 14 ) }*/
        if (port_mgmt_status_get(table_info.isid, table_info.if_id, &port_status) != VTSS_OK) {
            return FALSE;
        }
        if (port_status.fiber) {
            ulong_ret = 8;
        } else {
            ulong_ret = 2;
        }

        return (u_char *) & ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifJackTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not support now */
int
write_ifMauStatus(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifMauStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifMauStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifMauStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /*#if 0 */

int
write_ifMauDefaultType(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    int             max_size;
    int             if_num;
    oid             intval[MAX_OID_LEN];
    iftable_info_t           table_info;
    port_conf_t             port_conf;

    max_size = MAX_OID_LEN * sizeof(oid);
    //intval = *((oid *) var_val);
    memcpy(intval, (oid *) var_val, 9 * sizeof(oid));

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to ifMauDefaultType: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifMauDefaultType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */

        switch (table_info.type) {
        case IFTABLE_IFINDEX_TYPE_PORT:
            if (PORT_NO_IS_STACK(table_info.if_id)) {
                if (action == UNDO) {
                    return SNMP_ERR_NOERROR;
                } else {
                    return SNMP_ERR_NOTWRITABLE;
                }
            }
            if (port_mgmt_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            /*ifMauType:bOther ( 0 ) , bAUI ( 1 ) , b10base5 ( 2 ) , bFoirl ( 3 ) , b10base2 ( 4 ) , b10baseT ( 5 ) ,
            b10baseFP ( 6 ) , b10baseFB ( 7 ) , b10baseFL ( 8 ) , b10broad36 ( 9 ) , b10baseTHD ( 10 ) ,
            b10baseTFD ( 11 ) , b10baseFLHD ( 12 ) , b10baseFLFD ( 13 ) , b100baseT4 ( 14 ) , b100baseTXHD ( 15 ) ,
            b100baseTXFD ( 16 ) , b100baseFXHD ( 17 ) , b100baseFXFD ( 18 ) , b100baseT2HD ( 19 ) ,
            b100baseT2FD ( 20 ) , b1000baseXHD ( 21 ) , b1000baseXFD ( 22 ) , b1000baseLXHD ( 23 ) ,
            b1000baseLXFD ( 24 ) , b1000baseSXHD ( 25 ) , b1000baseSXFD ( 26 ) , b1000baseCXHD ( 27 ) ,
            b1000baseCXFD ( 28 ) , b1000baseTHD ( 29 ) , b1000baseTFD ( 30 ) , b10GbaseX ( 31 ) , b10GbaseLX4 ( 32 )
            , b10GbaseR ( 33 ) , b10GbaseER ( 34 ) , b10GbaseLR ( 35 ) , b10GbaseSR ( 36 ) , b10GbaseW ( 37 ) ,
            b10GbaseEW ( 38 ) , b10GbaseLW ( 39 ) , b10GbaseSW ( 40 ) */
            if (intval[8] == 22 || intval[8] == 30) {
                port_conf.speed = VTSS_SPEED_1G;
                port_conf.fdx = TRUE;
            } else if (intval[8] == 21 || intval[8] == 29) {
                port_conf.speed = VTSS_SPEED_1G;
                port_conf.fdx = FALSE;
            } else if (intval[8] == 16) {
                port_conf.speed = VTSS_SPEED_100M;
                port_conf.fdx = TRUE;
            } else if (intval[8] == 15) {
                port_conf.speed = VTSS_SPEED_100M;
                port_conf.fdx = FALSE;
            } else if (intval[8] == 11) {
                port_conf.speed = VTSS_SPEED_10M;
                port_conf.fdx = TRUE;
            } else if (intval[8] == 5) {
                port_conf.speed = VTSS_SPEED_10M;
                port_conf.fdx = FALSE;
            }

            if (port_mgmt_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            break;
        case IFTABLE_IFINDEX_TYPE_LLAG:
        case IFTABLE_IFINDEX_TYPE_GLAG:
        case IFTABLE_IFINDEX_TYPE_VLAN:
        case IFTABLE_IFINDEX_TYPE_IP:
        default:
            break;
        }

    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif      /*RFC3636_SUPPORTED_ifMAU*/

#if RFC3636_SUPPORTED_ifMAU_AUTONEG
/*
 * var_ifMauAutoNegTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_ifMauAutoNegTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */


    int                         table_index;
    u_long                      mau_ifIndex, mau_index;
    static u_long               ulong_ret;
    static u_char               string[SPRINT_MAX_LEN];
    ifMauAutoNegTable_entry_t   table_entry;
    oid                         *op = NULL;
    int                         len;

    *write_method = 0;              /* assume it isnt writable for the time being */
    *var_len = sizeof(ulong_ret);   /* assume an integer and change later if not */
    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length != 13) {
            return NULL;
        }

        mau_ifIndex = name[11];
        mau_index = name[12];
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (table_index != mau_ifIndex && mau_index != 1) {
            return NULL;
        }
        if (!get_ifMauAutoNegTable_entry(table_index, &table_entry)) {
            return NULL;
        }
    } else {
        mau_ifIndex = *length > 11 ? name[11] : 1;
        mau_index = *length > 12 ? name[12] : 0;
        op = name + 12;
        len = *length - 12;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
        }

        if (mau_index >= 1) {
            mau_ifIndex++;
        }
        table_index = get_available_ifTableIndex(mau_ifIndex);
        if (!get_ifMauAutoNegTable_entry(table_index, &table_entry) ) {
            return NULL;
        }

        name[11] = table_index;
        name[12] = 1;
        *length = 13;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFMAUAUTONEGADMINSTATUS: {
        *write_method = write_ifMauAutoNegAdminStatus;
        ulong_ret = table_entry.ifMauAutoNegAdminStatus;
        return (u_char *) &ulong_ret;
    }
    case IFMAUAUTONEGREMOTESIGNALING: {
        ulong_ret = table_entry.ifMauAutoNegRemoteSignaling;
        return (u_char *) &ulong_ret;
    }
    case IFMAUAUTONEGCONFIG: {
        ulong_ret = table_entry.ifMauAutoNegConfig;
        return (u_char *) &ulong_ret;
    }
#if 0 /* DEPRECATED */
    case IFMAUAUTONEGCAPABILITY: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFMAUAUTONEGCAPADVERTISED: {
        *write_method = write_ifMauAutoNegCapAdvertised;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFMAUAUTONEGCAPRECEIVED: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case IFMAUAUTONEGRESTART: {
        *write_method = write_ifMauAutoNegRestart;
        ulong_ret = table_entry.ifMauAutoNegRestart;
        return (u_char *) &ulong_ret;
    }
    case IFMAUAUTONEGCAPABILITYBITS: {
        int i;

        memset(string, 0, 2);
        *var_len = 2;
        for (i = 0; i <= 15; i++) {
            if (table_entry.ifMauAutoNegCapabilityBits & (0x1 << i) ) {
                string[i / 8] |= 0x1 << (7 - (i % 8));
            }
        }
        return (u_char *) string;
    }
    case IFMAUAUTONEGCAPADVERTISEDBITS: {
        int i;

        *write_method = write_ifMauAutoNegCapAdvertisedBits;

        memset(string, 0, 2);
        *var_len = 2;
        for (i = 0; i <= 15; i++) {
            if (table_entry.ifMauAutoNegCapAdvertisedBits & (0x1 << i) ) {
                string[i / 8] |= 0x1 << (7 - (i % 8));
            }
        }
        return (u_char *) string;
    }
    case IFMAUAUTONEGCAPRECEIVEDBITS: {
        int i;

        memset(string, 0, 2);
        *var_len = 2;
        for (i = 0; i <= 15; i++) {
            if (table_entry.ifMauAutoNegCapReceivedBits & (0x1 << i) ) {
                string[i / 8] |= 0x1 << (7 - (i % 8));
            }
        }
        return (u_char *) string;
    }
#if 0 /* Not support in E-Stax34 */
    case IFMAUAUTONEGREMOTEFAULTADVERTISED: {
        *write_method = write_ifMauAutoNegRemoteFaultAdvertised;
        ulong_ret = table_entry.ifMauAutoNegRemoteFaultAdvertised;
        return (u_char *) &ulong_ret;
    }
    case IFMAUAUTONEGREMOTEFAULTRECEIVED: {
        ulong_ret = table_entry.ifMauAutoNegRemoteFaultReceived;
        return (u_char *) &ulong_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ifMauAutoNegTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif      /*RFC3636_SUPPORTED_ifMAU_AUTONEG*/

#if RFC3636_SUPPORTED_BROAD_MAU
/*
 * var_broadMauBasicTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpDot3MauMgt above.
 */
u_char         *
var_broadMauBasicTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //broadMauBasicTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_broadMauBasicTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_broadMauBasicTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case BROADMAUIFINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case BROADMAUINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case BROADMAUXMTRCVSPLITTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case BROADMAUXMTCARRIERFREQ: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case BROADMAUTRANSLATIONFREQ: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_broadMauBasicTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif      /*RFC3636_SUPPORTED_BROAD_MAU*/

#if RFC3636_SUPPORTED_ifMAU_AUTONEG
int
write_ifMauAutoNegAdminStatus(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    int             max_size;
    long          intval;
    int             if_num;
    iftable_info_t           table_info;
    port_conf_t             port_conf;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    if_num = name[name_len - 2];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegAdminStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegAdminStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegAdminStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (port_mgmt_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        if (intval == 1 ) {
            port_conf.autoneg = TRUE;
        } else if (intval == 2 ) {
            port_conf.autoneg = FALSE;
        } else {
            return SNMP_ERR_BADVALUE;
        }

        if (port_mgmt_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifMauAutoNegRestart(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP, oid *name, size_t name_len)
{
    int             max_size;
    long          intval;
    int             if_num;
    iftable_info_t           table_info;
    port_conf_t             port_conf;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    if_num = name[name_len - 2];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRestart: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRestart: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRestart: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        if (port_mgmt_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        if (intval == 1 ) {
            if (port_conf.autoneg == TRUE) {
                if (port_mgmt_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                    return SNMP_ERR_RESOURCEUNAVAILABLE;
                }
            } else {
                return SNMP_ERR_NOERROR;
            }
        } else if (intval == 2 ) {
            return SNMP_ERR_NOERROR;
        } else {
            return SNMP_ERR_BADVALUE;
        }


        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifMauAutoNegCapAdvertisedBits(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    int             max_size;
    iftable_info_t           table_info;
    int             if_num;
    char          intval[2];
    ushort      autoneg_adver, thoundbaseT_control;
    port_info_t              port_info;

    max_size = 2 * sizeof(char);
    memcpy(intval, (char *) var_val, 2);

    if_num = name[name_len - 2];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegCapAdvertisedBits: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if ((*var_val < 0) || (*var_val > 0xFFFF)) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegCapAdvertisedBits: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x4, 0, &autoneg_adver, 0, 0) != VTSS_OK ) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        if ( misc_debug_phy_read(table_info.isid, table_info.if_id, 0x9, 0, &thoundbaseT_control, 0, 0) != VTSS_OK ) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        /* ifMauAutoNegCapAdvertisedBits: bOther ( 0 ) , b10baseT ( 1 ) , b10baseTFD ( 2 ) , b100baseT4 ( 3 ) ,
        b100baseTX ( 4 ) , b100baseTXFD ( 5 ) , b100baseT2 ( 6 ) , b100baseT2FD ( 7 ) , bfdxPause ( 8 ) ,
        bfdxAPause ( 9 ) , bfdxSPause ( 10 ) , bfdxBPause ( 11 ) , b1000baseX ( 12 ) , b1000baseXFD ( 13 ) ,
        b1000baseT ( 14 ) , b1000baseTFD ( 15 ) */
        thoundbaseT_control &= ~0x300;
        if  (intval[1] & 0x1) { //b1000baseTFD( 15 )
            thoundbaseT_control |= 0x200;
        }
        if  (intval[1] & 0x2) { //b1000baseT( 14 )
            thoundbaseT_control |= 0x100;
        }
        autoneg_adver &= ~0x3e0;
        if  (intval[0] & 0x10) { //b100baseT4( 3 )
            autoneg_adver |= 0x200;
        }
        if  (intval[0] & 0x04) { //b100baseTXFD( 5 )
            autoneg_adver |= 0x100;
        }
        if  (intval[0] & 0x08) { //b100baseTX( 4 )
            autoneg_adver |= 0x80;
        }
        if  (intval[0] & 0x20) { //b10baseTFD( 2 )
            autoneg_adver |= 0x40;
        }
        if  (intval[0] & 0x40) { //b10baseTFD( 1)
            autoneg_adver |= 0x20;
        }
        if (port_info_get(table_info.if_id, &port_info) == VTSS_OK && port_info.phy) {
            if ( misc_debug_phy_write(table_info.isid, table_info.if_id, 0x4, 0, autoneg_adver, 0, 0) != VTSS_OK ) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if ( misc_debug_phy_write(table_info.isid, table_info.if_id, 0x9, 0, thoundbaseT_control, 0, 0) != VTSS_OK ) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        }
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /*Not Support in E-StaX34 */
int
write_ifMauAutoNegRemoteFaultAdvertised(int action,
                                        u_char *var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char *statP,
                                        oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRemoteFaultAdvertised: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRemoteFaultAdvertised: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifMauAutoNegRemoteFaultAdvertised: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /*#if 0 */
#endif  /*RFC3636_SUPPORTED_ifMAU_AUTONEG*/

#if RFC3636_SUPPORTED_rpMAU
int
write_rpMauStatus(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to rpMauStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to rpMauStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to rpMauStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif      /*RFC3636_SUPPORTED_rpMAU*/

