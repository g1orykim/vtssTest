/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */


/* We *have* serialized access */
/*lint -esym(459, last_notification_change_time) */
/*lint -esym(459,tx_enable_list) */
/*lint -esym(459,VAR) */
/*lint -esym(459,table_info) */
/*lint -esym(459,VAR_STR) */
/*lint -esym(459,local_system_name) */
/*lint -esym(459,buf) */
/*lint -esym(459,old_buf) */


#include <main.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "dot1ab_lldp.h"

#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"

#include "lldp_api.h"
#include "lldp_remote.h"
#include "lldp_tlv.h"
#include "lldp_os.h"
#include "lldp.h"
#include "lldp_print.h"
#include "misc_api.h"


#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "rfc1213_mib2.h"
#include "iana_addr_family_nums.h"


/* #if (VTSS_TRACE_ENABLED) */
#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_LLDP
/* #endif /\* VTSS_TRACE_ENABLED *\/ */

#define SNMP_ASN_OCTET_STR_MAX_LEN  256  /* FIXME : Re-define it if needed */

#define REMOVE_STATS_IN_TRAP_BINDING_VAR

/*
* +++ Start (Internal implementation declarations)
*/
#if DOT1AB_SUPPORTED_LLDPOBJECTS
/* lldpobjects ----------------------------------------------------------*/
//???
#endif /* DOT1AB_SUPPORTED_LLDPOBJECTS */
/*
* --- End (Internal implementation declarations)
*/

#if DOT1AB_SUPPORTED_LLDPOBJECTS
/* lldpobjects ----------------------------------------------------------*/
/*
* lldpObjects_variables_oid:
*   this is the top level oid that we want to register under.  This
*   is essentially a prefix, with the suffix appearing in the
*   variable below.
*/

oid             lldpObjects_variables_oid[] = { 1, 0, 8802, 1, 1, 2, 1 };

/*
* variable4 lldpObjects_variables:
*   this variable defines function callbacks and type return information
*   for the lldpObjects mib section
*/


struct variable4 lldpObjects_variables[] = {
    /*
    * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
    */
#define LLDPMESSAGETXINTERVAL                   1
    {LLDPMESSAGETXINTERVAL, ASN_INTEGER, RWRITE, var_lldpConfiguration, 2, {1, 1}},
#define LLDPMESSAGETXHOLDMULTIPLIER             2
    {LLDPMESSAGETXHOLDMULTIPLIER, ASN_INTEGER, RWRITE, var_lldpConfiguration, 2, {1, 2}},
#define LLDPREINITDELAY                         3
    {LLDPREINITDELAY, ASN_INTEGER, RWRITE, var_lldpConfiguration, 2, {1, 3}},
#define LLDPTXDELAY                             4
    {LLDPTXDELAY, ASN_INTEGER, RWRITE, var_lldpConfiguration, 2, {1, 4}},
#define LLDPNOTIFICATIONINTERVAL                5
    {LLDPNOTIFICATIONINTERVAL, ASN_INTEGER, RWRITE, var_lldpConfiguration, 2, {1, 5}},
#define LLDPPORTCONFIGPORTNUM                   6
    {LLDPPORTCONFIGPORTNUM, ASN_INTEGER, RONLY, var_lldpPortConfigTable, 4, {1, 6, 1, 1}},
#define LLDPPORTCONFIGADMINSTATUS               7
    {LLDPPORTCONFIGADMINSTATUS, ASN_INTEGER, RWRITE, var_lldpPortConfigTable, 4, {1, 6, 1, 2}},
#define LLDPPORTCONFIGNOTIFICATIONENABLE        8
    {LLDPPORTCONFIGNOTIFICATIONENABLE, ASN_INTEGER, RWRITE, var_lldpPortConfigTable, 4, {1, 6, 1, 3}},
#define LLDPPORTCONFIGTLVSTXENABLE              9
    {LLDPPORTCONFIGTLVSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpPortConfigTable, 4, {1, 6, 1, 4}},
#define LLDPCONFIGMANADDRPORTSTXENABLE          10
    {LLDPCONFIGMANADDRPORTSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpConfigManAddrTable, 4, {1, 7, 1, 1}},
#define LLDPSTATSREMTABLESLASTCHANGETIME        11
    {LLDPSTATSREMTABLESLASTCHANGETIME, ASN_TIMETICKS, RONLY, var_lldpStatistics, 2, {2, 1}},
#define LLDPSTATSREMTABLESINSERTS               12
    {LLDPSTATSREMTABLESINSERTS, ASN_GAUGE, RONLY, var_lldpStatistics, 2, {2, 2}},
#define LLDPSTATSREMTABLESDELETES               13
    {LLDPSTATSREMTABLESDELETES, ASN_GAUGE, RONLY, var_lldpStatistics, 2, {2, 3}},
#define LLDPSTATSREMTABLESDROPS                 14
    {LLDPSTATSREMTABLESDROPS, ASN_GAUGE, RONLY, var_lldpStatistics, 2, {2, 4}},
#define LLDPSTATSREMTABLESAGEOUTS               15
    {LLDPSTATSREMTABLESAGEOUTS, ASN_GAUGE, RONLY, var_lldpStatistics, 2, {2, 5}},
#define LLDPSTATSTXPORTNUM                      16
    {LLDPSTATSTXPORTNUM, ASN_INTEGER, RONLY, var_lldpStatsTxPortTable, 4, {2, 6, 1, 1}},
#define LLDPSTATSTXPORTFRAMESTOTAL              17
    {LLDPSTATSTXPORTFRAMESTOTAL, ASN_COUNTER, RONLY, var_lldpStatsTxPortTable, 4, {2, 6, 1, 2}},
#define LLDPSTATSRXPORTNUM                      18
    {LLDPSTATSRXPORTNUM, ASN_INTEGER, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 1}},
#define LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL     19
    {LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 2}},
#define LLDPSTATSRXPORTFRAMESERRORS             20
    {LLDPSTATSRXPORTFRAMESERRORS, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 3}},
#define LLDPSTATSRXPORTFRAMESTOTAL              21
    {LLDPSTATSRXPORTFRAMESTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 4}},
#define LLDPSTATSRXPORTTLVSDISCARDEDTOTAL       22
    {LLDPSTATSRXPORTTLVSDISCARDEDTOTAL, ASN_COUNTER, RONLY,  var_lldpStatsRxPortTable, 4, {2, 7, 1, 5}},
#define LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL    23
    {LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 6}},
#define LLDPSTATSRXPORTAGEOUTSTOTAL             24
    {LLDPSTATSRXPORTAGEOUTSTOTAL, ASN_GAUGE, RONLY, var_lldpStatsRxPortTable, 4, {2, 7, 1, 7}},
#define LLDPLOCCHASSISIDSUBTYPE                 25
    {LLDPLOCCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocalSystemData, 2, {3, 1}},
#define LLDPLOCCHASSISID                        26
    {LLDPLOCCHASSISID, ASN_OCTET_STR, RONLY, var_lldpLocalSystemData, 2, {3, 2}},
#define LLDPLOCSYSNAME                          27
    {LLDPLOCSYSNAME, ASN_OCTET_STR, RONLY, var_lldpLocalSystemData, 2, {3, 3}},
#define LLDPLOCSYSDESC                          28
    {LLDPLOCSYSDESC, ASN_OCTET_STR, RONLY, var_lldpLocalSystemData, 2, {3, 4}},
#define LLDPLOCSYSCAPSUPPORTED                  29
    {LLDPLOCSYSCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpLocalSystemData, 2, {3, 5}},
#define LLDPLOCSYSCAPENABLED                    30
    {LLDPLOCSYSCAPENABLED, ASN_OCTET_STR, RONLY, var_lldpLocalSystemData, 2, {3, 6}},
#define LLDPLOCPORTNUM                          31
    {LLDPLOCPORTNUM, ASN_INTEGER, RONLY, var_lldpLocPortTable, 4, {3, 7, 1, 1}},
#define LLDPLOCPORTIDSUBTYPE                    32
    {LLDPLOCPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocPortTable, 4, {3, 7, 1, 2}},
#define LLDPLOCPORTID                           33
    {LLDPLOCPORTID, ASN_OCTET_STR, RONLY, var_lldpLocPortTable, 4, {3, 7, 1, 3}},
#define LLDPLOCPORTDESC                         34
    {LLDPLOCPORTDESC, ASN_OCTET_STR, RONLY, var_lldpLocPortTable, 4, {3, 7, 1, 4}},
    /*
    #define LLDPLOCMANADDRSUBTYPE                   35
    {LLDPLOCMANADDRSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 1}},
    #define LLDPLOCMANADDR                          36
    {LLDPLOCMANADDR, ASN_OCTET_STR, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 2}},
    */
#define LLDPLOCMANADDRLEN                       37
    {LLDPLOCMANADDRLEN, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 3}},
#define LLDPLOCMANADDRIFSUBTYPE                 38
    {LLDPLOCMANADDRIFSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 4}},
#define LLDPLOCMANADDRIFID                      39
    {LLDPLOCMANADDRIFID, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 5}},
#define LLDPLOCMANADDROID                       40
    {LLDPLOCMANADDROID, ASN_OBJECT_ID, RONLY, var_lldpLocManAddrTable, 4, {3, 8, 1, 6}},
#define LLDPREMTIMEMARK                         41
    {LLDPREMTIMEMARK, ASN_TIMETICKS, RONLY, var_lldpRemTable, 4, {4, 1, 1, 1}},
#define LLDPREMLOCALPORTNUM                     42
    {LLDPREMLOCALPORTNUM, ASN_INTEGER, RONLY, var_lldpRemTable, 4, {4, 1, 1, 2}},
#define LLDPREMINDEX                            43
    {LLDPREMINDEX, ASN_INTEGER, RONLY, var_lldpRemTable, 4, {4, 1, 1, 3}},
#define LLDPREMCHASSISIDSUBTYPE                 44
    {LLDPREMCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemTable, 4, {4, 1, 1, 4}},
#define LLDPREMCHASSISID                        45
    {LLDPREMCHASSISID, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 5}},
#define LLDPREMPORTIDSUBTYPE                    46
    {LLDPREMPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemTable, 4, {4, 1, 1, 6}},
#define LLDPREMPORTID                           47
    {LLDPREMPORTID, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 7}},
#define LLDPREMPORTDESC                         48
    {LLDPREMPORTDESC, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 8}},
#define LLDPREMSYSNAME                          49
    {LLDPREMSYSNAME, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 9}},
#define LLDPREMSYSDESC                          50
    {LLDPREMSYSDESC, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 10}},
#define LLDPREMSYSCAPSUPPORTED                  51
    {LLDPREMSYSCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 11}},
#define LLDPREMSYSCAPENABLED                    52
    {LLDPREMSYSCAPENABLED, ASN_OCTET_STR, RONLY, var_lldpRemTable, 4, {4, 1, 1, 12}},
    /*
    #define LLDPREMMANADDRSUBTYPE                   53
        {LLDPREMMANADDRSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemManAddrTable, 4, {4, 2, 1, 1}},
    #define LLDPREMMANADDR                          54
        {LLDPREMMANADDR, ASN_OCTET_STR, RONLY, var_lldpRemManAddrTable, 4, {4, 2, 1, 2}},
    */
#define LLDPREMMANADDRIFSUBTYPE                 55
    {LLDPREMMANADDRIFSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemManAddrTable, 4, {4, 2, 1, 3}},
#define LLDPREMMANADDRIFID                      56
    {LLDPREMMANADDRIFID, ASN_INTEGER, RONLY, var_lldpRemManAddrTable, 4, {4, 2, 1, 4}},
#define LLDPREMMANADDROID                       57
    {LLDPREMMANADDROID, ASN_OBJECT_ID, RONLY, var_lldpRemManAddrTable, 4, {4, 2, 1, 5}},

#ifndef NOT_SUPPORTED_IN_ESTAX34
#define LLDPREMUNKNOWNTLVTYPE                   58
    {LLDPREMUNKNOWNTLVTYPE, ASN_INTEGER, RONLY, var_lldpRemUnknownTLVTable, 4, {4, 3, 1, 1}},
#define LLDPREMUNKNOWNTLVINFO                   59
    {LLDPREMUNKNOWNTLVINFO, ASN_OCTET_STR, RONLY, var_lldpRemUnknownTLVTable, 4, {4, 3, 1, 2}},
#define LLDPREMORGDEFINFOOUI                    60
    {LLDPREMORGDEFINFOOUI, ASN_OCTET_STR, RONLY, var_lldpRemOrgDefInfoTable, 4, {4, 4, 1, 1}},
#define LLDPREMORGDEFINFOSUBTYPE                61
    {LLDPREMORGDEFINFOSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemOrgDefInfoTable, 4, {4, 4, 1, 2}},
#define LLDPREMORGDEFINFOINDEX                  62
    {LLDPREMORGDEFINFOINDEX, ASN_INTEGER, RONLY, var_lldpRemOrgDefInfoTable, 4, {4, 4, 1, 3}},
#define LLDPREMORGDEFINFO                       63
    {LLDPREMORGDEFINFO, ASN_OCTET_STR, RONLY, var_lldpRemOrgDefInfoTable, 4, {4, 4, 1, 4}},
#endif
};




/*
* (L = length of the oidsuffix)
*/



static dot1Port_info_t  table_info;

#define PORT_INDEX  table_info.if_id


// BITS type must be swapped
char BITS_type_swapbyte(unsigned char input)
{
    unsigned char result = 0;
    char r_index = 0;
    for (r_index = 0; r_index < 8; ++r_index) {
        result = result << 1;
        result |= (input & 1);
        input = input >> 1;
    }
    return result;
}

/*
* Initializes the lldpObjects module
*/
void
init_lldpObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(lldpObjects_variables_oid,
                             sizeof(lldpObjects_variables_oid) / sizeof(oid),
                             "LLDP-MIB : lldpObjects");

    DEBUGMSGTL(("lldpObjects", "Initializing\n"));

    /*
    * register ourselves with the agent to handle our mib tree
    */
    REGISTER_MIB("lldpObjects", lldpObjects_variables, variable4,
                 lldpObjects_variables_oid);

    /*
    * place any other initialization junk you need here
    */
}

/*
* var_lldpConfiguration():
*   This function is called every time the agent gets a request for
*   a scalar variable that might be found within your mib section
*   registered above.  It is up to you to do the right thing and
*   return the correct value.
*     You should also correct the value of "var_len" if necessary.
*
*   Please see the documentation for more information about writing
*   module extensions, and check out the examples in the examples
*   and mibII directories.
*/
u_char         *
var_lldpConfiguration(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact, size_t *var_len, WriteMethod **write_method)
{

    static long     VAR = 0;

    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, VTSS_ISID_LOCAL);

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    T_DG(TRACE_GRP_SNMP, "VTSS_ISID_LOCAL used not this isid:%d", table_info.isid);

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPMESSAGETXINTERVAL: {
        *write_method = write_lldpMessageTxInterval;
        VAR = lldp_conf.msgTxInterval;
        return (u_char *) & VAR;
    }
    case LLDPNOTIFICATIONINTERVAL: {
        *write_method = write_lldpNotificationInterval;
        VAR = lldp_mgmt_get_notification_interval(TRUE);
        return (u_char *) & VAR;
    }
    case LLDPMESSAGETXHOLDMULTIPLIER: {
        *write_method = write_lldpMessageTxHoldMultiplier;
        VAR = lldp_conf.msgTxHold;
        T_DG(TRACE_GRP_SNMP, "lldp_conf.msgTxHold:%d", lldp_conf.msgTxHold);
        return (u_char *) & VAR;
    }
    case LLDPTXDELAY: {
        *write_method = write_lldpTxDelay;
        VAR = lldp_conf.txDelay;
        return (u_char *) & VAR;
    }
    case LLDPREINITDELAY: {
        *write_method = write_lldpReinitDelay;
        VAR = lldp_conf.reInitDelay;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpConfiguration\n",
                    vp->magic));
    }
    return NULL;
}


void print_oid (int oid_length,
                oid *name)
{
    oid       *op = name;
    int i;
    for (i = 0; i < oid_length; i++) {
        T_IG(TRACE_GRP_SNMP, "OID[%d]=%lu", i, *op++);
    }

}




vtss_rc check_for_man_addr (int exact,
                            size_t *length,
                            int oid_length,
                            oid *name,
                            int subtype,
                            char *ip_addr,
                            int ip_len)
{

    BOOL      index_man_addr_subtype_found = FALSE;
    ulong     index_man_addr_subtype = 0;
    ulong     index_man_addr_length = 0;
    oid       *op = NULL;




    op = name + oid_length; // point to first index
    vtss_rc rc = VTSS_UNSPECIFIED_ERROR;
    ulong i;

    // Get the indexes
    if (op < name + *length) {
        index_man_addr_subtype = *op++;
        index_man_addr_subtype_found = TRUE;
    }

    if (op < name + *length) {
        index_man_addr_length = *op++;
    }


    if (exact) {
        T_DG(TRACE_GRP_SNMP, "check_for_man_addr exact, oid_length = %d, ip_len =%d, *length = %zu", oid_length, ip_len, *length);
        // Check that the requested OID isn't shorter than our OID
        if (*length != oid_length +  index_man_addr_length + 2) { // The  +2 is for man_addr_subtype and man_addr_length indexes.
            T_NG(TRACE_GRP_SNMP, "Wrong length, index_man_addr_length = %u", index_man_addr_length);
            rc =  VTSS_UNSPECIFIED_ERROR;
        } else if (index_man_addr_length != ip_len) {
            T_NG(TRACE_GRP_SNMP, "The reqested OID man address length doesn't match our OID man addr length, index_man_addr_length = %d, ip_len =%d",
                 index_man_addr_length, ip_len);
            rc =  VTSS_UNSPECIFIED_ERROR;
        } else {
            if (index_man_addr_subtype == (ulong)subtype) {
                rc = VTSS_OK; // By default we expect that the request is for us.

                // Loop through the management address and check if the request index exact the same a our OID.
                for (i = 0; i < (ulong)ip_len; i++) {
                    // Check that the request OID isn't longer the our OID
                    if (op > (name + oid_length + 2 + ip_len)) { // The  +2 is for man_addr_subtype and man_addr_length indexes.
                        T_IG(TRACE_GRP_SNMP, "The OID is longer than expected.");
                        rc = VTSS_UNSPECIFIED_ERROR; // The OID is longer than expected. = not exact
                        print_oid(*length, name);
                        break;
                    }

                    u32 ip_char = *ip_addr++;

                    if (*op++  != ip_char  ) {
                        T_IG(TRACE_GRP_SNMP, "IP address doesn't match.");
                        rc = VTSS_UNSPECIFIED_ERROR; // OK, it was not for us
                        break;
                    }
                }
            } else {
                T_IG(TRACE_GRP_SNMP, "Subtype didn't match.index_man_addr_subtype = %u, subtype = %d",
                     index_man_addr_subtype, subtype);
            }
        }
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");

        if (op >= (name + *length)) {
            // The requested OID is a subset of our OID (e.g. requested OID = 1.0.8802.1.1.2.1.3.8, our OID = 1.0.8802.1.1.2.1.3.8.1.5.1.4.192.168.111.58)
            T_NG(TRACE_GRP_SNMP, "Subset");
            rc = VTSS_OK; // Signaling that the request is for us
        } else  if (index_man_addr_subtype < (ulong)subtype || index_man_addr_subtype_found == FALSE) {
            T_NG(TRACE_GRP_SNMP, "index_man_addr_subtype = %u, subtype =%d", index_man_addr_subtype, subtype);
            rc = VTSS_OK;
        } else if (index_man_addr_subtype == subtype) {
            rc =  VTSS_UNSPECIFIED_ERROR; // By default expect that the request is not for us

            // Loop through the management address and check if the request index is "lower".
            for (i = 0; i < (ulong)ip_len; i++) {
                // Check if the man_addr index is a sub part of the management address ( index_man_addr_length < ip_len or id we exceeds the
                // the oid). If it is then it is a request for us.
                T_NG(TRACE_GRP_SNMP, "Same subtype, p, *op = %lu, ip_addr = %d", *op, *ip_addr);
                if (op >= (name + *length) || (i >= index_man_addr_length) ) {
                    T_NG(TRACE_GRP_SNMP, "Same subtype, Length");
                    rc = VTSS_OK; // Signaling that the request is for us
                    break; // OK - This if for us - continue
                }

                u32 ip_char = *ip_addr++;
                T_NG(TRACE_GRP_SNMP, "Same subtype,*op = %u, ip_addr = %d, ip_char = %u", (u32)*op, *ip_addr, ip_char);

                if (*op++  < ip_char  ) {
                    T_NG(TRACE_GRP_SNMP, "Same subtype, not our ip, *op = %u, ip_addr = %d", (u32)*op, *ip_addr);
                    rc = VTSS_OK; // Signaling that the request is for us
                    break; // OK - This if for us - continue
                }
            }

        } else {
            T_NG(TRACE_GRP_SNMP, "subtype larger index_man_addr_subtype = %u, subtype = %d", index_man_addr_subtype, subtype);
            rc =  VTSS_UNSPECIFIED_ERROR; // The request is not for us.
        }
    }

    return rc;
}


/*
 * The entry data structure for lldpLocManAddrTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            lldpLocManAddrSubtype;
    char            lldpLocManAddr[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t          lldpLocManAddr_len;

    /*
     * Entry columns
     */
    long            lldpLocManAddrLen;
    long            lldpLocManAddrIfSubtype;
    long            lldpLocManAddrIfId;
    oid             lldpLocManAddrOID[MAX_OID_LEN];
    size_t          lldpLocManAddrOID_len;
} lldpLocManAddrTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    char            string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid             objid_ret[MAX_OID_LEN];
    size_t          objid_len_ret;
} lldpManAddrTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, lldpLocManAddrTable_global_ret)
                                                      *//*
                                                      * Process one packet at the same time, therefore unprotected access is acceptable
                                                      */
static lldpManAddrTable_return_t lldpLocManAddrTable_global_ret;     /* static variables for retuning */


static void get_pre_lldpLocManAddrTableEntryKey(lldpLocManAddrTable_entry_t *key)
{
    int i = 0;
    BOOL found = FALSE;
    u8 *ptr = (u8 *) key->lldpLocManAddr;
    if (key->lldpLocManAddr_len > 1) {
        for (i = key->lldpLocManAddr_len - 1; i >= 0; i-- ) {
            if (*(ptr + i) != 0x0 ) {
                --*(ptr + i);
                found = TRUE;
                break;
            } else {
                *(ptr + i) = 0xff;
            }
        }
        if ( TRUE == found) {
            return;
        }
    }

    if (key->lldpLocManAddr_len >= 1) {
        --key->lldpLocManAddr_len;
        return;
    }

    key->lldpLocManAddr_len = SNMP_ASN_OCTET_STR_MAX_LEN;

    if (key->lldpLocManAddrSubtype >= 1) {
        --key->lldpLocManAddrSubtype;
        return;
    }
    memset(key, 0, sizeof(lldpLocManAddrTable_entry_t));
}

static BOOL get_next_lldpLocManAddrTableEntryByKey(lldpLocManAddrTable_entry_t *table_entry)
{
    vtss_ip_addr_t    ip_addr;
    vtss_if_id_vlan_t if_id;
    iftable_info_t    info;
    vtss_ipv4_t       addr_key;

    if ( table_entry->lldpLocManAddrSubtype > IANA_ADDR_IPV4 ) {
        return FALSE;
    }

    if ( table_entry->lldpLocManAddrSubtype == IANA_ADDR_IPV4 && table_entry->lldpLocManAddr_len > sizeof( addr_key ) ) {
        return FALSE;
    }

    if ( table_entry->lldpLocManAddrSubtype == IANA_ADDR_IPV4 && table_entry->lldpLocManAddr_len == sizeof( addr_key )) {
        memcpy(&addr_key, table_entry->lldpLocManAddr, sizeof( addr_key ));
        ip_addr.type = VTSS_IP_TYPE_IPV4;
        ip_addr.addr.ipv4 = ntohl(addr_key);
    } else {
        ip_addr.type = VTSS_IP_TYPE_IPV4;
        memset(&ip_addr.addr.ipv4, 0, sizeof( ip_addr.addr.ipv4 ));
    }

    if ( FALSE == get_next_ip(&ip_addr, &if_id) || ip_addr.type != VTSS_IP_TYPE_IPV4 ) {
        return FALSE;
    }

    table_entry->lldpLocManAddrSubtype = ip_addr.type == VTSS_IP_TYPE_IPV4 ? IANA_ADDR_IPV4 : IANA_ADDR_IPV4;
    table_entry->lldpLocManAddr_len = ip_addr.type == VTSS_IP_TYPE_IPV4 ? sizeof(ip_addr.addr.ipv4) : sizeof(ip_addr.addr.ipv6);
    addr_key = htonl(ip_addr.addr.ipv4);
    memcpy(table_entry->lldpLocManAddr, &addr_key, table_entry->lldpLocManAddr_len);

    table_entry->lldpLocManAddrLen = sizeof(addr_key) + 1;
    table_entry->lldpLocManAddrIfSubtype = ( i32) lldp_tlv_get_mgmt_if_num_subtype();

    info.if_id  = if_id;
    info.type   = IFTABLE_IFINDEX_TYPE_IP;
    (void) ifIndex_get_by_interface( &info );
    table_entry->lldpLocManAddrIfId = info.ifIndex;
    table_entry->lldpLocManAddrOID_len = 2;
    memset(table_entry->lldpLocManAddrOID, 0, table_entry->lldpLocManAddrOID_len * sizeof(oid));
    return TRUE;
}

static BOOL get_lldpLocManAddrTableEntryByKey(lldpLocManAddrTable_entry_t *table_entry)
{
    lldpLocManAddrTable_entry_t tmp;

    tmp.lldpLocManAddrSubtype = table_entry->lldpLocManAddrSubtype;
    tmp.lldpLocManAddr_len    = table_entry->lldpLocManAddr_len;
    memcpy(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len);
    get_pre_lldpLocManAddrTableEntryKey(&tmp);

    if ( FALSE == get_next_lldpLocManAddrTableEntryByKey(&tmp) ) {
        return FALSE;
    }

    if (tmp.lldpLocManAddrSubtype == table_entry->lldpLocManAddrSubtype && tmp.lldpLocManAddr_len == table_entry->lldpLocManAddr_len &&
        !memcmp(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len)) {
        memcpy(table_entry, &tmp, sizeof(tmp));
        return TRUE;
    }
    return FALSE;

}

static int
getfirst_lldpLocManAddrTableEntry(lldpLocManAddrTable_entry_t *
                                  table_entry)
{
    memset(table_entry, 0, sizeof(lldpLocManAddrTable_entry_t));
    table_entry->lldpLocManAddrSubtype = 0;
    table_entry->lldpLocManAddr_len = 0;
    if ( FALSE == get_next_lldpLocManAddrTableEntryByKey(table_entry) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
get_lldpLocManAddrTableEntry(lldpLocManAddrTable_entry_t *table_entry,
                             BOOL getnext)
{
    lldpLocManAddrTable_entry_t tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.lldpLocManAddrSubtype = table_entry->lldpLocManAddrSubtype;
    tmp.lldpLocManAddr_len = table_entry->lldpLocManAddr_len;
    memcpy(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len);

    if ( (getnext == TRUE &&  FALSE == get_next_lldpLocManAddrTableEntryByKey(&tmp)) ||
         (getnext == FALSE && FALSE == get_lldpLocManAddrTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
parse_lldpLocManAddrTable(oid *name,
                          size_t *length,
                          int exact,
                          lldpLocManAddrTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t         len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_lldpLocManAddrTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->lldpLocManAddrSubtype = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = *op++;
    len = len > sizeof(table_entry->lldpLocManAddr) ? sizeof(table_entry->lldpLocManAddr) : len;
    op_pos++;
    table_entry->lldpLocManAddr_len = len;
    cp = (u_char *) table_entry->lldpLocManAddr;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_lldpLocManAddrTable(oid *name,
                            size_t *length,
                            lldpLocManAddrTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->lldpLocManAddrSubtype;
    len = (int) table_entry->lldpLocManAddr_len;
    name[name_pos++] = (oid) table_entry->lldpLocManAddr_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->lldpLocManAddr[idx++];
    }

    *length = name_pos;
    return 0;
}


/*
 * var_lldpLocManAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lldpLocManAddrTable above.
 */
u_char         *
var_lldpLocManAddrTable(struct variable *vp,
                        oid *name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    lldpLocManAddrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_lldpLocManAddrTable(name, length, exact,
                                       &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_lldpLocManAddrTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_lldpLocManAddrTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_lldpLocManAddrTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case LLDPLOCMANADDRLEN: {
        lldpLocManAddrTable_global_ret.long_ret =
            table_entry.lldpLocManAddrLen;
        *var_len = sizeof(lldpLocManAddrTable_global_ret.long_ret);
        return (u_char *) & lldpLocManAddrTable_global_ret.long_ret;
    }
    case LLDPLOCMANADDRIFSUBTYPE: {
        lldpLocManAddrTable_global_ret.long_ret =
            table_entry.lldpLocManAddrIfSubtype;
        *var_len = sizeof(lldpLocManAddrTable_global_ret.long_ret);
        return (u_char *) & lldpLocManAddrTable_global_ret.long_ret;
    }
    case LLDPLOCMANADDRIFID: {
        lldpLocManAddrTable_global_ret.long_ret =
            table_entry.lldpLocManAddrIfId;
        *var_len = sizeof(lldpLocManAddrTable_global_ret.long_ret);
        return (u_char *) & lldpLocManAddrTable_global_ret.long_ret;
    }
    case LLDPLOCMANADDROID: {
        memcpy(lldpLocManAddrTable_global_ret.objid_ret,
               table_entry.lldpLocManAddrOID,
               table_entry.lldpLocManAddrOID_len * sizeof(oid));
        *var_len = table_entry.lldpLocManAddrOID_len * sizeof(oid);
        return (u_char *) lldpLocManAddrTable_global_ret.objid_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpLocManAddrTable\n",
                    vp->magic));
    }
    return NULL;
}


/*
* var_lldpStatsTxPortTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpStatsTxPortTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    static long     VAR = 0;
    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPSTATSTXPORTNUM: {
        return NULL;
    }
    case LLDPSTATSTXPORTFRAMESTOTAL: {
        lldp_counters_rec_t stat_cnts[LLDP_PORTS];
        if (lldp_mgmt_stat_get(table_info.isid, &stat_cnts[0], NULL, NULL) != VTSS_OK) {
            T_WG(TRACE_GRP_SNMP, "Problem getting statistic counters");
        };

        T_DG_PORT(TRACE_GRP_SNMP, (u32) PORT_INDEX, "Getting TX frames stat, cnt = %u", (u32) stat_cnts[PORT_INDEX].tx_total);
        VAR = stat_cnts[PORT_INDEX].tx_total;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpStatsTxPortTable\n",
                    vp->magic));
    }
    return NULL;
}



static ulong port2table_index(vtss_port_no_t iport)
{
    table_info.type = DOT1PORT_TYPE_PORT;
    table_info.if_id = iport;

    if (FALSE == dot1Port_get_by_interface ( &table_info)) {
        return (ulong) - 1;
    }
    return table_info.dot1port;
}


static vtss_rc get_table_info(ulong *table_index,
                              ulong lldp_loc_port_num,
                              oid *name,
                              size_t *length,
                              int exact)
{
    //  Select first port if "get next"
    if (lldp_loc_port_num == 0 && !exact) {
        lldp_loc_port_num = 1;
    }

    T_DG(TRACE_GRP_SNMP, "lldp_loc_port_num = %u ", lldp_loc_port_num);
    table_info.dot1port = lldp_loc_port_num - 1;
    if (FALSE == dot1Port_get_next(&table_info)) {
        return VTSS_UNSPECIFIED_ERROR;// Stop when last index is exceeded
    }

    *table_index = table_info.dot1port;

    return VTSS_OK;
}



vtss_rc header_loc_port_num_table (struct variable *vp,
                                   oid *name,
                                   size_t *length,
                                   int exact,
                                   size_t *var_len,
                                   WriteMethod **write_method)
{
    ulong           table_index;
    ulong           table_size = IFTABLE_IFINDEX_END;
    ulong           idx_num;


    T_DG(TRACE_GRP_SNMP, " name[(*length) - 1] =%lu. *length = %zu", name[(*length) - 1], *length);

    // Only one index (lldpLocPortNum), so we can use simple table
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return VTSS_UNSPECIFIED_ERROR;
    }
    T_DG(TRACE_GRP_SNMP, " name[(*length) - 1] =%lu. *length = %zu", name[(*length) - 1], *length);

    idx_num = name[(*length) - 1];
    table_info.dot1port = idx_num - 1;
    if (FALSE == dot1Port_get_next(&table_info) || (table_info.type != DOT1PORT_TYPE_PORT
                                                    && table_info.type != DOT1PORT_TYPE_LLAG && table_info.type != DOT1PORT_TYPE_GLAG)) {
        return VTSS_UNSPECIFIED_ERROR;
    }

    table_index = table_info.dot1port;

    if (exact && (table_index != idx_num)) {
        return VTSS_UNSPECIFIED_ERROR;
    }

#if 0
    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return VTSS_UNSPECIFIED_ERROR;
    }
#endif

    // Save this one as the "next one", if "table_index" is not sequence
    name[(*length) - 1] = table_index;

    return VTSS_OK;
}






vtss_rc header_simple_entries_table(struct variable *vp,
                                    oid *name,
                                    size_t *length,
                                    int exact,
                                    size_t *var_len, WriteMethod **write_method,
                                    int oid_length,
                                    lldp_remote_entry_t   *return_entry)
{
    oid                    *op = NULL;
    int                    idx_num;
    lldp_remote_entry_t    entry, temp_entry;

    lldp_u32_t index_rem_time_mark = 0;
    lldp_u32_t index_rem_local_port_num = 0;
    lldp_u16_t index_rem_index = 0;

    lldp_bool_t found = LLDP_FALSE;
    vtss_rc rc = VTSS_UNSPECIFIED_ERROR;

    if ( !VTSS_ISID_LEGAL(table_info.isid) ) {
        return rc;
    }

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long); /* assume an integer and change later if not */

    // Clear the entry to start from knwon point
    memset(&entry, 0x0, sizeof(entry));
    memset(&temp_entry, 0x0, sizeof(temp_entry));


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }



    // Get the entries
    lldp_remote_entry_t *entries = NULL;
    lldp_mgmt_get_lock();
    entries = lldp_mgmt_get_entries(table_info.isid);
    lldp_mgmt_get_unlock();

    op = name + oid_length; // point to first index


    if (op < name + *length) {
        index_rem_time_mark = *op++;
    }

    if (op < name + *length) {
        index_rem_local_port_num = *op++;
    }

    if (op < name + *length) {
        index_rem_index = *op++;
    }

    ulong table_index;
    if (get_table_info(&table_index,
                       index_rem_local_port_num,
                       name,
                       length,
                       exact) != VTSS_OK) {
        return VTSS_UNSPECIFIED_ERROR;
    }



    if (exact) {
        // Check that the requested OID has the correct length
        if (*length != (ulong)(oid_length + 3)) { // + 3 is the rem_time_mark, local_port_num and rem_index  indexes
            T_DG(TRACE_GRP_SNMP, "Requested OID length (%zu) didn't match. Expected length: %d",
                 *length, oid_length + 3);
            return VTSS_UNSPECIFIED_ERROR;
        }


        // make sure that we are *exact*
        if (op != name + oid_length + 3) {
            T_IG(TRACE_GRP_SNMP, "We are not exact (exact was expeted)");
            return VTSS_UNSPECIFIED_ERROR;
        }

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            T_RG(TRACE_GRP_SNMP, "entry.time_mark = %u, index_rem_time_mark =%u", entry.time_mark, index_rem_time_mark);

            if (entry.time_mark          == index_rem_time_mark &&
                entry.receive_port       == table_info.if_id &&
                entry.lldp_remote_index  == index_rem_index) {

                rc = VTSS_OK;
                break; // OK - Entry found, stop looking.
            }
        }
    } else {
        T_NG(TRACE_GRP_SNMP, "Not exact ");


        /* Use parameters of time_mark, local_port_num, index, policy_app_type
        to lookup your entry, find a entry that entry keys is great current keys */

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            if ((entry.time_mark > index_rem_time_mark) ||
                (entry.time_mark == index_rem_time_mark && entry.receive_port > table_info.if_id) ||
                (entry.time_mark == index_rem_time_mark && entry.receive_port == table_info.if_id && entry.lldp_remote_index > index_rem_index)) {
                if (found == FALSE) {
                    /* record the fist find entry that entry keys is great current keys */
                    T_NG(TRACE_GRP_SNMP, "found = 1");
                    found = TRUE;
                    temp_entry = entry;

                    /* keep lookup to find if there is any smaller keys entry */

                } else if (temp_entry.time_mark > entry.time_mark ||
                           (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port > entry.receive_port) ||
                           (temp_entry.time_mark == entry.time_mark && temp_entry.receive_port == entry.receive_port &&
                            temp_entry.lldp_remote_index > entry.lldp_remote_index)) {                   /* find another smaller keys entry */
                    T_NG(TRACE_GRP_SNMP, "Update temp entry");
                    temp_entry = entry;
                }

                T_NG(TRACE_GRP_SNMP, "Mark time %u, %u - port %u, %u - index %u, %u",
                     entry.time_mark, temp_entry.time_mark,
                     entry.receive_port, temp_entry.receive_port,
                     entry.lldp_remote_index, temp_entry.lldp_remote_index);

            }
        }

        if (found) {
            entry = temp_entry;
            rc = VTSS_OK;

            T_NG(TRACE_GRP_SNMP, "rc = VTSS_OK");
            *length = oid_length;
            name[(*length)++] = entry.time_mark;
            name[(*length)++] = port2table_index(entry.receive_port);
            name[(*length)++] = entry.lldp_remote_index;
        }
    }


    memcpy(return_entry, &entry, sizeof(lldp_remote_entry_t));
    return rc;
}


/*
* var_lldpRemTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpRemTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    static long     VAR = 0;
    static char     VAR_STR[255];

    lldp_remote_entry_t    entry;

    // Oid Length = 11 (1.0.8802.1.1.2.1.4.1.1.4)
    T_D("enter");
    if (header_simple_entries_table(vp, name,
                                    length, exact,
                                    var_len,
                                    write_method,
                                    11,
                                    &entry) != VTSS_OK) {
        return NULL;
    }


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPREMTIMEMARK: {
        return NULL;
    }
    case LLDPREMLOCALPORTNUM: {
        return NULL;
    }
    case LLDPREMINDEX: {
        return NULL;
    }
    case LLDPREMCHASSISIDSUBTYPE: {
        VAR = entry.chassis_id_subtype;
        if (VAR == 0 ) {
            VAR = 1;
        }
        return (u_char *) & VAR;
    }
    case LLDPREMCHASSISID: {
        char chassis_id_str[MAX_CHASSIS_ID_LENGTH] = "";
        lldp_remote_chassis_id_to_string(&entry, &chassis_id_str[0]);

        T_DG(TRACE_GRP_SNMP, "Getting chassis id = %s", chassis_id_str);
        strcpy(VAR_STR, &chassis_id_str[0]);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPREMPORTIDSUBTYPE: {
        VAR = entry.port_id_subtype;
        return (u_char *) & VAR;
    }
    case LLDPREMPORTID: {
        char port_id_str[MAX_PORT_ID_LENGTH] = "";
        lldp_remote_port_id_to_string(&entry, &port_id_str[0]);

        T_DG(TRACE_GRP_SNMP, "Getting remote port id = %s", port_id_str);
        strcpy(VAR_STR, &port_id_str[0]);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPREMPORTDESC: {

        char port_decr_str[MAX_PORT_DESCR_LENGTH] = "";
        lldp_remote_port_descr_to_string(&entry, &port_decr_str[0]);

        T_DG(TRACE_GRP_SNMP, "Getting remote port description = %s", port_decr_str);

        strcpy(VAR_STR, &port_decr_str[0]);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;

    }
    case LLDPREMSYSNAME: {
        char sys_name_str[MAX_SYSTEM_NAME_LENGTH] = "";
        lldp_remote_system_name_to_string(&entry, &sys_name_str[0]);

        T_DG(TRACE_GRP_SNMP, "Getting remote system name = %s", sys_name_str);

        strcpy(VAR_STR, &sys_name_str[0]);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPREMSYSDESC: {
        char sys_desc_str[MAX_SYSTEM_DESCR_LENGTH] = "";
        lldp_remote_system_descr_to_string(&entry, &sys_desc_str[0]);

        T_DG(TRACE_GRP_SNMP, "Getting remote system description = %s", sys_desc_str);

        misc_strncpyz(VAR_STR, &sys_desc_str[0], 255);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPREMSYSCAPSUPPORTED: {
        VAR_STR[0] = ((int)entry.system_capabilities[0]) << 8 | BITS_type_swapbyte(entry.system_capabilities[1]);
        *var_len = 1;
        return (u_char *) VAR_STR;
    }
    case LLDPREMSYSCAPENABLED: {
        VAR_STR[0] = ((int)entry.system_capabilities[2]) << 8 | BITS_type_swapbyte(entry.system_capabilities[3]);
        *var_len = 1;
        return (u_char *) VAR_STR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpRemTable\n",
                    vp->magic));
    }
    return NULL;
}


#ifndef NOT_SUPPORTED_IN_ESTAX34 /* Not supported in E-StaX34 project */
/*
* var_lldpRemOrgDefInfoTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpRemOrgDefInfoTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{
    int             table_size;
    int             idx_num;


    table_size = 1;             /* FIXME */

    /*
    * This assumes that the table is a 'simple' table.
    *  See the implementation documentation for the meaning of this.
    *  You will need to provide the correct value for the TABLE_SIZE parameter
    *
    * If this table does not meet the requirements for a simple table,
    *  you will need to provide the replacement code yourself.
    *  Mib2c is not smart enough to write this for you.
    *    Again, see the implementation documentation for what is required.
    */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_lldpRemOrgDefInfoTableIndex(idx_num); /* FIXME */
    //if (!get_lldpRemOrgDefInfoTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
    * Save this one as the "next one", if "table_index" is not sequence
    */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPREMORGDEFINFOOUI: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case LLDPREMORGDEFINFOSUBTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case LLDPREMORGDEFINFOINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case LLDPREMORGDEFINFO: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpRemOrgDefInfoTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif


#ifndef NOT_SUPPORTED_IN_ESTAX34
/*
* var_lldpRemUnknownTLVTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpRemUnknownTLVTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{
    int             table_size;
    int             idx_num;

    table_size = 1;             /* FIXME */

    /*
    * This assumes that the table is a 'simple' table.
    *  See the implementation documentation for the meaning of this.
    *  You will need to provide the correct value for the TABLE_SIZE parameter
    *
    * If this table does not meet the requirements for a simple table,
    *  you will need to provide the replacement code yourself.
    *  Mib2c is not smart enough to write this for you.
    *    Again, see the implementation documentation for what is required.
    */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_lldpRemUnknownTLVTableIndex(idx_num); /* FIXME */
    //if (!get_lldpRemUnknownTLVTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
    * Save this one as the "next one", if "table_index" is not sequence
    */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPREMUNKNOWNTLVTYPE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case LLDPREMUNKNOWNTLVINFO: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpRemUnknownTLVTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif

/*
* var_lldpLocPortTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpLocPortTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    static long     VAR = 0;
    static char     VAR_STR[255];
    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPLOCPORTNUM: {
        return NULL;
    }
    case LLDPLOCPORTIDSUBTYPE: {
        VAR = (long)  lldp_tlv_get_port_id_subtype();
        T_DG(TRACE_GRP_SNMP, "Getting Port id subtype = %lu", VAR);
        return (u_char *) & VAR;
    }
    case LLDPLOCPORTID: {
        char port_id_str[MAX_PORT_ID_LENGTH] = "";
        int port_id = lldp_os_get_port_id(topo_isid2usid(table_info.isid), iport2uport(table_info.if_id));
        sprintf(port_id_str, "%02d", port_id);

        strcpy(VAR_STR, &port_id_str[0]);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;


    }
    case LLDPLOCPORTDESC: {
        char port_desc_str[MAX_PORT_DESCR_LENGTH] = "";
        lldp_os_get_if_descr(topo_isid2usid(table_info.isid), iport2uport(table_info.if_id), &port_desc_str[0]);
        misc_strncpyz(VAR_STR, &port_desc_str[0], 255);

        T_DG(TRACE_GRP_SNMP, "Getting local port description : %s", VAR_STR);
        *var_len = strlen(VAR_STR);

        return (u_char *) VAR_STR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpLocPortTable\n",
                    vp->magic));
    }
    return NULL;
}


int get_num_of_active_isids(void)
{

    unsigned char            num_of_isids = 1 ; // Default one switch in stack

#if VTSS_SWITCH_STACKABLE
    vtss_usid_t              isid        = VTSS_ISID_START;
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        } else {
            num_of_isids++;
        }
    }
#endif
    return num_of_isids;
}

/*
* var_lldpPortConfigTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpPortConfigTable(struct variable *vp,
                        oid *name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod **write_method)
{
    static long VAR;

    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }



    // Get current configuration
    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid);


    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPPORTCONFIGPORTNUM: {
        return NULL;

    }
    case LLDPPORTCONFIGADMINSTATUS: {
        *write_method = write_lldpPortConfigAdminStatus;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid) ;
        T_NG(TRACE_GRP_SNMP, "Adminstate = %d", lldp_conf.admin_state[PORT_INDEX]);
        switch (lldp_conf.admin_state[PORT_INDEX]) {


        case LLDP_DISABLED :
            VAR = (long) 4;
            break;
        case LLDP_ENABLED_RX_ONLY:
            VAR = (long) 2;
            break;
        case LLDP_ENABLED_TX_ONLY:
            VAR = (long) 1;
            break;
        default: //LLDP_ENABLED_RX_TX
            VAR = (long) 3;
            break;
        }
        return (u_char *) & VAR;
    }
    case LLDPPORTCONFIGNOTIFICATIONENABLE: {
        *write_method = write_lldpPortConfigNotificationEnable;
        VAR = lldp_mgmt_get_notification_ena(PORT_INDEX, table_info.isid, TRUE);
        return (u_char *) & VAR;
    }
    case LLDPPORTCONFIGTLVSTXENABLE: {
        *write_method = write_lldpPortConfigTLVsTxEnable;

        unsigned char tlvs_ena = 0;  // By default we expect that all optional TLVs are disabled

        // Check if the optional TLVs are enabled one by one.
        if (lldp_mgmt_get_opt_tlv_enabled(LLDP_TLV_BASIC_MGMT_PORT_DESCR, PORT_INDEX, table_info.isid) ) {
            tlvs_ena |= 1 << 7;
        }

        if (lldp_mgmt_get_opt_tlv_enabled(LLDP_TLV_BASIC_MGMT_SYSTEM_NAME, PORT_INDEX, table_info.isid)) {
            tlvs_ena |= 1 << 6;
        }

        if (lldp_mgmt_get_opt_tlv_enabled(LLDP_TLV_BASIC_MGMT_SYSTEM_DESCR, PORT_INDEX, table_info.isid)) {
            tlvs_ena |= 1 << 5;
        }


        if (lldp_mgmt_get_opt_tlv_enabled(LLDP_TLV_BASIC_MGMT_SYSTEM_CAPA, PORT_INDEX, table_info.isid)) {
            tlvs_ena |= 1 << 4;
        }

        T_DG(TRACE_GRP_SNMP, "Optional TLVs = %u", tlvs_ena);
        *var_len = 1;
        VAR = tlvs_ena;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpPortConfigTable\n",
                    vp->magic));
    }
    T_NG(TRACE_GRP_SNMP, "Return NULL");
    return NULL;
}




/*
 * The entry data structure for lldpConfigManAddrTable
 */
typedef struct {
    /* Entry keys */
    long           lldpLocManAddrSubtype;
    char             lldpLocManAddr[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              lldpLocManAddr_len;

    /* Entry columns */
    char             lldpConfigManAddrPortsTxEnable[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              lldpConfigManAddrPortsTxEnable_len;
} lldpConfigManAddrTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
} lldpConfigManAddrTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, lldpConfigManAddrTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static lldpConfigManAddrTable_return_t lldpConfigManAddrTable_global_ret; /* static variables for retuning */

static void get_pre_lldpConfigManAddrTableEntryKey(lldpConfigManAddrTable_entry_t *key)
{
    int i = 0;
    BOOL found = FALSE;
    u8 *ptr = (u8 *) key->lldpLocManAddr;
    if (key->lldpLocManAddr_len > 1) {
        for (i = key->lldpLocManAddr_len - 1; i >= 0; i-- ) {
            if (*(ptr + i) != 0x0 ) {
                --*(ptr + i);
                found = TRUE;
                break;
            } else {
                *(ptr + i) = 0xff;
            }
        }
        if ( TRUE == found) {
            return;
        }
    }

    if (key->lldpLocManAddr_len >= 1) {
        --key->lldpLocManAddr_len;
        return;
    }

    key->lldpLocManAddr_len = SNMP_ASN_OCTET_STR_MAX_LEN;

    if (key->lldpLocManAddrSubtype >= 1) {
        --key->lldpLocManAddrSubtype;
        return;
    }
    memset(key, 0, sizeof(lldpConfigManAddrTable_entry_t));
}

static BOOL get_next_lldpConfigManAddrTableEntryKey(lldpConfigManAddrTable_entry_t *table_entry)
{
    vtss_ipv4_t addr_key;
    vtss_ip_addr_t ip_addr;
    if ( table_entry->lldpLocManAddrSubtype > IANA_ADDR_IPV4 ) {
        return FALSE;
    }

    if ( table_entry->lldpLocManAddrSubtype == IANA_ADDR_IPV4 && table_entry->lldpLocManAddr_len > sizeof( addr_key ) ) {
        return FALSE;
    }

    if ( table_entry->lldpLocManAddrSubtype == IANA_ADDR_IPV4 && table_entry->lldpLocManAddr_len == sizeof( addr_key )) {
        memcpy(&addr_key, table_entry->lldpLocManAddr, sizeof( addr_key ));
        ip_addr.type = VTSS_IP_TYPE_IPV4;
        ip_addr.addr.ipv4 = ntohl(addr_key);
    } else {
        ip_addr.type = VTSS_IP_TYPE_IPV4;
        memset(&ip_addr.addr.ipv4, 0, sizeof( ip_addr.addr.ipv4 ));
    }

    if ( FALSE == get_next_ip(&ip_addr, NULL) || ip_addr.type != VTSS_IP_TYPE_IPV4 ) {
        return FALSE;
    }

    table_entry->lldpLocManAddrSubtype = ip_addr.type == VTSS_IP_TYPE_IPV4 ? IANA_ADDR_IPV4 : IANA_ADDR_IPV4;
    table_entry->lldpLocManAddr_len = ip_addr.type == VTSS_IP_TYPE_IPV4 ? sizeof(ip_addr.addr.ipv4) : sizeof(ip_addr.addr.ipv6);
    addr_key = htonl(ip_addr.addr.ipv4);
    memcpy(table_entry->lldpLocManAddr, &addr_key, table_entry->lldpLocManAddr_len);

    return TRUE;
}

static BOOL get_lldpConfigManAddrTableEntryKey(lldpConfigManAddrTable_entry_t *table_entry)
{
    lldpConfigManAddrTable_entry_t tmp;

    tmp.lldpLocManAddrSubtype = table_entry->lldpLocManAddrSubtype;
    tmp.lldpLocManAddr_len    = table_entry->lldpLocManAddr_len;
    memcpy(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len);
    get_pre_lldpConfigManAddrTableEntryKey(&tmp);

    if ( FALSE == get_next_lldpConfigManAddrTableEntryKey(&tmp) ) {
        return FALSE;
    }

    if (tmp.lldpLocManAddrSubtype == table_entry->lldpLocManAddrSubtype && tmp.lldpLocManAddr_len == table_entry->lldpLocManAddr_len &&
        !memcmp(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len)) {
        return TRUE;
    }
    return FALSE;

}

static void get_txEnablePortList_BF_size(u_long *port_count_p)
{
    dot1Port_info_t info;
    switch_iter_t   sit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START + port_isid_port_count(sit.isid) - 1;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
    }

    *port_count_p = VTSS_PORTLIST_BF_SIZE(info.dot1port);

}


static void get_txEnable_portList( i8 *portList, u32 *portList_len)
{
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    switch_iter_t           sit;
    port_iter_t             pit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {

        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;


        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (lldp_mgmt_get_opt_tlv_enabled(LLDP_TLV_BASIC_MGMT_MGMT_ADDR, pit.iport, sit.isid) ) {
                VTSS_PORTLIST_BF_SET(portList, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(portList, dot1port_start + pit.iport, 0);
            }
        }
    }

    get_txEnablePortList_BF_size((u_long *)portList_len);

}


static int
getfirst_lldpConfigManAddrTableEntry(lldpConfigManAddrTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(lldpConfigManAddrTable_entry_t));
    table_entry->lldpLocManAddrSubtype = 0;
    table_entry->lldpLocManAddr_len = 0;
    if ( FALSE == get_next_lldpConfigManAddrTableEntryKey(table_entry) ) {
        return VTSS_RC_ERROR;
    }
    get_txEnable_portList(table_entry->lldpConfigManAddrPortsTxEnable, (u32 *)&table_entry->lldpConfigManAddrPortsTxEnable_len);
    return VTSS_RC_OK;
}

static int
get_lldpConfigManAddrTableEntry(lldpConfigManAddrTable_entry_t *table_entry, BOOL getnext)
{
    lldpConfigManAddrTable_entry_t tmp;

    memset (&tmp, 0, sizeof(tmp));
    tmp.lldpLocManAddrSubtype = table_entry->lldpLocManAddrSubtype;
    tmp.lldpLocManAddr_len = table_entry->lldpLocManAddr_len;
    memcpy(tmp.lldpLocManAddr, table_entry->lldpLocManAddr, table_entry->lldpLocManAddr_len);

    if ( (getnext == TRUE &&  FALSE == get_next_lldpConfigManAddrTableEntryKey(&tmp)) ||
         (getnext == FALSE && FALSE == get_lldpConfigManAddrTableEntryKey(&tmp))) {
        return VTSS_RC_ERROR;
    }

    get_txEnable_portList(tmp.lldpConfigManAddrPortsTxEnable, (u32 *)&tmp.lldpConfigManAddrPortsTxEnable_len);
    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
parse_lldpConfigManAddrTable(oid     *name,
                             size_t  *length,
                             int     exact,
                             lldpConfigManAddrTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t  len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_lldpConfigManAddrTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->lldpLocManAddrSubtype = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = *op++;
    len = len > sizeof(table_entry->lldpLocManAddr) ? sizeof(table_entry->lldpLocManAddr) : len;
    op_pos++;
    table_entry->lldpLocManAddr_len = len;
    T_D("table_entry->lldpLocManAddr_len = %u, len = %d", table_entry->lldpLocManAddr_len, len);
    cp = (u_char *) table_entry->lldpLocManAddr;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_lldpConfigManAddrTable(oid     *name,
                               size_t  *length,
                               lldpConfigManAddrTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->lldpLocManAddrSubtype;
    len = (int) table_entry->lldpLocManAddr_len;
    name[name_pos++] = (oid) table_entry->lldpLocManAddr_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->lldpLocManAddr[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_lldpConfigManAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lldpConfigManAddrTable above.
 */
u_char *
var_lldpConfigManAddrTable(struct variable *vp,
                           oid     *name,
                           size_t  *length,
                           int     exact,
                           size_t  *var_len,
                           WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    lldpConfigManAddrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_lldpConfigManAddrTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_lldpConfigManAddrTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_lldpConfigManAddrTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_lldpConfigManAddrTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case LLDPCONFIGMANADDRPORTSTXENABLE: {
        *write_method = write_lldpConfigManAddrPortsTxEnable;
        *var_len = table_entry.lldpConfigManAddrPortsTxEnable_len;
        memcpy(lldpConfigManAddrTable_global_ret.string_ret, table_entry.lldpConfigManAddrPortsTxEnable, *var_len);
        lldpConfigManAddrTable_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) lldpConfigManAddrTable_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpConfigManAddrTable\n", vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for lldpRemManAddrTable
 */
typedef struct {
    /* Entry keys */
    u_long           lldpRemTimeMark;
    long           lldpRemLocalPortNum;
    long           lldpRemIndex;
    long           lldpRemManAddrSubtype;
    char             lldpRemManAddr[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              lldpRemManAddr_len;

    /* Entry columns */
    long             lldpRemManAddrIfSubtype;
    long             lldpRemManAddrIfId;
    oid             lldpRemManAddrOID[MAX_OID_LEN];
    size_t              lldpRemManAddrOID_len;
} lldpRemManAddrTable_entry_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, lldpRemManAddrTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static lldpManAddrTable_return_t lldpRemManAddrTable_global_ret; /* static variables for retuning */

static void get_pre_lldpRemManAddrTableEntryKey(lldpRemManAddrTable_entry_t *key)
{
    int i = 0;
    BOOL found = FALSE;
    u8 *ptr = (u8 *) key->lldpRemManAddr;
    if (key->lldpRemManAddr_len > 1) {
        for (i = key->lldpRemManAddr_len - 1; i >= 0; i-- ) {
            if (*(ptr + i) != 0x0 ) {
                --*(ptr + i);
                found = TRUE;
                break;
            } else {
                *(ptr + i) = 0xff;
            }
        }
        if ( TRUE == found) {
            return;
        }
    }

    if (key->lldpRemManAddr_len >= 1) {
        --key->lldpRemManAddr_len;
        return;
    }

    key->lldpRemManAddr_len = SNMP_ASN_OCTET_STR_MAX_LEN;

    if (key->lldpRemManAddrSubtype >= 1) {
        --key->lldpRemManAddrSubtype;
        return;
    }

    key->lldpRemManAddrSubtype = 65535;

    if (key->lldpRemIndex >= 1) {
        --key->lldpRemIndex;
        return;
    }

    key->lldpRemIndex = 0x7fffffff;

    if (key->lldpRemLocalPortNum >= 1) {
        --key->lldpRemLocalPortNum;
        return;
    }

    key->lldpRemLocalPortNum = 0x7fffffff;

    if (key->lldpRemTimeMark >= 1) {
        --key->lldpRemTimeMark;
        return;
    }

    memset(key, 0, sizeof(lldpRemManAddrTable_entry_t));
}

static int cmp_lldpRemManAddrTableEntryKey(lldpRemManAddrTable_entry_t *data, lldpRemManAddrTable_entry_t *key)
{
    int cmp;
    if (data->lldpRemTimeMark > key->lldpRemTimeMark) {
        return 1;
    } else if (data->lldpRemTimeMark < key->lldpRemTimeMark) {
        return -1;
    }

    if (data->lldpRemLocalPortNum > key->lldpRemLocalPortNum) {
        return 1;
    } else if (data->lldpRemLocalPortNum < key->lldpRemLocalPortNum) {
        return -1;
    }

    if (data->lldpRemIndex > key->lldpRemIndex) {
        return 1;
    } else if (data->lldpRemIndex < key->lldpRemIndex) {
        return -1;
    }

    if (data->lldpRemManAddrSubtype > key->lldpRemManAddrSubtype) {
        return 1;
    } else if (data->lldpRemManAddrSubtype < key->lldpRemManAddrSubtype) {
        return -1;
    }

    if (data->lldpRemManAddr_len > key->lldpRemManAddr_len) {
        return 1;
    } else if (data->lldpRemManAddr_len < key->lldpRemManAddr_len) {
        return -1;
    }

    cmp = memcmp(data->lldpRemManAddr, key->lldpRemManAddr, data->lldpRemManAddr_len);
    return cmp;
}



static BOOL get_next_lldpRemManAddrTableEntryKey(lldpRemManAddrTable_entry_t *key)
{
    switch_iter_t       sit;
    int                 idx_num, tmp_idx_num = 0;
    lldp_remote_entry_t *entries = NULL;
    lldp_remote_entry_t entry;
    u8 mgmt_addr_index, tmp_mgmt_addr_index = 0;
    lldpRemManAddrTable_entry_t buf, tmp;
    vtss_isid_t              tmp_isid = 0;
    BOOL                    found = FALSE;
    iftable_info_t           info;

    tmp.lldpRemTimeMark = 0xffffffff;
    tmp.lldpRemLocalPortNum = 0x7fffffff;
    tmp.lldpRemIndex = 0x7fffffff;
    tmp.lldpRemManAddrSubtype = 0x7fffffff;
    tmp.lldpRemManAddr_len = SNMP_ASN_OCTET_STR_MAX_LEN;

    lldp_mgmt_get_lock();

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {

        entries = lldp_mgmt_get_entries(sit.isid);

        for (idx_num = 0; idx_num < lldp_remote_get_max_entries(); idx_num++) {
            entry = entries[idx_num];

            if (entry.in_use == 0) {
                continue;
            }

            for (mgmt_addr_index = 0; mgmt_addr_index < LLDP_MGMT_ADDR_CNT; mgmt_addr_index++) {
                info.isid = sit.isid;
                info.if_id = entry.receive_port;
                info.type = IFTABLE_IFINDEX_TYPE_PORT;

                if (ifIndex_get_by_interface(&info) == FALSE) {
                    continue;
                }

                buf.lldpRemTimeMark         = entry.time_mark;
                buf.lldpRemLocalPortNum     = info.ifIndex;
                buf.lldpRemIndex            = entry.lldp_remote_index;
                buf.lldpRemManAddrSubtype   = entry.mgmt_addr[mgmt_addr_index].subtype;
                buf.lldpRemManAddr_len      = entry.mgmt_addr[mgmt_addr_index].length;
                memcpy(buf.lldpRemManAddr, entry.mgmt_addr[mgmt_addr_index].mgmt_address, entry.mgmt_addr[mgmt_addr_index].length);
                if (cmp_lldpRemManAddrTableEntryKey(&buf, key) <= 0 || buf.lldpRemManAddr_len != 4 ) {
                    continue;
                }
                if (cmp_lldpRemManAddrTableEntryKey(&tmp, &buf ) > 0 ) {
                    memcpy(&tmp, &buf, sizeof(buf));
                    found = TRUE;
                    tmp_isid = sit.isid;
                    tmp_idx_num = idx_num;
                    tmp_mgmt_addr_index = mgmt_addr_index;
                }

            }
        }
    }


    if ( TRUE != found ) {
        lldp_mgmt_get_unlock();
        return FALSE;
    }

    entries = lldp_mgmt_get_entries(tmp_isid);
    entry = entries[tmp_idx_num];
    tmp.lldpRemManAddrIfSubtype = entry.mgmt_addr[tmp_mgmt_addr_index].if_number_subtype;
    tmp.lldpRemManAddrIfId = entry.mgmt_addr[tmp_mgmt_addr_index].if_number[0] << 24 ||
                             entry.mgmt_addr[tmp_mgmt_addr_index].if_number[1] << 16 ||
                             entry.mgmt_addr[tmp_mgmt_addr_index].if_number[2] << 8 ||
                             entry.mgmt_addr[tmp_mgmt_addr_index].if_number[3];

    tmp.lldpRemManAddrOID_len = 2;
    memset(tmp.lldpRemManAddrOID, 0, tmp.lldpRemManAddrOID_len * sizeof(oid));
    memcpy( key, &tmp, sizeof(tmp));
    lldp_mgmt_get_unlock();
    return TRUE;
}

static BOOL get_lldpRemManAddrTableEntryKey(lldpRemManAddrTable_entry_t *key)
{
    lldpRemManAddrTable_entry_t tmp;

    tmp.lldpRemTimeMark = key->lldpRemTimeMark;
    tmp.lldpRemLocalPortNum = key->lldpRemLocalPortNum;
    tmp.lldpRemIndex = key->lldpRemIndex;
    tmp.lldpRemManAddrSubtype = key->lldpRemManAddrSubtype;
    tmp.lldpRemManAddr_len = key->lldpRemManAddr_len;
    memcpy (tmp.lldpRemManAddr, key->lldpRemManAddr, key->lldpRemManAddr_len);
    get_pre_lldpRemManAddrTableEntryKey (&tmp);

    if (  FALSE == get_next_lldpRemManAddrTableEntryKey (&tmp) ||
          cmp_lldpRemManAddrTableEntryKey (&tmp, key) != 0) {
        return FALSE;
    }

    memcpy( key, &tmp, sizeof(tmp));
    return TRUE;
}

static int
getfirst_lldpRemManAddrTableEntry(lldpRemManAddrTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(lldpRemManAddrTable_entry_t));
    if ( FALSE == get_next_lldpRemManAddrTableEntryKey(table_entry)) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
get_lldpRemManAddrTableEntry(lldpRemManAddrTable_entry_t *table_entry, BOOL getnext)
{
    if ( ( TRUE == getnext && FALSE == get_next_lldpRemManAddrTableEntryKey (table_entry)) ||
         ( FALSE == getnext && FALSE == get_lldpRemManAddrTableEntryKey (table_entry))) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
parse_lldpRemManAddrTable(oid     *name,
                          size_t  *length,
                          int     exact,
                          lldpRemManAddrTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t  len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 6)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_lldpRemManAddrTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->lldpRemTimeMark = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->lldpRemLocalPortNum = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->lldpRemIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->lldpRemManAddrSubtype = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = *op++;
    len = len > sizeof(table_entry->lldpRemManAddr) ? sizeof(table_entry->lldpRemManAddr) : len;
    op_pos++;
    table_entry->lldpRemManAddr_len = (char) len;
    cp = (u_char *) table_entry->lldpRemManAddr;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_lldpRemManAddrTable(oid     *name,
                            size_t  *length,
                            lldpRemManAddrTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->lldpRemTimeMark;
    name[name_pos++] = (oid) table_entry->lldpRemLocalPortNum;
    name[name_pos++] = (oid) table_entry->lldpRemIndex;
    name[name_pos++] = (oid) table_entry->lldpRemManAddrSubtype;
    len = (int) table_entry->lldpRemManAddr_len;
    name[name_pos++] = (oid) len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->lldpRemManAddr[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_lldpRemManAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lldpRemManAddrTable above.
 */
u_char *
var_lldpRemManAddrTable(struct variable *vp,
                        oid     *name,
                        size_t  *length,
                        int     exact,
                        size_t  *var_len,
                        WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    lldpRemManAddrTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_lldpRemManAddrTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_lldpRemManAddrTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_lldpRemManAddrTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_lldpRemManAddrTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case LLDPREMMANADDRIFSUBTYPE: {
        lldpRemManAddrTable_global_ret.long_ret = table_entry.lldpRemManAddrIfSubtype;
        *var_len = sizeof(lldpRemManAddrTable_global_ret.long_ret);
        return (u_char *) &lldpRemManAddrTable_global_ret.long_ret;
    }
    case LLDPREMMANADDRIFID: {
        lldpRemManAddrTable_global_ret.long_ret = table_entry.lldpRemManAddrIfId;
        *var_len = sizeof(lldpRemManAddrTable_global_ret.long_ret);
        return (u_char *) &lldpRemManAddrTable_global_ret.long_ret;
    }
    case LLDPREMMANADDROID: {
        memcpy(lldpRemManAddrTable_global_ret.objid_ret, table_entry.lldpRemManAddrOID, table_entry.lldpRemManAddrOID_len * sizeof(oid));
        *var_len = table_entry.lldpRemManAddrOID_len * sizeof(oid);
        return (u_char *) lldpRemManAddrTable_global_ret.objid_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpRemManAddrTable\n", vp->magic));
    }
    return NULL;
}

/*
* var_lldpStatsRxPortTable():
*   Handle this table separately from the scalar value case.
*   The workings of this are basically the same as for var_lldpConfiguration above.
*/
u_char         *
var_lldpStatsRxPortTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    static long VAR;
    lldp_counters_rec_t stat_cnts[LLDP_PORTS];

    // Determine if the table indexes are in use
    if (header_loc_port_num_table(vp, name, length, exact, var_len, write_method) != VTSS_OK) {
        return NULL;
    }

    /*
    Get the stat counters
    */
    if (lldp_mgmt_stat_get(table_info.isid, &stat_cnts[0], NULL, NULL) != VTSS_OK) {
        T_WG(TRACE_GRP_SNMP, "Problem getting statistic counters");
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPSTATSRXPORTNUM: {
        return NULL;
    }
    case LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL: {
        VAR = stat_cnts[PORT_INDEX].rx_discarded;
        return (u_char *) & VAR;
    }
    case LLDPSTATSRXPORTFRAMESERRORS: {
        VAR = stat_cnts[PORT_INDEX].rx_error;
        return (u_char *) & VAR;
    }
    case LLDPSTATSRXPORTFRAMESTOTAL: {
        VAR = stat_cnts[PORT_INDEX].rx_total;
        return (u_char *) & VAR;
    }
    case LLDPSTATSRXPORTTLVSDISCARDEDTOTAL: {
        VAR = stat_cnts[PORT_INDEX].TLVs_discarded;
        return (u_char *) & VAR;
    }
    case LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL: {
        VAR = stat_cnts[PORT_INDEX].TLVs_unrecognized;
        return (u_char *) & VAR;
    }
    case LLDPSTATSRXPORTAGEOUTSTOTAL: {
        VAR = stat_cnts[PORT_INDEX].ageouts;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_lldpStatsRxPortTable\n",
                    vp->magic));
    }
    return NULL;
}


int write_lldpMessageTxInterval(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP, oid *name, size_t name_len)
{
    static int      buf = 30;
    static int      old_buf = 30;
    size_t          max_size = sizeof(int);
    long            intval = *((int *) var_val);
    lldp_struc_0_t   lldp_conf;

    T_DG(TRACE_GRP_SNMP, "TX interval Enter action = %d", action);
    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxInterval: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxInterval: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 5 || intval > 32768) {
            T_DG(TRACE_GRP_SNMP, "TX interval Wrong Value");
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxInterval: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        T_DG(TRACE_GRP_SNMP, "TX interval Reserve1");
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        T_DG(TRACE_GRP_SNMP, "TX interval Reserve2");
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        T_DG(TRACE_GRP_SNMP, "TX interval Free");
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((int *) var_val);

        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.msgTxInterval = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        T_DG(TRACE_GRP_SNMP, "TX interval Action");
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.msgTxInterval = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_UNDOFAILED;
        }

        T_DG(TRACE_GRP_SNMP, "TX interval UNDO");
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    default:
        T_DG(TRACE_GRP_SNMP, "TX interval default");

    }
    T_DG(TRACE_GRP_SNMP, "Return OK");
    return SNMP_ERR_NOERROR;
}

int
write_lldpNotificationInterval(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    static int           buf = 5, old_buf = 5;
    size_t          max_size = sizeof(long);
    long            intval;


    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpNotificationInterval: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpNotificationInterval: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 5 || intval > 3600) {   /* Interval defined by IEEE 802.1ab */
            (void) snmp_log(LOG_ERR,
                            "write to lldpNotificationInterval: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((int *) var_val);


        if (lldp_mgmt_set_notification_interval(buf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}


int
write_lldpMessageTxHoldMultiplier(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    static int buf = 2, old_buf = 2;
    size_t            max_size = sizeof(int);
    long              intval;
    lldp_struc_0_t    lldp_conf;

    intval = *((char *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxHoldMultiplier: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxHoldMultiplier: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 2 || intval > 10) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpMessageTxHoldMultiplier: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((char *) var_val);
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.msgTxHold = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;

    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.msgTxHold = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_UNDOFAILED;
        }

        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpTxDelay(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    static int      buf = LLDP_TX_DELAY_DEFAULT, old_buf = LLDP_TX_DELAY_DEFAULT;
    size_t          max_size = sizeof(int);
    long            intval;
    lldp_struc_0_t    lldp_conf;

    intval = *((int *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpTxDelay: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR, "write to lldpTxDelay: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < LLDP_TX_DELAY_MIN || intval > LLDP_TX_DELAY_MAX) {
            (void) snmp_log(LOG_ERR, "write to lldpTxDelay: bad value - Minimum = %d\n", LLDP_TX_DELAY_MIN);
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((int *) var_val);
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.txDelay = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.txDelay = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_UNDOFAILED;
        }
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpReinitDelay(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    static char     buf = 2, old_buf = 2;
    size_t          max_size = sizeof(int);
    long            intval;
    lldp_struc_0_t    lldp_conf;

    intval = *((char *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpReinitDelay: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpReinitDelay: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 1 || intval > 10) {
            (void) snmp_log(LOG_ERR, "write to lldpReinitDelay: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */

        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((char *) var_val);
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.reInitDelay = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        lldp_mgmt_get_config(&lldp_conf, table_info.isid);
        lldp_conf.reInitDelay = buf;
        if (lldp_mgmt_set_config(&lldp_conf, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_UNDOFAILED;
        }
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpPortConfigAdminStatus(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP,
                                oid *name, size_t name_len)
{
    static char    buf = 1, old_buf = 1;
    size_t          max_size = sizeof(int);
    long            intval;


    intval = *((char *) var_val);


    T_NG(TRACE_GRP_SNMP, "entering write_lldpPortConfigAdminStatus");

    lldp_struc_0_t lldp_conf;


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigAdminStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigAdminStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 1 || intval > 4) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigAdminStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */

        lldp_mgmt_get_config(&lldp_conf, table_info.isid);

        buf = *((char *) var_val);

        switch (buf) {

        case 4 :
            lldp_conf.admin_state[PORT_INDEX] = LLDP_DISABLED;
            break;
        case 2 :
            lldp_conf.admin_state[PORT_INDEX] = LLDP_ENABLED_RX_ONLY;
            break;
        case 1 :
            lldp_conf.admin_state[PORT_INDEX] = LLDP_ENABLED_TX_ONLY;
            break;
        default: //LLDP_ENABLED_RX_TX
            lldp_conf.admin_state[PORT_INDEX] = LLDP_ENABLED_RX_TX;
            break;
        }

        if (lldp_mgmt_set_admin_state(lldp_conf.admin_state, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;

    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpPortConfigNotificationEnable(int action,
                                       u_char *var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char *statP,
                                       oid *name, size_t name_len)
{
    static long     buf = 1, old_buf = 1;
    size_t          max_size = sizeof(long);
    long            intval;

    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigNotificationEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigNotificationEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigNotificationEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */
        buf = *((long *) var_val);

        if (lldp_mgmt_set_notification_ena(buf, PORT_INDEX, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpPortConfigTLVsTxEnable(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    static char     buf, old_buf;
    size_t          max_size = 3;

    lldp_struc_0_t lldp_conf;


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigTLVsTxEnable: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            T_DG(TRACE_GRP_SNMP, "var_val_len = %d", (char)var_val_len);
            (void) snmp_log(LOG_ERR,
                            "write to lldpPortConfigTLVsTxEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */



        break;

    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {
        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */


        // Get current configuration
        lldp_mgmt_get_config(&lldp_conf, table_info.isid) ;

        T_DG_PORT(TRACE_GRP_SNMP, (u32) PORT_INDEX, "write_lldpPortConfigTLVsTxEnable Action");
        memcpy(&buf, var_val, 1);

        // Update with new configuration
        T_DG_PORT(TRACE_GRP_SNMP, (u32) PORT_INDEX, "write_lldpPortConfigTLVsTxEnable ACTION - buf = 0x%X,table_info.isid = %d",
                  buf, table_info.isid);

        if (buf & 0x80) {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_PORT_DESCR, 1, &lldp_conf, PORT_INDEX);
        } else {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_PORT_DESCR, 0, &lldp_conf, PORT_INDEX);
        }


        if (buf & 0x40) {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_NAME, 1, &lldp_conf, PORT_INDEX);
        } else {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_NAME, 0, &lldp_conf, PORT_INDEX);
        }


        if (buf & 0x20) {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_DESCR, 1, &lldp_conf, PORT_INDEX);
        } else {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_DESCR, 0, &lldp_conf, PORT_INDEX);
        }



        if (buf & 0x10) {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_CAPA, 1, &lldp_conf, PORT_INDEX);
        } else {
            lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_SYSTEM_CAPA, 0, &lldp_conf, PORT_INDEX);
        }

        if (lldp_mgmt_set_optional_tlvs(lldp_conf.optional_tlv, table_info.isid) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        T_DG_PORT(TRACE_GRP_SNMP, (u32) PORT_INDEX, "write_lldpPortConfigTLVsTxEnable Undo");
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_lldpConfigManAddrPortsTxEnable(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    static char     buf, old_buf;
    size_t          max_size = 10;
    lldp_struc_0_t   lldp_conf;


    T_NG(TRACE_GRP_SNMP, "var_val_len  =%zu,var_val_type =%d", var_val_len, var_val_type);
    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpConfigManAddrPortsTxEnable: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to lldpConfigManAddrPortsTxEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
        * Allocate memory and similar resources
        */
        break;
    }
    case FREE: {
        /*
        * Release any resources that have been allocated
        */
        break;
    }
    case ACTION: {


        /*
        * The variable has been stored in 'value' for you to use,
        * and you have just been asked to do something with it.
        * Note that anything done here must be reversable in the UNDO case
        */
        /*
        * Save to current configuration
        */

        vtss_isid_t isid;

        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            T_DG_PORT(TRACE_GRP_SNMP, (u32) PORT_INDEX, "write_lldpConfigManAddrPortsTxEnable ACTION - buf = 0x%X,table_info.isid = %d",
                      buf, isid);


            char port_idx = 0;
            lldp_mgmt_get_config(&lldp_conf, isid);

//            memcpy(&buf, var_val, 3);
            buf = *var_val;
            char bit_pos = 0;
            for (port_idx = 0 ; port_idx < VTSS_FRONT_PORT_COUNT; port_idx++) {
                T_NG(TRACE_GRP_SNMP, "Setting mgmt addr - bit %d, var_val[port_idx/8] = %d , %d", port_idx, var_val[port_idx / 8], port_idx / 8 );
                if (((var_val[port_idx / 8] >> bit_pos ) & 0x1) == 0) {
                    lldp_os_set_optional_tlv(LLDP_TLV_BASIC_MGMT_MGMT_ADDR, 0, &lldp_conf, port_idx);
                } else {
                    lldp_os_set_optional_tlv(    LLDP_TLV_BASIC_MGMT_MGMT_ADDR, 1, &lldp_conf, port_idx);
                    T_NG(TRACE_GRP_SNMP, "Setting mgmt addr - bit %d set to 1", port_idx);
                }

                bit_pos++;
                if (bit_pos == 8) {
                    bit_pos = 0;
                }
            }

            if (lldp_mgmt_set_optional_tlvs(lldp_conf.optional_tlv, isid) != VTSS_OK) {
                T_NG(TRACE_GRP_SNMP, "Set error");
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        }
        break;
    }
    case UNDO: {
        /*
        * Back out any changes made in the ACTION case
        */
        /*
        * Restore current configuration form old configuration
        */
        buf = old_buf;
        break;
    }
    case COMMIT: {
        /*
        * Things are working well, so it's now safe to make the change
        * permanently.  Make sure that anything done here can't fail!
        */
        /*
        * Update old configuration
        */
        old_buf = buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
* var_lldpStatistics():
*   This function is called every time the agent gets a request for
*   a scalar variable that might be found within your mib section
*   registered above.  It is up to you to do the right thing and
*   return the correct value.
*     You should also correct the value of "var_len" if necessary.
*
*   Please see the documentation for more information about writing
*   module extensions, and check out the examples in the examples
*   and mibII directories.
*/
u_char         *
var_lldpStatistics(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{

    static long VAR;
    lldp_mib_stats_t global_cnt;
    int             idx_num;
    time_t          last_change_ago;

    /*
    * This assumes that the table is a 'simple' table.
    *  See the implementation documentation for the meaning of this.
    *  You will need to provide the correct value for the TABLE_SIZE parameter
    *
    * If this table does not meet the requirements for a simple table,
    *  you will need to provide the replacement code yourself.
    *  Mib2c is not smart enough to write this for you.
    *    Again, see the implementation documentation for what is required.
    */

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }


    idx_num = name[(*length) - 1];

    /*
    * Save this one as the "next one"
    */
    name[(*length) - 1] = idx_num;


    // Get the statistics
    (void)lldp_mgmt_stat_get(VTSS_ISID_START /* anything valid (doesn't have to exist) */, NULL, &global_cnt, &last_change_ago);

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPSTATSREMTABLESLASTCHANGETIME: {
        VAR = last_change_ago * 100; // We need to give the time in hundredths of a sec.
        return (u_char *) & VAR;
    }
    case LLDPSTATSREMTABLESDELETES: {
        VAR = global_cnt.table_deletes;
        return (u_char *) & VAR;
    }
    case LLDPSTATSREMTABLESDROPS: {
        VAR = global_cnt.table_drops;
        return (u_char *) & VAR;
    }
    case LLDPSTATSREMTABLESINSERTS: {
        VAR = global_cnt.table_inserts;
        return (u_char *) & VAR;
    }
    case LLDPSTATSREMTABLESAGEOUTS: {
        VAR = global_cnt.table_ageouts;
        return (u_char *) & VAR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpStatistics\n",
                    vp->magic));
    }
    return NULL;
}

/*
* var_lldpLocalSystemData():
*   This function is called every time the agent gets a request for
*   a scalar variable that might be found within your mib section
*   registered above.  It is up to you to do the right thing and
*   return the correct value.
*     You should also correct the value of "var_len" if necessary.
*
*   Please see the documentation for more information about writing
*   module extensions, and check out the examples in the examples
*   and mibII directories.
*/
u_char         *
var_lldpLocalSystemData(struct variable *vp,
                        oid *name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod **write_method)
{
    static long VAR;
    static char     VAR_STR[255];
    T_NG(TRACE_GRP_SNMP, "entering var_lldpLocalSystemData");
    lldp_struc_0_t   lldp_conf;
    lldp_mgmt_get_config(&lldp_conf, table_info.isid);

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
    * this is where we do the value assignments for the mib results.
    */
    switch (vp->magic) {
    case LLDPLOCSYSDESC: {
        char sys_desc[MAX_SYSTEM_DESCR_LENGTH] = "";
        lldp_tlv_get_system_descr(&sys_desc[0]);
        misc_strncpyz(VAR_STR, &sys_desc[0], 255);

        T_DG(TRACE_GRP_SNMP, "Getting local system description : %s", VAR_STR);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPLOCCHASSISIDSUBTYPE:

    {
        VAR = lldp_tlv_get_chassis_id_subtype();
        T_DG(TRACE_GRP_SNMP, "Getting Chassis ID subtype, %lu", VAR);
        return (u_char *) & VAR;
    }
    case LLDPLOCSYSCAPSUPPORTED: {
        VAR_STR[0] =  BITS_type_swapbyte(lldp_tlv_get_system_capabilities());
        *var_len = 1;
        return (u_char *) VAR_STR;
    }
    case LLDPLOCSYSCAPENABLED: {
        VAR_STR[0] = BITS_type_swapbyte(lldp_tlv_get_system_capabilities_ena());
        *var_len = 1;
        return (u_char *) VAR_STR;
    }
    case LLDPLOCSYSNAME: {
        char sys_name[MAX_SYSTEM_NAME_LENGTH] = "";
        lldp_tlv_get_system_name(&sys_name[0]);
        strcpy(VAR_STR, &sys_name[0]);

        T_DG(TRACE_GRP_SNMP, "Getting local system name : %s", VAR_STR);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    case LLDPLOCCHASSISID: {

        // Get the MAC address
        vtss_common_macaddr_t mac_addr = lldp_conf.mac_addr;

        // Type conversion.
        char mac_addr_ptr[VTSS_COMMON_MACADDR_SIZE] = "";
        memcpy(&mac_addr_ptr[0], mac_addr.macaddr, VTSS_COMMON_MACADDR_SIZE);
        mac_addr2str(&mac_addr_ptr[0], &VAR_STR[0]);


        // Return MAC address as string
        T_DG(TRACE_GRP_SNMP, "Getting local chassis ID : %s", VAR_STR);
        *var_len = strlen(VAR_STR);
        return (u_char *) VAR_STR;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lldpLocalSystemData\n",
                    vp->magic));
    }
    return NULL;

}



// LLDP notification Trap - Must be called when ever a entry is modified.
void snmpLLDPNotificationChange(vtss_isid_t isid, int port_index, lldp_mib_stats_t *stat, int notification_interval )
{

    // Variable for stoing when the last notification trap was transmitted
    static int last_notification_change_time = 0;
    struct variable_list *top = NULL;
    iftable_info_t info;
    // Set the notification OID
    oid  lldp_notifications_oid[] = {1, 0, 8802, 1, 1, 2, 0, 0, 1};
    oid  ifIndex_oid[] = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
#if !defined(REMOVE_STATS_IN_TRAP_BINDING_VAR)
    u32 tmp;
    oid  inserts_oid[] = {1, 0, 8802, 1, 1, 2, 1, 2, 2};
    oid  deletes_oid[] = {1, 0, 8802, 1, 1, 2, 1, 2, 3};
    oid  drops_oid[]   = {1, 0, 8802, 1, 1, 2, 1, 2, 4};
    oid  ageouts_oid[] = {1, 0, 8802, 1, 1, 2, 1, 2, 5};
#endif /*   REMOVE_STATS_IN_TRAP_BINDING_VAR    */

    snmp_vars_trap_entry_t  trap_entry;

    T_DG(TRACE_GRP_SNMP, "Notification Change called for isid = %d, port = %d", isid, port_index);

    // Check is the trap shall be throttled.
    if (msg_uptime_get(VTSS_ISID_LOCAL) - last_notification_change_time > notification_interval ) {

        // Check if notfication for the port the has has changed is enabled
        T_DG(TRACE_GRP_SNMP, "Notification for port was enabled");

        info.type = IFTABLE_IFINDEX_TYPE_PORT;
        info.isid = isid;
        info.if_id = port_index;
        ( void ) ifIndex_get_by_interface(&info);
        ifIndex_oid[OID_LENGTH(ifIndex_oid) - 1] =  info.ifIndex;
        // Transmit the SNMP trap
        memset(&trap_entry, 0x0, sizeof(trap_entry));
        trap_entry.oid_len = OID_LENGTH(lldp_notifications_oid);

        memcpy(trap_entry.oid, lldp_notifications_oid, sizeof(oid) * trap_entry.oid_len);

#if !defined(REMOVE_STATS_IN_TRAP_BINDING_VAR)
        tmp = stat->table_ageouts;
        top = snmp_bind_var(top, &tmp, ASN_INTEGER, sizeof(u_int),
                            ageouts_oid, OID_LENGTH(ageouts_oid));

        tmp = stat->table_drops;
        top = snmp_bind_var(top, &tmp, ASN_INTEGER, sizeof(u_int),
                            drops_oid, OID_LENGTH(drops_oid));

        tmp = stat->table_deletes;
        top = snmp_bind_var(top, &tmp, ASN_INTEGER, sizeof(u_int),
                            deletes_oid, OID_LENGTH(deletes_oid));

        tmp = stat->table_inserts;
        top = snmp_bind_var(top, &tmp, ASN_INTEGER, sizeof(u_int),
                            inserts_oid, OID_LENGTH(inserts_oid));
#endif /*   REMOVE_STATS_IN_TRAP_BINDING_VAR    */

        top = snmp_bind_var(top, &info.ifIndex, ASN_INTEGER, sizeof(u_int),
                            ifIndex_oid, OID_LENGTH(ifIndex_oid));

        trap_entry.vars = top;
        snmp_send_vars_trap(SNMP_TRAP_ENTERPRISESPECIFIC, &trap_entry);

        // Store the time that this SNMP trap was transmitted.
        last_notification_change_time = msg_uptime_get(VTSS_ISID_LOCAL);

    }
}

#endif /* DOT1AB_SUPPORTED_LLDPOBJECTS */
