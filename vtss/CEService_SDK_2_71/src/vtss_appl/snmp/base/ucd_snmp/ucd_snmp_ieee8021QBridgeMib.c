/*
 * 
 * Vitesse Switch Software.
 * 
 Copyright (c) 2002-2014 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 * 
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* For header_generic() */

#include "ucd_snmp_ieee8021QBridgeMib.h"
#include "ieee8021QBridgeMib.h"
#include "ucd_snmp_callout.h"   //ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


#define IEEE8021QBRIDGEMIB_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define IEEE8021QBRIDGEMIB_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define IEEE8021QBRIDGEMIB_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long            long_ret;
    char            string_ret[IEEE8021QBRIDGEMIB_STR_LEN_MAX + 1];
    struct counter64 c64_ret;
    u_long          ulong_ret;
} ieee8021QBridgeMib_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod   ieee8021QBridgeMib_var;
FindVarMethod   ieee8021QBridgeTable_var;
FindVarMethod   ieee8021QBridgeCVlanPortTable_var;
FindVarMethod   ieee8021QBridgeFdbTable_var;
FindVarMethod   ieee8021QBridgeTpFdbTable_var;
FindVarMethod   ieee8021QBridgeTpGroupTable_var;
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
FindVarMethod   ieee8021QBridgeForwardAllTable_var;
FindVarMethod   ieee8021QBridgeForwardUnregisteredTable_var;
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
FindVarMethod   ieee8021QBridgeStaticUnicastTable_var;
FindVarMethod   ieee8021QBridgeStaticMulticastTable_var;
FindVarMethod   ieee8021QBridgeVlanCurrentTable_var;
FindVarMethod   ieee8021QBridgeVlanStaticTable_var;
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
FindVarMethod   ieee8021QBridgeNextFreeLocalVlanTable_var;
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
FindVarMethod   ieee8021QBridgePortVlanTable_var;
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
FindVarMethod   ieee8021QBridgePortVlanStatisticsTable_var;
FindVarMethod   ieee8021QBridgeLearningConstraintsTable_var;
FindVarMethod   ieee8021QBridgeLearningConstraintDefaultsTable_var;
FindVarMethod   ieee8021QBridgeProtocolGroupTable_var;
FindVarMethod   ieee8021QBridgeProtocolPortTable_var;
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
WriteMethod     ieee8021QBridgeMvrpEnabledStatus_write;
WriteMethod     ieee8021QBridgeCVlanPortRowStatus_write;
WriteMethod     ieee8021QBridgeFdbAgingTime_write;
WriteMethod     ieee8021QBridgeForwardAllStaticPorts_write;
WriteMethod     ieee8021QBridgeForwardAllForbiddenPorts_write;
WriteMethod     ieee8021QBridgeForwardUnregisteredStaticPorts_write;
WriteMethod     ieee8021QBridgeForwardUnregisteredForbiddenPorts_write;
WriteMethod     ieee8021QBridgeStaticUnicastStaticEgressPorts_write;
WriteMethod     ieee8021QBridgeStaticUnicastForbiddenEgressPorts_write;
WriteMethod     ieee8021QBridgeStaticUnicastStorageType_write;
WriteMethod     ieee8021QBridgeStaticUnicastRowStatus_write;
WriteMethod     ieee8021QBridgeStaticMulticastStaticEgressPorts_write;
WriteMethod     ieee8021QBridgeStaticMulticastForbiddenEgressPorts_write;
WriteMethod     ieee8021QBridgeStaticMulticastStorageType_write;
WriteMethod     ieee8021QBridgeStaticMulticastRowStatus_write;
WriteMethod     ieee8021QBridgeVlanStaticName_write;
WriteMethod     ieee8021QBridgeVlanStaticEgressPorts_write;
WriteMethod     ieee8021QBridgeVlanForbiddenEgressPorts_write;
WriteMethod     ieee8021QBridgeVlanStaticUntaggedPorts_write;
WriteMethod     ieee8021QBridgeVlanStaticRowStatus_write;
WriteMethod     ieee8021QBridgePvid_write;
WriteMethod     ieee8021QBridgePortAcceptableFrameTypes_write;
WriteMethod     ieee8021QBridgePortIngressFiltering_write;
WriteMethod     ieee8021QBridgePortMvrpEnabledStatus_write;
WriteMethod     ieee8021QBridgePortRestrictedVlanRegistration_write;
WriteMethod     ieee8021QBridgeLearningConstraintsType_write;
WriteMethod     ieee8021QBridgeLearningConstraintsStatus_write;
WriteMethod     ieee8021QBridgeLearningConstraintDefaultsSet_write;
WriteMethod     ieee8021QBridgeLearningConstraintDefaultsType_write;
WriteMethod     ieee8021QBridgeProtocolGroupId_write;
WriteMethod     ieee8021QBridgeProtocolGroupRowStatus_write;
WriteMethod     ieee8021QBridgeProtocolPortGroupVid_write;
WriteMethod     ieee8021QBridgeProtocolPortRowStatus_write;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*
 * lint -esym(459, ieee8021QBridgeMib_global_ret) 
 */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static ieee8021QBridgeMib_ret_t ieee8021QBridgeMib_global_ret;

/*
 * ieee8021QBridgeMib_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid      ieee8021QBridgeMib_variables_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 4 };



/*
 * variable ieee8021QBridgeMib_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021QBridgeMib mib section
 */

struct variable7 ieee8021QBridgeMib_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGEVLANNUMDELETES		1
    {IEEE8021QBRIDGEVLANNUMDELETES, ASN_COUNTER64, RONLY,
     ieee8021QBridgeMib_var, 3, {1, 4, 1}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGEVLANVERSIONNUMBER		2
    {IEEE8021QBRIDGEVLANVERSIONNUMBER, ASN_INTEGER, RONLY,
     ieee8021QBridgeTable_var, 5, {1, 1, 1, 1, 2}},
#define IEEE8021QBRIDGEMAXVLANID		3
    {IEEE8021QBRIDGEMAXVLANID, ASN_INTEGER, RONLY,
     ieee8021QBridgeTable_var, 5, {1, 1, 1, 1, 3}},
#define IEEE8021QBRIDGEMAXSUPPORTEDVLANS		4
    {IEEE8021QBRIDGEMAXSUPPORTEDVLANS, ASN_UNSIGNED, RONLY,
     ieee8021QBridgeTable_var, 5, {1, 1, 1, 1, 4}},
#define IEEE8021QBRIDGENUMVLANS		5
    {IEEE8021QBRIDGENUMVLANS, ASN_GAUGE, RONLY, ieee8021QBridgeTable_var,
     5, {1, 1, 1, 1, 5}},





#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGECVLANPORTROWSTATUS		7
    {IEEE8021QBRIDGECVLANPORTROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeCVlanPortTable_var, 5, {1, 1, 2, 1, 3}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGEFDBDYNAMICCOUNT		8
    {IEEE8021QBRIDGEFDBDYNAMICCOUNT, ASN_GAUGE, RONLY,
     ieee8021QBridgeFdbTable_var, 5, {1, 2, 1, 1, 3}},
#define IEEE8021QBRIDGEFDBLEARNEDENTRYDISCARDS		9
    {IEEE8021QBRIDGEFDBLEARNEDENTRYDISCARDS, ASN_COUNTER64, RONLY,
     ieee8021QBridgeFdbTable_var, 5, {1, 2, 1, 1, 4}},
#define IEEE8021QBRIDGEFDBAGINGTIME		10
    {IEEE8021QBRIDGEFDBAGINGTIME, ASN_INTEGER, RWRITE,
     ieee8021QBridgeFdbTable_var, 5, {1, 2, 1, 1, 5}},
#define IEEE8021QBRIDGETPFDBPORT		11
    {IEEE8021QBRIDGETPFDBPORT, ASN_UNSIGNED, RONLY,
     ieee8021QBridgeTpFdbTable_var, 5, {1, 2, 2, 1, 2}},
#define IEEE8021QBRIDGETPFDBSTATUS		12
    {IEEE8021QBRIDGETPFDBSTATUS, ASN_INTEGER, RONLY,
     ieee8021QBridgeTpFdbTable_var, 5, {1, 2, 2, 1, 3}},
#define IEEE8021QBRIDGETPGROUPEGRESSPORTS		13
    {IEEE8021QBRIDGETPGROUPEGRESSPORTS, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeTpGroupTable_var, 5, {1, 2, 3, 1, 2}},
#define IEEE8021QBRIDGETPGROUPLEARNT		14
    {IEEE8021QBRIDGETPGROUPLEARNT, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeTpGroupTable_var, 5, {1, 2, 3, 1, 3}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGEFORWARDALLPORTS		15
    {IEEE8021QBRIDGEFORWARDALLPORTS, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeForwardAllTable_var, 5, {1, 2, 4, 1, 2}},
#define IEEE8021QBRIDGEFORWARDALLSTATICPORTS		16
    {IEEE8021QBRIDGEFORWARDALLSTATICPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeForwardAllTable_var, 5, {1, 2, 4, 1, 3}},
#define IEEE8021QBRIDGEFORWARDALLFORBIDDENPORTS		17
    {IEEE8021QBRIDGEFORWARDALLFORBIDDENPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeForwardAllTable_var, 5, {1, 2, 4, 1, 4}},
#define IEEE8021QBRIDGEFORWARDUNREGISTEREDPORTS		18
    {IEEE8021QBRIDGEFORWARDUNREGISTEREDPORTS, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeForwardUnregisteredTable_var, 5, {1, 2, 5, 1, 2}},
#define IEEE8021QBRIDGEFORWARDUNREGISTEREDSTATICPORTS		19
    {IEEE8021QBRIDGEFORWARDUNREGISTEREDSTATICPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeForwardUnregisteredTable_var, 5, {1, 2, 5, 1, 3}},
#define IEEE8021QBRIDGEFORWARDUNREGISTEREDFORBIDDENPORTS		20
    {IEEE8021QBRIDGEFORWARDUNREGISTEREDFORBIDDENPORTS, ASN_OCTET_STR,
     RWRITE, ieee8021QBridgeForwardUnregisteredTable_var, 5, {1, 2, 5, 1,
                                                              4}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS		21
    {IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeStaticUnicastTable_var, 5, {1, 3, 1, 1, 5}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS		22
    {IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS, ASN_OCTET_STR,
     RWRITE, ieee8021QBridgeStaticUnicastTable_var, 5, {1, 3, 1, 1, 6}},
#define IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE		23
    {IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE, ASN_INTEGER, RWRITE,
     ieee8021QBridgeStaticUnicastTable_var, 5, {1, 3, 1, 1, 7}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGESTATICUNICASTROWSTATUS		24
    {IEEE8021QBRIDGESTATICUNICASTROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeStaticUnicastTable_var, 5, {1, 3, 1, 1, 8}},
#define IEEE8021QBRIDGESTATICMULTICASTSTATICEGRESSPORTS		25
    {IEEE8021QBRIDGESTATICMULTICASTSTATICEGRESSPORTS, ASN_OCTET_STR,
     RWRITE, ieee8021QBridgeStaticMulticastTable_var, 5, {1, 3, 2, 1, 3}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGESTATICMULTICASTFORBIDDENEGRESSPORTS		26
    {IEEE8021QBRIDGESTATICMULTICASTFORBIDDENEGRESSPORTS, ASN_OCTET_STR,
     RWRITE, ieee8021QBridgeStaticMulticastTable_var, 5, {1, 3, 2, 1, 4}},
#define IEEE8021QBRIDGESTATICMULTICASTSTORAGETYPE		27
    {IEEE8021QBRIDGESTATICMULTICASTSTORAGETYPE, ASN_INTEGER, RWRITE,
     ieee8021QBridgeStaticMulticastTable_var, 5, {1, 3, 2, 1, 5}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGESTATICMULTICASTROWSTATUS		28
    {IEEE8021QBRIDGESTATICMULTICASTROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeStaticMulticastTable_var, 5, {1, 3, 2, 1, 6}},
#define IEEE8021QBRIDGEVLANFDBID		29
    {IEEE8021QBRIDGEVLANFDBID, ASN_UNSIGNED, RONLY,
     ieee8021QBridgeVlanCurrentTable_var, 5, {1, 4, 2, 1, 4}},
#define IEEE8021QBRIDGEVLANCURRENTEGRESSPORTS		30
    {IEEE8021QBRIDGEVLANCURRENTEGRESSPORTS, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeVlanCurrentTable_var, 5, {1, 4, 2, 1, 5}},
#define IEEE8021QBRIDGEVLANCURRENTUNTAGGEDPORTS		31
    {IEEE8021QBRIDGEVLANCURRENTUNTAGGEDPORTS, ASN_OCTET_STR, RONLY,
     ieee8021QBridgeVlanCurrentTable_var, 5, {1, 4, 2, 1, 6}},
#define IEEE8021QBRIDGEVLANSTATUS		32
    {IEEE8021QBRIDGEVLANSTATUS, ASN_INTEGER, RONLY,
     ieee8021QBridgeVlanCurrentTable_var, 5, {1, 4, 2, 1, 7}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGEVLANCREATIONTIME		33
    {IEEE8021QBRIDGEVLANCREATIONTIME, ASN_TIMETICKS, RONLY,
     ieee8021QBridgeVlanCurrentTable_var, 5, {1, 4, 2, 1, 8}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGEVLANSTATICNAME		34
    {IEEE8021QBRIDGEVLANSTATICNAME, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeVlanStaticTable_var, 5, {1, 4, 3, 1, 3}},
#define IEEE8021QBRIDGEVLANSTATICEGRESSPORTS		35
    {IEEE8021QBRIDGEVLANSTATICEGRESSPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeVlanStaticTable_var, 5, {1, 4, 3, 1, 4}},
#define IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS		36
    {IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeVlanStaticTable_var, 5, {1, 4, 3, 1, 5}},
#define IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS		37
    {IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS, ASN_OCTET_STR, RWRITE,
     ieee8021QBridgeVlanStaticTable_var, 5, {1, 4, 3, 1, 6}},
#define IEEE8021QBRIDGEVLANSTATICROWSTATUS		38
    {IEEE8021QBRIDGEVLANSTATICROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeVlanStaticTable_var, 5, {1, 4, 3, 1, 7}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGENEXTFREELOCALVLANINDEX		39
    {IEEE8021QBRIDGENEXTFREELOCALVLANINDEX, ASN_UNSIGNED, RONLY,
     ieee8021QBridgeNextFreeLocalVlanTable_var, 5, {1, 4, 4, 1, 2}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
#define IEEE8021QBRIDGEPVID		40
    {IEEE8021QBRIDGEPVID, ASN_UNSIGNED, RWRITE,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 1}},
#define IEEE8021QBRIDGEPORTACCEPTABLEFRAMETYPES		41
    {IEEE8021QBRIDGEPORTACCEPTABLEFRAMETYPES, ASN_INTEGER, RWRITE,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 2}},
#define IEEE8021QBRIDGEPORTINGRESSFILTERING		42
    {IEEE8021QBRIDGEPORTINGRESSFILTERING, ASN_INTEGER, RWRITE,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 3}},
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#define IEEE8021QBRIDGEPORTMVRPENABLEDSTATUS		43
    {IEEE8021QBRIDGEPORTMVRPENABLEDSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 4}},
#define IEEE8021QBRIDGEPORTMVRPFAILEDREGISTRATIONS		44
    {IEEE8021QBRIDGEPORTMVRPFAILEDREGISTRATIONS, ASN_COUNTER64, RONLY,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 5}},
#define IEEE8021QBRIDGEPORTMVRPLASTPDUORIGIN		45
    {IEEE8021QBRIDGEPORTMVRPLASTPDUORIGIN, ASN_OCTET_STR, RONLY,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 6}},
#define IEEE8021QBRIDGEPORTRESTRICTEDVLANREGISTRATION		46
    {IEEE8021QBRIDGEPORTRESTRICTEDVLANREGISTRATION, ASN_INTEGER, RWRITE,
     ieee8021QBridgePortVlanTable_var, 5, {1, 4, 5, 1, 7}},
#define IEEE8021QBRIDGETPVLANPORTINFRAMES		47
    {IEEE8021QBRIDGETPVLANPORTINFRAMES, ASN_COUNTER64, RONLY,
     ieee8021QBridgePortVlanStatisticsTable_var, 5, {1, 4, 6, 1, 1}},
#define IEEE8021QBRIDGETPVLANPORTOUTFRAMES		48
    {IEEE8021QBRIDGETPVLANPORTOUTFRAMES, ASN_COUNTER64, RONLY,
     ieee8021QBridgePortVlanStatisticsTable_var, 5, {1, 4, 6, 1, 2}},
#define IEEE8021QBRIDGETPVLANPORTINDISCARDS		49
    {IEEE8021QBRIDGETPVLANPORTINDISCARDS, ASN_COUNTER64, RONLY,
     ieee8021QBridgePortVlanStatisticsTable_var, 5, {1, 4, 6, 1, 3}},
#define IEEE8021QBRIDGELEARNINGCONSTRAINTSTYPE		50
    {IEEE8021QBRIDGELEARNINGCONSTRAINTSTYPE, ASN_INTEGER, RWRITE,
     ieee8021QBridgeLearningConstraintsTable_var, 5, {1, 4, 8, 1, 4}},
#define IEEE8021QBRIDGELEARNINGCONSTRAINTSSTATUS		51
    {IEEE8021QBRIDGELEARNINGCONSTRAINTSSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeLearningConstraintsTable_var, 5, {1, 4, 8, 1, 5}},
#define IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSSET		52
    {IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSSET, ASN_INTEGER, RWRITE,
     ieee8021QBridgeLearningConstraintDefaultsTable_var, 5, {1, 4, 9, 1,
                                                             2}},
#define IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSTYPE		53
    {IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSTYPE, ASN_INTEGER, RWRITE,
     ieee8021QBridgeLearningConstraintDefaultsTable_var, 5, {1, 4, 9, 1,
                                                             3}},
#define IEEE8021QBRIDGEPROTOCOLGROUPID		54
    {IEEE8021QBRIDGEPROTOCOLGROUPID, ASN_INTEGER, RWRITE,
     ieee8021QBridgeProtocolGroupTable_var, 5, {1, 5, 1, 1, 4}},
#define IEEE8021QBRIDGEPROTOCOLGROUPROWSTATUS		55
    {IEEE8021QBRIDGEPROTOCOLGROUPROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeProtocolGroupTable_var, 5, {1, 5, 1, 1, 5}},
#define IEEE8021QBRIDGEPROTOCOLPORTGROUPVID		56
    {IEEE8021QBRIDGEPROTOCOLPORTGROUPVID, ASN_INTEGER, RWRITE,
     ieee8021QBridgeProtocolPortTable_var, 5, {1, 5, 2, 1, 2}},
#define IEEE8021QBRIDGEPROTOCOLPORTROWSTATUS		57
    {IEEE8021QBRIDGEPROTOCOLPORTROWSTATUS, ASN_INTEGER, RWRITE,
     ieee8021QBridgeProtocolPortTable_var, 5, {1, 5, 2, 1, 3}},
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
};


/******************************************************************************/
// ucd_snmp_init_ieee8021QBridgeMib()
// Initializes the UCD-SNMP-part of the IEEE8021-Q-BRIDGE-MIB:ieee8021QBridgeMib.
/******************************************************************************/
void
ucd_snmp_init_ieee8021QBridgeMib(void)
{
    DEBUGMSGTL(("ieee8021QBridgeMib", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("ieee8021QBridgeMib", ieee8021QBridgeMib_variables,
                 variable7, ieee8021QBridgeMib_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeMib_var():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
u_char         *
ieee8021QBridgeMib_var(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    ieee8021QBridgeVlan_scalar_t ieee8021QBridgeVlan_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }

    if (ieee8021QBridgeVlanScalar_get(&ieee8021QBridgeVlan_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEVLANNUMDELETES:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                ieee8021QBridgeVlan_scalar_entry.
                ieee8021QBridgeVlanNumDeletes;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in ieee8021QBridgeMib_var\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeTable_parse(oid * name,
                           size_t *length,
                           int exact,
                           ieee8021QBridgeTable_entry_t * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeTable_fillobj(oid * name,
                             size_t *length,
                             ieee8021QBridgeTable_entry_t * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021QBridgeComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeTable_var(struct variable * vp,
                         oid * name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeTable_parse(name, length, exact,
                                    &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEVLANVERSIONNUMBER:{
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeVlanVersionNumber;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEMAXVLANID:{
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeMaxVlanId;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEMAXSUPPORTEDVLANS:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeMaxSupportedVlans;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    case IEEE8021QBRIDGENUMVLANS:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeNumVlans;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
#ifdef IEEE8021QBRIDGEMVRPENABLEDSTATUS
    case IEEE8021QBRIDGEMVRPENABLEDSTATUS:{
            *write_method = ieee8021QBridgeMvrpEnabledStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeMvrpEnabledStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#endif
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeTable\n",
                    vp->magic));
    }
    return NULL;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeCVlanPortTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeCVlanPortTable_parse(oid * name,
                                    size_t *length,
                                    int exact,
                                    ieee8021QBridgeCVlanPortTable_entry_t *
                                    table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeCVlanPortTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeCVlanPortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeCVlanPortNumber = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeCVlanPortTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeCVlanPortTable_fillobj(oid * name,
                                      size_t *length,
                                      ieee8021QBridgeCVlanPortTable_entry_t
                                      * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeCVlanPortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeCVlanPortNumber;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeCVlanPortTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeCVlanPortTable_var(struct variable * vp,
                                  oid * name,
                                  size_t *length,
                                  int exact,
                                  size_t *var_len,
                                  WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeCVlanPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeCVlanPortTable_parse(name, length, exact,
                                             &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeCVlanPortTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeCVlanPortTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGECVLANPORTROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeCVlanPortRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeCVlanPortTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGECVLANPORTROWSTATUS:{
            *write_method = ieee8021QBridgeCVlanPortRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeCVlanPortRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeCVlanPortTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeFdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeFdbTable_parse(oid * name,
                              size_t *length,
                              int exact,
                              ieee8021QBridgeFdbTable_entry_t *
                              table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeFdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeFdbComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeFdbId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeFdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeFdbTable_fillobj(oid * name,
                                size_t *length,
                                ieee8021QBridgeFdbTable_entry_t *
                                table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021QBridgeFdbComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeFdbId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeFdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeFdbTable_var(struct variable * vp,
                            oid * name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeFdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeFdbTable_parse(name, length, exact,
                                       &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeFdbTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeFdbTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeFdbTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEFDBDYNAMICCOUNT:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeFdbDynamicCount;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    case IEEE8021QBRIDGEFDBLEARNEDENTRYDISCARDS:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                table_entry.ieee8021QBridgeFdbLearnedEntryDiscards;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    case IEEE8021QBRIDGEFDBAGINGTIME:{
            *write_method = ieee8021QBridgeFdbAgingTime_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeFdbAgingTime;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeFdbTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeTpFdbTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeTpFdbTable_parse(oid * name,
                                size_t *length,
                                int exact,
                                ieee8021QBridgeTpFdbTable_entry_t *
                                table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t          len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeTpFdbTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeFdbComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeFdbId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->ieee8021QBridgeTpFdbAddress_len = len;
    cp = (u_char *) table_entry->ieee8021QBridgeTpFdbAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeTpFdbTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeTpFdbTable_fillobj(oid * name,
                                  size_t *length,
                                  ieee8021QBridgeTpFdbTable_entry_t *
                                  table_entry)
{
    int             name_pos = 11 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ieee8021QBridgeFdbComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeFdbId;
    len = (int) table_entry->ieee8021QBridgeTpFdbAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->
            ieee8021QBridgeTpFdbAddress[idx++];
    }

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeTpFdbTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeTpFdbTable_var(struct variable * vp,
                              oid * name,
                              size_t *length,
                              int exact,
                              size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeTpFdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeTpFdbTable_parse(name, length, exact,
                                         &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeTpFdbTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeTpFdbTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeTpFdbTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGETPFDBPORT:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeTpFdbPort;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    case IEEE8021QBRIDGETPFDBSTATUS:{
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeTpFdbStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeTpFdbTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeTpGroupTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeTpGroupTable_parse(oid * name,
                                  size_t *length,
                                  int exact,
                                  ieee8021QBridgeTpGroupTable_entry_t *
                                  table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t          len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeTpGroupTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->ieee8021QBridgeTpGroupAddress_len = len;
    cp = (u_char *) table_entry->ieee8021QBridgeTpGroupAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeTpGroupTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeTpGroupTable_fillobj(oid * name,
                                    size_t *length,
                                    ieee8021QBridgeTpGroupTable_entry_t *
                                    table_entry)
{
    int             name_pos = 11 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanCurrentComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeVlanIndex;
    len = (int) table_entry->ieee8021QBridgeTpGroupAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->
            ieee8021QBridgeTpGroupAddress[idx++];
    }

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeTpGroupTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeTpGroupTable_var(struct variable * vp,
                                oid * name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeTpGroupTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeTpGroupTable_parse(name, length, exact,
                                           &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeTpGroupTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeTpGroupTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeTpGroupTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGETPGROUPEGRESSPORTS:{
            *var_len = table_entry.ieee8021QBridgeTpGroupEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeTpGroupEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGETPGROUPLEARNT:{
            *var_len = table_entry.ieee8021QBridgeTpGroupLearnt_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeTpGroupLearnt, *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeTpGroupTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeForwardAllTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeForwardAllTable_parse(oid * name,
                                     size_t *length,
                                     int exact,
                                     ieee8021QBridgeForwardAllTable_entry_t
                                     * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeForwardAllTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeForwardAllVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeForwardAllTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeForwardAllTable_fillobj(oid * name,
                                       size_t *length,
                                       ieee8021QBridgeForwardAllTable_entry_t
                                       * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanCurrentComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeForwardAllVlanIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeForwardAllTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeForwardAllTable_var(struct variable * vp,
                                   oid * name,
                                   size_t *length,
                                   int exact,
                                   size_t *var_len,
                                   WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeForwardAllTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeForwardAllTable_parse(name, length, exact,
                                              &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeForwardAllTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeForwardAllTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeForwardAllTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEFORWARDALLPORTS:{
            *var_len = table_entry.ieee8021QBridgeForwardAllPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeForwardAllPorts, *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEFORWARDALLSTATICPORTS:{
            *write_method = ieee8021QBridgeForwardAllStaticPorts_write;
            *var_len =
                table_entry.ieee8021QBridgeForwardAllStaticPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeForwardAllStaticPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEFORWARDALLFORBIDDENPORTS:{
            *write_method = ieee8021QBridgeForwardAllForbiddenPorts_write;
            *var_len =
                table_entry.ieee8021QBridgeForwardAllForbiddenPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeForwardAllForbiddenPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeForwardAllTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeForwardUnregisteredTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeForwardUnregisteredTable_parse(oid * name,
                                              size_t *length,
                                              int exact,
                                              ieee8021QBridgeForwardUnregisteredTable_entry_t
                                              * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeForwardUnregisteredTableEntry_getfirst
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeForwardUnregisteredVlanIndex =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeForwardUnregisteredTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeForwardUnregisteredTable_fillobj(oid * name,
                                                size_t *length,
                                                ieee8021QBridgeForwardUnregisteredTable_entry_t
                                                * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanCurrentComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeForwardUnregisteredVlanIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeForwardUnregisteredTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeForwardUnregisteredTable_var(struct variable * vp,
                                            oid * name,
                                            size_t *length,
                                            int exact,
                                            size_t *var_len,
                                            WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeForwardUnregisteredTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeForwardUnregisteredTable_parse(name, length, exact,
                                                       &table_entry)) <
        0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeForwardUnregisteredTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeForwardUnregisteredTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeForwardUnregisteredTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEFORWARDUNREGISTEREDPORTS:{
            *var_len =
                table_entry.ieee8021QBridgeForwardUnregisteredPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeForwardUnregisteredPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEFORWARDUNREGISTEREDSTATICPORTS:{
            *write_method =
                ieee8021QBridgeForwardUnregisteredStaticPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeForwardUnregisteredStaticPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeForwardUnregisteredStaticPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEFORWARDUNREGISTEREDFORBIDDENPORTS:{
            *write_method =
                ieee8021QBridgeForwardUnregisteredForbiddenPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeForwardUnregisteredForbiddenPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeForwardUnregisteredForbiddenPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeForwardUnregisteredTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeStaticUnicastTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeStaticUnicastTable_parse(oid * name,
                                        size_t *length,
                                        int exact,
                                        ieee8021QBridgeStaticUnicastTable_entry_t
                                        * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t          len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeStaticUnicastTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeStaticUnicastComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeStaticUnicastVlanIndex =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->ieee8021QBridgeStaticUnicastAddress_len = len;
    cp = (u_char *) table_entry->ieee8021QBridgeStaticUnicastAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeStaticUnicastReceivePort =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeStaticUnicastTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeStaticUnicastTable_fillobj(oid * name,
                                          size_t *length,
                                          ieee8021QBridgeStaticUnicastTable_entry_t
                                          * table_entry)
{
    int             name_pos = 11 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeStaticUnicastComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeStaticUnicastVlanIndex;
    len = (int) table_entry->ieee8021QBridgeStaticUnicastAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->
            ieee8021QBridgeStaticUnicastAddress[idx++];
    }
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeStaticUnicastReceivePort;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeStaticUnicastTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeStaticUnicastTable_var(struct variable * vp,
                                      oid * name,
                                      size_t *length,
                                      int exact,
                                      size_t *var_len,
                                      WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeStaticUnicastTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeStaticUnicastTable_parse(name, length, exact,
                                                 &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeStaticUnicastTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeStaticUnicastTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGESTATICUNICASTROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeStaticUnicastRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeStaticUnicastTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS:{
            *write_method =
                ieee8021QBridgeStaticUnicastStaticEgressPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeStaticUnicastStaticEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeStaticUnicastStaticEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
    case IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS:{
            *write_method =
                ieee8021QBridgeStaticUnicastForbiddenEgressPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeStaticUnicastForbiddenEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeStaticUnicastForbiddenEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE:{
            *write_method = ieee8021QBridgeStaticUnicastStorageType_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeStaticUnicastStorageType;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
    case IEEE8021QBRIDGESTATICUNICASTROWSTATUS:{
            *write_method = ieee8021QBridgeStaticUnicastRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeStaticUnicastRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeStaticUnicastTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeStaticMulticastTable_parse(oid * name,
                                          size_t *length,
                                          int exact,
                                          ieee8021QBridgeStaticMulticastTable_entry_t
                                          * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t          len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 5)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeStaticMulticastTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->ieee8021QBridgeStaticMulticastAddress_len = len;
    cp = (u_char *) table_entry->ieee8021QBridgeStaticMulticastAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeStaticMulticastReceivePort =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeStaticMulticastTable_fillobj(oid * name,
                                            size_t *length,
                                            ieee8021QBridgeStaticMulticastTable_entry_t
                                            * table_entry)
{
    int             name_pos = 11 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanCurrentComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeVlanIndex;
    len = (int) table_entry->ieee8021QBridgeStaticMulticastAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->
            ieee8021QBridgeStaticMulticastAddress[idx++];
    }
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeStaticMulticastReceivePort;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeStaticMulticastTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeStaticMulticastTable_var(struct variable * vp,
                                        oid * name,
                                        size_t *length,
                                        int exact,
                                        size_t *var_len,
                                        WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeStaticMulticastTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeStaticMulticastTable_parse(name, length, exact,
                                                   &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeStaticMulticastTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeStaticMulticastTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGESTATICMULTICASTROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeStaticMulticastRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeStaticMulticastTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGESTATICMULTICASTSTATICEGRESSPORTS:{
            *write_method =
                ieee8021QBridgeStaticMulticastStaticEgressPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeStaticMulticastStaticEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeStaticMulticastStaticEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
    case IEEE8021QBRIDGESTATICMULTICASTFORBIDDENEGRESSPORTS:{
            *write_method =
                ieee8021QBridgeStaticMulticastForbiddenEgressPorts_write;
            *var_len =
                table_entry.
                ieee8021QBridgeStaticMulticastForbiddenEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.
                   ieee8021QBridgeStaticMulticastForbiddenEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGESTATICMULTICASTSTORAGETYPE:{
            *write_method =
                ieee8021QBridgeStaticMulticastStorageType_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeStaticMulticastStorageType;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
    case IEEE8021QBRIDGESTATICMULTICASTROWSTATUS:{
            *write_method = ieee8021QBridgeStaticMulticastRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeStaticMulticastRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeStaticMulticastTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeVlanCurrentTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeVlanCurrentTable_parse(oid * name,
                                      size_t *length,
                                      int exact,
                                      ieee8021QBridgeVlanCurrentTable_entry_t
                                      * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeVlanCurrentTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanTimeMark = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanCurrentComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeVlanCurrentTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeVlanCurrentTable_fillobj(oid * name,
                                        size_t *length,
                                        ieee8021QBridgeVlanCurrentTable_entry_t
                                        * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->ieee8021QBridgeVlanTimeMark;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanCurrentComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeVlanIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeVlanCurrentTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeVlanCurrentTable_var(struct variable * vp,
                                    oid * name,
                                    size_t *length,
                                    int exact,
                                    size_t *var_len,
                                    WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeVlanCurrentTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeVlanCurrentTable_parse(name, length, exact,
                                               &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeVlanCurrentTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeVlanCurrentTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeVlanCurrentTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEVLANFDBID:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeVlanFdbId;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    case IEEE8021QBRIDGEVLANCURRENTEGRESSPORTS:{
            *var_len =
                table_entry.ieee8021QBridgeVlanCurrentEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanCurrentEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANCURRENTUNTAGGEDPORTS:{
            *var_len =
                table_entry.ieee8021QBridgeVlanCurrentUntaggedPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanCurrentUntaggedPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANSTATUS:{
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeVlanStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
    case IEEE8021QBRIDGEVLANCREATIONTIME:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeVlanCreationTime;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeVlanCurrentTable\n",
                    vp->magic));
    }
    return NULL;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeVlanStaticTable_parse(oid * name,
                                     size_t *length,
                                     int exact,
                                     ieee8021QBridgeVlanStaticTable_entry_t
                                     * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeVlanStaticTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanStaticComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanStaticVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeVlanStaticTable_fillobj(oid * name,
                                       size_t *length,
                                       ieee8021QBridgeVlanStaticTable_entry_t
                                       * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanStaticComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeVlanStaticVlanIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeVlanStaticTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeVlanStaticTable_var(struct variable * vp,
                                   oid * name,
                                   size_t *length,
                                   int exact,
                                   size_t *var_len,
                                   WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeVlanStaticTable_parse(name, length, exact,
                                              &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeVlanStaticTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeVlanStaticTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGEVLANSTATICROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeVlanStaticRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeVlanStaticTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEVLANSTATICNAME:{
            *write_method = ieee8021QBridgeVlanStaticName_write;
            *var_len = table_entry.ieee8021QBridgeVlanStaticName_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanStaticName, *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:{
            *write_method = ieee8021QBridgeVlanStaticEgressPorts_write;
            *var_len =
                table_entry.ieee8021QBridgeVlanStaticEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanStaticEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:{
            *write_method = ieee8021QBridgeVlanForbiddenEgressPorts_write;
            *var_len =
                table_entry.ieee8021QBridgeVlanForbiddenEgressPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanForbiddenEgressPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:{
            *write_method = ieee8021QBridgeVlanStaticUntaggedPorts_write;
            *var_len =
                table_entry.ieee8021QBridgeVlanStaticUntaggedPorts_len;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgeVlanStaticUntaggedPorts,
                   *var_len);
            ieee8021QBridgeMib_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEVLANSTATICROWSTATUS:{
            *write_method = ieee8021QBridgeVlanStaticRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeVlanStaticRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeVlanStaticTable\n",
                    vp->magic));
    }
    return NULL;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeNextFreeLocalVlanTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeNextFreeLocalVlanTable_parse(oid * name,
                                            size_t *length,
                                            int exact,
                                            ieee8021QBridgeNextFreeLocalVlanTable_entry_t
                                            * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeNextFreeLocalVlanTableEntry_getfirst
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeNextFreeLocalVlanComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgeNextFreeLocalVlanTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeNextFreeLocalVlanTable_fillobj(oid * name,
                                              size_t *length,
                                              ieee8021QBridgeNextFreeLocalVlanTable_entry_t
                                              * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeNextFreeLocalVlanComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeNextFreeLocalVlanTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeNextFreeLocalVlanTable_var(struct variable * vp,
                                          oid * name,
                                          size_t *length,
                                          int exact,
                                          size_t *var_len,
                                          WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeNextFreeLocalVlanTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeNextFreeLocalVlanTable_parse(name, length, exact,
                                                     &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeNextFreeLocalVlanTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeNextFreeLocalVlanTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeNextFreeLocalVlanTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGENEXTFREELOCALVLANINDEX:{
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgeNextFreeLocalVlanIndex;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeNextFreeLocalVlanTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
/******************************************************************************/
// ieee8021QBridgePortVlanTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgePortVlanTable_parse(oid * name,
                                   size_t *length,
                                   int exact,
                                   ieee8021QBridgePortVlanTable_entry_t *
                                   table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgePortVlanTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgePortVlanTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgePortVlanTable_fillobj(oid * name,
                                     size_t *length,
                                     ieee8021QBridgePortVlanTable_entry_t *
                                     table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021BridgeBasePortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgePortVlanTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgePortVlanTable_var(struct variable * vp,
                                 oid * name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len,
                                 WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgePortVlanTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgePortVlanTable_parse(name, length, exact,
                                            &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgePortVlanTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgePortVlanTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgePortVlanTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEPVID:{
            *write_method = ieee8021QBridgePvid_write;
            ieee8021QBridgeMib_global_ret.ulong_ret =
                table_entry.ieee8021QBridgePvid;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.ulong_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.ulong_ret;
        }
    case IEEE8021QBRIDGEPORTACCEPTABLEFRAMETYPES:{
            *write_method = ieee8021QBridgePortAcceptableFrameTypes_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgePortAcceptableFrameTypes;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEPORTINGRESSFILTERING:{
            *write_method = ieee8021QBridgePortIngressFiltering_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgePortIngressFiltering;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
    case IEEE8021QBRIDGEPORTMVRPENABLEDSTATUS:{
            *write_method = ieee8021QBridgePortMvrpEnabledStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgePortMvrpEnabledStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEPORTMVRPFAILEDREGISTRATIONS:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                table_entry.ieee8021QBridgePortMvrpFailedRegistrations;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    case IEEE8021QBRIDGEPORTMVRPLASTPDUORIGIN:{
            *var_len = 6;
            memcpy(ieee8021QBridgeMib_global_ret.string_ret,
                   table_entry.ieee8021QBridgePortMvrpLastPduOrigin,
                   *var_len);
            return (u_char *) ieee8021QBridgeMib_global_ret.string_ret;
        }
    case IEEE8021QBRIDGEPORTRESTRICTEDVLANREGISTRATION:{
            *write_method =
                ieee8021QBridgePortRestrictedVlanRegistration_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgePortRestrictedVlanRegistration;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgePortVlanTable\n",
                    vp->magic));
    }
    return NULL;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgePortVlanStatisticsTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgePortVlanStatisticsTable_parse(oid * name,
                                             size_t *length,
                                             int exact,
                                             ieee8021QBridgePortVlanStatisticsTable_entry_t
                                             * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgePortVlanStatisticsTableEntry_getfirst
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// ieee8021QBridgePortVlanStatisticsTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgePortVlanStatisticsTable_fillobj(oid * name,
                                               size_t *length,
                                               ieee8021QBridgePortVlanStatisticsTable_entry_t
                                               * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021BridgeBasePortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;
    name[name_pos++] = (oid) table_entry->ieee8021QBridgeVlanIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgePortVlanStatisticsTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgePortVlanStatisticsTable_var(struct variable * vp,
                                           oid * name,
                                           size_t *length,
                                           int exact,
                                           size_t *var_len,
                                           WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgePortVlanStatisticsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgePortVlanStatisticsTable_parse(name, length, exact,
                                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgePortVlanStatisticsTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgePortVlanStatisticsTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgePortVlanStatisticsTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGETPVLANPORTINFRAMES:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                table_entry.ieee8021QBridgeTpVlanPortInFrames;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    case IEEE8021QBRIDGETPVLANPORTOUTFRAMES:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                table_entry.ieee8021QBridgeTpVlanPortOutFrames;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    case IEEE8021QBRIDGETPVLANPORTINDISCARDS:{
            ieee8021QBridgeMib_global_ret.c64_ret =
                table_entry.ieee8021QBridgeTpVlanPortInDiscards;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.c64_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.c64_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgePortVlanStatisticsTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeLearningConstraintsTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeLearningConstraintsTable_parse(oid * name,
                                              size_t *length,
                                              int exact,
                                              ieee8021QBridgeLearningConstraintsTable_entry_t
                                              * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeLearningConstraintsTableEntry_getfirst
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeLearningConstraintsComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeLearningConstraintsVlan =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeLearningConstraintsSet = (long) *op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeLearningConstraintsTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeLearningConstraintsTable_fillobj(oid * name,
                                                size_t *length,
                                                ieee8021QBridgeLearningConstraintsTable_entry_t
                                                * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeLearningConstraintsComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeLearningConstraintsVlan;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeLearningConstraintsSet;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeLearningConstraintsTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeLearningConstraintsTable_var(struct variable * vp,
                                            oid * name,
                                            size_t *length,
                                            int exact,
                                            size_t *var_len,
                                            WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeLearningConstraintsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeLearningConstraintsTable_parse(name, length, exact,
                                                       &table_entry)) <
        0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeLearningConstraintsTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeLearningConstraintsTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGELEARNINGCONSTRAINTSSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeLearningConstraintsStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeLearningConstraintsTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGELEARNINGCONSTRAINTSTYPE:{
            *write_method = ieee8021QBridgeLearningConstraintsType_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeLearningConstraintsType;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGELEARNINGCONSTRAINTSSTATUS:{
            *write_method = ieee8021QBridgeLearningConstraintsStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeLearningConstraintsStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeLearningConstraintsTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeLearningConstraintDefaultsTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeLearningConstraintDefaultsTable_parse(oid * name,
                                                     size_t *length,
                                                     int exact,
                                                     ieee8021QBridgeLearningConstraintDefaultsTable_entry_t
                                                     * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_getfirst
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeLearningConstraintDefaultsComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeLearningConstraintDefaultsTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeLearningConstraintDefaultsTable_fillobj(oid * name,
                                                       size_t *length,
                                                       ieee8021QBridgeLearningConstraintDefaultsTable_entry_t
                                                       * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->
        ieee8021QBridgeLearningConstraintDefaultsComponentId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeLearningConstraintDefaultsTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeLearningConstraintDefaultsTable_var(struct variable * vp,
                                                   oid * name,
                                                   size_t *length,
                                                   int exact,
                                                   size_t *var_len,
                                                   WriteMethod **
                                                   write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeLearningConstraintDefaultsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeLearningConstraintDefaultsTable_parse(name, length,
                                                              exact,
                                                              &table_entry))
        < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeLearningConstraintDefaultsTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (ieee8021QBridgeLearningConstraintDefaultsTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSSET:{
            *write_method =
                ieee8021QBridgeLearningConstraintDefaultsSet_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeLearningConstraintDefaultsSet;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGELEARNINGCONSTRAINTDEFAULTSTYPE:{
            *write_method =
                ieee8021QBridgeLearningConstraintDefaultsType_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeLearningConstraintDefaultsType;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeLearningConstraintDefaultsTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeProtocolGroupTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeProtocolGroupTable_parse(oid * name,
                                        size_t *length,
                                        int exact,
                                        ieee8021QBridgeProtocolGroupTable_entry_t
                                        * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t          len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeProtocolGroupTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021QBridgeProtocolGroupComponentId =
            (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeProtocolTemplateFrameType =
            (long) *op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) *op++;
    len =
        (unsigned int) len >
        sizeof(table_entry->
               ieee8021QBridgeProtocolTemplateProtocolValue) ?
        sizeof(table_entry->
               ieee8021QBridgeProtocolTemplateProtocolValue) : len;
    op_pos++;
    table_entry->ieee8021QBridgeProtocolTemplateProtocolValue_len = len;
    cp = (u_char *) table_entry->
        ieee8021QBridgeProtocolTemplateProtocolValue;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeProtocolGroupTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeProtocolGroupTable_fillobj(oid * name,
                                          size_t *length,
                                          ieee8021QBridgeProtocolGroupTable_entry_t
                                          * table_entry)
{
    int             name_pos = 11 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeProtocolGroupComponentId;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeProtocolTemplateFrameType;
    len =
        (int) table_entry->
        ieee8021QBridgeProtocolTemplateProtocolValue_len;
    name[name_pos++] =
        (oid) table_entry->
        ieee8021QBridgeProtocolTemplateProtocolValue_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->
            ieee8021QBridgeProtocolTemplateProtocolValue[idx++];
    }

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeProtocolGroupTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeProtocolGroupTable_var(struct variable * vp,
                                      oid * name,
                                      size_t *length,
                                      int exact,
                                      size_t *var_len,
                                      WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeProtocolGroupTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeProtocolGroupTable_parse(name, length, exact,
                                                 &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeProtocolGroupTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeProtocolGroupTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGEPROTOCOLGROUPROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeProtocolGroupRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeProtocolGroupTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEPROTOCOLGROUPID:{
            *write_method = ieee8021QBridgeProtocolGroupId_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeProtocolGroupId;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEPROTOCOLGROUPROWSTATUS:{
            *write_method = ieee8021QBridgeProtocolGroupRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeProtocolGroupRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeProtocolGroupTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeProtocolPortTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
ieee8021QBridgeProtocolPortTable_parse(oid * name,
                                       size_t *length,
                                       int exact,
                                       ieee8021QBridgeProtocolPortTable_entry_t
                                       * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (ieee8021QBridgeProtocolPortTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePortComponentId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021BridgeBasePort = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ieee8021QBridgeProtocolPortGroupId = (long) *op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeProtocolPortTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
ieee8021QBridgeProtocolPortTable_fillobj(oid * name,
                                         size_t *length,
                                         ieee8021QBridgeProtocolPortTable_entry_t
                                         * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] =
        (oid) table_entry->ieee8021BridgeBasePortComponentId;
    name[name_pos++] = (oid) table_entry->ieee8021BridgeBasePort;
    name[name_pos++] =
        (oid) table_entry->ieee8021QBridgeProtocolPortGroupId;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * ieee8021QBridgeProtocolPortTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for ieee8021QBridgeMib_var above.
 */
u_char         *
ieee8021QBridgeProtocolPortTable_var(struct variable * vp,
                                     oid * name,
                                     size_t *length,
                                     int exact,
                                     size_t *var_len,
                                     WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ieee8021QBridgeProtocolPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
         ieee8021QBridgeProtocolPortTable_parse(name, length, exact,
                                                &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (ieee8021QBridgeProtocolPortTable_fillobj
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (ieee8021QBridgeProtocolPortTableEntry_get
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IEEE8021QBRIDGEPROTOCOLPORTROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry. 
                     */
                    *write_method =
                        ieee8021QBridgeProtocolPortRowStatus_write;
                }
                return NULL;
            }
            if (ieee8021QBridgeProtocolPortTable_fillobj
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IEEE8021QBRIDGEPROTOCOLPORTGROUPVID:{
            *write_method = ieee8021QBridgeProtocolPortGroupVid_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeProtocolPortGroupVid;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    case IEEE8021QBRIDGEPROTOCOLPORTROWSTATUS:{
            *write_method = ieee8021QBridgeProtocolPortRowStatus_write;
            ieee8021QBridgeMib_global_ret.long_ret =
                table_entry.ieee8021QBridgeProtocolPortRowStatus;
            *var_len = sizeof(ieee8021QBridgeMib_global_ret.long_ret);
            return (u_char *) & ieee8021QBridgeMib_global_ret.long_ret;
        }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ieee8021QBridgeProtocolPortTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/

/******************************************************************************/
// ieee8021QBridgeMvrpEnabledStatus_write()
/******************************************************************************/
int
ieee8021QBridgeMvrpEnabledStatus_write(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeTable_entry_t table_entry;
    static ieee8021QBridgeTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeMvrpEnabledStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeMvrpEnabledStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeMvrpEnabledStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeMvrpEnabledStatus = set_value;
            if (ieee8021QBridgeTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

#if IEEE8021QBRIDGEMIB_NOT_SUPPORTED
/******************************************************************************/
// ieee8021QBridgeCVlanPortRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeCVlanPortRowStatus_write(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeCVlanPortTable_entry_t table_entry;
    static ieee8021QBridgeCVlanPortTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeCVlanPortRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeCVlanPortRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeCVlanPortRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeCVlanPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeCVlanPortTableEntry_get(old_table_entry_p,
                                                       FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeCVlanPortRowStatus = set_value;
            if (ieee8021QBridgeCVlanPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeCVlanPortTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* IEEE8021QBRIDGEMIB_NOT_SUPPORTED */

/******************************************************************************/
// ieee8021QBridgeFdbAgingTime_write()
/******************************************************************************/
int
ieee8021QBridgeFdbAgingTime_write(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeFdbTable_entry_t table_entry;
    static ieee8021QBridgeFdbTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeFdbAgingTime: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeFdbAgingTime: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 10 || var_val_len > 1000000) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeFdbTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeFdbTableEntry_get(old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeFdbAgingTime = set_value;
            if (ieee8021QBridgeFdbTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeFdbTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeForwardAllStaticPorts_write()
/******************************************************************************/
int
ieee8021QBridgeForwardAllStaticPorts_write(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    ieee8021QBridgeForwardAllTable_entry_t table_entry;
    static ieee8021QBridgeForwardAllTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardAllStaticPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardAllStaticPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardAllTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardAllTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeForwardAllStaticPorts,
                   var_val, var_val_len);
            table_entry.ieee8021QBridgeForwardAllStaticPorts_len =
                var_val_len;
            if (ieee8021QBridgeForwardAllTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeForwardAllTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeForwardAllForbiddenPorts_write()
/******************************************************************************/
int
ieee8021QBridgeForwardAllForbiddenPorts_write(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    ieee8021QBridgeForwardAllTable_entry_t table_entry;
    static ieee8021QBridgeForwardAllTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardAllForbiddenPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardAllForbiddenPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardAllTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardAllTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeForwardAllForbiddenPorts,
                   var_val, var_val_len);
            table_entry.ieee8021QBridgeForwardAllForbiddenPorts_len =
                var_val_len;
            if (ieee8021QBridgeForwardAllTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeForwardAllTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeForwardUnregisteredStaticPorts_write()
/******************************************************************************/
int
ieee8021QBridgeForwardUnregisteredStaticPorts_write(int action,
                                                    u_char * var_val,
                                                    u_char var_val_type,
                                                    size_t var_val_len,
                                                    u_char * statP,
                                                    oid * name,
                                                    size_t name_len)
{
    ieee8021QBridgeForwardUnregisteredTable_entry_t table_entry;
    static ieee8021QBridgeForwardUnregisteredTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardUnregisteredStaticPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardUnregisteredStaticPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardUnregisteredTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardUnregisteredTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeForwardUnregisteredStaticPorts, var_val,
                   var_val_len);
            table_entry.ieee8021QBridgeForwardUnregisteredStaticPorts_len =
                var_val_len;
            if (ieee8021QBridgeForwardUnregisteredTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeForwardUnregisteredTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeForwardUnregisteredForbiddenPorts_write()
/******************************************************************************/
int
ieee8021QBridgeForwardUnregisteredForbiddenPorts_write(int action,
                                                       u_char * var_val,
                                                       u_char var_val_type,
                                                       size_t var_val_len,
                                                       u_char * statP,
                                                       oid * name,
                                                       size_t name_len)
{
    ieee8021QBridgeForwardUnregisteredTable_entry_t table_entry;
    static ieee8021QBridgeForwardUnregisteredTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardUnregisteredForbiddenPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeForwardUnregisteredForbiddenPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardUnregisteredTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeForwardUnregisteredTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeForwardUnregisteredForbiddenPorts,
                   var_val, var_val_len);
            table_entry.
                ieee8021QBridgeForwardUnregisteredForbiddenPorts_len =
                var_val_len;
            if (ieee8021QBridgeForwardUnregisteredTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeForwardUnregisteredTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticUnicastStaticEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeStaticUnicastStaticEgressPorts_write(int action,
                                                    u_char * var_val,
                                                    u_char var_val_type,
                                                    size_t var_val_len,
                                                    u_char * statP,
                                                    oid * name,
                                                    size_t name_len)
{
    ieee8021QBridgeStaticUnicastTable_entry_t table_entry;
    static ieee8021QBridgeStaticUnicastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastStaticEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastStaticEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeStaticUnicastStaticEgressPorts, var_val,
                   var_val_len);
            table_entry.ieee8021QBridgeStaticUnicastStaticEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeStaticUnicastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticUnicastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticUnicastForbiddenEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeStaticUnicastForbiddenEgressPorts_write(int action,
                                                       u_char * var_val,
                                                       u_char var_val_type,
                                                       size_t var_val_len,
                                                       u_char * statP,
                                                       oid * name,
                                                       size_t name_len)
{
    ieee8021QBridgeStaticUnicastTable_entry_t table_entry;
    static ieee8021QBridgeStaticUnicastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastForbiddenEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastForbiddenEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeStaticUnicastForbiddenEgressPorts,
                   var_val, var_val_len);
            table_entry.
                ieee8021QBridgeStaticUnicastForbiddenEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeStaticUnicastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticUnicastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticUnicastStorageType_write()
/******************************************************************************/
int
ieee8021QBridgeStaticUnicastStorageType_write(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeStaticUnicastTable_entry_t table_entry;
    static ieee8021QBridgeStaticUnicastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastStorageType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastStorageType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3 && set_value != 4 && set_value != 5) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastStorageType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeStaticUnicastStorageType =
                set_value;
            if (ieee8021QBridgeStaticUnicastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticUnicastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticUnicastRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeStaticUnicastRowStatus_write(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeStaticUnicastTable_entry_t table_entry;
    static ieee8021QBridgeStaticUnicastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticUnicastRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticUnicastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeStaticUnicastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeStaticUnicastRowStatus = set_value;
            if (ieee8021QBridgeStaticUnicastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticUnicastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastStaticEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeStaticMulticastStaticEgressPorts_write(int action,
                                                      u_char * var_val,
                                                      u_char var_val_type,
                                                      size_t var_val_len,
                                                      u_char * statP,
                                                      oid * name,
                                                      size_t name_len)
{
    ieee8021QBridgeStaticMulticastTable_entry_t table_entry;
    static ieee8021QBridgeStaticMulticastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastStaticEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastStaticEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeStaticMulticastStaticEgressPorts,
                   var_val, var_val_len);
            table_entry.
                ieee8021QBridgeStaticMulticastStaticEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeStaticMulticastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticMulticastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastForbiddenEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeStaticMulticastForbiddenEgressPorts_write(int action,
                                                         u_char * var_val,
                                                         u_char
                                                         var_val_type,
                                                         size_t
                                                         var_val_len,
                                                         u_char * statP,
                                                         oid * name,
                                                         size_t name_len)
{
    ieee8021QBridgeStaticMulticastTable_entry_t table_entry;
    static ieee8021QBridgeStaticMulticastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastForbiddenEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastForbiddenEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.
                   ieee8021QBridgeStaticMulticastForbiddenEgressPorts,
                   var_val, var_val_len);
            table_entry.
                ieee8021QBridgeStaticMulticastForbiddenEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeStaticMulticastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticMulticastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastStorageType_write()
/******************************************************************************/
int
ieee8021QBridgeStaticMulticastStorageType_write(int action,
                                                u_char * var_val,
                                                u_char var_val_type,
                                                size_t var_val_len,
                                                u_char * statP,
                                                oid * name,
                                                size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeStaticMulticastTable_entry_t table_entry;
    static ieee8021QBridgeStaticMulticastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastStorageType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastStorageType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3 && set_value != 4 && set_value != 5) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastStorageType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeStaticMulticastStorageType =
                set_value;
            if (ieee8021QBridgeStaticMulticastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticMulticastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeStaticMulticastRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeStaticMulticastRowStatus_write(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeStaticMulticastTable_entry_t table_entry;
    static ieee8021QBridgeStaticMulticastTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeStaticMulticastRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeStaticMulticastTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeStaticMulticastTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeStaticMulticastRowStatus =
                set_value;
            if (ieee8021QBridgeStaticMulticastTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeStaticMulticastTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticName_write()
/******************************************************************************/
int
ieee8021QBridgeVlanStaticName_write(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;
    static ieee8021QBridgeVlanStaticTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticName: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticName: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 32) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeVlanStaticName, var_val,
                   var_val_len);
            table_entry.ieee8021QBridgeVlanStaticName_len = var_val_len;
            if (ieee8021QBridgeVlanStaticTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeVlanStaticTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeVlanStaticEgressPorts_write(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;
    static ieee8021QBridgeVlanStaticTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeVlanStaticEgressPorts,
                   var_val, var_val_len);
            table_entry.ieee8021QBridgeVlanStaticEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeVlanStaticTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeVlanStaticTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeVlanForbiddenEgressPorts_write()
/******************************************************************************/
int
ieee8021QBridgeVlanForbiddenEgressPorts_write(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;
    static ieee8021QBridgeVlanStaticTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanForbiddenEgressPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanForbiddenEgressPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeVlanForbiddenEgressPorts,
                   var_val, var_val_len);
            table_entry.ieee8021QBridgeVlanForbiddenEgressPorts_len =
                var_val_len;
            if (ieee8021QBridgeVlanStaticTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeVlanStaticTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticUntaggedPorts_write()
/******************************************************************************/
int
ieee8021QBridgeVlanStaticUntaggedPorts_write(int action,
                                             u_char * var_val,
                                             u_char var_val_type,
                                             size_t var_val_len,
                                             u_char * statP,
                                             oid * name, size_t name_len)
{
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;
    static ieee8021QBridgeVlanStaticTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_OCTET_STR) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticUntaggedPorts: not ASN_OCTET_STR\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > IEEE8021QBRIDGEMIB_STR_LEN_MAX) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticUntaggedPorts: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            memcpy(table_entry.ieee8021QBridgeVlanStaticUntaggedPorts,
                   var_val, var_val_len);
            table_entry.ieee8021QBridgeVlanStaticUntaggedPorts_len =
                var_val_len;
            if (ieee8021QBridgeVlanStaticTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeVlanStaticTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeVlanStaticRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeVlanStaticRowStatus_write(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeVlanStaticTable_entry_t table_entry;
    static ieee8021QBridgeVlanStaticTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeVlanStaticRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeVlanStaticTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeVlanStaticTableEntry_get(old_table_entry_p,
                                                        FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeVlanStaticRowStatus = set_value;
            if (ieee8021QBridgeVlanStaticTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeVlanStaticTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgePvid_write()
/******************************************************************************/
int
ieee8021QBridgePvid_write(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          set_value = var_val ? *((u_long *) var_val) : 0;
    ieee8021QBridgePortVlanTable_entry_t table_entry;
    static ieee8021QBridgePortVlanTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_UNSIGNED) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePvid: not ASN_UNSIGNED\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePvid: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 4094) {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 4096 || var_val_len > -1) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgePvid = set_value;
            if (ieee8021QBridgePortVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgePortVlanTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgePortAcceptableFrameTypes_write()
/******************************************************************************/
int
ieee8021QBridgePortAcceptableFrameTypes_write(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgePortVlanTable_entry_t table_entry;
    static ieee8021QBridgePortVlanTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortAcceptableFrameTypes: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortAcceptableFrameTypes: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2 && set_value != 3) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortAcceptableFrameTypes: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgePortAcceptableFrameTypes =
                set_value;
            if (ieee8021QBridgePortVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgePortVlanTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgePortIngressFiltering_write()
/******************************************************************************/
int
ieee8021QBridgePortIngressFiltering_write(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgePortVlanTable_entry_t table_entry;
    static ieee8021QBridgePortVlanTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortIngressFiltering: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortIngressFiltering: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortIngressFiltering: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgePortIngressFiltering = set_value;
            if (ieee8021QBridgePortVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgePortVlanTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgePortMvrpEnabledStatus_write()
/******************************************************************************/
int
ieee8021QBridgePortMvrpEnabledStatus_write(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgePortVlanTable_entry_t table_entry;
    static ieee8021QBridgePortVlanTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortMvrpEnabledStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortMvrpEnabledStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortMvrpEnabledStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgePortMvrpEnabledStatus = set_value;
            if (ieee8021QBridgePortVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgePortVlanTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgePortRestrictedVlanRegistration_write()
/******************************************************************************/
int
ieee8021QBridgePortRestrictedVlanRegistration_write(int action,
                                                    u_char * var_val,
                                                    u_char var_val_type,
                                                    size_t var_val_len,
                                                    u_char * statP,
                                                    oid * name,
                                                    size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgePortVlanTable_entry_t table_entry;
    static ieee8021QBridgePortVlanTable_entry_t *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortRestrictedVlanRegistration: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortRestrictedVlanRegistration: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgePortRestrictedVlanRegistration: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgePortVlanTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgePortRestrictedVlanRegistration =
                set_value;
            if (ieee8021QBridgePortVlanTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgePortVlanTableEntry_set(old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeLearningConstraintsType_write()
/******************************************************************************/
int
ieee8021QBridgeLearningConstraintsType_write(int action,
                                             u_char * var_val,
                                             u_char var_val_type,
                                             size_t var_val_len,
                                             u_char * statP,
                                             oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeLearningConstraintsTable_entry_t table_entry;
    static ieee8021QBridgeLearningConstraintsTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintsTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintsTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeLearningConstraintsType = set_value;
            if (ieee8021QBridgeLearningConstraintsTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeLearningConstraintsTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeLearningConstraintsStatus_write()
/******************************************************************************/
int
ieee8021QBridgeLearningConstraintsStatus_write(int action,
                                               u_char * var_val,
                                               u_char var_val_type,
                                               size_t var_val_len,
                                               u_char * statP,
                                               oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeLearningConstraintsTable_entry_t table_entry;
    static ieee8021QBridgeLearningConstraintsTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintsStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintsTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeLearningConstraintsTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeLearningConstraintsStatus =
                set_value;
            if (ieee8021QBridgeLearningConstraintsTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeLearningConstraintsTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeLearningConstraintDefaultsSet_write()
/******************************************************************************/
int
ieee8021QBridgeLearningConstraintDefaultsSet_write(int action,
                                                   u_char * var_val,
                                                   u_char var_val_type,
                                                   size_t var_val_len,
                                                   u_char * statP,
                                                   oid * name,
                                                   size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeLearningConstraintDefaultsTable_entry_t table_entry;
    static ieee8021QBridgeLearningConstraintDefaultsTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintDefaultsSet: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintDefaultsSet: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 65535) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintDefaultsTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeLearningConstraintDefaultsSet =
                set_value;
            if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeLearningConstraintDefaultsType_write()
/******************************************************************************/
int
ieee8021QBridgeLearningConstraintDefaultsType_write(int action,
                                                    u_char * var_val,
                                                    u_char var_val_type,
                                                    size_t var_val_len,
                                                    u_char * statP,
                                                    oid * name,
                                                    size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeLearningConstraintDefaultsTable_entry_t table_entry;
    static ieee8021QBridgeLearningConstraintDefaultsTable_entry_t
        *old_table_entry_p = NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintDefaultsType: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintDefaultsType: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1 && set_value != 2) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeLearningConstraintDefaultsType: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintDefaultsTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeLearningConstraintDefaultsType =
                set_value;
            if (ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
                (&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeLearningConstraintDefaultsTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeProtocolGroupId_write()
/******************************************************************************/
int
ieee8021QBridgeProtocolGroupId_write(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeProtocolGroupTable_entry_t table_entry;
    static ieee8021QBridgeProtocolGroupTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolGroupId: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolGroupId: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len > 2147483647) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolGroupTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolGroupTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeProtocolGroupId = set_value;
            if (ieee8021QBridgeProtocolGroupTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeProtocolGroupTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeProtocolGroupRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeProtocolGroupRowStatus_write(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeProtocolGroupTable_entry_t table_entry;
    static ieee8021QBridgeProtocolGroupTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolGroupRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolGroupRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolGroupRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolGroupTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeProtocolGroupTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeProtocolGroupRowStatus = set_value;
            if (ieee8021QBridgeProtocolGroupTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeProtocolGroupTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeProtocolPortGroupVid_write()
/******************************************************************************/
int
ieee8021QBridgeProtocolPortGroupVid_write(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeProtocolPortTable_entry_t table_entry;
    static ieee8021QBridgeProtocolPortTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolPortGroupVid: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolPortGroupVid: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (var_val_len < 1 || var_val_len > 4094) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeProtocolPortGroupVid = set_value;
            if (ieee8021QBridgeProtocolPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeProtocolPortTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

/******************************************************************************/
// ieee8021QBridgeProtocolPortRowStatus_write()
/******************************************************************************/
int
ieee8021QBridgeProtocolPortRowStatus_write(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ieee8021QBridgeProtocolPortTable_entry_t table_entry;
    static ieee8021QBridgeProtocolPortTable_entry_t *old_table_entry_p =
        NULL;

    switch (action) {
    case RESERVE1:{
            if (var_val_type != ASN_INTEGER) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolPortRowStatus: not ASN_INTEGER\n");
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolPortRowStatus: bad length\n");
                return SNMP_ERR_WRONGLENGTH;
            }
            if (set_value != 1
                && set_value != 2
                && set_value != 3
                && set_value != 4 && set_value != 5 && set_value != 6) {
                (void) snmp_log(LOG_ERR,
                                "write to ieee8021QBridgeProtocolPortRowStatus: bad value\n");
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }
    case RESERVE2:{
            if ((old_table_entry_p =
                 ucd_snmp_callout_malloc(sizeof(*old_table_entry_p))) ==
                NULL) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            if (ieee8021QBridgeProtocolPortTable_parse
                (name, &name_len, TRUE, old_table_entry_p)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            /*
             * Return error code when the entry isn't existing
             * except for "createAndGo(4)" or "createAndWait(5)" status 
             */
            if (set_value != SNMP_ROW_CREATEANDGO &&
                set_value != SNMP_ROW_CREATEANDWAIT &&
                ieee8021QBridgeProtocolPortTableEntry_get
                (old_table_entry_p, FALSE)) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            break;
        }
    case FREE:{
            if (old_table_entry_p) {
                ucd_snmp_callout_free(old_table_entry_p);
                old_table_entry_p = NULL;
            }
            break;
        }
    case ACTION:{
            // Set new configuration
            table_entry = *old_table_entry_p;
            table_entry.ieee8021QBridgeProtocolPortRowStatus = set_value;
            if (ieee8021QBridgeProtocolPortTableEntry_set(&table_entry)) {
                return SNMP_ERR_GENERR;
            }
            break;
        }
    case UNDO:{
            int             set_rc =
                ieee8021QBridgeProtocolPortTableEntry_set
                (old_table_entry_p);
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            if (set_rc) {
                return SNMP_ERR_UNDOFAILED;
            }
            break;
        }
    case COMMIT:{
            ucd_snmp_callout_free(old_table_entry_p);
            old_table_entry_p = NULL;
            break;
        }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}
