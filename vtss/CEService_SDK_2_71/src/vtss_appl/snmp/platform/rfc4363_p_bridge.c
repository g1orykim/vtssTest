/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
//#include <pkgconf/hal.h>
//#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc4363_p_bridge.h"
#include "msg_api.h" //msg_switch_exists()
#include "port_api.h"
#include "dot1Port_api.h"
#include "qos_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#include <vtss_module_id.h>

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP

#define SNMP_ASN_OCTET_STR_MAX_LEN  8 /* FIXME : Re-define it if needed */

/*
 * The entry data structure for dot1dTpHCPortTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dTpPort;

    /*
     * Entry columns
     */
    struct counter64 dot1dTpHCPortInFrames;
    struct counter64 dot1dTpHCPortOutFrames;
    struct counter64 dot1dTpHCPortInDiscards;
} dot1dTpHCPortTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    struct counter64 c64_ret;
} dot1dTpHCPortTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, dot1dTpHCPortTable_global_ret)
                                                     *//*
                                                     * Process one packet at the same time, therefore unprotected access is acceptable
                                                     */
static dot1dTpHCPortTable_return_t dot1dTpHCPortTable_global_ret;       /* static variables for retuning */

/*
 * dot1dTpHCPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1dTpHCPortTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 17, 4, 5 };



/*
 * variable dot1dTpHCPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the dot1dTpHCPortTable mib section
 */

struct variable2 dot1dTpHCPortTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define DOT1DTPHCPORTINFRAMES       1
    {
        DOT1DTPHCPORTINFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable,
        2, {1, 1}
    },
#define DOT1DTPHCPORTOUTFRAMES      2
    {
        DOT1DTPHCPORTOUTFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable,
        2, {1, 2}
    },
#define DOT1DTPHCPORTINDISCARDS     3
    {
        DOT1DTPHCPORTINDISCARDS, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable,
        2, {1, 3}
    },
};

/*
 * Initializes the dot1dTpHCPortTable module
 */
void
init_dot1dTpHCPortTable(void)
{
    // Register mibContextTable
    mibContextTable_register(dot1dTpHCPortTable_variables_oid,
                             sizeof(dot1dTpHCPortTable_variables_oid) / sizeof(oid),
                             "SNMP-MPD-MIB : dot1dTpHCPortTable");

    DEBUGMSGTL(("dot1dTpHCPortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1dTpHCPortTable", dot1dTpHCPortTable_variables,
                 variable2, dot1dTpHCPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL update_dot1dTpHCPortTable_entry(vtss_isid_t isid, vtss_port_no_t port_idx, dot1dTpHCPortTable_entry_t *table_entry_p)
{
    vtss_port_counters_t counters;
    port_conf_t              port_conf;
    if (!msg_switch_exists(isid)) {
        /* if the interface not exist, the counters always equal 0 */
        return TRUE;
    }

    if (port_mgmt_counters_get(isid, port_idx, &counters) != VTSS_OK) {
        return FALSE;
    }

    if (port_mgmt_conf_get(isid, port_idx, &port_conf) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->dot1dTpHCPortInFrames.low    += counters.rmon.rx_etherStatsPkts & 0xffffffff;
    table_entry_p->dot1dTpHCPortInFrames.high   += counters.rmon.rx_etherStatsPkts >> 32 & 0xffffffff;
    table_entry_p->dot1dTpHCPortOutFrames.low   += counters.rmon.tx_etherStatsPkts & 0xffffffff;
    table_entry_p->dot1dTpHCPortOutFrames.high  += counters.rmon.tx_etherStatsPkts >> 32 & 0xffffffff;
    table_entry_p->dot1dTpHCPortInDiscards.low  += counters.if_group.ifInDiscards & 0xffffffff;
    table_entry_p->dot1dTpHCPortInDiscards.high += counters.if_group.ifInDiscards >> 32 & 0xffffffff;

    return TRUE;
}

static int
getfirst_dot1dTpHCPortTableEntry(dot1dTpHCPortTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = 0;
    if ( FALSE == dot1Port_get_next(&table_info) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1dTpPort = table_info.dot1port;
    if ( FALSE == update_dot1dTpHCPortTable_entry (table_info.isid, table_info.if_id, table_entry) ) {
        return VTSS_RC_ERROR;
    }

    T_D("OK");
    return VTSS_RC_OK;
}

static int
get_dot1dTpHCPortTableEntry(dot1dTpHCPortTable_entry_t *table_entry,
                            BOOL getnext)
{
    vtss_port_no_t              port_idx;
    aggr_mgmt_group_no_t        aggr_no;
    aggr_mgmt_group_member_t    aggr_members;
    dot1Port_info_t             table_info;
    port_iter_t              pit;
    vtss_isid_t              isid = 0;

    table_info.dot1port = table_entry->dot1dTpPort;
    if (getnext) {
        if ( FALSE == dot1Port_get_next(&table_info) ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if ( FALSE == dot1Port_get(&table_info) ) {
            return VTSS_RC_ERROR;
        }
    }

    table_entry->dot1dTpPort = table_info.dot1port;

    switch (table_info.type) {
    case DOT1PORT_TYPE_PORT:
        if ( FALSE == update_dot1dTpHCPortTable_entry (table_info.isid, table_info.if_id, table_entry) ) {
            return VTSS_RC_ERROR;
        }
        break;
    case DOT1PORT_TYPE_LLAG:
        aggr_no = table_info.if_id;

        /* if the aggr_no is LACP mode and no ports up in the LACP ID, Operation status is down */
        if ((aggr_mgmt_port_members_get(table_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(table_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)
#endif
           ) {
            return VTSS_RC_OK;
        }

        for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_START + port_isid_port_count(table_info.isid); port_idx++) {
            if (!aggr_members.entry.member[port_idx]) {
                continue;
            }
            if (update_dot1dTpHCPortTable_entry(table_info.isid, port_idx, table_entry) == FALSE) {
                return VTSS_RC_ERROR;
            }
        }
        break;
    case DOT1PORT_TYPE_GLAG:
        aggr_no = table_info.if_id;
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, aggr_no, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_dot1dTpHCPortTable_entry(isid, pit.iport, table_entry) == FALSE) {
                    return FALSE;
                }
            }
        }
        break;

    default:
        return VTSS_RC_ERROR;
    }

    T_D("OK");
    return VTSS_RC_OK;
}

static int
parse_dot1dTpHCPortTable(oid *name,
                         size_t *length,
                         int exact,
                         dot1dTpHCPortTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTpHCPortTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dTpPort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTpHCPortTable(oid *name,
                           size_t *length,
                           dot1dTpHCPortTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->dot1dTpPort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTpHCPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dTpHCPortTable above.
 */
u_char         *
var_dot1dTpHCPortTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dTpHCPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dTpHCPortTable(name, length, exact,
                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dTpHCPortTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTpHCPortTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTpHCPortTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPHCPORTINFRAMES: {
        dot1dTpHCPortTable_global_ret.c64_ret =
            table_entry.dot1dTpHCPortInFrames;
        *var_len = sizeof(dot1dTpHCPortTable_global_ret.c64_ret);
        return (u_char *) & dot1dTpHCPortTable_global_ret.c64_ret;
    }
    case DOT1DTPHCPORTOUTFRAMES: {
        dot1dTpHCPortTable_global_ret.c64_ret =
            table_entry.dot1dTpHCPortOutFrames;
        *var_len = sizeof(dot1dTpHCPortTable_global_ret.c64_ret);
        return (u_char *) & dot1dTpHCPortTable_global_ret.c64_ret;
    }
    case DOT1DTPHCPORTINDISCARDS: {
        dot1dTpHCPortTable_global_ret.c64_ret =
            table_entry.dot1dTpHCPortInDiscards;
        *var_len = sizeof(dot1dTpHCPortTable_global_ret.c64_ret);
        return (u_char *) & dot1dTpHCPortTable_global_ret.c64_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dTpHCPortTable\n",
                    vp->magic));
    }
    return NULL;
}




/*
 * The entry data structure for dot1dDeviceCapabilities
 */
typedef struct {
    char            dot1dDeviceCapabilities[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t          dot1dDeviceCapabilities_len;
    long            dot1dTrafficClassesEnabled;
    long            dot1dGmrpStatus;
} dot1dExtBase_scalar_t;

/*
 * The entry data structure for dot1dPortCapabilitiesTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;

    /*
     * Entry columns
     */
    char            dot1dPortCapabilities[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t          dot1dPortCapabilities_len;
} dot1dPortCapabilitiesTable_entry_t;
/*
 * The entry data structure for dot1dPortPriorityTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;

    /*
     * Entry columns
     */
    long            dot1dPortDefaultUserPriority;
    long            dot1dPortNumTrafficClasses;
} dot1dPortPriorityTable_entry_t;
/*
 * The entry data structure for dot1dUserPriorityRegenTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;
    long            dot1dUserPriority;

    /*
     * Entry columns
     */
    long            dot1dRegenUserPriority;
} dot1dUserPriorityRegenTable_entry_t;
/*
 * The entry data structure for dot1dTrafficClassTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;
    long            dot1dTrafficClassPriority;

    /*
     * Entry columns
     */
    long            dot1dTrafficClass;
} dot1dTrafficClassTable_entry_t;
/*
 * The entry data structure for dot1dPortOutboundAccessPriorityTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;
    long            dot1dRegenUserPriority;

    /*
     * Entry columns
     */
    long            dot1dPortOutboundAccessPriority;
} dot1dPortOutboundAccessPriorityTable_entry_t;
/*
 * The entry data structure for dot1dPortGarpTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;

    /*
     * Entry columns
     */
    long            dot1dPortGarpJoinTime;
    long            dot1dPortGarpLeaveTime;
    long            dot1dPortGarpLeaveAllTime;
} dot1dPortGarpTable_entry_t;
/*
 * The entry data structure for dot1dPortGmrpTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            dot1dBasePort;

    /*
     * Entry columns
     */
    long            dot1dPortGmrpStatus;
    u_long          dot1dPortGmrpFailedRegistrations;
    char            dot1dPortGmrpLastPduOrigin[6];
    size_t          dot1dPortGmrpLastPduOrigin_len;
    long            dot1dPortRestrictedGroupRegistration;
} dot1dPortGmrpTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    char            string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long          ulong_ret;
} pBridgeMIB_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, pBridgeMIB_global_ret)
                                             *//*
                                             * Process one packet at the same time, therefore unprotected access is acceptable
                                             */
static pBridgeMIB_return_t pBridgeMIB_global_ret;       /* static variables for retuning */

/*
 * pBridgeMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             pBridgeMIB_variables_oid[] = { 1, 3, 6, 1, 2, 1, 17, 6 };



/*
 * variable pBridgeMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the pBridgeMIB mib section
 */

struct variable7 pBridgeMIB_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define DOT1DDEVICECAPABILITIES     1
    {
        DOT1DDEVICECAPABILITIES, ASN_OCTET_STR, RONLY, var_pBridgeMIB, 3,
        {1, 1, 1}
    },
#define DOT1DTRAFFICCLASSESENABLED      2
    {
#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
        DOT1DTRAFFICCLASSESENABLED, ASN_INTEGER, RWRITE, var_pBridgeMIB, 3,
#else
        DOT1DTRAFFICCLASSESENABLED, ASN_INTEGER, RONLY, var_pBridgeMIB, 3,
#endif
        {1, 1, 2}
    },
#if 0
#define DOT1DGMRPSTATUS     3
    {DOT1DGMRPSTATUS, ASN_INTEGER, RWRITE, var_pBridgeMIB, 3, {1, 1, 3}},
#endif
#define DOT1DPORTCAPABILITIES       4
    {
        DOT1DPORTCAPABILITIES, ASN_OCTET_STR, RONLY,
        var_dot1dPortCapabilitiesTable, 5, {1, 1, 4, 1, 1}
    },
#define DOT1DPORTDEFAULTUSERPRIORITY        5
    {
        DOT1DPORTDEFAULTUSERPRIORITY, ASN_INTEGER, RWRITE,
        var_dot1dPortPriorityTable, 5, {1, 2, 1, 1, 1}
    },
#if 0
#define DOT1DPORTNUMTRAFFICCLASSES      6
    {
        DOT1DPORTNUMTRAFFICCLASSES, ASN_INTEGER, RWRITE,
        var_dot1dPortPriorityTable, 5, {1, 2, 1, 1, 2}
    },
#define DOT1DREGENUSERPRIORITY      7
    {
        DOT1DREGENUSERPRIORITY, ASN_INTEGER, RWRITE,
        var_dot1dUserPriorityRegenTable, 5, {1, 2, 2, 1, 2}
    },
#endif
#define DOT1DTRAFFICCLASS       8
    {
        DOT1DTRAFFICCLASS, ASN_INTEGER, RWRITE, var_dot1dTrafficClassTable, 5,
        {1, 2, 3, 1, 2}
    },
#if 0
#define DOT1DPORTOUTBOUNDACCESSPRIORITY     9
    {
        DOT1DPORTOUTBOUNDACCESSPRIORITY, ASN_INTEGER, RONLY,
        var_dot1dPortOutboundAccessPriorityTable, 5, {1, 2, 4, 1, 1}
    },
#define DOT1DPORTGARPJOINTIME       10
    {
        DOT1DPORTGARPJOINTIME, ASN_INTEGER, RWRITE, var_dot1dPortGarpTable, 5,
        {1, 3, 1, 1, 1}
    },
#define DOT1DPORTGARPLEAVETIME      11
    {
        DOT1DPORTGARPLEAVETIME, ASN_INTEGER, RWRITE, var_dot1dPortGarpTable,
        5, {1, 3, 1, 1, 2}
    },
#define DOT1DPORTGARPLEAVEALLTIME       12
    {
        DOT1DPORTGARPLEAVEALLTIME, ASN_INTEGER, RWRITE,
        var_dot1dPortGarpTable, 5, {1, 3, 1, 1, 3}
    },
#define DOT1DPORTGMRPSTATUS     13
    {
        DOT1DPORTGMRPSTATUS, ASN_INTEGER, RWRITE, var_dot1dPortGmrpTable, 5,
        {1, 4, 1, 1, 1}
    },
#define DOT1DPORTGMRPFAILEDREGISTRATIONS        14
    {
        DOT1DPORTGMRPFAILEDREGISTRATIONS, ASN_COUNTER, RONLY,
        var_dot1dPortGmrpTable, 5, {1, 4, 1, 1, 2}
    },
#define DOT1DPORTGMRPLASTPDUORIGIN      15
    {
        DOT1DPORTGMRPLASTPDUORIGIN, ASN_OCTET_STR, RONLY,
        var_dot1dPortGmrpTable, 5, {1, 4, 1, 1, 3}
    },
#define DOT1DPORTRESTRICTEDGROUPREGISTRATION        16
    {
        DOT1DPORTRESTRICTEDGROUPREGISTRATION, ASN_INTEGER, RWRITE,
        var_dot1dPortGmrpTable, 5, {1, 4, 1, 1, 4}
    },
#endif
};

#define DOT1DEXTENDEDFILTERINGSERVICES  0x80
#define DOT1DTRAFFICCLASSES             0x40
#define DOT1QSTATICENTRYINDIVIDUALPORT  0x20
#define DOT1QIVLCAPABLE                 0x10
#define DOT1QSVLCAPABLE                 0x8
#define DOT1QHYBRIDCAPABLE              0x4
#define DOT1QCONFIGURABLEPVIDTAGGING    0x2
#define DOT1DLOCALVLANCAPABLE           0x1

#define DOT1QDOT1QTAGGING                       0x80
#define DOT1QCONFIGURABLEACCEPTABLEFRAMETYPES   0x40
#define DOT1QINGRESSFILTERING                   0x20

#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
/*lint -esym(459, dscp_class_enable) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static BOOL      dscp_class_enable[VTSS_ISID_END][VTSS_PORTS];

static void get_init_dscp(void)
{
    vtss_rc         rc;
    port_iter_t     pit;
    switch_iter_t   sit;
    BOOL            *ptr;
    qos_port_conf_t conf;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            ptr = &dscp_class_enable[sit.isid][pit.iport];
            if ( VTSS_RC_OK != (rc = qos_port_conf_get(sit.isid, pit.iport, &conf)) ) {
                T_E("%s", error_txt(rc));
                continue;
            }
            *ptr = conf.dscp_class_enable;

        }
    }
}
#endif
/*
 * Initializes the pBridgeMIB module
 */
void
init_rfc4363_p_bridge(void)
{
    // Register mibContextTable
    mibContextTable_register(pBridgeMIB_variables_oid,
                             sizeof(pBridgeMIB_variables_oid) / sizeof(oid),
                             "P-BRIDGE-MIB : pBridgeMIB");

    DEBUGMSGTL(("pBridgeMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("pBridgeMIB", pBridgeMIB_variables, variable7,
                 pBridgeMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
    init_dot1dTpHCPortTable();
#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    get_init_dscp();
#endif
}


static int
get_dot1dExtBaseScalar(dot1dExtBase_scalar_t *scalar_entry)
{
#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    vtss_rc         rc;
    qos_port_conf_t conf;
    port_iter_t     pit;
    switch_iter_t   sit;
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */
    scalar_entry->dot1dDeviceCapabilities_len = 1;
    scalar_entry->dot1dDeviceCapabilities[0] = DOT1DTRAFFICCLASSES | DOT1QSTATICENTRYINDIVIDUALPORT | DOT1QCONFIGURABLEPVIDTAGGING;

#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    (void)switch_iter_getnext(&sit);
    (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
    (void)port_iter_getnext(&pit);
    if ( VTSS_RC_OK != (rc = qos_port_conf_get(sit.isid, pit.iport, &conf)) ) {
        T_E("%s", error_txt(rc));
    }
    scalar_entry->dot1dTrafficClassesEnabled = (rc == VTSS_OK ? (conf.tag_class_enable ? 1 : 2) : 2);
#else
    scalar_entry->dot1dTrafficClassesEnabled = 1;
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */
    return VTSS_RC_OK;
}

static int
set_dot1dExtBaseScalar(dot1dExtBase_scalar_t *scalar_entry)
{
    vtss_rc         rc;
    port_iter_t     pit;
    switch_iter_t   sit;
    qos_port_conf_t conf;
#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    BOOL            tmp = scalar_entry->dot1dTrafficClassesEnabled == 1 ? TRUE : FALSE, *ptr;
#endif

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if ( VTSS_RC_OK != (rc = qos_port_conf_get(sit.isid, pit.iport, &conf)) ) {
                T_E("%s", error_txt(rc));
                continue;
            }
#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
            ptr = &dscp_class_enable[sit.isid][pit.iport];
            if ( conf.tag_class_enable != tmp ) {
                if ( TRUE == tmp ) {
                    conf.default_prio    = conf.qos_class_map[conf.usr_prio][0];
                    *ptr = conf.dscp_class_enable;
                    conf.dscp_class_enable = FALSE;
                } else {
                    conf.default_prio    = 0;
                    conf.dscp_class_enable = *ptr;
                }
                conf.tag_remark_mode = VTSS_TAG_REMARK_MODE_CLASSIFIED;
                conf.tag_class_enable = tmp;
                if ( VTSS_RC_OK != (rc = qos_port_conf_set(sit.isid, pit.iport, &conf)) ) {
                    T_E("%s", error_txt(rc));
                }
            }
#endif
        }
    }

    return VTSS_RC_OK;
}

/*
 * var_pBridgeMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_pBridgeMIB(struct variable *vp,
               oid *name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod **write_method)
{
    dot1dExtBase_scalar_t dot1dExtBase_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }

    if (get_dot1dExtBaseScalar(&dot1dExtBase_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DDEVICECAPABILITIES: {
        *var_len =
            dot1dExtBase_scalar_entry.dot1dDeviceCapabilities_len;
        memcpy(pBridgeMIB_global_ret.string_ret,
               dot1dExtBase_scalar_entry.dot1dDeviceCapabilities,
               *var_len);
        pBridgeMIB_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) pBridgeMIB_global_ret.string_ret;
    }
    case DOT1DTRAFFICCLASSESENABLED: {
        *write_method = write_dot1dTrafficClassesEnabled;
        pBridgeMIB_global_ret.long_ret =
            dot1dExtBase_scalar_entry.dot1dTrafficClassesEnabled;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
#if 0
    case DOT1DGMRPSTATUS: {
        *write_method = write_dot1dGmrpStatus;
        pBridgeMIB_global_ret.long_ret =
            dot1dExtBase_scalar_entry.dot1dGmrpStatus;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_pBridgeMIB\n",
                    vp->magic));
    }
    return NULL;
}

static void get_dot1dPortCapabilitiesTableEntryByDot1Port(dot1Port_info_t *table_info, dot1dPortCapabilitiesTable_entry_t *table_entry)
{
    table_entry->dot1dBasePort = table_info->dot1port;
    table_entry->dot1dPortCapabilities_len = 1;
    if (table_info->type != DOT1PORT_TYPE_PORT ) {
        memset(table_entry->dot1dPortCapabilities, 0, table_entry->dot1dPortCapabilities_len);
    } else {
        table_entry->dot1dPortCapabilities[0] = ( char )(DOT1QDOT1QTAGGING | DOT1QCONFIGURABLEACCEPTABLEFRAMETYPES | DOT1QINGRESSFILTERING);
    }

}

static BOOL get_next_dot1dPortCapabilitiesTableEntryByKey(dot1dPortCapabilitiesTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = table_entry->dot1dBasePort;
    if ( FALSE == dot1Port_get_next(&table_info) ) {
        return FALSE;
    }

    get_dot1dPortCapabilitiesTableEntryByDot1Port(&table_info, table_entry);
    return TRUE;
}

static BOOL get_dot1dPortCapabilitiesTableEntryByKey(dot1dPortCapabilitiesTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = table_entry->dot1dBasePort;
    if ( FALSE == dot1Port_get(&table_info) ) {
        return FALSE;
    }

    get_dot1dPortCapabilitiesTableEntryByDot1Port(&table_info, table_entry);
    return TRUE;
}

static int
getfirst_dot1dPortCapabilitiesTableEntry(dot1dPortCapabilitiesTable_entry_t
                                         * table_entry)
{
    return get_next_dot1dPortCapabilitiesTableEntryByKey(table_entry) == TRUE ? VTSS_RC_OK : VTSS_RC_ERROR;
}

static int
get_dot1dPortCapabilitiesTableEntry(dot1dPortCapabilitiesTable_entry_t *
                                    table_entry, BOOL getnext)
{
    if ( (FALSE == getnext && FALSE == get_dot1dPortCapabilitiesTableEntryByKey(table_entry)) ||
         (TRUE == getnext && FALSE == get_next_dot1dPortCapabilitiesTableEntryByKey(table_entry)) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
parse_dot1dPortCapabilitiesTable(oid *name,
                                 size_t *length,
                                 int exact,
                                 dot1dPortCapabilitiesTable_entry_t *
                                 table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dPortCapabilitiesTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dPortCapabilitiesTable(oid *name,
                                   size_t *length,
                                   dot1dPortCapabilitiesTable_entry_t *
                                   table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dPortCapabilitiesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dPortCapabilitiesTable(struct variable *vp,
                               oid *name,
                               size_t *length,
                               int exact,
                               size_t *var_len,
                               WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dPortCapabilitiesTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dPortCapabilitiesTable(name, length, exact,
                                              &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dPortCapabilitiesTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dPortCapabilitiesTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dPortCapabilitiesTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DPORTCAPABILITIES: {
        *var_len = table_entry.dot1dPortCapabilities_len;
        memcpy(pBridgeMIB_global_ret.string_ret,
               table_entry.dot1dPortCapabilities, *var_len);
        pBridgeMIB_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) pBridgeMIB_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dPortCapabilitiesTable\n",
                    vp->magic));
    }
    return NULL;
}

static BOOL get_dot1dPortPriorityTableEntryByDot1Port(dot1Port_info_t *table_info, dot1dPortPriorityTable_entry_t *table_entry, qos_port_conf_t *conf )
{
    vtss_rc rc;
    qos_port_conf_t tmp;

    if ( VTSS_RC_OK != (rc = qos_port_conf_get(table_info->isid, table_info->if_id, &tmp)) ) {
        T_E("%s", error_txt(rc));
        return FALSE;
    }

    if ( table_entry ) {
        table_entry->dot1dBasePort = table_info->dot1port;
        table_entry->dot1dPortDefaultUserPriority = ( long ) tmp.usr_prio;
    }

    if ( conf ) {
        *conf = tmp;
    }
    return TRUE;
}

static BOOL get_next_dot1dPortPriorityTableEntryByKey(dot1dPortPriorityTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = table_entry->dot1dBasePort;
    if ( FALSE == dot1Port_get_next(&table_info) || table_info.type != DOT1PORT_TYPE_PORT ) {
        return FALSE;
    }

    return get_dot1dPortPriorityTableEntryByDot1Port(&table_info, table_entry, NULL);
}

static BOOL get_dot1dPortPriorityTableEntryByKey(dot1dPortPriorityTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = table_entry->dot1dBasePort;
    if ( FALSE == dot1Port_get(&table_info) || table_info.type != DOT1PORT_TYPE_PORT ) {
        return FALSE;
    }

    return get_dot1dPortPriorityTableEntryByDot1Port(&table_info, table_entry, NULL);
}

static int
getfirst_dot1dPortPriorityTableEntry(dot1dPortPriorityTable_entry_t *
                                     table_entry)
{
    return get_next_dot1dPortPriorityTableEntryByKey(table_entry) == TRUE ? VTSS_RC_OK : VTSS_RC_ERROR;
}

static int
get_dot1dPortPriorityTableEntry(dot1dPortPriorityTable_entry_t *
                                table_entry, BOOL getnext)
{
    if ( (FALSE == getnext && FALSE == get_dot1dPortPriorityTableEntryByKey(table_entry)) ||
         (TRUE == getnext && FALSE == get_next_dot1dPortPriorityTableEntryByKey(table_entry)) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
set_dot1dPortPriorityTableEntry(dot1dPortPriorityTable_entry_t *
                                table_entry)
{
    vtss_rc rc;
    qos_port_conf_t conf;

    dot1Port_info_t table_info;
    table_info.dot1port = table_entry->dot1dBasePort;
    if ( FALSE == dot1Port_get(&table_info) || table_info.type != DOT1PORT_TYPE_PORT ) {
        return FALSE;
    }

    if ( FALSE == get_dot1dPortPriorityTableEntryByDot1Port(&table_info, NULL, &conf) ) {
        return VTSS_RC_OK;
    }

    conf.usr_prio = table_entry->dot1dPortDefaultUserPriority;

#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    conf.default_dei    = 0;
    conf.default_prio   = conf.qos_class_map[conf.usr_prio][0];
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */

    if ( (rc = qos_port_conf_set(table_info.isid, table_info.if_id, &conf)) != VTSS_RC_OK ) {
        T_E("%s", error_txt(rc));
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
parse_dot1dPortPriorityTable(oid *name,
                             size_t *length,
                             int exact,
                             dot1dPortPriorityTable_entry_t *table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dPortPriorityTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dPortPriorityTable(oid *name,
                               size_t *length,
                               dot1dPortPriorityTable_entry_t *
                               table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dPortPriorityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dPortPriorityTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dPortPriorityTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dPortPriorityTable(name, length, exact,
                                          &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dPortPriorityTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dPortPriorityTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dPortPriorityTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DPORTDEFAULTUSERPRIORITY: {
        *write_method = write_dot1dPortDefaultUserPriority;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortDefaultUserPriority;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
#if 0
    case DOT1DPORTNUMTRAFFICCLASSES: {
        *write_method = write_dot1dPortNumTrafficClasses;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortNumTrafficClasses;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dPortPriorityTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0
static int
getfirst_dot1dUserPriorityRegenTableEntry
(dot1dUserPriorityRegenTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_dot1dUserPriorityRegenTableEntry(dot1dUserPriorityRegenTable_entry_t *
                                     table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
set_dot1dUserPriorityRegenTableEntry(dot1dUserPriorityRegenTable_entry_t *
                                     table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_dot1dUserPriorityRegenTable(oid *name,
                                  size_t *length,
                                  int exact,
                                  dot1dUserPriorityRegenTable_entry_t *
                                  table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dUserPriorityRegenTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1dUserPriority = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dUserPriorityRegenTable(oid *name,
                                    size_t *length,
                                    dot1dUserPriorityRegenTable_entry_t *
                                    table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1dUserPriority;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dUserPriorityRegenTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dUserPriorityRegenTable(struct variable *vp,
                                oid *name,
                                size_t *length,
                                int exact,
                                size_t *var_len,
                                WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dUserPriorityRegenTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dUserPriorityRegenTable(name, length, exact,
                                               &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dUserPriorityRegenTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dUserPriorityRegenTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dUserPriorityRegenTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DREGENUSERPRIORITY: {
        *write_method = write_dot1dRegenUserPriority;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dRegenUserPriority;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dUserPriorityRegenTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif


#ifdef VTSS_FEATURE_QOS_CLASSIFICATION_V2
static BOOL get_dot1dTrafficClassTableEntryByDot1Port(dot1Port_info_t *table_info, dot1dTrafficClassTable_entry_t *table_entry, qos_port_conf_t *conf )
{
    vtss_rc                      rc;
    qos_port_conf_t              tmp_conf;

    if ( VTSS_RC_OK != (rc = qos_port_conf_get(table_info->isid, table_info->if_id, &tmp_conf)) ) {
        T_E("%s", error_txt(rc));
        return FALSE;
    }

    table_entry->dot1dTrafficClass          = tmp_conf.qos_class_map[table_entry->dot1dTrafficClassPriority][0];
    if ( conf ) {
        *conf = tmp_conf;
    }
    return TRUE;

}

static BOOL get_next_dot1dTrafficClassTableEntryByKey(dot1dTrafficClassTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    dot1dTrafficClassTable_entry_t tmp = *table_entry;
    table_info.dot1port = tmp.dot1dBasePort;

    T_D("IN: dot1dbasePort = %ld, dot1dTrafficClassPriority = %ld", tmp.dot1dBasePort, tmp.dot1dTrafficClassPriority);

    if ( tmp.dot1dTrafficClassPriority < 7 && TRUE == dot1Port_get(&table_info)) {
        tmp.dot1dTrafficClassPriority = tmp.dot1dTrafficClassPriority >= 0 ?
                                        tmp.dot1dTrafficClassPriority + 1 : 0;
        T_D("OUT: dot1dbasePort = %ld, dot1dTrafficClassPriority = %ld", tmp.dot1dBasePort, tmp.dot1dTrafficClassPriority);
    } else if ( TRUE == dot1Port_get_next(&table_info)) {
        tmp.dot1dBasePort = table_info.dot1port;
        tmp.dot1dTrafficClassPriority = 0;
        T_D("OUT: dot1dbasePort = %ld, dot1dTrafficClassPriority = %ld", tmp.dot1dBasePort, tmp.dot1dTrafficClassPriority);
    } else {
        return FALSE;
    }

    if (table_info.type != DOT1PORT_TYPE_PORT) {
        return FALSE;
    }

    if ( FALSE == get_dot1dTrafficClassTableEntryByDot1Port ( &table_info, &tmp, NULL)) {
        return FALSE;
    }

    *table_entry = tmp;
    T_D("OK");
    return TRUE;
}

static  BOOL get_dot1dTrafficClassTableEntryByKey(dot1dTrafficClassTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    dot1dTrafficClassTable_entry_t tmp = *table_entry;
    table_info.dot1port = tmp.dot1dBasePort;

    T_D("IN: dot1dbasePort = %ld, dot1dTrafficClassPriority = %ld", tmp.dot1dBasePort, tmp.dot1dTrafficClassPriority);
    if ( tmp.dot1dTrafficClassPriority > 7 || tmp.dot1dTrafficClassPriority < 0 ||  FALSE == dot1Port_get(&table_info) ) {
        return FALSE;
    }

    if (table_info.type != DOT1PORT_TYPE_PORT) {
        return FALSE;
    }

    T_D("OUT: dot1dbasePort = %ld, dot1dTrafficClassPriority = %ld", tmp.dot1dBasePort, tmp.dot1dTrafficClassPriority);
    if ( FALSE == get_dot1dTrafficClassTableEntryByDot1Port ( &table_info, &tmp, NULL)) {
        return FALSE;
    }

    *table_entry = tmp;
    T_D("OK");
    return TRUE;

}
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */

static int
getfirst_dot1dTrafficClassTableEntry(dot1dTrafficClassTable_entry_t *
                                     table_entry)
{
#ifndef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    return VTSS_RC_ERROR;
#else
    return get_next_dot1dTrafficClassTableEntryByKey( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */
}

static int
get_dot1dTrafficClassTableEntry(dot1dTrafficClassTable_entry_t *
                                table_entry, BOOL getnext)
{
#ifndef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    return VTSS_RC_ERROR;
#else
    if ( ( TRUE == getnext && FALSE == get_next_dot1dTrafficClassTableEntryByKey( table_entry )) ||
         ( FALSE == getnext && FALSE == get_dot1dTrafficClassTableEntryByKey( table_entry )) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */
}

static int
set_dot1dTrafficClassTableEntry(dot1dTrafficClassTable_entry_t *
                                table_entry)
{
#ifndef VTSS_FEATURE_QOS_CLASSIFICATION_V2
    return VTSS_RC_ERROR;
#else
    vtss_rc                      rc;
    dot1Port_info_t              table_info;
    qos_port_conf_t              conf;
    dot1dTrafficClassTable_entry_t tmp = *table_entry;
    table_info.dot1port = tmp.dot1dBasePort;

    if ( tmp.dot1dTrafficClassPriority > 7 || tmp.dot1dTrafficClassPriority < 0
         ||  FALSE == dot1Port_get(&table_info) || FALSE == get_dot1dTrafficClassTableEntryByDot1Port ( &table_info, &tmp, &conf )) {
        return VTSS_RC_ERROR;
    }

    conf.qos_class_map[table_entry->dot1dTrafficClassPriority][0] = table_entry->dot1dTrafficClass;
    conf.qos_class_map[table_entry->dot1dTrafficClassPriority][1] = table_entry->dot1dTrafficClass;

    if ( table_entry->dot1dTrafficClassPriority == conf.usr_prio) {
        conf.default_prio = table_entry->dot1dTrafficClass;
    }

    if ( (rc = qos_port_conf_set(table_info.isid, table_info.if_id, &conf)) != VTSS_RC_OK ) {
        T_E("%s", error_txt(rc));
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
#endif /*   VTSS_FEATURE_QOS_CLASSIFICATION_V2  */
}

static int
parse_dot1dTrafficClassTable(oid *name,
                             size_t *length,
                             int exact,
                             dot1dTrafficClassTable_entry_t *table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTrafficClassTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1dTrafficClassPriority = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTrafficClassTable(oid *name,
                               size_t *length,
                               dot1dTrafficClassTable_entry_t *
                               table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1dTrafficClassPriority;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTrafficClassTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dTrafficClassTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dTrafficClassTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dTrafficClassTable(name, length, exact,
                                          &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dTrafficClassTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTrafficClassTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTrafficClassTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTRAFFICCLASS: {
        *write_method = write_dot1dTrafficClass;
        pBridgeMIB_global_ret.long_ret = table_entry.dot1dTrafficClass;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dTrafficClassTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0
static int
getfirst_dot1dPortOutboundAccessPriorityTableEntry
(dot1dPortOutboundAccessPriorityTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_dot1dPortOutboundAccessPriorityTableEntry
(dot1dPortOutboundAccessPriorityTable_entry_t *table_entry,
 BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_dot1dPortOutboundAccessPriorityTable(oid *name,
                                           size_t *length,
                                           int exact,
                                           dot1dPortOutboundAccessPriorityTable_entry_t
                                           * table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dPortOutboundAccessPriorityTableEntry
            (table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1dRegenUserPriority = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dPortOutboundAccessPriorityTable(oid *name,
                                             size_t *length,
                                             dot1dPortOutboundAccessPriorityTable_entry_t
                                             * table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1dRegenUserPriority;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dPortOutboundAccessPriorityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dPortOutboundAccessPriorityTable(struct variable *vp,
                                         oid *name,
                                         size_t *length,
                                         int exact,
                                         size_t *var_len,
                                         WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dPortOutboundAccessPriorityTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dPortOutboundAccessPriorityTable(name, length, exact,
                                                        &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dPortOutboundAccessPriorityTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dPortOutboundAccessPriorityTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dPortOutboundAccessPriorityTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DPORTOUTBOUNDACCESSPRIORITY: {
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortOutboundAccessPriority;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dPortOutboundAccessPriorityTable\n",
                    vp->magic));
    }
    return NULL;
}

static int
getfirst_dot1dPortGarpTableEntry(dot1dPortGarpTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_dot1dPortGarpTableEntry(dot1dPortGarpTable_entry_t *table_entry,
                            BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
set_dot1dPortGarpTableEntry(dot1dPortGarpTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_dot1dPortGarpTable(oid *name,
                         size_t *length,
                         int exact,
                         dot1dPortGarpTable_entry_t *table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dPortGarpTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dPortGarpTable(oid *name,
                           size_t *length,
                           dot1dPortGarpTable_entry_t *table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dPortGarpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dPortGarpTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dPortGarpTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dPortGarpTable(name, length, exact,
                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dPortGarpTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dPortGarpTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dPortGarpTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DPORTGARPJOINTIME: {
        *write_method = write_dot1dPortGarpJoinTime;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortGarpJoinTime;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    case DOT1DPORTGARPLEAVETIME: {
        *write_method = write_dot1dPortGarpLeaveTime;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortGarpLeaveTime;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    case DOT1DPORTGARPLEAVEALLTIME: {
        *write_method = write_dot1dPortGarpLeaveAllTime;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortGarpLeaveAllTime;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dPortGarpTable\n",
                    vp->magic));
    }
    return NULL;
}

static int
getfirst_dot1dPortGmrpTableEntry(dot1dPortGmrpTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_dot1dPortGmrpTableEntry(dot1dPortGmrpTable_entry_t *table_entry,
                            BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
set_dot1dPortGmrpTableEntry(dot1dPortGmrpTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_dot1dPortGmrpTable(oid *name,
                         size_t *length,
                         int exact,
                         dot1dPortGmrpTable_entry_t *table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dPortGmrpTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dPortGmrpTable(oid *name,
                           size_t *length,
                           dot1dPortGmrpTable_entry_t *table_entry)
{
    int             name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dPortGmrpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_pBridgeMIB above.
 */
u_char         *
var_dot1dPortGmrpTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    dot1dPortGmrpTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_dot1dPortGmrpTable(name, length, exact,
                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_dot1dPortGmrpTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dPortGmrpTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dPortGmrpTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DPORTGMRPSTATUS: {
        *write_method = write_dot1dPortGmrpStatus;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortGmrpStatus;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    case DOT1DPORTGMRPFAILEDREGISTRATIONS: {
        pBridgeMIB_global_ret.ulong_ret =
            table_entry.dot1dPortGmrpFailedRegistrations;
        *var_len = sizeof(pBridgeMIB_global_ret.ulong_ret);
        return (u_char *) & pBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1DPORTGMRPLASTPDUORIGIN: {
        *var_len = 6;
        memcpy(pBridgeMIB_global_ret.string_ret,
               table_entry.dot1dPortGmrpLastPduOrigin, *var_len);
        return (u_char *) pBridgeMIB_global_ret.string_ret;
    }
    case DOT1DPORTRESTRICTEDGROUPREGISTRATION: {
        *write_method = write_dot1dPortRestrictedGroupRegistration;
        pBridgeMIB_global_ret.long_ret =
            table_entry.dot1dPortRestrictedGroupRegistration;
        *var_len = sizeof(pBridgeMIB_global_ret.long_ret);
        return (u_char *) & pBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot1dPortGmrpTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif

int
write_dot1dTrafficClassesEnabled(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dExtBase_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dTrafficClassesEnabled: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dTrafficClassesEnabled: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dTrafficClassesEnabled: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1dExtBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1dTrafficClassesEnabled = set_value;
        if (set_dot1dExtBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0
int
write_dot1dGmrpStatus(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dExtBase_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dGmrpStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dGmrpStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dGmrpStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1dExtBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1dGmrpStatus = set_value;
        if (set_dot1dExtBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot1dPortDefaultUserPriority(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortPriorityTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortDefaultUserPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortDefaultUserPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value > 7 || set_value < 0) {
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortPriorityTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortPriorityTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortDefaultUserPriority = set_value;
        if (set_dot1dPortPriorityTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0
int
write_dot1dPortNumTrafficClasses(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortPriorityTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortNumTrafficClasses: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortNumTrafficClasses: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortPriorityTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortPriorityTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortNumTrafficClasses = set_value;
        if (set_dot1dPortPriorityTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1dRegenUserPriority(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dUserPriorityRegenTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dRegenUserPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dRegenUserPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dUserPriorityRegenTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dUserPriorityRegenTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dRegenUserPriority = set_value;
        if (set_dot1dUserPriorityRegenTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot1dTrafficClass(int action,
                        u_char *var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dTrafficClassTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dTrafficClass: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dTrafficClass: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dTrafficClassTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dTrafficClassTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dTrafficClass = set_value;
        if (set_dot1dTrafficClassTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0
int
write_dot1dPortGarpJoinTime(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortGarpTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpJoinTime: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpJoinTime: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortGarpTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortGarpTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortGarpJoinTime = set_value;
        if (set_dot1dPortGarpTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1dPortGarpLeaveTime(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortGarpTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpLeaveTime: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpLeaveTime: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortGarpTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortGarpTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortGarpLeaveTime = set_value;
        if (set_dot1dPortGarpTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1dPortGarpLeaveAllTime(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP,
                                oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortGarpTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpLeaveAllTime: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGarpLeaveAllTime: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortGarpTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortGarpTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortGarpLeaveAllTime = set_value;
        if (set_dot1dPortGarpTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1dPortGmrpStatus(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortGmrpTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGmrpStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGmrpStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortGmrpStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortGmrpTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortGmrpTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortGmrpStatus = set_value;
        if (set_dot1dPortGmrpTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1dPortRestrictedGroupRegistration(int action,
                                           u_char *var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char *statP,
                                           oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    dot1dPortGmrpTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortRestrictedGroupRegistration: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortRestrictedGroupRegistration: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to dot1dPortRestrictedGroupRegistration: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1dPortGmrpTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1dPortGmrpTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1dPortRestrictedGroupRegistration = set_value;
        if (set_dot1dPortGmrpTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif
