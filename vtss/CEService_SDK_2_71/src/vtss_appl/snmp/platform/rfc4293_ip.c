/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
//#include <pkgconf/hal.h>
//#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "ifIndex_api.h"
#include "ip2_api.h"
#include "ip2_iterators.h"
#include "ip2_os_api.h"
#include "ip2_snmp.h"
#include "rfc4293_ip.h"
#include "inet_address.h"
#include "mibContextTable.h"  //mibContextTable_register

#define SNMP_ASN_OCTET_STR_MAX_LEN  256 /* FIXME : Re-define it if needed */

#ifdef VTSS_TRACE_MODULE_ID
#undef VTSS_TRACE_MODULE_ID
#endif

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP

/*
 * The entry data structure for ipAddressTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipAddressAddrType;
    char            ipAddressAddr[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t          ipAddressAddr_len;

    /*
     * Entry columns
     */
    long            ipAddressIfIndex;
    long            ipAddressType;
    oid             ipAddressPrefix[MAX_OID_LEN];
    size_t          ipAddressPrefix_len;
    long            ipAddressOrigin;
    long            ipAddressStatus;
    u_long          ipAddressCreated;
    u_long          ipAddressLastChanged;
    long            ipAddressRowStatus;
    long            ipAddressStorageType;
} ipAddressTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    char            string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid             objid_ret[MAX_OID_LEN];
    size_t          objid_len_ret;
    u_long          ulong_ret;
} ipAddressTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipAddressTable_global_ret)
                                                 *//*
                                                 * Process one packet at the same time, therefore unprotected access is acceptable
                                                 */
static ipAddressTable_return_t ipAddressTable_global_ret;       /* static variables for retuning */

/*
 * ipAddressTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ipAddressTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 4, 34 };



/*
 * variable ipAddressTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipAddressTable mib section
 */

struct variable2 ipAddressTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPADDRESSIFINDEX        1
    {IPADDRESSIFINDEX, ASN_INTEGER, RWRITE, var_ipAddressTable, 2, {1, 3}},
#define IPADDRESSTYPE       2
    {IPADDRESSTYPE, ASN_INTEGER, RWRITE, var_ipAddressTable, 2, {1, 4}},
#define IPADDRESSPREFIX     3
    {IPADDRESSPREFIX, ASN_OBJECT_ID, RONLY, var_ipAddressTable, 2, {1, 5}},
#if 0
#define IPADDRESSORIGIN     4
    {IPADDRESSORIGIN, ASN_INTEGER, RONLY, var_ipAddressTable, 2, {1, 6}},
#endif
#define IPADDRESSSTATUS     5
    {IPADDRESSSTATUS, ASN_INTEGER, RWRITE, var_ipAddressTable, 2, {1, 7}},
#define IPADDRESSCREATED        6
    {
        IPADDRESSCREATED, ASN_TIMETICKS, RONLY, var_ipAddressTable, 2,
        {1, 8}
    },
#define IPADDRESSLASTCHANGED        7
    {
        IPADDRESSLASTCHANGED, ASN_TIMETICKS, RONLY, var_ipAddressTable, 2,
        {1, 9}
    },
#define IPADDRESSROWSTATUS      8
    {
        IPADDRESSROWSTATUS, ASN_INTEGER, RWRITE, var_ipAddressTable, 2,
        {1, 10}
    },
#define IPADDRESSSTORAGETYPE        9
    {
        IPADDRESSSTORAGETYPE, ASN_INTEGER, RWRITE, var_ipAddressTable, 2,
        {1, 11}
    },
};

/*
 * Initializes the ipAddressTable module
 */
static void
init_ipAddressTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipAddressTable_variables_oid,
                             sizeof(ipAddressTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipAddressTable");

    DEBUGMSGTL(("ipAddressTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ipAddressTable", ipAddressTable_variables, variable2,
                 ipAddressTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL get_next_ipAddressTableEntryByKey(ipAddressTable_entry_t *table_entry)
{
    vtss_ip_addr_t      ip_addr;
    vtss_if_id_vlan_t   if_id;
    vtss_ipv4_t         n_v4_dst;
    iftable_info_t      table_info;
    ipAddressTable_entry_t tmp;
    u64  ipAddressCreated, ipAddressLastChanged;

    memcpy(&tmp, table_entry, sizeof(tmp));

    if (tmp.ipAddressAddrType > INET_ADDRESS_IPV6) {
        return FALSE;
    }

    switch (tmp.ipAddressAddrType) {
    case INET_ADDRESS_UNKNOWN:
        tmp.ipAddressAddrType = INET_ADDRESS_IPV4;
        tmp.ipAddressAddr_len = INET_ADDRESS_IPV4_LEN;
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    case INET_ADDRESS_IPV4:
        if (tmp.ipAddressAddr_len < INET_ADDRESS_IPV4_LEN) {
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV4_LEN;
        } else if (tmp.ipAddressAddr_len > INET_ADDRESS_IPV4_LEN) {
            tmp.ipAddressAddrType = INET_ADDRESS_IPV6;
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        } else {
            break;
        }
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    case INET_ADDRESS_IPV6:
        if (tmp.ipAddressAddr_len < INET_ADDRESS_IPV6_LEN) {
            tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        } else if (tmp.ipAddressAddr_len > INET_ADDRESS_IPV6_LEN) {
            return FALSE;
        } else {
            break;
        }
        memset(tmp.ipAddressAddr, 0, tmp.ipAddressAddr_len);
        break;
    default:
        break;
    }

    if (tmp.ipAddressAddrType == INET_ADDRESS_IPV6) {
        ip_addr.type = VTSS_IP_TYPE_IPV6;
        memcpy(&ip_addr.addr.ipv6, tmp.ipAddressAddr, INET_ADDRESS_IPV6_LEN);
    } else {
        ip_addr.type = VTSS_IP_TYPE_IPV4;
        memcpy(&n_v4_dst, tmp.ipAddressAddr, INET_ADDRESS_IPV4_LEN);
        ip_addr.addr.ipv4 = ntohl(n_v4_dst);
    }

    if ( FALSE == get_next_ip(&ip_addr, &if_id)) {
        return FALSE;
    }

    table_info.type = IFTABLE_IFINDEX_TYPE_IP;
    table_info.if_id = if_id;
    (void) ifIndex_get_by_interface(&table_info);

    if (ip_addr.type == VTSS_IP_TYPE_IPV4) {
        n_v4_dst = htonl (ip_addr.addr.ipv4);
        memcpy(tmp.ipAddressAddr, &n_v4_dst, INET_ADDRESS_IPV4_LEN);
        (void) vtss_ip2_address_created_ipv4( if_id, &ipAddressCreated);
        (void) vtss_ip2_address_changed_ipv4( if_id, &ipAddressLastChanged);
    } else {
        tmp.ipAddressAddrType = INET_ADDRESS_IPV6;
        tmp.ipAddressAddr_len = INET_ADDRESS_IPV6_LEN;
        memcpy(tmp.ipAddressAddr, &ip_addr.addr.ipv6, INET_ADDRESS_IPV6_LEN);
        (void) vtss_ip2_address_created_ipv6( if_id, &ipAddressCreated);
        (void) vtss_ip2_address_changed_ipv6( if_id, &ipAddressLastChanged);
    }

    tmp.ipAddressCreated = (u32) (ipAddressCreated * 100);
    tmp.ipAddressLastChanged = (u32) (ipAddressLastChanged * 100);
    tmp.ipAddressIfIndex = table_info.ifIndex;
    tmp.ipAddressType = 1;
    tmp.ipAddressPrefix_len = 2;
    memset(tmp.ipAddressPrefix, 0, tmp.ipAddressPrefix_len);
    tmp.ipAddressStatus = 1;

    tmp.ipAddressRowStatus = 1;
    tmp.ipAddressStorageType = 4;
    memcpy(table_entry, &tmp, sizeof(tmp));

    return TRUE;
}

static BOOL get_ipAddressTableEntryByKey(ipAddressTable_entry_t *table_entry)
{
    ipAddressTable_entry_t tmp;
    unsigned char *ptr =  (unsigned char *)tmp.ipAddressAddr;
    int i = 0;
    BOOL overflow = TRUE;

    memcpy(&tmp, table_entry, sizeof(tmp));

    if (tmp.ipAddressAddrType != INET_ADDRESS_IPV6 &&
        tmp.ipAddressAddrType != INET_ADDRESS_IPV4) {
        return FALSE;
    }

    switch (tmp.ipAddressAddrType) {
    case INET_ADDRESS_IPV4:
        if (tmp.ipAddressAddr_len != INET_ADDRESS_IPV4_LEN) {
            return FALSE;
        }
        break;
    case INET_ADDRESS_IPV6:
        if (tmp.ipAddressAddr_len != INET_ADDRESS_IPV6_LEN) {
            return FALSE;
        }
        break;
    default:
        break;
    }

    for (i = tmp.ipAddressAddr_len - 1, ptr = (unsigned char *)(tmp.ipAddressAddr + tmp.ipAddressAddr_len - 1) ; i >= 0; i--, ptr-- ) {
        if (*ptr != 0x0 ) {
            --*ptr;
            overflow = FALSE;
            break;
        } else {
            *ptr = 0xff;
        }
    }

    if (overflow == TRUE) {
        --tmp.ipAddressAddr_len;
    }

    for (i = 0, ptr = (unsigned char *)tmp.ipAddressAddr; i < (int)tmp.ipAddressAddr_len; i++, ptr++) {
        T_D("%d", *ptr);
    }
    if ( FALSE == get_next_ipAddressTableEntryByKey(&tmp) || (tmp.ipAddressAddrType != table_entry->ipAddressAddrType) ||
         tmp.ipAddressAddr_len != table_entry->ipAddressAddr_len ||
         memcmp(tmp.ipAddressAddr, table_entry->ipAddressAddr, table_entry->ipAddressAddr_len)) {
        return FALSE;
    }

    memcpy(table_entry, &tmp, sizeof(tmp));

    return TRUE;

}

static int
getfirst_ipAddressTableEntry(ipAddressTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipAddressTable_entry_t));
    if ( FALSE == get_next_ipAddressTableEntryByKey (table_entry)) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
get_ipAddressTableEntry(ipAddressTable_entry_t *table_entry, BOOL getnext)
{
//    ipAddressTable_entry_t tmp;
//    memcpy(&tmp, table_entry, sizeof(tmp));

    if ( (getnext == TRUE && FALSE == get_next_ipAddressTableEntryByKey(table_entry)) ||
         (getnext == FALSE && FALSE == get_ipAddressTableEntryByKey(table_entry))) {
        return -1;
    }

//    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
set_ipAddressTableEntry(ipAddressTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipAddressTable(oid *name,
                     size_t *length,
                     int exact, ipAddressTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);
    u_char         *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipAddressTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipAddressAddrType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->ipAddressAddr) ? sizeof(table_entry->ipAddressAddr) : len;
    op_pos++;
    table_entry->ipAddressAddr_len = len;
    cp = (u_char *) table_entry->ipAddressAddr;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipAddressTable(oid *name,
                       size_t *length,
                       ipAddressTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;
    int             len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipAddressAddrType;
    len = (int) table_entry->ipAddressAddr_len;
    name[name_pos++] = (oid) table_entry->ipAddressAddr_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] =
            (unsigned char) table_entry->ipAddressAddr[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_ipAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipAddressTable above.
 */
u_char         *
var_ipAddressTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipAddressTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipAddressTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipAddressTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipAddressTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IPADDRESSROWSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry.
                     */
                    *write_method = write_ipAddressRowStatus;
                }
                return NULL;
            }
            if (fillobj_ipAddressTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPADDRESSIFINDEX: {
        *write_method = write_ipAddressIfIndex;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressIfIndex;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSTYPE: {
        *write_method = write_ipAddressType;
        ipAddressTable_global_ret.long_ret = table_entry.ipAddressType;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSPREFIX: {
        memcpy(ipAddressTable_global_ret.objid_ret,
               table_entry.ipAddressPrefix,
               table_entry.ipAddressPrefix_len * sizeof(oid));
        *var_len = table_entry.ipAddressPrefix_len * sizeof(oid);
        return (u_char *) ipAddressTable_global_ret.objid_ret;
    }
#if 0
    case IPADDRESSORIGIN: {
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressOrigin;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
#endif
    case IPADDRESSSTATUS: {
        *write_method = write_ipAddressStatus;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressStatus;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSCREATED: {
        ipAddressTable_global_ret.ulong_ret =
            table_entry.ipAddressCreated;
        *var_len = sizeof(ipAddressTable_global_ret.ulong_ret);
        return (u_char *) & ipAddressTable_global_ret.ulong_ret;
    }
    case IPADDRESSLASTCHANGED: {
        ipAddressTable_global_ret.ulong_ret =
            table_entry.ipAddressLastChanged;
        *var_len = sizeof(ipAddressTable_global_ret.ulong_ret);
        return (u_char *) & ipAddressTable_global_ret.ulong_ret;
    }
    case IPADDRESSROWSTATUS: {
        *write_method = write_ipAddressRowStatus;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressRowStatus;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    case IPADDRESSSTORAGETYPE: {
        *write_method = write_ipAddressStorageType;
        ipAddressTable_global_ret.long_ret =
            table_entry.ipAddressStorageType;
        *var_len = sizeof(ipAddressTable_global_ret.long_ret);
        return (u_char *) & ipAddressTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipAddressTable\n",
                    vp->magic));
    }
    return NULL;
}

int
write_ipAddressIfIndex(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressIfIndex: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressIfIndex: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressIfIndex = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressType(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2 && set_value != 3) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressType = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressStatus(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6 && set_value != 7 && set_value != 8) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressStatus = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressRowStatus(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4 && set_value != 5 && set_value != 6) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /*
         * Return error code when the entry isn't existing
         * except for "createAndGo(4)" or "createAndWait(5)" status
         */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressRowStatus = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipAddressStorageType(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ipAddressTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3 && set_value != 4 && set_value != 5) {
            (void) snmp_log(LOG_ERR,
                            "write to ipAddressStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipAddressTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipAddressTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipAddressStorageType = set_value;
        if (set_ipAddressTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipIfStatsTableLastChange
 */
typedef struct {
    u_long          ipIfStatsTableLastChange;
} ipTrafficStats_scalar_t;

/*
 * The entry data structure for ipSystemStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipSystemStatsIPVersion;

    /*
     * Entry columns
     */
    u_long          ipSystemStatsInReceives;
    struct counter64 ipSystemStatsHCInReceives;
    u_long          ipSystemStatsInOctets;
    struct counter64 ipSystemStatsHCInOctets;
    u_long          ipSystemStatsInHdrErrors;
    u_long          ipSystemStatsInNoRoutes;
    u_long          ipSystemStatsInAddrErrors;
    u_long          ipSystemStatsInUnknownProtos;
    u_long          ipSystemStatsInTruncatedPkts;
    u_long          ipSystemStatsInForwDatagrams;
    struct counter64 ipSystemStatsHCInForwDatagrams;
    u_long          ipSystemStatsReasmReqds;
    u_long          ipSystemStatsReasmOKs;
    u_long          ipSystemStatsReasmFails;
    u_long          ipSystemStatsInDiscards;
    u_long          ipSystemStatsInDelivers;
    struct counter64 ipSystemStatsHCInDelivers;
    u_long          ipSystemStatsOutRequests;
    struct counter64 ipSystemStatsHCOutRequests;
    u_long          ipSystemStatsOutNoRoutes;
    u_long          ipSystemStatsOutForwDatagrams;
    struct counter64 ipSystemStatsHCOutForwDatagrams;
    u_long          ipSystemStatsOutDiscards;
    u_long          ipSystemStatsOutFragReqds;
    u_long          ipSystemStatsOutFragOKs;
    u_long          ipSystemStatsOutFragFails;
    u_long          ipSystemStatsOutFragCreates;
    u_long          ipSystemStatsOutTransmits;
    struct counter64 ipSystemStatsHCOutTransmits;
    u_long          ipSystemStatsOutOctets;
    struct counter64 ipSystemStatsHCOutOctets;
    u_long          ipSystemStatsInMcastPkts;
    struct counter64 ipSystemStatsHCInMcastPkts;
    u_long          ipSystemStatsInMcastOctets;
    struct counter64 ipSystemStatsHCInMcastOctets;
    u_long          ipSystemStatsOutMcastPkts;
    struct counter64 ipSystemStatsHCOutMcastPkts;
    u_long          ipSystemStatsOutMcastOctets;
    struct counter64 ipSystemStatsHCOutMcastOctets;
    u_long          ipSystemStatsInBcastPkts;
    struct counter64 ipSystemStatsHCInBcastPkts;
    u_long          ipSystemStatsOutBcastPkts;
    struct counter64 ipSystemStatsHCOutBcastPkts;
    u_long          ipSystemStatsDiscontinuityTime;
    u_long          ipSystemStatsRefreshRate;
} ipSystemStatsTable_entry_t;
/*
 * The entry data structure for ipIfStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ipIfStatsIPVersion;
    long            ipIfStatsIfIndex;

    /*
     * Entry columns
     */
    u_long          ipIfStatsInReceives;
    struct counter64 ipIfStatsHCInReceives;
    u_long          ipIfStatsInOctets;
    struct counter64 ipIfStatsHCInOctets;
    u_long          ipIfStatsInHdrErrors;
    u_long          ipIfStatsInNoRoutes;
    u_long          ipIfStatsInAddrErrors;
    u_long          ipIfStatsInUnknownProtos;
    u_long          ipIfStatsInTruncatedPkts;
    u_long          ipIfStatsInForwDatagrams;
    struct counter64 ipIfStatsHCInForwDatagrams;
    u_long          ipIfStatsReasmReqds;
    u_long          ipIfStatsReasmOKs;
    u_long          ipIfStatsReasmFails;
    u_long          ipIfStatsInDiscards;
    u_long          ipIfStatsInDelivers;
    struct counter64 ipIfStatsHCInDelivers;
    u_long          ipIfStatsOutRequests;
    struct counter64 ipIfStatsHCOutRequests;
    u_long          ipIfStatsOutForwDatagrams;
    struct counter64 ipIfStatsHCOutForwDatagrams;
    u_long          ipIfStatsOutDiscards;
    u_long          ipIfStatsOutFragReqds;
    u_long          ipIfStatsOutFragOKs;
    u_long          ipIfStatsOutFragFails;
    u_long          ipIfStatsOutFragCreates;
    u_long          ipIfStatsOutTransmits;
    struct counter64 ipIfStatsHCOutTransmits;
    u_long          ipIfStatsOutOctets;
    struct counter64 ipIfStatsHCOutOctets;
    u_long          ipIfStatsInMcastPkts;
    struct counter64 ipIfStatsHCInMcastPkts;
    u_long          ipIfStatsInMcastOctets;
    struct counter64 ipIfStatsHCInMcastOctets;
    u_long          ipIfStatsOutMcastPkts;
    struct counter64 ipIfStatsHCOutMcastPkts;
    u_long          ipIfStatsOutMcastOctets;
    struct counter64 ipIfStatsHCOutMcastOctets;
    u_long          ipIfStatsInBcastPkts;
    struct counter64 ipIfStatsHCInBcastPkts;
    u_long          ipIfStatsOutBcastPkts;
    struct counter64 ipIfStatsHCOutBcastPkts;
    u_long          ipIfStatsDiscontinuityTime;
    u_long          ipIfStatsRefreshRate;
} ipIfStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    struct counter64 c64_ret;
    u_long          ulong_ret;
} ipTrafficStats_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipTrafficStats_global_ret)
                                                 *//*
                                                 * Process one packet at the same time, therefore unprotected access is acceptable
                                                 */
static ipTrafficStats_return_t ipTrafficStats_global_ret;       /* static variables for retuning */

/*
 * ipTrafficStats_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ipTrafficStats_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 4, 31 };



/*
 * variable ipTrafficStats_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipTrafficStats mib section
 */

struct variable4 ipTrafficStats_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define IPSYSTEMSTATSINRECEIVES     2
    {
        IPSYSTEMSTATSINRECEIVES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 3}
    },
#define IPSYSTEMSTATSHCINRECEIVES       3
    {
        IPSYSTEMSTATSHCINRECEIVES, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 4}
    },
#define IPSYSTEMSTATSINOCTETS       4
    {
        IPSYSTEMSTATSINOCTETS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 5}
    },
#define IPSYSTEMSTATSHCINOCTETS     5
    {
        IPSYSTEMSTATSHCINOCTETS, ASN_COUNTER64, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 6}
    },
#define IPSYSTEMSTATSINHDRERRORS        6
    {
        IPSYSTEMSTATSINHDRERRORS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 7}
    },
#define IPSYSTEMSTATSINNOROUTES     7
    {
        IPSYSTEMSTATSINNOROUTES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 8}
    },
#define IPSYSTEMSTATSINADDRERRORS       8
    {
        IPSYSTEMSTATSINADDRERRORS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 9}
    },
#define IPSYSTEMSTATSINUNKNOWNPROTOS        9
    {
        IPSYSTEMSTATSINUNKNOWNPROTOS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 10}
    },
#define IPSYSTEMSTATSINTRUNCATEDPKTS        10
    {
        IPSYSTEMSTATSINTRUNCATEDPKTS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 11}
    },
#define IPSYSTEMSTATSINFORWDATAGRAMS        11
    {
        IPSYSTEMSTATSINFORWDATAGRAMS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 12}
    },
#define IPSYSTEMSTATSHCINFORWDATAGRAMS      12
    {
        IPSYSTEMSTATSHCINFORWDATAGRAMS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 13}
    },
#define IPSYSTEMSTATSREASMREQDS     13
    {
        IPSYSTEMSTATSREASMREQDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 14}
    },
#define IPSYSTEMSTATSREASMOKS       14
    {
        IPSYSTEMSTATSREASMOKS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 15}
    },
#define IPSYSTEMSTATSREASMFAILS     15
    {
        IPSYSTEMSTATSREASMFAILS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 16}
    },
#define IPSYSTEMSTATSINDISCARDS     16
    {
        IPSYSTEMSTATSINDISCARDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 17}
    },
#define IPSYSTEMSTATSINDELIVERS     17
    {
        IPSYSTEMSTATSINDELIVERS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 18}
    },
#define IPSYSTEMSTATSHCINDELIVERS       18
    {
        IPSYSTEMSTATSHCINDELIVERS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 19}
    },
#define IPSYSTEMSTATSOUTREQUESTS        19
    {
        IPSYSTEMSTATSOUTREQUESTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 20}
    },
#define IPSYSTEMSTATSHCOUTREQUESTS      20
    {
        IPSYSTEMSTATSHCOUTREQUESTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 21}
    },
#define IPSYSTEMSTATSOUTNOROUTES        21
    {
        IPSYSTEMSTATSOUTNOROUTES, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 22}
    },
#define IPSYSTEMSTATSOUTFORWDATAGRAMS       22
    {
        IPSYSTEMSTATSOUTFORWDATAGRAMS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 23}
    },
#define IPSYSTEMSTATSHCOUTFORWDATAGRAMS     23
    {
        IPSYSTEMSTATSHCOUTFORWDATAGRAMS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 24}
    },
#define IPSYSTEMSTATSOUTDISCARDS        24
    {
        IPSYSTEMSTATSOUTDISCARDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 25}
    },
#define IPSYSTEMSTATSOUTFRAGREQDS       25
    {
        IPSYSTEMSTATSOUTFRAGREQDS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 26}
    },
#define IPSYSTEMSTATSOUTFRAGOKS     26
    {
        IPSYSTEMSTATSOUTFRAGOKS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 27}
    },
#define IPSYSTEMSTATSOUTFRAGFAILS       27
    {
        IPSYSTEMSTATSOUTFRAGFAILS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 28}
    },
#define IPSYSTEMSTATSOUTFRAGCREATES     28
    {
        IPSYSTEMSTATSOUTFRAGCREATES, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 29}
    },
#define IPSYSTEMSTATSOUTTRANSMITS       29
    {
        IPSYSTEMSTATSOUTTRANSMITS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 30}
    },
#define IPSYSTEMSTATSHCOUTTRANSMITS     30
    {
        IPSYSTEMSTATSHCOUTTRANSMITS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 31}
    },
#define IPSYSTEMSTATSOUTOCTETS      31
    {
        IPSYSTEMSTATSOUTOCTETS, ASN_COUNTER, RONLY, var_ipSystemStatsTable, 3,
        {1, 1, 32}
    },
#define IPSYSTEMSTATSHCOUTOCTETS        32
    {
        IPSYSTEMSTATSHCOUTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 33}
    },
#define IPSYSTEMSTATSINMCASTPKTS        33
    {
        IPSYSTEMSTATSINMCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 34}
    },
#define IPSYSTEMSTATSHCINMCASTPKTS      34
    {
        IPSYSTEMSTATSHCINMCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 35}
    },
#define IPSYSTEMSTATSINMCASTOCTETS      35
    {
        IPSYSTEMSTATSINMCASTOCTETS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 36}
    },
#define IPSYSTEMSTATSHCINMCASTOCTETS        36
    {
        IPSYSTEMSTATSHCINMCASTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 37}
    },
#define IPSYSTEMSTATSOUTMCASTPKTS       37
    {
        IPSYSTEMSTATSOUTMCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 38}
    },
#define IPSYSTEMSTATSHCOUTMCASTPKTS     38
    {
        IPSYSTEMSTATSHCOUTMCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 39}
    },
#define IPSYSTEMSTATSOUTMCASTOCTETS     39
    {
        IPSYSTEMSTATSOUTMCASTOCTETS, ASN_COUNTER, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 40}
    },
#define IPSYSTEMSTATSHCOUTMCASTOCTETS       40
    {
        IPSYSTEMSTATSHCOUTMCASTOCTETS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 41}
    },
#define IPSYSTEMSTATSINBCASTPKTS        41
    {
        IPSYSTEMSTATSINBCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 42}
    },
#define IPSYSTEMSTATSHCINBCASTPKTS      42
    {
        IPSYSTEMSTATSHCINBCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 43}
    },
#define IPSYSTEMSTATSOUTBCASTPKTS       43
    {
        IPSYSTEMSTATSOUTBCASTPKTS, ASN_COUNTER, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 44}
    },
#define IPSYSTEMSTATSHCOUTBCASTPKTS     44
    {
        IPSYSTEMSTATSHCOUTBCASTPKTS, ASN_COUNTER64, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 45}
    },
#define IPSYSTEMSTATSDISCONTINUITYTIME      45
    {
        IPSYSTEMSTATSDISCONTINUITYTIME, ASN_TIMETICKS, RONLY,
        var_ipSystemStatsTable, 3, {1, 1, 46}
    },
#define IPSYSTEMSTATSREFRESHRATE        46
    {
        IPSYSTEMSTATSREFRESHRATE, ASN_UNSIGNED, RONLY, var_ipSystemStatsTable,
        3, {1, 1, 47}
    },
#define IPIFSTATSTABLELASTCHANGE        1
    {
        IPIFSTATSTABLELASTCHANGE, ASN_TIMETICKS, RONLY, var_ipTrafficStats, 1,
        {2}
    },
#define IPIFSTATSINRECEIVES     47
    {
        IPIFSTATSINRECEIVES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 3}
    },
#define IPIFSTATSHCINRECEIVES       48
    {
        IPIFSTATSHCINRECEIVES, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 4}
    },
#define IPIFSTATSINOCTETS       49
    {
        IPIFSTATSINOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 5}
    },
#define IPIFSTATSHCINOCTETS     50
    {
        IPIFSTATSHCINOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 6}
    },
#define IPIFSTATSINHDRERRORS        51
    {
        IPIFSTATSINHDRERRORS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 7}
    },
#define IPIFSTATSINNOROUTES     52
    {
        IPIFSTATSINNOROUTES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 8}
    },
#define IPIFSTATSINADDRERRORS       53
    {
        IPIFSTATSINADDRERRORS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 9}
    },
#define IPIFSTATSINUNKNOWNPROTOS        54
    {
        IPIFSTATSINUNKNOWNPROTOS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 10}
    },
#define IPIFSTATSINTRUNCATEDPKTS        55
    {
        IPIFSTATSINTRUNCATEDPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 11}
    },
#define IPIFSTATSINFORWDATAGRAMS        56
    {
        IPIFSTATSINFORWDATAGRAMS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 12}
    },
#define IPIFSTATSHCINFORWDATAGRAMS      57
    {
        IPIFSTATSHCINFORWDATAGRAMS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 13}
    },
#define IPIFSTATSREASMREQDS     58
    {
        IPIFSTATSREASMREQDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 14}
    },
#define IPIFSTATSREASMOKS       59
    {
        IPIFSTATSREASMOKS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 15}
    },
#define IPIFSTATSREASMFAILS     60
    {
        IPIFSTATSREASMFAILS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 16}
    },
#define IPIFSTATSINDISCARDS     61
    {
        IPIFSTATSINDISCARDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 17}
    },
#define IPIFSTATSINDELIVERS     62
    {
        IPIFSTATSINDELIVERS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 18}
    },
#define IPIFSTATSHCINDELIVERS       63
    {
        IPIFSTATSHCINDELIVERS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 19}
    },
#define IPIFSTATSOUTREQUESTS        64
    {
        IPIFSTATSOUTREQUESTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 20}
    },
#define IPIFSTATSHCOUTREQUESTS      65
    {
        IPIFSTATSHCOUTREQUESTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 21}
    },
#define IPIFSTATSOUTFORWDATAGRAMS       66
    {
        IPIFSTATSOUTFORWDATAGRAMS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 23}
    },
#define IPIFSTATSHCOUTFORWDATAGRAMS     67
    {
        IPIFSTATSHCOUTFORWDATAGRAMS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 24}
    },
#define IPIFSTATSOUTDISCARDS        68
    {
        IPIFSTATSOUTDISCARDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 25}
    },
#define IPIFSTATSOUTFRAGREQDS       69
    {
        IPIFSTATSOUTFRAGREQDS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 26}
    },
#define IPIFSTATSOUTFRAGOKS     70
    {
        IPIFSTATSOUTFRAGOKS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 27}
    },
#define IPIFSTATSOUTFRAGFAILS       71
    {
        IPIFSTATSOUTFRAGFAILS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 28}
    },
#define IPIFSTATSOUTFRAGCREATES     72
    {
        IPIFSTATSOUTFRAGCREATES, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 29}
    },
#define IPIFSTATSOUTTRANSMITS       73
    {
        IPIFSTATSOUTTRANSMITS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 30}
    },
#define IPIFSTATSHCOUTTRANSMITS     74
    {
        IPIFSTATSHCOUTTRANSMITS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 31}
    },
#define IPIFSTATSOUTOCTETS      75
    {
        IPIFSTATSOUTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 32}
    },
#define IPIFSTATSHCOUTOCTETS        76
    {
        IPIFSTATSHCOUTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 33}
    },
#define IPIFSTATSINMCASTPKTS        77
    {
        IPIFSTATSINMCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 34}
    },
#define IPIFSTATSHCINMCASTPKTS      78
    {
        IPIFSTATSHCINMCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 35}
    },
#define IPIFSTATSINMCASTOCTETS      79
    {
        IPIFSTATSINMCASTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 36}
    },
#define IPIFSTATSHCINMCASTOCTETS        80
    {
        IPIFSTATSHCINMCASTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 37}
    },
#define IPIFSTATSOUTMCASTPKTS       81
    {
        IPIFSTATSOUTMCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 38}
    },
#define IPIFSTATSHCOUTMCASTPKTS     82
    {
        IPIFSTATSHCOUTMCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 39}
    },
#define IPIFSTATSOUTMCASTOCTETS     83
    {
        IPIFSTATSOUTMCASTOCTETS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 40}
    },
#define IPIFSTATSHCOUTMCASTOCTETS       84
    {
        IPIFSTATSHCOUTMCASTOCTETS, ASN_COUNTER64, RONLY, var_ipIfStatsTable,
        3, {3, 1, 41}
    },
#define IPIFSTATSINBCASTPKTS        85
    {
        IPIFSTATSINBCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 42}
    },
#define IPIFSTATSHCINBCASTPKTS      86
    {
        IPIFSTATSHCINBCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 43}
    },
#define IPIFSTATSOUTBCASTPKTS       87
    {
        IPIFSTATSOUTBCASTPKTS, ASN_COUNTER, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 44}
    },
#define IPIFSTATSHCOUTBCASTPKTS     88
    {
        IPIFSTATSHCOUTBCASTPKTS, ASN_COUNTER64, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 45}
    },
#define IPIFSTATSDISCONTINUITYTIME      89
    {
        IPIFSTATSDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_ipIfStatsTable,
        3, {3, 1, 46}
    },
#define IPIFSTATSREFRESHRATE        90
    {
        IPIFSTATSREFRESHRATE, ASN_UNSIGNED, RONLY, var_ipIfStatsTable, 3,
        {3, 1, 47}
    },
};

/*
 * Initializes the ipTrafficStats module
 */
static void
init_ipTrafficStats(void)
{
    // Register mibContextTable
    mibContextTable_register(ipTrafficStats_variables_oid,
                             sizeof(ipTrafficStats_variables_oid) / sizeof(oid),
                             "IP-MIB : ipTrafficStats");

    DEBUGMSGTL(("ipTrafficStats", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ipTrafficStats", ipTrafficStats_variables, variable4,
                 ipTrafficStats_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


static int
get_ipTrafficStatsScalar(ipTrafficStats_scalar_t *scalar_entry)
{
    u64 ipIfStatsTableLastChange;
    (void) vtss_ip2_interfaces_last_change (&ipIfStatsTableLastChange);
    scalar_entry->ipIfStatsTableLastChange = (u32) (ipIfStatsTableLastChange * 100);
    return VTSS_RC_OK;
}

/*
 * var_ipTrafficStats():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_ipTrafficStats(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    ipTrafficStats_scalar_t ipTrafficStats_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }

    if (get_ipTrafficStatsScalar(&ipTrafficStats_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPIFSTATSTABLELASTCHANGE: {
        ipTrafficStats_global_ret.ulong_ret =
            ipTrafficStats_scalar_entry.ipIfStatsTableLastChange;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipTrafficStats\n",
                    vp->magic));
    }
    return NULL;
}

#define VTSS_HC_2_SNMP_HC(VTSS_HC, SNMP_HC, HC, _PREFIX_) \
{\
    (SNMP_HC)->_PREFIX_##HC.low =  (VTSS_HC)->HC & 0xffffffff;\
    (SNMP_HC)->_PREFIX_##HC.high = (VTSS_HC)->HC >> 32;\
}

#define VTSS_C_2_SNMP_C(VTSS_C, SNMP_C, C, _PREFIX_) \
{\
    (SNMP_C)->_PREFIX_##C = (VTSS_C)->C;\
}

#define VTSS_TS_2_SNMP_TS(VTSS_TS, SNMP_TS, TS, _PREFIX_) \
{\
    (SNMP_TS)->_PREFIX_##TS = (VTSS_TS)->TS.seconds* 100 + (VTSS_TS)->TS.nanoseconds* 10000;\
}

static void vtss_ip_stat_system2ipSystemStats(vtss_ip_stat_data_t *entry, ipSystemStatsTable_entry_t *table_entry)
{
    VTSS_C_2_SNMP_C(entry, table_entry, InReceives, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InHdrErrors, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InNoRoutes, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InAddrErrors, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InUnknownProtos, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InTruncatedPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InForwDatagrams, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmReqds, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmOKs, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, ReasmFails, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InDiscards, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InDelivers, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutRequests, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutNoRoutes, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutForwDatagrams, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutDiscards, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragReqds, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragOKs, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragFails, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutFragCreates, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutTransmits, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InMcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InMcastOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutMcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutMcastOctets, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, InBcastPkts, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, OutBcastPkts, ipSystemStats);
    VTSS_TS_2_SNMP_TS(entry, table_entry, DiscontinuityTime, ipSystemStats);
    VTSS_C_2_SNMP_C(entry, table_entry, RefreshRate, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInReceives, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInForwDatagrams, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInDelivers, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutRequests, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutForwDatagrams, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutTransmits, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInMcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInMcastOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutMcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutMcastOctets, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCInBcastPkts, ipSystemStats);
    VTSS_HC_2_SNMP_HC(entry, table_entry, HCOutBcastPkts, ipSystemStats);
}

static int
getfirst_ipSystemStatsTableEntry(ipSystemStatsTable_entry_t *table_entry)
{
    vtss_ips_ip_stat_t      entry;
    vtss_ip_stat_data_t     *data = &entry.data;
    vtss_ip_type_t          version = VTSS_IP_TYPE_NONE;

    if ( VTSS_OK != vtss_ip2_cntr_syst_stat_iter_first( &version, &entry ) ) {
        return VTSS_RC_ERROR;
    }
    vtss_ip_stat_system2ipSystemStats(data, table_entry);
    table_entry->ipSystemStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                          entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;

    return VTSS_RC_OK;
}

static int
get_ipSystemStatsTableEntry(ipSystemStatsTable_entry_t *table_entry,
                            BOOL getnext)
{
    vtss_ips_ip_stat_t      entry;
    vtss_ip_stat_data_t     *data = &entry.data;
    vtss_ip_type_t          version;

    version = table_entry->ipSystemStatsIPVersion == INET_VERSION_UNKNOWN ? VTSS_IP_TYPE_NONE :
              table_entry->ipSystemStatsIPVersion == INET_VERSION_IPV4 ? VTSS_IP_TYPE_IPV4 : VTSS_IP_TYPE_IPV6;
    if ( (TRUE == getnext && VTSS_OK != vtss_ip2_cntr_syst_stat_iter_next( &version, &entry ))  ||
         (FALSE == getnext && VTSS_OK != vtss_ip2_cntr_syst_stat_iter_get( &version, &entry )) ) {
        return VTSS_RC_ERROR;
    }

    if (TRUE == getnext) {
        table_entry->ipSystemStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                              entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;
    }
    vtss_ip_stat_system2ipSystemStats(data, table_entry);
    return VTSS_RC_OK;
}

static int
parse_ipSystemStatsTable(oid *name,
                         size_t *length,
                         int exact,
                         ipSystemStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipSystemStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipSystemStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipSystemStatsTable(oid *name,
                           size_t *length,
                           ipSystemStatsTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ipSystemStatsIPVersion;

    *length = name_pos;
    return 0;
}

/*
 * var_ipSystemStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipTrafficStats above.
 */
u_char         *
var_ipSystemStatsTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipSystemStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_ipSystemStatsTable(name, length, exact,
                                      &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipSystemStatsTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipSystemStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipSystemStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPSYSTEMSTATSINRECEIVES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINRECEIVES: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINHDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInHdrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINADDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInAddrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINUNKNOWNPROTOS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInUnknownProtos;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINTRUNCATEDPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInTruncatedPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSREASMREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREASMOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREASMFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsReasmFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSINDELIVERS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINDELIVERS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTREQUESTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTREQUESTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTFRAGCREATES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutFragCreates;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSOUTTRANSMITS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTTRANSMITS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSINBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCINBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSOUTBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSHCOUTBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipSystemStatsHCOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPSYSTEMSTATSDISCONTINUITYTIME: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsDiscontinuityTime;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPSYSTEMSTATSREFRESHRATE: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipSystemStatsRefreshRate;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ipSystemStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

static void vtss_ip_stat_interface2ipIfStats(vtss_ip_stat_data_t *data, ipIfStatsTable_entry_t *table_entry)
{
    VTSS_C_2_SNMP_C(data, table_entry, InReceives, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InHdrErrors, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InNoRoutes, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InAddrErrors, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InUnknownProtos, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InTruncatedPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InForwDatagrams, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmReqds, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmOKs, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, ReasmFails, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InDiscards, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InDelivers, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutRequests, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutForwDatagrams, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutDiscards, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragReqds, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragOKs, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragFails, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutFragCreates, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutTransmits, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InMcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InMcastOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutMcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutMcastOctets, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, InBcastPkts, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutBcastPkts, ipIfStats);
    VTSS_TS_2_SNMP_TS(data, table_entry, DiscontinuityTime, ipIfStats);
    VTSS_C_2_SNMP_C(data, table_entry, RefreshRate, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInReceives, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInForwDatagrams, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInDelivers, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutRequests, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutForwDatagrams, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutTransmits, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInMcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInMcastOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutMcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutMcastOctets, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCInBcastPkts, ipIfStats);
    VTSS_HC_2_SNMP_HC(data, table_entry, HCOutBcastPkts, ipIfStats);
}

static int
getfirst_ipIfStatsTableEntry(ipIfStatsTable_entry_t *table_entry)
{
    vtss_if_status_ip_stat_t        entry;
    vtss_ip_stat_data_t             *data = &entry.data;
    iftable_info_t                  info;
    vtss_ip_type_t                  version = VTSS_IP_TYPE_NONE;
    vtss_if_id_vlan_t               vidx = 0;

    if ( VTSS_OK != vtss_ip2_cntr_intf_stat_iter_first( &version, &vidx, &entry)) {
        return VTSS_RC_ERROR;
    }

    table_entry->ipIfStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                      entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;

    info.if_id = entry.IfIndex.u.vlan;
    info.type = IFTABLE_IFINDEX_TYPE_IP;
    (void) ifIndex_get_by_interface( &info );
    table_entry->ipIfStatsIfIndex = info.ifIndex;
    vtss_ip_stat_interface2ipIfStats(data, table_entry);
    return VTSS_RC_OK;
}

static BOOL get_next_ipIfStatsTableEntryByKey(ipIfStatsTable_entry_t *table_entry)
{
    vtss_if_status_ip_stat_t    entry;
    vtss_ip_stat_data_t         *data = &entry.data;
    iftable_info_t              info;
    ipIfStatsTable_entry_t      tmp = *table_entry;
    vtss_ip_type_t              version = VTSS_IP_TYPE_NONE;
    vtss_if_id_vlan_t           vidx = 0;

    version = tmp.ipIfStatsIPVersion == INET_VERSION_UNKNOWN ? VTSS_IP_TYPE_NONE :
              tmp.ipIfStatsIPVersion == INET_VERSION_IPV4 ? VTSS_IP_TYPE_IPV4 : VTSS_IP_TYPE_IPV6;

    info.type = IFTABLE_IFINDEX_TYPE_IP;
    (void) ifIndex_get_first_by_type( &info );


    if ((u32)tmp.ipIfStatsIfIndex < info.ifIndex && VTSS_OK != vtss_ip2_cntr_intf_stat_iter_next( &version, &vidx, &entry)) {
        return FALSE;
    } else if ((u32)tmp.ipIfStatsIfIndex >= info.ifIndex) {
        info.ifIndex = tmp.ipIfStatsIfIndex;
        if ( FALSE == ifIndex_get_valid(&info) || info.type != IFTABLE_IFINDEX_TYPE_IP) {
            return FALSE;
        }
        vidx = info.if_id;
        if (VTSS_OK != vtss_ip2_cntr_intf_stat_iter_next( &version, &vidx, &entry )) {
            return FALSE;
        }
    }

    tmp.ipIfStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                             entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;

    info.if_id = entry.IfIndex.u.vlan;
    info.type = IFTABLE_IFINDEX_TYPE_IP;
    (void) ifIndex_get_by_interface( &info );
    tmp.ipIfStatsIfIndex = info.ifIndex;
    vtss_ip_stat_interface2ipIfStats(data, &tmp);
    *table_entry = tmp;
    return TRUE;
}

static BOOL get_ipIfStatsTableEntryByKey(ipIfStatsTable_entry_t *table_entry)
{
    ipIfStatsTable_entry_t  tmp = *table_entry;

    if (tmp.ipIfStatsIfIndex > 0) {
        --tmp.ipIfStatsIfIndex;
    } else if (tmp.ipIfStatsIPVersion > 0) {
        --tmp.ipIfStatsIPVersion;
        tmp.ipIfStatsIfIndex = 0x7fffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == get_next_ipIfStatsTableEntryByKey (&tmp) ||
         table_entry->ipIfStatsIPVersion != tmp.ipIfStatsIPVersion ||
         table_entry->ipIfStatsIfIndex != tmp.ipIfStatsIfIndex) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}


static int
get_ipIfStatsTableEntry(ipIfStatsTable_entry_t *table_entry, BOOL getnext)
{
    if ( (TRUE == getnext && FALSE == get_next_ipIfStatsTableEntryByKey(table_entry))  ||
         (FALSE == getnext && FALSE == get_ipIfStatsTableEntryByKey(table_entry)) ) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
parse_ipIfStatsTable(oid *name,
                     size_t *length,
                     int exact, ipIfStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipIfStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipIfStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ipIfStatsIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipIfStatsTable(oid *name,
                       size_t *length,
                       ipIfStatsTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ipIfStatsIPVersion;
    name[name_pos++] = (oid) table_entry->ipIfStatsIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipIfStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipTrafficStats above.
 */
u_char         *
var_ipIfStatsTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ipIfStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipIfStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ipIfStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipIfStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipIfStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPIFSTATSINRECEIVES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINRECEIVES: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInReceives;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINHDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInHdrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINNOROUTES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInNoRoutes;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINADDRERRORS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInAddrErrors;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINUNKNOWNPROTOS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInUnknownProtos;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINTRUNCATEDPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInTruncatedPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSREASMREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREASMOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREASMFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsReasmFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSINDELIVERS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINDELIVERS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInDelivers;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTREQUESTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTREQUESTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutRequests;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTFORWDATAGRAMS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutForwDatagrams;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTDISCARDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutDiscards;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGREQDS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragReqds;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGOKS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragOKs;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGFAILS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragFails;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTFRAGCREATES: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutFragCreates;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSOUTTRANSMITS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTTRANSMITS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutTransmits;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTMCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTMCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutMcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTMCASTOCTETS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutMcastOctets;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSINBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCINBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCInBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSOUTBCASTPKTS: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSHCOUTBCASTPKTS: {
        ipTrafficStats_global_ret.c64_ret =
            table_entry.ipIfStatsHCOutBcastPkts;
        *var_len = sizeof(ipTrafficStats_global_ret.c64_ret);
        return (u_char *) & ipTrafficStats_global_ret.c64_ret;
    }
    case IPIFSTATSDISCONTINUITYTIME: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsDiscontinuityTime;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    case IPIFSTATSREFRESHRATE: {
        ipTrafficStats_global_ret.ulong_ret =
            table_entry.ipIfStatsRefreshRate;
        *var_len = sizeof(ipTrafficStats_global_ret.ulong_ret);
        return (u_char *) & ipTrafficStats_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipIfStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for icmpStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            icmpStatsIPVersion;

    /*
     * Entry columns
     */
    u_long          icmpStatsInMsgs;
    u_long          icmpStatsInErrors;
    u_long          icmpStatsOutMsgs;
    u_long          icmpStatsOutErrors;
} icmpStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    u_long          ulong_ret;
} icmpStatsTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, icmpStatsTable_global_ret)
                                                 *//*
                                                 * Process one packet at the same time, therefore unprotected access is acceptable
                                                 */
static icmpStatsTable_return_t icmpStatsTable_global_ret;       /* static variables for retuning */

/*
 * icmpStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             icmpStatsTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 5, 29 };



/*
 * variable icmpStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the icmpStatsTable mib section
 */

struct variable2 icmpStatsTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define ICMPSTATSINMSGS     1
    {ICMPSTATSINMSGS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 2}},
#define ICMPSTATSINERRORS       2
    {ICMPSTATSINERRORS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 3}},
#define ICMPSTATSOUTMSGS        3
    {ICMPSTATSOUTMSGS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2, {1, 4}},
#define ICMPSTATSOUTERRORS      4
    {
        ICMPSTATSOUTERRORS, ASN_COUNTER, RONLY, var_icmpStatsTable, 2,
        {1, 5}
    },
};

/*
 * Initializes the icmpStatsTable module
 */
static void
init_icmpStatsTable(void)
{
    // Register mibContextTable
    mibContextTable_register(icmpStatsTable_variables_oid,
                             sizeof(icmpStatsTable_variables_oid) / sizeof(oid),
                             "IP-MIB : icmpStatsTable");

    DEBUGMSGTL(("icmpStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("icmpStatsTable", icmpStatsTable_variables, variable2,
                 icmpStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static void vtss_ip_stat_icmp2icmpStats(vtss_icmp_stat_data_t *data, icmpStatsTable_entry_t *table_entry)
{
    VTSS_C_2_SNMP_C(data, table_entry, InMsgs, icmpStats);
    VTSS_C_2_SNMP_C(data, table_entry, InErrors, icmpStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutMsgs, icmpStats);
    VTSS_C_2_SNMP_C(data, table_entry, OutErrors, icmpStats);
}

static int
getfirst_icmpStatsTableEntry(icmpStatsTable_entry_t *table_entry)
{
    vtss_ips_icmp_stat_t    entry;
    vtss_icmp_stat_data_t   *data = &entry.data;
    vtss_ip_type_t          version = VTSS_IP_TYPE_NONE;

    if (VTSS_OK != vtss_ip2_cntr_icmp_ver_iter_first( &version, &entry )) {
        return VTSS_RC_ERROR;
    }

    table_entry->icmpStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                      entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;
    vtss_ip_stat_icmp2icmpStats(data, table_entry);
    return VTSS_RC_OK;
}

static int
get_icmpStatsTableEntry(icmpStatsTable_entry_t *table_entry, BOOL getnext)
{
    vtss_ips_icmp_stat_t    entry;
    vtss_icmp_stat_data_t   *data = &entry.data;
    vtss_ip_type_t          version;

    if ( TRUE != getnext && FALSE != getnext) {
        return VTSS_RC_ERROR;
    }
    version = table_entry->icmpStatsIPVersion == INET_VERSION_UNKNOWN ? VTSS_IP_TYPE_NONE :
              table_entry->icmpStatsIPVersion == INET_VERSION_IPV4 ? VTSS_IP_TYPE_IPV4 : VTSS_IP_TYPE_IPV6;

    if ( (TRUE == getnext &&  VTSS_OK != vtss_ip2_cntr_icmp_ver_iter_next ( &version, &entry )) ||
         (FALSE == getnext &&  VTSS_OK != vtss_ip2_cntr_icmp_ver_iter_get ( &version, &entry )) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->icmpStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                      entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;
    vtss_ip_stat_icmp2icmpStats(data, table_entry);
    return VTSS_RC_OK;
}

static int
parse_icmpStatsTable(oid *name,
                     size_t *length,
                     int exact, icmpStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_icmpStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->icmpStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_icmpStatsTable(oid *name,
                       size_t *length,
                       icmpStatsTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->icmpStatsIPVersion;

    *length = name_pos;
    return 0;
}

/*
 * var_icmpStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_icmpStatsTable above.
 */
u_char         *
var_icmpStatsTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    icmpStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_icmpStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_icmpStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_icmpStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_icmpStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ICMPSTATSINMSGS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsInMsgs;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSINERRORS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsInErrors;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSOUTMSGS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsOutMsgs;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    case ICMPSTATSOUTERRORS: {
        icmpStatsTable_global_ret.ulong_ret =
            table_entry.icmpStatsOutErrors;
        *var_len = sizeof(icmpStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpStatsTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_icmpStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for icmpMsgStatsTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            icmpMsgStatsIPVersion;
    long            icmpMsgStatsType;

    /*
     * Entry columns
     */
    u_long          icmpMsgStatsInPkts;
    u_long          icmpMsgStatsOutPkts;
} icmpMsgStatsTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    u_long          ulong_ret;
} icmpMsgStatsTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, icmpMsgStatsTable_global_ret)
                                                    *//*
                                                    * Process one packet at the same time, therefore unprotected access is acceptable
                                                    */
static icmpMsgStatsTable_return_t icmpMsgStatsTable_global_ret; /* static variables for retuning */

/*
 * icmpMsgStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             icmpMsgStatsTable_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 5, 30 };



/*
 * variable icmpMsgStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the icmpMsgStatsTable mib section
 */

struct variable2 icmpMsgStatsTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define ICMPMSGSTATSINPKTS      1
    {
        ICMPMSGSTATSINPKTS, ASN_COUNTER, RONLY, var_icmpMsgStatsTable, 2,
        {1, 3}
    },
#define ICMPMSGSTATSOUTPKTS     2
    {
        ICMPMSGSTATSOUTPKTS, ASN_COUNTER, RONLY, var_icmpMsgStatsTable, 2,
        {1, 4}
    },
};

/*
 * Initializes the icmpMsgStatsTable module
 */
static void
init_icmpMsgStatsTable(void)
{
    // Register mibContextTable
    mibContextTable_register(icmpMsgStatsTable_variables_oid,
                             sizeof(icmpMsgStatsTable_variables_oid) / sizeof(oid),
                             "IP-MIB : icmpMsgStatsTable");

    DEBUGMSGTL(("icmpMsgStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("icmpMsgStatsTable", icmpMsgStatsTable_variables,
                 variable2, icmpMsgStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static void vtss_ip_stat_icmp_msg2icmpMsgStats(vtss_icmp_stat_data_t *data, icmpMsgStatsTable_entry_t *table_entry)
{
    table_entry->icmpMsgStatsInPkts = data->InMsgs;
    table_entry->icmpMsgStatsOutPkts = data->OutMsgs;
}

static int
getfirst_icmpMsgStatsTableEntry(icmpMsgStatsTable_entry_t *table_entry)
{
    vtss_ips_icmp_stat_t    entry;
    vtss_icmp_stat_data_t   *data = &entry.data;
    vtss_ip_type_t          version = VTSS_IP_TYPE_NONE;
    u32                     imsg = 0;

    if ( VTSS_OK != vtss_ip2_cntr_icmp_msg_iter_first( &version, &imsg, &entry )) {
        return VTSS_RC_ERROR;
    }

    table_entry->icmpMsgStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                         entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;
    table_entry->icmpMsgStatsType = entry.Type;

    vtss_ip_stat_icmp_msg2icmpMsgStats(data, table_entry);
    return VTSS_RC_OK;

}

static int
get_icmpMsgStatsTableEntry(icmpMsgStatsTable_entry_t *table_entry,
                           BOOL getnext)
{
    vtss_ips_icmp_stat_t    entry;
    vtss_icmp_stat_data_t   *data = &entry.data;
    vtss_ip_type_t          version;
    u32                     imsg;

    if ( TRUE != getnext && FALSE != getnext) {
        return VTSS_RC_ERROR;
    }
    version = table_entry->icmpMsgStatsIPVersion == INET_VERSION_UNKNOWN ? VTSS_IP_TYPE_NONE :
              table_entry->icmpMsgStatsIPVersion == INET_VERSION_IPV4 ? VTSS_IP_TYPE_IPV4 : VTSS_IP_TYPE_IPV6;
    imsg = table_entry->icmpMsgStatsType;

    if ( (TRUE == getnext &&  VTSS_OK != vtss_ip2_cntr_icmp_msg_iter_next ( &version, &imsg, &entry )) ||
         (FALSE == getnext &&  VTSS_OK != vtss_ip2_cntr_icmp_msg_iter_get ( &version, &imsg, &entry )) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->icmpMsgStatsIPVersion = entry.IPVersion == VTSS_IP_TYPE_NONE ? INET_VERSION_UNKNOWN :
                                         entry.IPVersion == VTSS_IP_TYPE_IPV4 ? INET_VERSION_IPV4 : INET_VERSION_IPV6;
    table_entry->icmpMsgStatsType = entry.Type;

    vtss_ip_stat_icmp_msg2icmpMsgStats(data, table_entry);
    return VTSS_RC_OK;
}

static int
parse_icmpMsgStatsTable(oid *name,
                        size_t *length,
                        int exact, icmpMsgStatsTable_entry_t *table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_icmpMsgStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->icmpMsgStatsIPVersion = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->icmpMsgStatsType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_icmpMsgStatsTable(oid *name,
                          size_t *length,
                          icmpMsgStatsTable_entry_t *table_entry)
{
    int             name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->icmpMsgStatsIPVersion;
    name[name_pos++] = (oid) table_entry->icmpMsgStatsType;

    *length = name_pos;
    return 0;
}

/*
 * var_icmpMsgStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_icmpMsgStatsTable above.
 */
u_char         *
var_icmpMsgStatsTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    icmpMsgStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_icmpMsgStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_icmpMsgStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_icmpMsgStatsTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_icmpMsgStatsTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case ICMPMSGSTATSINPKTS: {
        icmpMsgStatsTable_global_ret.ulong_ret =
            table_entry.icmpMsgStatsInPkts;
        *var_len = sizeof(icmpMsgStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpMsgStatsTable_global_ret.ulong_ret;
    }
    case ICMPMSGSTATSOUTPKTS: {
        icmpMsgStatsTable_global_ret.ulong_ret =
            table_entry.icmpMsgStatsOutPkts;
        *var_len = sizeof(icmpMsgStatsTable_global_ret.ulong_ret);
        return (u_char *) & icmpMsgStatsTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_icmpMsgStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for ipNetToPhysicalTable
 */
typedef struct {
    /* Entry keys */
    long           ipNetToPhysicalIfIndex;
    long           ipNetToPhysicalNetAddressType;
    char             ipNetToPhysicalNetAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipNetToPhysicalNetAddress_len;

    /* Entry columns */
    char             ipNetToPhysicalPhysAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipNetToPhysicalPhysAddress_len;
    u_long             ipNetToPhysicalLastUpdated;
    long             ipNetToPhysicalType;
    long             ipNetToPhysicalState;
    long             ipNetToPhysicalRowStatus;
} ipNetToPhysicalTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipNetToPhysicalTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipNetToPhysicalTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipNetToPhysicalTable_return_t ipNetToPhysicalTable_global_ret; /* static variables for retuning */

/*
 * ipNetToPhysicalTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipNetToPhysicalTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 35};



/*
 * variable ipNetToPhysicalTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipNetToPhysicalTable mib section
 */

struct variable2 ipNetToPhysicalTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPNETTOPHYSICALPHYSADDRESS      1
    {IPNETTOPHYSICALPHYSADDRESS, ASN_OCTET_STR, RWRITE, var_ipNetToPhysicalTable, 2, {1, 4}},
#if 0
#define IPNETTOPHYSICALLASTUPDATED      2
    {IPNETTOPHYSICALLASTUPDATED, ASN_TIMETICKS, RONLY, var_ipNetToPhysicalTable, 2, {1, 5}},
#define IPNETTOPHYSICALTYPE     3
    {IPNETTOPHYSICALTYPE, ASN_INTEGER, RWRITE, var_ipNetToPhysicalTable, 2, {1, 6}},
#define IPNETTOPHYSICALSTATE        4
    {IPNETTOPHYSICALSTATE, ASN_INTEGER, RONLY, var_ipNetToPhysicalTable, 2, {1, 7}},
#endif
#define IPNETTOPHYSICALROWSTATUS        5
    {IPNETTOPHYSICALROWSTATUS, ASN_INTEGER, RWRITE, var_ipNetToPhysicalTable, 2, {1, 8}},
};

/*
 * Initializes the ipNetToPhysicalTable module
 */
static void
init_ipNetToPhysicalTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipNetToPhysicalTable_variables_oid,
                             sizeof(ipNetToPhysicalTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipNetToPhysicalTable");

    DEBUGMSGTL(("ipNetToPhysicalTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipNetToPhysicalTable", ipNetToPhysicalTable_variables, variable2,
                 ipNetToPhysicalTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int compare_nb(vtss_neighbour_status_t *data, vtss_neighbour_status_t *key)
{
    int cmp;

    if ( data->interface.u.vlan != key->interface.u.vlan) {
        return data->interface.u.vlan - key->interface.u.vlan;
    }

    if (data->ip_address.type != key->ip_address.type) {
        return data->ip_address.type - key->ip_address.type;
    }

    if (data->ip_address.type == VTSS_IP_TYPE_IPV4) {
        cmp = (data->ip_address.addr.ipv4 >  key->ip_address.addr.ipv4) ? 1 : (data->ip_address.addr.ipv4 <  key->ip_address.addr.ipv4) ? -1 : 0;
    } else {
        cmp = memcmp(&data->ip_address.addr.ipv6, &key->ip_address.addr.ipv6, sizeof(key->ip_address.addr.ipv6));
    }

    return cmp;

}

static BOOL vtss_ip2_nb_get_nextByKey (ipNetToPhysicalTable_entry_t *table_entry)
{
#define ARP_MAX 1024
    vtss_neighbour_status_t *status_v4, *status_v6, tmp, key, *ptr;
    vtss_ipv4_t   n_v4_addr;
    iftable_info_t info;
    u32 cnt, cnt_v4, cnt_v6, i;
    BOOL found = FALSE;

    info.type = IFTABLE_IFINDEX_TYPE_IP;
    if ( FALSE == ifIndex_get_first_by_type( &info) ) {
        return FALSE;
    }

    if (table_entry->ipNetToPhysicalIfIndex < (long) info.ifIndex) {
        key.interface.u.vlan = info.if_id;
        key.ip_address.type = VTSS_IP_TYPE_IPV4;
        memset(&key.ip_address.addr.ipv4, 0, INET_ADDRESS_IPV4_LEN);
    } else {
        info.ifIndex = table_entry->ipNetToPhysicalIfIndex;
        if ( FALSE == ifIndex_get_valid( &info) || info.type != IFTABLE_IFINDEX_TYPE_IP) {
            return FALSE;
        }
        key.interface.u.vlan = info.if_id;
        if (table_entry->ipNetToPhysicalNetAddressType == VTSS_IP_TYPE_IPV4) {
            key.ip_address.type = VTSS_IP_TYPE_IPV4;
            memcpy(&n_v4_addr, table_entry->ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress_len);
            key.ip_address.addr.ipv4 = ntohl(n_v4_addr);
        } else {
            key.ip_address.type = VTSS_IP_TYPE_IPV6;
            memcpy( &key.ip_address.addr.ipv6, table_entry->ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress_len);
        }
    }

    tmp.interface.u.vlan = VTSS_VIDS;

    status_v4 = VTSS_CALLOC(ARP_MAX, sizeof(vtss_neighbour_status_t));
    if ( !status_v4 ) {
        T_E("out of memory");
        return FALSE;
    }

    status_v6 = VTSS_CALLOC(ARP_MAX, sizeof(vtss_neighbour_status_t));
    if ( !status_v6 ) {
        T_E("out of memory");
        goto free_v4;
    }

    if (vtss_ip2_nb_status_get(VTSS_IP_TYPE_IPV4, ARP_MAX, &cnt_v4, status_v4) != VTSS_RC_OK) {
        cnt_v4 = 0;
    }

    if (vtss_ip2_nb_status_get(VTSS_IP_TYPE_IPV6, ARP_MAX, &cnt_v6, status_v6) != VTSS_RC_OK) {
        cnt_v6 = 0;
    }

    if ( !cnt_v4 && !cnt_v6) {
        goto free_v4_v6;
    }

    cnt = cnt_v4 + cnt_v6;

    for (i = 0, ptr = status_v4; i < cnt; i++) {
        if (i == cnt_v4) {
            ptr = status_v6;
        }
        if (compare_nb(ptr, &key) > 0 && compare_nb(ptr, &tmp) < 0) {
            tmp = *ptr;
            found = TRUE;
        }
        ptr++;
    }

    if ( TRUE == found ) {
        info.if_id = tmp.interface.u.vlan;
        info.type = IFTABLE_IFINDEX_TYPE_IP;
        (void) ifIndex_get_by_interface(&info);
        table_entry->ipNetToPhysicalIfIndex = info.ifIndex;
        if (tmp.ip_address.type == VTSS_IP_TYPE_IPV4) {
            table_entry->ipNetToPhysicalNetAddressType = INET_ADDRESS_IPV4;
            table_entry->ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV4_LEN;
            n_v4_addr = htonl(tmp.ip_address.addr.ipv4);
            memcpy(table_entry->ipNetToPhysicalNetAddress, &n_v4_addr, INET_ADDRESS_IPV4_LEN);
        } else {
            table_entry->ipNetToPhysicalNetAddressType = INET_ADDRESS_IPV6;
            table_entry->ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV6_LEN;
            memcpy(table_entry->ipNetToPhysicalNetAddress, &tmp.ip_address.addr.ipv6, INET_ADDRESS_IPV6_LEN);
        }

        memcpy(table_entry->ipNetToPhysicalPhysAddress, &tmp.mac_address, 6);
        table_entry->ipNetToPhysicalPhysAddress_len = 6;
        table_entry->ipNetToPhysicalRowStatus = 1;
    }
free_v4_v6:
    VTSS_FREE(status_v6);
free_v4:
    VTSS_FREE(status_v4);
#undef ARP_MAX
    return found;
}

static BOOL get_next_ipNetToPhysicalTableEntryByKey(ipNetToPhysicalTable_entry_t *table_entry)
{
    ipNetToPhysicalTable_entry_t tmp = *table_entry;

    if ( FALSE == prepare_get_next_inetAddress(&tmp.ipNetToPhysicalNetAddressType,
                                               tmp.ipNetToPhysicalNetAddress, SNMP_ASN_OCTET_STR_MAX_LEN, &tmp.ipNetToPhysicalNetAddress_len)) {
        tmp.ipNetToPhysicalNetAddressType = INET_VERSION_IPV4;
        tmp.ipNetToPhysicalNetAddress_len = INET_ADDRESS_IPV4_LEN;
        memset(tmp.ipNetToPhysicalNetAddress, 0, INET_ADDRESS_IPV4_LEN);
        tmp.ipNetToPhysicalIfIndex++;
    }

    if ( FALSE == vtss_ip2_nb_get_nextByKey(&tmp) ) {
        return FALSE;
    }

    memcpy(table_entry, &tmp, sizeof(tmp));
    return TRUE;
}

static BOOL get_pre_ipNetToPhysicalTableEntryKey(ipNetToPhysicalTable_entry_t *table_entry)
{
    vtss_rc rc = get_pre_inetAddress(table_entry->ipNetToPhysicalNetAddress, &table_entry->ipNetToPhysicalNetAddress_len );
    if ( rc == VTSS_RC_INCOMPLETE) {
        T_E("VTSS_RC_INCOMPLETE");
        return FALSE;
    } else if ( rc != VTSS_RC_OK) {
        memset( table_entry->ipNetToPhysicalNetAddress, 0xff, table_entry->ipNetToPhysicalNetAddress_len );
        if (table_entry->ipNetToPhysicalNetAddressType) {
            table_entry->ipNetToPhysicalNetAddressType--;
        } else if (table_entry->ipNetToPhysicalIfIndex != 0) {
            table_entry->ipNetToPhysicalNetAddressType = 0x7fffffff;
            table_entry->ipNetToPhysicalIfIndex--;
        } else {
            T_E("overflow");
            return FALSE;
        }
    }

    return TRUE;
}

static int
getfirst_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry)
{
    return !get_next_ipNetToPhysicalTableEntryByKey(table_entry);
}

static int
get_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry, BOOL getnext)
{
    ipNetToPhysicalTable_entry_t tmp = *table_entry;
    if ( getnext == TRUE && FALSE == get_next_ipNetToPhysicalTableEntryByKey(&tmp)) {
        return VTSS_RC_ERROR;
    } else if (getnext == FALSE ) {
        if ( FALSE == get_pre_ipNetToPhysicalTableEntryKey( &tmp) || FALSE == get_next_ipNetToPhysicalTableEntryByKey(&tmp)
             || tmp.ipNetToPhysicalIfIndex != table_entry->ipNetToPhysicalIfIndex ||
             tmp.ipNetToPhysicalNetAddressType != table_entry->ipNetToPhysicalNetAddressType ||
             tmp.ipNetToPhysicalNetAddress_len != table_entry->ipNetToPhysicalNetAddress_len ||
             memcmp(tmp.ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress, table_entry->ipNetToPhysicalNetAddress_len)) {
            return VTSS_RC_ERROR;
        }
    }

    memcpy(table_entry, &tmp, sizeof(tmp));

    return VTSS_RC_OK;
}

static int
set_ipNetToPhysicalTableEntry(ipNetToPhysicalTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipNetToPhysicalTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           ipNetToPhysicalTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipNetToPhysicalTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipNetToPhysicalIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ipNetToPhysicalNetAddressType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->ipNetToPhysicalNetAddress) ? sizeof(table_entry->ipNetToPhysicalNetAddress) : len;
    op_pos++;
    table_entry->ipNetToPhysicalNetAddress_len = len;
    cp = (u_char *) table_entry->ipNetToPhysicalNetAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipNetToPhysicalTable(oid     *name,
                             size_t  *length,
                             ipNetToPhysicalTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipNetToPhysicalIfIndex;
    name[name_pos++] = (oid) table_entry->ipNetToPhysicalNetAddressType;
    len = (int) table_entry->ipNetToPhysicalNetAddress_len;
    name[name_pos++] = (oid) table_entry->ipNetToPhysicalNetAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->ipNetToPhysicalNetAddress[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_ipNetToPhysicalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipNetToPhysicalTable above.
 */
u_char *
var_ipNetToPhysicalTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipNetToPhysicalTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipNetToPhysicalTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipNetToPhysicalTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipNetToPhysicalTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IPNETTOPHYSICALROWSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_ipNetToPhysicalRowStatus;
                }
                return NULL;
            }
            if (fillobj_ipNetToPhysicalTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPNETTOPHYSICALPHYSADDRESS: {
        *write_method = write_ipNetToPhysicalPhysAddress;
        *var_len = table_entry.ipNetToPhysicalPhysAddress_len;
        memcpy(ipNetToPhysicalTable_global_ret.string_ret, table_entry.ipNetToPhysicalPhysAddress, *var_len);
        ipNetToPhysicalTable_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ipNetToPhysicalTable_global_ret.string_ret;
    }
#if 0
    case IPNETTOPHYSICALLASTUPDATED: {
        ipNetToPhysicalTable_global_ret.ulong_ret = table_entry.ipNetToPhysicalLastUpdated;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.ulong_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.ulong_ret;
    }
    case IPNETTOPHYSICALTYPE: {
        *write_method = write_ipNetToPhysicalType;
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalType;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
    case IPNETTOPHYSICALSTATE: {
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalState;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
#endif
    case IPNETTOPHYSICALROWSTATUS: {
        *write_method = write_ipNetToPhysicalRowStatus;
        ipNetToPhysicalTable_global_ret.long_ret = table_entry.ipNetToPhysicalRowStatus;
        *var_len = sizeof(ipNetToPhysicalTable_global_ret.long_ret);
        return (u_char *) &ipNetToPhysicalTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipNetToPhysicalTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipNetToPhysicalPhysAddress(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalPhysAddress: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SNMP_ASN_OCTET_STR_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalPhysAddress: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_len > 65535) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.ipNetToPhysicalPhysAddress, var_val, var_val_len);
        table_entry.ipNetToPhysicalPhysAddress_len = var_val_len;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipNetToPhysicalType(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipNetToPhysicalType = set_value;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipNetToPhysicalRowStatus(int      action,
                               u_char   *var_val,
                               u_char   var_val_type,
                               size_t   var_val_len,
                               u_char   *statP,
                               oid      *name,
                               size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipNetToPhysicalTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to ipNetToPhysicalRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipNetToPhysicalTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ipNetToPhysicalTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipNetToPhysicalRowStatus = set_value;
        if (set_ipNetToPhysicalTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipDefaultRouterTable
 */
typedef struct {
    /* Entry keys */
    long           ipDefaultRouterAddressType;
    char             ipDefaultRouterAddress[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipDefaultRouterAddress_len;
    long           ipDefaultRouterIfIndex;

    /* Entry columns */
    u_long             ipDefaultRouterLifetime;
    long             ipDefaultRouterPreference;
} ipDefaultRouterTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipDefaultRouterTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipDefaultRouterTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipDefaultRouterTable_return_t ipDefaultRouterTable_global_ret; /* static variables for retuning */

/*
 * ipDefaultRouterTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipDefaultRouterTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 37};



/*
 * variable ipDefaultRouterTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipDefaultRouterTable mib section
 */

struct variable2 ipDefaultRouterTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if 0
#define IPDEFAULTROUTERLIFETIME     1
    {IPDEFAULTROUTERLIFETIME, ASN_UNSIGNED, RONLY, var_ipDefaultRouterTable, 2, {1, 4}},
#endif
#define IPDEFAULTROUTERPREFERENCE       2
    {IPDEFAULTROUTERPREFERENCE, ASN_INTEGER, RONLY, var_ipDefaultRouterTable, 2, {1, 5}},
};

/*
 * Initializes the ipDefaultRouterTable module
 */
static void
init_ipDefaultRouterTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipDefaultRouterTable_variables_oid,
                             sizeof(ipDefaultRouterTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipDefaultRouterTable");

    DEBUGMSGTL(("ipDefaultRouterTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipDefaultRouterTable", ipDefaultRouterTable_variables, variable2,
                 ipDefaultRouterTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int cmp_route (vtss_routing_status_t *rs_data, vtss_routing_status_t *rs_key)
{
    int cmp;
    vtss_routing_entry_t *data = &rs_data->rt, *key = &rs_key->rt;
    vtss_ipv4_t         *key_v4_dst = &key->route.ipv4_uc.destination, *data_v4_dst = &data->route.ipv4_uc.destination;
    vtss_ipv6_t         *key_v6_dst = &key->route.ipv6_uc.destination, *data_v6_dst = &data->route.ipv6_uc.destination;

    if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV6_UC && key->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC) {
        return 1;
    } else if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC && key->type == VTSS_ROUTING_ENTRY_TYPE_IPV6_UC) {
        return -1;
    }

    if (data->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC) {
        cmp = (*data_v4_dst > *key_v4_dst) ? 1 : (*data_v4_dst < *key_v4_dst) ? -1 : 0;
    } else {
        cmp = memcmp(data_v6_dst, key_v6_dst, sizeof(vtss_ipv6_t));
    }

    if (cmp) {
        return cmp;
    }

    return rs_data->interface.u.vlan > rs_key->interface.u.vlan ? 1 : -1;

}

static BOOL get_next_default_route(vtss_routing_status_t  *entry)
{
#define SIZE 2048
    u32 i, cnt = 0, cnt_v4, cnt_v6;
    BOOL found = FALSE;
    vtss_routing_status_t *rts_v4, *rts_v6, *ptr;
    vtss_routing_entry_t *rt_tmp;
    vtss_ipv4_network_t v4_zero_network;
    vtss_ipv6_network_t v6_zero_network;

    memset(&v4_zero_network, 0, sizeof(v4_zero_network));
    memset(&v6_zero_network, 0, sizeof(v6_zero_network));

    rts_v4 = VTSS_CALLOC(SIZE, sizeof(vtss_routing_status_t));
    if ( !rts_v4 ) {
        return FALSE;
    }

    rts_v6 = VTSS_CALLOC(SIZE, sizeof(vtss_routing_status_t));
    if ( !rts_v6 ) {
        goto free_v4_return;
    }


    if (vtss_ip2_os_route_get(VTSS_ROUTING_ENTRY_TYPE_IPV4_UC, SIZE, rts_v4, &cnt_v4) != VTSS_RC_OK) {
        cnt_v4 = 0;
    }

    if (vtss_ip2_os_route_get(VTSS_ROUTING_ENTRY_TYPE_IPV6_UC, SIZE, rts_v6, &cnt_v6) != VTSS_RC_OK) {
        cnt_v6 = 0;
    }

    if ( !cnt_v4 && !cnt_v6 ) {
        goto free_v4_v6_return;
    }

    cnt = cnt_v4 + cnt_v6;
    for (i = 0, ptr = rts_v4; i < cnt; i++) {
        if ( i == cnt_v4 ) {
            ptr = rts_v6;
        }
        rt_tmp = &ptr->rt;

        if ( (rt_tmp->type != VTSS_ROUTING_ENTRY_TYPE_IPV4_UC && rt_tmp->type != VTSS_ROUTING_ENTRY_TYPE_IPV6_UC ) ||
             ptr->interface.type != VTSS_ID_IF_TYPE_VLAN ||
             (rt_tmp->type == VTSS_ROUTING_ENTRY_TYPE_IPV4_UC && memcmp( &rt_tmp->route.ipv4_uc.network, &v4_zero_network, sizeof(v4_zero_network))) ||
             (rt_tmp->type == VTSS_ROUTING_ENTRY_TYPE_IPV6_UC && memcmp( &rt_tmp->route.ipv6_uc.network.address, &v6_zero_network.address, sizeof(v6_zero_network.address)))) {
            ptr++;
            continue;
        }
        if (cmp_route(ptr, entry) > 0 ) {
            found = TRUE;
            *entry = *ptr;
            break;
        }
        ptr++;
    }

free_v4_v6_return:
    VTSS_FREE(rts_v6);
free_v4_return:
    VTSS_FREE(rts_v4);
#undef SIZE
    return found;

}

static BOOL get_next_ipDefaultRouterTableEntryByKey(ipDefaultRouterTable_entry_t *table_entry)
{
    iftable_info_t          info;
    vtss_routing_status_t   entry;
    long                    type = table_entry->ipDefaultRouterAddressType;
    size_t                  addr_len = table_entry->ipDefaultRouterAddress_len;
    vtss_ipv4_t             *v4_dst = &entry.rt.route.ipv4_uc.destination;
    vtss_ipv6_t             *v6_dst = &entry.rt.route.ipv6_uc.destination;
    vtss_ipv4_t             n_v4_dst, h_v4_dst;


    info.type = IFTABLE_IFINDEX_TYPE_IP;
    if ( FALSE == ifIndex_get_first_by_type ( &info) ) {
        return FALSE;
    }

    if ( FALSE == prepare_get_next_inetAddress( &type, table_entry->ipDefaultRouterAddress,
                                                SNMP_ASN_OCTET_STR_MAX_LEN, &addr_len) ) {
        return FALSE;
    }

    entry.interface.type = VTSS_ID_IF_TYPE_VLAN;
    if ( type == table_entry->ipDefaultRouterAddressType && addr_len == table_entry->ipDefaultRouterAddress_len &&
         table_entry->ipDefaultRouterIfIndex >= ( i32 ) info.ifIndex) {

        info.ifIndex = table_entry->ipDefaultRouterIfIndex;

        if (FALSE == ifIndex_get_valid( &info) || info.type != IFTABLE_IFINDEX_TYPE_IP ) {
            return FALSE;
        }
        entry.interface.u.vlan = info.if_id;
    } else {
        table_entry->ipDefaultRouterAddressType = type;
        table_entry->ipDefaultRouterAddress_len = addr_len;
        entry.interface.u.vlan = 0;
    }

    switch (table_entry->ipDefaultRouterAddressType) {
    case INET_ADDRESS_IPV4:
        entry.rt.type = VTSS_ROUTING_ENTRY_TYPE_IPV4_UC;
        memcpy(&n_v4_dst, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len);
        *v4_dst = ntohl(n_v4_dst);
        break;
    case INET_ADDRESS_IPV6:
        entry.rt.type = VTSS_ROUTING_ENTRY_TYPE_IPV6_UC;
        memcpy(v6_dst, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len);
        break;
    default:
        T_E("internal error");
        return FALSE;
    }

    if ( FALSE == get_next_default_route(&entry) ) {
        return FALSE;
    }

    switch (entry.rt.type) {
    case VTSS_ROUTING_ENTRY_TYPE_IPV4_UC:
        table_entry->ipDefaultRouterAddressType = INET_ADDRESS_IPV4;
        memcpy(&h_v4_dst, v4_dst, table_entry->ipDefaultRouterAddress_len);
        n_v4_dst = htonl(h_v4_dst);
        memcpy( table_entry->ipDefaultRouterAddress, &n_v4_dst, table_entry->ipDefaultRouterAddress_len);
        break;
    case VTSS_ROUTING_ENTRY_TYPE_IPV6_UC:
        table_entry->ipDefaultRouterAddressType = INET_ADDRESS_IPV6;
        table_entry->ipDefaultRouterAddress_len = INET_ADDRESS_IPV6_LEN;
        memcpy( table_entry->ipDefaultRouterAddress, v6_dst, table_entry->ipDefaultRouterAddress_len);
        break;
    default:
        T_E("internal error");
        return FALSE;
    }

    info.if_id = entry.interface.u.vlan;
    info.type = IFTABLE_IFINDEX_TYPE_IP;
    (void) ifIndex_get_by_interface (&info);
    table_entry->ipDefaultRouterIfIndex = info.ifIndex;
    table_entry->ipDefaultRouterPreference = entry.preference;
    return TRUE;
}

static BOOL get_pre_ipDefaultRouterTableEntryKey(ipDefaultRouterTable_entry_t *table_entry)
{
    vtss_rc rc;

    if (table_entry->ipDefaultRouterIfIndex) {
        table_entry->ipDefaultRouterIfIndex--;
    } else {
        table_entry->ipDefaultRouterIfIndex = 0x7fffffff;
        rc = get_pre_inetAddress(table_entry->ipDefaultRouterAddress, &table_entry->ipDefaultRouterAddress_len );
        if ( rc == VTSS_RC_INCOMPLETE) {
            return FALSE;
        }
        if (  VTSS_RC_OK != rc && table_entry->ipDefaultRouterAddressType == 0 ) {
            return FALSE;
        } else if (VTSS_RC_OK != rc) {
            memset(table_entry->ipDefaultRouterAddress, 0xff, table_entry->ipDefaultRouterAddress_len );
            table_entry->ipDefaultRouterAddressType--;
        }
    }

    return TRUE;
}

static int
getfirst_ipDefaultRouterTableEntry(ipDefaultRouterTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipDefaultRouterTable_entry_t));

    return !get_next_ipDefaultRouterTableEntryByKey(table_entry);
}

static int
get_ipDefaultRouterTableEntry(ipDefaultRouterTable_entry_t *table_entry, BOOL getnext)
{
    ipDefaultRouterTable_entry_t tmp = *table_entry;
    if ( TRUE == getnext && FALSE == get_next_ipDefaultRouterTableEntryByKey(&tmp)) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext) {
        if ( FALSE == get_pre_ipDefaultRouterTableEntryKey(&tmp) || FALSE == get_next_ipDefaultRouterTableEntryByKey(&tmp) ||
             tmp.ipDefaultRouterAddressType != table_entry->ipDefaultRouterAddressType ||
             tmp.ipDefaultRouterAddress_len != table_entry->ipDefaultRouterAddress_len ||
             memcmp(tmp.ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress, table_entry->ipDefaultRouterAddress_len) ||
             tmp.ipDefaultRouterIfIndex != table_entry->ipDefaultRouterIfIndex ) {
            return VTSS_RC_ERROR;
        }
    }

    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
parse_ipDefaultRouterTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           ipDefaultRouterTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    size_t     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipDefaultRouterTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipDefaultRouterAddressType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (unsigned int) * op++;
    len = (unsigned int )len > sizeof(table_entry->ipDefaultRouterAddress) ? sizeof(table_entry->ipDefaultRouterAddress) : len;
    op_pos++;
    table_entry->ipDefaultRouterAddress_len = len;
    cp = (u_char *) table_entry->ipDefaultRouterAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->ipDefaultRouterIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipDefaultRouterTable(oid     *name,
                             size_t  *length,
                             ipDefaultRouterTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->ipDefaultRouterAddressType;
    len = (int) table_entry->ipDefaultRouterAddress_len;
    name[name_pos++] = (oid) table_entry->ipDefaultRouterAddress_len;
    idx = 0;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->ipDefaultRouterAddress[idx++];
    }
    name[name_pos++] = (oid) table_entry->ipDefaultRouterIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipDefaultRouterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipDefaultRouterTable above.
 */
u_char *
var_ipDefaultRouterTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipDefaultRouterTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipDefaultRouterTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipDefaultRouterTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipDefaultRouterTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipDefaultRouterTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if 0
    case IPDEFAULTROUTERLIFETIME: {
        ipDefaultRouterTable_global_ret.ulong_ret = table_entry.ipDefaultRouterLifetime;
        *var_len = sizeof(ipDefaultRouterTable_global_ret.ulong_ret);
        return (u_char *) &ipDefaultRouterTable_global_ret.ulong_ret;
    }
#endif
    case IPDEFAULTROUTERPREFERENCE: {
        ipDefaultRouterTable_global_ret.long_ret = table_entry.ipDefaultRouterPreference;
        *var_len = sizeof(ipDefaultRouterTable_global_ret.long_ret);
        return (u_char *) &ipDefaultRouterTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipDefaultRouterTable\n", vp->magic));
    }
    return NULL;
}

/*
 * The entry data structure for ipv4InterfaceTable
 */
typedef struct {
    /* Entry keys */
    long           ipv4InterfaceIfIndex;

    /* Entry columns */
    long             ipv4InterfaceReasmMaxSize;
    long             ipv4InterfaceEnableStatus;
    u_long             ipv4InterfaceRetransmitTime;
} ipv4InterfaceTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    u_long              ulong_ret;
} ipv4InterfaceTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv4InterfaceTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv4InterfaceTable_return_t ipv4InterfaceTable_global_ret; /* static variables for retuning */

/*
 * ipv4InterfaceTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv4InterfaceTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 28};



/*
 * variable ipv4InterfaceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv4InterfaceTable mib section
 */

struct variable2 ipv4InterfaceTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV4INTERFACEREASMMAXSIZE       1
    {IPV4INTERFACEREASMMAXSIZE, ASN_INTEGER, RONLY, var_ipv4InterfaceTable, 2, {1, 2}},
#if 0
#define IPV4INTERFACEENABLESTATUS       2
    {IPV4INTERFACEENABLESTATUS, ASN_INTEGER, RWRITE, var_ipv4InterfaceTable, 2, {1, 3}},
#endif
#define IPV4INTERFACERETRANSMITTIME     3
    {IPV4INTERFACERETRANSMITTIME, ASN_UNSIGNED, RONLY, var_ipv4InterfaceTable, 2, {1, 4}},
};

/*
 * Initializes the ipv4InterfaceTable module
 */
static void
init_ipv4InterfaceTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv4InterfaceTable_variables_oid,
                             sizeof(ipv4InterfaceTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv4InterfaceTable");

    DEBUGMSGTL(("ipv4InterfaceTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv4InterfaceTable", ipv4InterfaceTable_variables, variable2,
                 ipv4InterfaceTable_variables_oid);

    /* place any other initialization junk you need here */
}

static BOOL get_next_ipv4InterfaceTableEntryByKey(ipv4InterfaceTable_entry_t *table_entry)
{
    iftable_info_t      info;
    vtss_if_status_t    if_status;
    u32                 ipcnt;

    info.type = IFTABLE_IFINDEX_TYPE_IP;

    if ( FALSE == ifIndex_get_first_by_type(&info) ) {
        return FALSE;
    }

    if ( (table_entry->ipv4InterfaceIfIndex >= ( i32 ) info.ifIndex) && (info.ifIndex = table_entry->ipv4InterfaceIfIndex) &&
         ( FALSE == ifIndex_get_next(&info) || info.type != IFTABLE_IFINDEX_TYPE_IP) ) {
        return FALSE;
    }

    if ( vtss_ip2_if_status_get(VTSS_IF_STATUS_TYPE_IPV4, info.if_id, 1, &ipcnt, &if_status) != VTSS_RC_OK ) {
        return FALSE;
    }

    table_entry->ipv4InterfaceIfIndex = info.ifIndex;
    table_entry->ipv4InterfaceReasmMaxSize = if_status.u.ipv4.reasm_max_size;
    table_entry->ipv4InterfaceRetransmitTime = if_status.u.ipv4.arp_retransmit_time;

    return TRUE;
}

static int
getfirst_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry)
{
    memset(table_entry, 0, sizeof(ipv4InterfaceTable_entry_t));
    return !get_next_ipv4InterfaceTableEntryByKey(table_entry);
}

static int
get_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry, BOOL getnext)
{
    ipv4InterfaceTable_entry_t tmp = *table_entry;
    if ( (TRUE == getnext && FALSE == get_next_ipv4InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv4InterfaceIfIndex == 0 || ((tmp.ipv4InterfaceIfIndex--) && FALSE == get_next_ipv4InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv4InterfaceIfIndex != table_entry->ipv4InterfaceIfIndex) ) {
        return VTSS_RC_ERROR;
    }
    memcpy(table_entry, &tmp, sizeof(tmp));
    return VTSS_RC_OK;
}

static int
set_ipv4InterfaceTableEntry(ipv4InterfaceTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipv4InterfaceTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         ipv4InterfaceTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv4InterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv4InterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv4InterfaceTable(oid     *name,
                           size_t  *length,
                           ipv4InterfaceTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv4InterfaceIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv4InterfaceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv4InterfaceTable above.
 */
u_char *
var_ipv4InterfaceTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv4InterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv4InterfaceTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv4InterfaceTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv4InterfaceTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv4InterfaceTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV4INTERFACEREASMMAXSIZE: {
        ipv4InterfaceTable_global_ret.long_ret = table_entry.ipv4InterfaceReasmMaxSize;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.long_ret;
    }
#if 0
    case IPV4INTERFACEENABLESTATUS: {
        *write_method = write_ipv4InterfaceEnableStatus;
        ipv4InterfaceTable_global_ret.long_ret = table_entry.ipv4InterfaceEnableStatus;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.long_ret;
    }
#endif
    case IPV4INTERFACERETRANSMITTIME: {
        ipv4InterfaceTable_global_ret.ulong_ret = table_entry.ipv4InterfaceRetransmitTime;
        *var_len = sizeof(ipv4InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv4InterfaceTable_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv4InterfaceTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipv4InterfaceEnableStatus(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv4InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv4InterfaceEnableStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv4InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv4InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv4InterfaceEnableStatus = set_value;
        if (set_ipv4InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipv6InterfaceTable
 */
typedef struct {
    /* Entry keys */
    long           ipv6InterfaceIfIndex;

    /* Entry columns */
    u_long             ipv6InterfaceReasmMaxSize;
    char             ipv6InterfaceIdentifier[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              ipv6InterfaceIdentifier_len;
    long             ipv6InterfaceEnableStatus;
    u_long             ipv6InterfaceReachableTime;
    u_long             ipv6InterfaceRetransmitTime;
    long             ipv6InterfaceForwarding;
} ipv6InterfaceTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    u_long              ulong_ret;
} ipv6InterfaceTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv6InterfaceTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv6InterfaceTable_return_t ipv6InterfaceTable_global_ret; /* static variables for retuning */

/*
 * ipv6InterfaceTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv6InterfaceTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 30};



/*
 * variable ipv6InterfaceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv6InterfaceTable mib section
 */

struct variable2 ipv6InterfaceTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV6INTERFACEREASMMAXSIZE       1
    {IPV6INTERFACEREASMMAXSIZE, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 2}},
#define IPV6INTERFACEIDENTIFIER     2
    {IPV6INTERFACEIDENTIFIER, ASN_OCTET_STR, RONLY, var_ipv6InterfaceTable, 2, {1, 3}},
#define IPV6INTERFACEENABLESTATUS       3
    {IPV6INTERFACEENABLESTATUS, ASN_INTEGER, RWRITE, var_ipv6InterfaceTable, 2, {1, 5}},
#define IPV6INTERFACEREACHABLETIME      4
    {IPV6INTERFACEREACHABLETIME, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 6}},
#define IPV6INTERFACERETRANSMITTIME     5
    {IPV6INTERFACERETRANSMITTIME, ASN_UNSIGNED, RONLY, var_ipv6InterfaceTable, 2, {1, 7}},
#define IPV6INTERFACEFORWARDING     6
    {IPV6INTERFACEFORWARDING, ASN_INTEGER, RWRITE, var_ipv6InterfaceTable, 2, {1, 8}},
};

/*
 * Initializes the ipv6InterfaceTable module
 */
void
init_ipv6InterfaceTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv6InterfaceTable_variables_oid,
                             sizeof(ipv6InterfaceTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv6InterfaceTable");

    DEBUGMSGTL(("ipv6InterfaceTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv6InterfaceTable", ipv6InterfaceTable_variables, variable2,
                 ipv6InterfaceTable_variables_oid);

    /* place any other initialization junk you need here */
}

static BOOL get_next_ipv6InterfaceTableEntryByKey(ipv6InterfaceTable_entry_t *table_entry)
{
    iftable_info_t      info;
    vtss_if_status_t    if_status;
    u32                 ipcnt;
    unsigned char       *ipv6_addr = if_status.u.ipv6.net.address.addr;

    info.type = IFTABLE_IFINDEX_TYPE_IP;

    if ( FALSE == ifIndex_get_first_by_type(&info) ) {
        return FALSE;
    }

    if ( (table_entry->ipv6InterfaceIfIndex >= ( i32 ) info.ifIndex) && (info.ifIndex = table_entry->ipv6InterfaceIfIndex) &&
         ( FALSE == ifIndex_get_next(&info) || info.type != IFTABLE_IFINDEX_TYPE_IP) ) {
        return FALSE;
    }

    if ( vtss_ip2_if_status_get(VTSS_IF_STATUS_TYPE_IPV6, info.if_id, 1, &ipcnt, &if_status) != VTSS_RC_OK ) {
        return FALSE;
    }

    table_entry->ipv6InterfaceIfIndex = info.ifIndex;
    table_entry->ipv6InterfaceIdentifier_len = 8;
    memcpy (table_entry->ipv6InterfaceIdentifier, ipv6_addr + 8, table_entry->ipv6InterfaceIdentifier_len );
    table_entry->ipv6InterfaceReasmMaxSize = 65535;
    table_entry->ipv6InterfaceRetransmitTime = 300;
    return TRUE;
}


static int
getfirst_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry)
{
    memset( table_entry, 0, sizeof(ipv6InterfaceTable_entry_t));
    return !get_next_ipv6InterfaceTableEntryByKey(table_entry);
}

static int
get_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry, BOOL getnext)
{
    ipv6InterfaceTable_entry_t tmp = *table_entry;
    if ( (TRUE == getnext && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv6InterfaceIfIndex == 0 || ((tmp.ipv6InterfaceIfIndex--) && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv6InterfaceIfIndex != table_entry->ipv6InterfaceIfIndex) ) {
        return VTSS_RC_ERROR;
    }

    *table_entry = tmp;
    return VTSS_RC_OK;
}

static int
set_ipv6InterfaceTableEntry(ipv6InterfaceTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_ipv6InterfaceTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         ipv6InterfaceTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv6InterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv6InterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv6InterfaceTable(oid     *name,
                           size_t  *length,
                           ipv6InterfaceTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv6InterfaceIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv6InterfaceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv6InterfaceTable above.
 */
u_char *
var_ipv6InterfaceTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv6InterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv6InterfaceTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv6InterfaceTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv6InterfaceTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv6InterfaceTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV6INTERFACEREASMMAXSIZE: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceReasmMaxSize;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
    case IPV6INTERFACEIDENTIFIER: {
        *var_len = table_entry.ipv6InterfaceIdentifier_len;
        memcpy(ipv6InterfaceTable_global_ret.string_ret, table_entry.ipv6InterfaceIdentifier, *var_len);
        ipv6InterfaceTable_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) ipv6InterfaceTable_global_ret.string_ret;
    }
#if 0
    case IPV6INTERFACEENABLESTATUS: {
        *write_method = write_ipv6InterfaceEnableStatus;
        ipv6InterfaceTable_global_ret.long_ret = table_entry.ipv6InterfaceEnableStatus;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.long_ret;
    }
    case IPV6INTERFACEREACHABLETIME: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceReachableTime;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
#endif
    case IPV6INTERFACERETRANSMITTIME: {
        ipv6InterfaceTable_global_ret.ulong_ret = table_entry.ipv6InterfaceRetransmitTime;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.ulong_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.ulong_ret;
    }
#if 0
    case IPV6INTERFACEFORWARDING: {
        *write_method = write_ipv6InterfaceForwarding;
        ipv6InterfaceTable_global_ret.long_ret = table_entry.ipv6InterfaceForwarding;
        *var_len = sizeof(ipv6InterfaceTable_global_ret.long_ret);
        return (u_char *) &ipv6InterfaceTable_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv6InterfaceTable\n", vp->magic));
    }
    return NULL;
}

int
write_ipv6InterfaceEnableStatus(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv6InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceEnableStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv6InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv6InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv6InterfaceEnableStatus = set_value;
        if (set_ipv6InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipv6InterfaceForwarding(int      action,
                              u_char   *var_val,
                              u_char   var_val_type,
                              size_t   var_val_len,
                              u_char   *statP,
                              oid      *name,
                              size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    ipv6InterfaceTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to ipv6InterfaceForwarding: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ipv6InterfaceTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_ipv6InterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ipv6InterfaceForwarding = set_value;
        if (set_ipv6InterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

/*
 * The entry data structure for ipv6ScopeZoneIndexTable
 */
typedef struct {
    /* Entry keys */
    long           ipv6ScopeZoneIndexIfIndex;

    /* Entry columns */
    u_long             ipv6ScopeZoneIndexLinkLocal;
    u_long             ipv6ScopeZoneIndex3;
    u_long             ipv6ScopeZoneIndexAdminLocal;
    u_long             ipv6ScopeZoneIndexSiteLocal;
    u_long             ipv6ScopeZoneIndex6;
    u_long             ipv6ScopeZoneIndex7;
    u_long             ipv6ScopeZoneIndexOrganizationLocal;
    u_long             ipv6ScopeZoneIndex9;
    u_long             ipv6ScopeZoneIndexA;
    u_long             ipv6ScopeZoneIndexB;
    u_long             ipv6ScopeZoneIndexC;
    u_long             ipv6ScopeZoneIndexD;
} ipv6ScopeZoneIndexTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    u_long              ulong_ret;
} ipv6ScopeZoneIndexTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ipv6ScopeZoneIndexTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ipv6ScopeZoneIndexTable_return_t ipv6ScopeZoneIndexTable_global_ret; /* static variables for retuning */

/*
 * ipv6ScopeZoneIndexTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipv6ScopeZoneIndexTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 4, 36};



/*
 * variable ipv6ScopeZoneIndexTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the ipv6ScopeZoneIndexTable mib section
 */

struct variable2 ipv6ScopeZoneIndexTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define IPV6SCOPEZONEINDEXLINKLOCAL     1
    {IPV6SCOPEZONEINDEXLINKLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 2}},
#if 0
#define IPV6SCOPEZONEINDEX3     2
    {IPV6SCOPEZONEINDEX3, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 3}},
#define IPV6SCOPEZONEINDEXADMINLOCAL        3
    {IPV6SCOPEZONEINDEXADMINLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 4}},
#define IPV6SCOPEZONEINDEXSITELOCAL     4
    {IPV6SCOPEZONEINDEXSITELOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 5}},
#define IPV6SCOPEZONEINDEX6     5
    {IPV6SCOPEZONEINDEX6, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 6}},
#define IPV6SCOPEZONEINDEX7     6
    {IPV6SCOPEZONEINDEX7, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 7}},
#define IPV6SCOPEZONEINDEXORGANIZATIONLOCAL     7
    {IPV6SCOPEZONEINDEXORGANIZATIONLOCAL, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 8}},
#define IPV6SCOPEZONEINDEX9     8
    {IPV6SCOPEZONEINDEX9, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 9}},
#define IPV6SCOPEZONEINDEXA     9
    {IPV6SCOPEZONEINDEXA, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 10}},
#define IPV6SCOPEZONEINDEXB     10
    {IPV6SCOPEZONEINDEXB, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 11}},
#define IPV6SCOPEZONEINDEXC     11
    {IPV6SCOPEZONEINDEXC, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 12}},
#define IPV6SCOPEZONEINDEXD     12
    {IPV6SCOPEZONEINDEXD, ASN_UNSIGNED, RONLY, var_ipv6ScopeZoneIndexTable, 2, {1, 13}},
#endif
};

/*
 * Initializes the ipv6ScopeZoneIndexTable module
 */
void
init_ipv6ScopeZoneIndexTable(void)
{
    // Register mibContextTable
    mibContextTable_register(ipv6ScopeZoneIndexTable_variables_oid,
                             sizeof(ipv6ScopeZoneIndexTable_variables_oid) / sizeof(oid),
                             "IP-MIB : ipv6ScopeZoneIndexTable");

    DEBUGMSGTL(("ipv6ScopeZoneIndexTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipv6ScopeZoneIndexTable", ipv6ScopeZoneIndexTable_variables, variable2,
                 ipv6ScopeZoneIndexTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int
getfirst_ipv6ScopeZoneIndexTableEntry(ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    ipv6InterfaceTable_entry_t tmp;
    memset(&tmp, 0, sizeof(tmp));

    if ( FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp) ) {
        return VTSS_RC_ERROR;
    }
    table_entry->ipv6ScopeZoneIndexIfIndex = tmp.ipv6InterfaceIfIndex;
    table_entry->ipv6ScopeZoneIndexLinkLocal = tmp.ipv6InterfaceIdentifier[3];
    return VTSS_RC_OK;
}

static int
get_ipv6ScopeZoneIndexTableEntry(ipv6ScopeZoneIndexTable_entry_t *table_entry, BOOL getnext)
{
    ipv6InterfaceTable_entry_t tmp;
    tmp.ipv6InterfaceIfIndex = table_entry->ipv6ScopeZoneIndexIfIndex;

    if ( TRUE != getnext && FALSE != getnext) {
        return VTSS_RC_ERROR;
    }
    if ( (TRUE == getnext && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp))) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext &&
                (tmp.ipv6InterfaceIfIndex == 0 || ((tmp.ipv6InterfaceIfIndex--) && FALSE == get_next_ipv6InterfaceTableEntryByKey(&tmp)) ||
                 tmp.ipv6InterfaceIfIndex != table_entry->ipv6ScopeZoneIndexIfIndex) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->ipv6ScopeZoneIndexIfIndex = tmp.ipv6InterfaceIfIndex;
    table_entry->ipv6ScopeZoneIndexLinkLocal = tmp.ipv6InterfaceIdentifier[3];

    return VTSS_RC_OK;
}

static int
parse_ipv6ScopeZoneIndexTable(oid     *name,
                              size_t  *length,
                              int     exact,
                              ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    size_t  op_pos = 8 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ipv6ScopeZoneIndexTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ipv6ScopeZoneIndexIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ipv6ScopeZoneIndexTable(oid     *name,
                                size_t  *length,
                                ipv6ScopeZoneIndexTable_entry_t *table_entry)
{
    int     name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->ipv6ScopeZoneIndexIfIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_ipv6ScopeZoneIndexTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ipv6ScopeZoneIndexTable above.
 */
u_char *
var_ipv6ScopeZoneIndexTable(struct variable *vp,
                            oid     *name,
                            size_t  *length,
                            int     exact,
                            size_t  *var_len,
                            WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    ipv6ScopeZoneIndexTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ipv6ScopeZoneIndexTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_ipv6ScopeZoneIndexTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ipv6ScopeZoneIndexTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_ipv6ScopeZoneIndexTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IPV6SCOPEZONEINDEXLINKLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexLinkLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
#if 0
    case IPV6SCOPEZONEINDEX3: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex3;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXADMINLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexAdminLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXSITELOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexSiteLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX6: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex6;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX7: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex7;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXORGANIZATIONLOCAL: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexOrganizationLocal;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEX9: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndex9;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXA: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexA;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXB: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexB;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXC: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexC;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
    case IPV6SCOPEZONEINDEXD: {
        ipv6ScopeZoneIndexTable_global_ret.ulong_ret = table_entry.ipv6ScopeZoneIndexD;
        *var_len = sizeof(ipv6ScopeZoneIndexTable_global_ret.ulong_ret);
        return (u_char *) &ipv6ScopeZoneIndexTable_global_ret.ulong_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipv6ScopeZoneIndexTable\n", vp->magic));
    }
    return NULL;
}

void init_ip(void)
{
    init_ipAddressTable();
    init_ipTrafficStats();
    init_icmpStatsTable();
    init_icmpMsgStatsTable();
    init_ipNetToPhysicalTable();
    init_ipDefaultRouterTable();
    init_ipv4InterfaceTable();
    init_ipv6InterfaceTable();
    init_ipv6ScopeZoneIndexTable();
}

