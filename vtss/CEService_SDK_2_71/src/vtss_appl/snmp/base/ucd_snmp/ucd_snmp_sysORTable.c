/*
 * 
 * Vitesse Switch Software.
 * 
 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 * 
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       It is based on UCD-SNMP APIs, we should not do any change unless the implement
//       is different with standard MIB definition. For example:
//       1. The specific OID is not supported.
//       2. The 'read-write' operation doesn't supported.
//       3. The specific variable range is different from standard definition.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* For header_generic() */

#include "ucd_snmp_sysORTable.h"
#include "sysORTable.h"


// #define SYSORTABLE_NOT_SUPPORTED       0   /* Excpetion case 1. */
// #define SYSORTABLE_ONLY_RO_SUPPORTED   1   /* Excpetion case 2. */
// #define SYSORTABLE_DIFFERENT_RANGE     1   /* Excpetion case 3. */


/******************************************************************************/
//
// Local data structure declaration
//
/******************************************************************************/
// The data structure for return value, UCD-SNMP engine needs as address point for processing get operation
typedef struct {
    long            long_ret;
    char            string_ret[SYSORTABLE_STR_LEN_MAX + 1];
    oid             objid_ret[SYSORTABLE_OID_LEN_MAX];
    size_t          objid_len_ret;
    u_long          ulong_ret;
} sysORTable_ret_t;


/******************************************************************************/
//
// Local function declarations
//
/******************************************************************************/
FindVarMethod   sysORTable_var;
FindVarMethod   sysORTable_var;


/******************************************************************************/
//
// Local variable declarations
//
/******************************************************************************/
/*
 * lint -esym(459, sysORTable_global_ret) 
 */
// The variable is protected by thread
// The UCD-SNMP engine needs as address point for processing get operation
static sysORTable_ret_t sysORTable_global_ret;

/*
 * sysORTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static oid      sysORTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 1, 9 };



/*
 * variable sysORTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the sysORTable mib section
 */

struct variable2 sysORTable_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define SYSORID		1
    {SYSORID, ASN_OBJECT_ID, RONLY, sysORTable_var, 2, {1, 2}},
#define SYSORDESCR		2
    {SYSORDESCR, ASN_OCTET_STR, RONLY, sysORTable_var, 2, {1, 3}},
#define SYSORUPTIME		3
    {SYSORUPTIME, ASN_TIMETICKS, RONLY, sysORTable_var, 2, {1, 4}},
};


/******************************************************************************/
// ucd_snmp_init_sysORTable()
// Initializes the UCD-SNMP-part of the SNMPv2-MIB:sysORTable.
/******************************************************************************/
void
ucd_snmp_init_sysORTable(void)
{
    DEBUGMSGTL(("sysORTable", "Initializing\n"));

    // Register mib tree to UCD-SNMP core engine
    REGISTER_MIB("sysORTable", sysORTable_variables, variable2,
                 sysORTable_variables_oid);
}


/******************************************************************************/
//
// Variable scalar functions
//
/******************************************************************************/

/******************************************************************************/
// sysORTable_parse()
// Parse the table entry key from #name.
//
// Returns:
//  -1 on error
//   0 on getnext or getexact
//   1 on getfirst
/******************************************************************************/
static int
sysORTable_parse(oid * name,
                 size_t *length,
                 int exact, sysORTable_entry_t * table_entry)
{
    size_t          op_pos = 8 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (8 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (sysORTableEntry_getfirst(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->sysORIndex = (long) *op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

/******************************************************************************/
// sysORTable_fillobj()
// Fills in #name according to the table entry key.
/******************************************************************************/
static int
sysORTable_fillobj(oid * name,
                   size_t *length, sysORTable_entry_t * table_entry)
{
    int             name_pos = 8 + 2;

    name[name_pos++] = (oid) table_entry->sysORIndex;

    *length = name_pos;
    return 0;
}


/******************************************************************************/
//
// Variable table functions
//
/******************************************************************************/
/*
 * sysORTable_var():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for sysORTable_var above.
 */
u_char         *
sysORTable_var(struct variable * vp,
               oid * name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod ** write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    sysORTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = sysORTable_parse(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (sysORTable_fillobj(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (sysORTableEntry_get(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (sysORTable_fillobj(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SYSORID:{
            memcpy(sysORTable_global_ret.objid_ret, table_entry.sysORID,
                   table_entry.sysORID_len * sizeof(oid));
            *var_len = table_entry.sysORID_len * sizeof(oid);
            return (u_char *) sysORTable_global_ret.objid_ret;
        }
    case SYSORDESCR:{
            *var_len = table_entry.sysORDescr_len;
            memcpy(sysORTable_global_ret.string_ret,
                   table_entry.sysORDescr, *var_len);
            sysORTable_global_ret.string_ret[*var_len] = '\0';
            return (u_char *) sysORTable_global_ret.string_ret;
        }
    case SYSORUPTIME:{
            sysORTable_global_ret.ulong_ret = table_entry.sysORUpTime;
            *var_len = sizeof(sysORTable_global_ret.ulong_ret);
            return (u_char *) & sysORTable_global_ret.ulong_ret;
        }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_sysORTable\n",
                    vp->magic));
    }
    return NULL;
}


/******************************************************************************/
//
// Write scalar functions
//
/******************************************************************************/


/******************************************************************************/
//
// Write table functions
//
/******************************************************************************/
