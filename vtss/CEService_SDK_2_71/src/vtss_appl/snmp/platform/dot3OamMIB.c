/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.2 2007/09/04 06:33:18 pchen Exp $
 */

#include <main.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */

#include "msg_api.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"

#ifdef VTSS_SW_OPTION_ETH_LINK_OAM
#include "vtss_eth_link_oam_api.h"
#include "vtss_eth_link_oam_base_api.h"
#include "eth_link_oam_api.h"
#include "vtss_eth_link_oam_control_api.h"
#include "cli_trace_def.h"
#include "dot3OamMIB.h"
#endif
#include "mibContextTable.h"  //mibContextTable_register

/*
 * +++ Start (Internal implementation declarations)
 */

/*******************************************************************************
*Purpose    : Retrieves the Local OAM Table entries for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamTable_entry(int isid, int table_index, dot3OamTable_entry_t *table_entry)
{
    vtss_eth_link_oam_conf_t            conf;
    vtss_eth_link_oam_info_tlv_t        local_info;
    iftable_info_t                      table_info;
    vtss_eth_link_oam_discovery_state_t state;
    u16                                 mtu_size;
    u16                                 temp;
    u8                                  func_support = 0;

    memset(&conf, 0, sizeof(conf));
    memset(&local_info, 0, sizeof(local_info));

    if (!get_ifTableIndex_info (table_index, &table_info)) {
        return FALSE;
    }

    memset(table_entry, 0, sizeof(dot3OamTable_entry_t));

    if (!PORT_NO_IS_STACK(table_info.if_id) && eth_link_oam_mgmt_port_conf_get(isid, table_info.if_id, &conf) == VTSS_OK ) {
        if (eth_link_oam_client_port_local_info_get (isid, table_info.if_id, &local_info) == VTSS_RC_OK) {
            table_entry->dot3OamAdminState = conf.oam_control ? LINK_OAM_ADMIN_ENABLED : LINK_OAM_ADMIN_DISABLED;
            if (eth_link_oam_control_layer_port_discovery_state_get(isid, table_info.if_id, &state) != VTSS_RC_OK) {
                return FALSE;
            } else {
                switch (state) {
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_FAULT:
                    table_entry->dot3OamOperStatus = LINK_OAM_LINK_FAULT;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_ACTIVE_SEND_LOCAL:
                    table_entry->dot3OamOperStatus = LINK_OAM_ACTIVE_SEND_LOCAL;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_PASSIVE_WAIT:
                    table_entry->dot3OamOperStatus = LINK_OAM_PASSIVE_WAIT;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_LOCAL_REMOTE:
                    table_entry->dot3OamOperStatus = LINK_OAM_SEND_LOCAL_AND_REMOTE;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_LOCAL_REMOTE_OK:
                    table_entry->dot3OamOperStatus = LINK_OAM_SEND_LOCAL_AND_REMOTE_OK;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_SEND_ANY:
                    table_entry->dot3OamOperStatus = LINK_OAM_OPERATIONAL;
                    break;
                case VTSS_ETH_LINK_OAM_DISCOVERY_STATE_LAST:
                    table_entry->dot3OamOperStatus = LINK_OAM_DISABLED;
                    break;
                default:
                    table_entry->dot3OamOperStatus = LINK_OAM_DISABLED;
                }
            }
            table_entry->dot3OamMode = IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_MODE) ? LINK_OAM_ACTIVE : LINK_OAM_PASSIVE;
            memcpy(&mtu_size, local_info.oampdu_conf, sizeof(u16));
            mtu_size = NET2HOSTS(mtu_size);
            table_entry->dot3OamMaxOamPduSize = mtu_size;
            memcpy(&temp, local_info.revision, sizeof(temp));
            temp = NET2HOSTS(temp);
            table_entry->dot3OamConfigRevision = temp;
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_UNI_DIRECTIONAL_SUPPORT)) {
                func_support |= LINK_OAM_UNI_DIRECTIONAL_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_REMOTE_LOOP_BACK_CONTROL_SUPPORT)) {
                func_support |= LINK_OAM_LOOPBACK_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_LINK_EVENTS_SUPPORT)) {
                func_support |= LINK_OAM_EVENT_SUPPORT;
            }
            if (IS_CONF_ACTIVE(local_info.oam_conf, VTSS_ETH_LINK_OAM_CONF_VARIABLE_RETRIVEL_SUPPORT)) {
                func_support |= LINK_OAM_VARIABLE_SUPPORT;
            }
            table_entry->dot3OamFunctionsSupported = func_support;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}
/*******************************************************************************
*Purpose    : Retrieves the Peer OAM Table entries for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamPeerTable_entry(int isid, int table_index, dot3OamPeerTable_entry_t *table_entry)
{
    vtss_eth_link_oam_info_tlv_t        remote_info;
    iftable_info_t                      table_info;
    u8                                  func_support    = 0;
    u16                                 remote_temp     = 0;
    u16                                 remote_mtu_size = 0;

    memset(&remote_info, 0, sizeof(remote_info));

    if (!get_ifTableIndex_info (table_index, &table_info)) {
        return FALSE;
    }

    memset(table_entry, 0, sizeof(dot3OamPeerTable_entry_t));
    if (eth_link_oam_client_port_remote_info_get(isid, table_info.if_id,
                                                 &remote_info) != VTSS_RC_OK) {
        return FALSE;
    } else {
        if (eth_link_oam_client_port_remote_mac_addr_info_get(isid, table_info.if_id,
                                                              table_entry->dot3OamPeerMacAddress) != VTSS_RC_OK) {
            return FALSE;
        }
        memcpy(&remote_temp, remote_info.revision, sizeof(remote_temp));
        remote_temp = NET2HOSTS(remote_temp);
        memcpy(&remote_mtu_size, remote_info.oampdu_conf, sizeof(u16));
        remote_mtu_size = NET2HOSTS(remote_mtu_size);
    }
    memcpy(table_entry->dot3OamPeerVendorOui, remote_info.oui,
           sizeof(table_entry->dot3OamPeerVendorOui));
    table_entry->dot3OamPeerMode = IS_CONF_ACTIVE(remote_info.oam_conf,
                                                  VTSS_ETH_LINK_OAM_CONF_MODE) ? LINK_OAM_ACTIVE : LINK_OAM_PASSIVE ;
    table_entry->dot3OamPeerMaxOamPduSize = remote_mtu_size;
    table_entry->dot3OamPeerConfigRevision = remote_temp;
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_UNI_DIRECTIONAL_SUPPORT)) {
        func_support |= LINK_OAM_UNI_DIRECTIONAL_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_REMOTE_LOOP_BACK_CONTROL_SUPPORT)) {
        func_support |= LINK_OAM_LOOPBACK_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_LINK_EVENTS_SUPPORT)) {
        func_support |= LINK_OAM_EVENT_SUPPORT;
    }
    if (IS_CONF_ACTIVE(remote_info.oam_conf,
                       VTSS_ETH_LINK_OAM_CONF_VARIABLE_RETRIVEL_SUPPORT)) {
        func_support |= LINK_OAM_VARIABLE_SUPPORT;
    }
    table_entry->dot3OamPeerFunctionsSupported = func_support;
    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM Loopback configuration for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamLoopbackTable_entry(int isid, int table_index, dot3OamLoopbackTable_entry_t *table_entry)
{
    vtss_eth_link_oam_loopback_status_t loop_status;
    iftable_info_t                      table_info;


    if (!get_ifTableIndex_info (table_index, &table_info)) {
        return FALSE;
    }

    memset(table_entry, 0, sizeof(dot3OamLoopbackTable_entry_t));
    if (eth_link_oam_port_loopback_oper_status_get(isid, table_info.if_id, &loop_status) != VTSS_RC_OK) {
        return FALSE;
    } else {
        table_entry->dot3OamLoopbackStatus = loop_status;
        table_entry->dot3OamLoopbackIgnoreRx = LINK_OAM_LOOPBACK_PROCESS;
    }

    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM statistics information for a particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamStatsTable_entry(int isid, int table_index, dot3OamStatsTable_entry_t *table_entry)
{
    iftable_info_t                        table_info;
    vtss_rc                               rc;
    vtss_eth_link_oam_control_port_conf_t port_stats;

    if (!get_ifTableIndex_info (table_index, &table_info)) {
        return FALSE;
    }

    memset(&port_stats, 0, sizeof(port_stats));
    rc = eth_link_oam_control_layer_port_pdu_stats_get(isid, table_info.if_id, &port_stats.oam_stats);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    table_entry->dot3OamInformationRx = port_stats.oam_stats.information_rx;
    table_entry->dot3OamInformationTx = port_stats.oam_stats.information_tx;
    table_entry->dot3OamUniqueEventNotificationRx = port_stats.oam_stats.unique_event_notification_rx;
    table_entry->dot3OamUniqueEventNotificationTx = port_stats.oam_stats.unique_event_notification_tx;
    table_entry->dot3OamDuplicateEventNotificationRx = port_stats.oam_stats.duplicate_event_notification_rx;
    table_entry->dot3OamDuplicateEventNotificationTx = port_stats.oam_stats.duplicate_event_notification_tx;
    table_entry->dot3OamLoopbackControlRx = port_stats.oam_stats.loopback_control_rx;
    table_entry->dot3OamLoopbackControlTx = port_stats.oam_stats.loopback_control_tx;
    table_entry->dot3OamVariableRequestRx = port_stats.oam_stats.variable_request_rx;
    table_entry->dot3OamVariableRequestTx = port_stats.oam_stats.variable_request_tx;
    table_entry->dot3OamVariableResponseRx = port_stats.oam_stats.variable_response_rx;
    table_entry->dot3OamVariableResponseTx = port_stats.oam_stats.variable_response_tx;
    table_entry->dot3OamOrgSpecificRx = port_stats.oam_stats.org_specific_rx;
    table_entry->dot3OamOrgSpecificTx = port_stats.oam_stats.org_specific_tx;
    table_entry->dot3OamUnsupportedCodesRx = port_stats.oam_stats.unsupported_codes_rx;
    table_entry->dot3OamUnsupportedCodesTx = port_stats.oam_stats.unsupported_codes_tx;
    table_entry->dot3OamFramesLostDueToOam = 0;

    return TRUE;
}

/*******************************************************************************
*Purpose    : Retrieves the OAM Event specific Configuration information for a
              particular Port.
*Arguments  : isid: Internal switch Id, table_index: Index of the table (uport),
              table_entry: Pointer to the table entry to store the data
*Re-entrant : Must be Re-entrant.
*******************************************************************************/
BOOL get_dot3OamEventConfigTable_entry(int isid, int table_index, dot3OamEventConfigTable_entry_t *table_entry)
{
    iftable_info_t                                          table_info;
    vtss_rc                                                 rc;
    const int                                               endian = 1;
    char                                                    *p = (char *)&endian;
    u64                                                     temp_symbol_period;
    u64                                                     temp_symbol_threshold;
    u8                                                      *temp_ptr = (u8 *)&temp_symbol_period;
    BOOL                                                    little_endian;
    u16                                                     temp_err_frame_secs_summary_window = 0;
    vtss_eth_link_oam_error_frame_event_tlv_t               error_frame_tlv;
    vtss_eth_link_oam_error_frame_event_tlv_t               remote_error_frame_tlv;
    vtss_eth_link_oam_error_frame_period_event_tlv_t        error_frame_period_tlv;
    vtss_eth_link_oam_error_frame_period_event_tlv_t        remote_error_frame_period_tlv;
    vtss_eth_link_oam_error_symbol_period_event_tlv_t       error_symbol_period_tlv;
    vtss_eth_link_oam_error_symbol_period_event_tlv_t       remote_error_symbol_period_tlv;
    vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t  local_secs_info;
    vtss_eth_link_oam_error_frame_secs_summary_event_tlv_t  remote_secs_info;

    memset(&error_symbol_period_tlv, 0, sizeof(error_symbol_period_tlv));
    memset(&remote_error_symbol_period_tlv, 0, sizeof(remote_error_symbol_period_tlv));
    memset(&error_frame_period_tlv, 0, sizeof(error_frame_period_tlv));
    memset(&remote_error_frame_period_tlv, 0, sizeof(remote_error_frame_period_tlv));
    memset(&error_frame_tlv, 0, sizeof(error_frame_tlv));
    memset(&remote_error_frame_tlv, 0, sizeof(remote_error_frame_tlv));
    memset(&local_secs_info, 0, sizeof(local_secs_info));
    memset(&remote_secs_info, 0, sizeof(remote_secs_info));

    if (!get_ifTableIndex_info (table_index, &table_info)) {
        return FALSE;
    }

    rc = eth_link_oam_client_port_symbol_period_error_info_get(isid, table_info.if_id,
                                                               &error_symbol_period_tlv,
                                                               &remote_error_symbol_period_tlv);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_client_port_frame_error_info_get(isid, table_info.if_id,
                                                       &error_frame_tlv,
                                                       &remote_error_frame_tlv);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_client_port_frame_period_error_info_get(isid, table_info.if_id,
                                                              &error_frame_period_tlv,
                                                              &remote_error_frame_period_tlv);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    rc = eth_link_oam_client_port_error_frame_secs_summary_info_get(isid, table_info.if_id, &local_secs_info, &remote_secs_info);

    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    if (*p) {
        little_endian = TRUE;
    } else {
        little_endian = FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(isid, table_info.if_id, &temp_symbol_period);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(isid, table_info.if_id, &temp_symbol_threshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    if (little_endian) {
        memcpy(&table_entry->dot3OamErrSymPeriodWindowLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowLo));
        temp_ptr = temp_ptr + 4;
        memcpy(&table_entry->dot3OamErrSymPeriodWindowHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowHi));
        temp_ptr = (u8 *)&temp_symbol_threshold;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdLo));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdHi));
    } else {
        memcpy(&table_entry->dot3OamErrSymPeriodWindowHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowHi));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodWindowLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodWindowLo));
        temp_ptr = (u8 *) &temp_symbol_threshold;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdHi, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdHi));
        temp_ptr += 4;
        memcpy(&table_entry->dot3OamErrSymPeriodThresholdLo, temp_ptr, sizeof(table_entry->dot3OamErrSymPeriodThresholdLo));
    }
    table_entry->dot3OamErrSymPeriodEvNotifEnable = TRUE;
    rc = eth_link_oam_mgmt_port_link_frame_period_error_window_get(isid, table_info.if_id, &table_entry->dot3OamErrFramePeriodWindow);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    rc = eth_link_oam_mgmt_port_link_frame_period_error_threshold_get(isid, table_info.if_id, &table_entry->dot3OamErrFramePeriodThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    table_entry->dot3OamErrFramePeriodEvNotifEnable = TRUE;
    rc = eth_link_oam_mgmt_port_link_error_frame_window_get(isid, table_info.if_id, (u16 *)&table_entry->dot3OamErrFrameWindow);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    rc = eth_link_oam_mgmt_port_link_error_frame_threshold_get(isid, table_info.if_id, &table_entry->dot3OamErrFrameThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }
    table_entry->dot3OamErrFrameEvNotifEnable = TRUE;
    rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_window_get(isid, table_info.if_id, &temp_err_frame_secs_summary_window);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->dot3OamErrFrameSecsSummaryWindow = 10 * temp_err_frame_secs_summary_window;
    rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_threshold_get(isid, table_info.if_id, (u16 *)&table_entry->dot3OamErrFrameSecsSummaryThreshold);
    if (rc != VTSS_RC_OK) {
        return FALSE;
    }

    table_entry->dot3OamErrFrameSecsEvNotifEnable = TRUE;
    table_entry->dot3OamDyingGaspEnable = TRUE;
    table_entry->dot3OamCriticalEventEnable = TRUE;
    return TRUE;
}
/*
 * --- End (Internal implementation declarations)
 */

/*
 * dot3OamMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3OamMIB_variables_oid[] = { 1, 3, 6, 1, 2, 1, 158 };

/*
 * variable4 dot3OamMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the dot3OamMIB mib section
 */

struct variable4 dot3OamMIB_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3OAMADMINSTATE       1
    {
        DOT3OAMADMINSTATE, ASN_INTEGER, RWRITE, var_dot3OamTable, 4,
        {1, 1, 1, 1}
    },
#define DOT3OAMOPERSTATUS       2
    {
        DOT3OAMOPERSTATUS, ASN_INTEGER, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 2}
    },
#define DOT3OAMMODE     3
    {DOT3OAMMODE, ASN_INTEGER, RWRITE, var_dot3OamTable, 4, {1, 1, 1, 3}},
#define DOT3OAMMAXOAMPDUSIZE        4
    {
        DOT3OAMMAXOAMPDUSIZE, ASN_UNSIGNED, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 4}
    },
#define DOT3OAMCONFIGREVISION       5
    {
        DOT3OAMCONFIGREVISION, ASN_UNSIGNED, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 5}
    },
#define DOT3OAMFUNCTIONSSUPPORTED       6
    {
        DOT3OAMFUNCTIONSSUPPORTED, ASN_OCTET_STR, RONLY, var_dot3OamTable, 4,
        {1, 1, 1, 6}
    },
#define DOT3OAMPEERMACADDRESS       7
    {
        DOT3OAMPEERMACADDRESS, ASN_OCTET_STR, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 1}
    },
#define DOT3OAMPEERVENDOROUI        8
    {
        DOT3OAMPEERVENDOROUI, ASN_OCTET_STR, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 2}
    },
#define DOT3OAMPEERVENDORINFO       9
    {
        DOT3OAMPEERVENDORINFO, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 3}
    },
#define DOT3OAMPEERMODE     10
    {
        DOT3OAMPEERMODE, ASN_INTEGER, RONLY, var_dot3OamPeerTable, 4,
        {1, 2, 1, 4}
    },
#define DOT3OAMPEERMAXOAMPDUSIZE        11
    {
        DOT3OAMPEERMAXOAMPDUSIZE, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable,
        4, {1, 2, 1, 5}
    },
#define DOT3OAMPEERCONFIGREVISION       12
    {
        DOT3OAMPEERCONFIGREVISION, ASN_UNSIGNED, RONLY, var_dot3OamPeerTable,
        4, {1, 2, 1, 6}
    },
#define DOT3OAMPEERFUNCTIONSSUPPORTED       13
    {
        DOT3OAMPEERFUNCTIONSSUPPORTED, ASN_OCTET_STR, RONLY,
        var_dot3OamPeerTable, 4, {1, 2, 1, 7}
    },
#define DOT3OAMLOOPBACKSTATUS       14
    {
        DOT3OAMLOOPBACKSTATUS, ASN_INTEGER, RWRITE, var_dot3OamLoopbackTable,
        4, {1, 3, 1, 1}
    },
#define DOT3OAMLOOPBACKIGNORERX     15
    {
        DOT3OAMLOOPBACKIGNORERX, ASN_INTEGER, RWRITE,
        var_dot3OamLoopbackTable, 4, {1, 3, 1, 2}
    },
#define DOT3OAMINFORMATIONTX        16
    {
        DOT3OAMINFORMATIONTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 1}
    },
#define DOT3OAMINFORMATIONRX        17
    {
        DOT3OAMINFORMATIONRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 2}
    },
#define DOT3OAMUNIQUEEVENTNOTIFICATIONTX        18
    {
        DOT3OAMUNIQUEEVENTNOTIFICATIONTX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 3}
    },
#define DOT3OAMUNIQUEEVENTNOTIFICATIONRX        19
    {
        DOT3OAMUNIQUEEVENTNOTIFICATIONRX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 4}
    },
#define DOT3OAMDUPLICATEEVENTNOTIFICATIONTX     20
    {
        DOT3OAMDUPLICATEEVENTNOTIFICATIONTX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 5}
    },
#define DOT3OAMDUPLICATEEVENTNOTIFICATIONRX     21
    {
        DOT3OAMDUPLICATEEVENTNOTIFICATIONRX, ASN_COUNTER, RONLY,
        var_dot3OamStatsTable, 4, {1, 4, 1, 6}
    },
#define DOT3OAMLOOPBACKCONTROLTX        22
    {
        DOT3OAMLOOPBACKCONTROLTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 7}
    },
#define DOT3OAMLOOPBACKCONTROLRX        23
    {
        DOT3OAMLOOPBACKCONTROLRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 8}
    },
#define DOT3OAMVARIABLEREQUESTTX        24
    {
        DOT3OAMVARIABLEREQUESTTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 9}
    },
#define DOT3OAMVARIABLEREQUESTRX        25
    {
        DOT3OAMVARIABLEREQUESTRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 10}
    },
#define DOT3OAMVARIABLERESPONSETX       26
    {
        DOT3OAMVARIABLERESPONSETX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 11}
    },
#define DOT3OAMVARIABLERESPONSERX       27
    {
        DOT3OAMVARIABLERESPONSERX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 12}
    },
#define DOT3OAMORGSPECIFICTX        28
    {
        DOT3OAMORGSPECIFICTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 13}
    },
#define DOT3OAMORGSPECIFICRX        29
    {
        DOT3OAMORGSPECIFICRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable, 4,
        {1, 4, 1, 14}
    },
#define DOT3OAMUNSUPPORTEDCODESTX       30
    {
        DOT3OAMUNSUPPORTEDCODESTX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 15}
    },
#define DOT3OAMUNSUPPORTEDCODESRX       31
    {
        DOT3OAMUNSUPPORTEDCODESRX, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 16}
    },
#define DOT3OAMFRAMESLOSTDUETOOAM       32
    {
        DOT3OAMFRAMESLOSTDUETOOAM, ASN_COUNTER, RONLY, var_dot3OamStatsTable,
        4, {1, 4, 1, 17}
    },
#define DOT3OAMERRSYMPERIODWINDOWHI     33
    {
        DOT3OAMERRSYMPERIODWINDOWHI, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 1}
    },
#define DOT3OAMERRSYMPERIODWINDOWLO     34
    {
        DOT3OAMERRSYMPERIODWINDOWLO, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 2}
    },
#define DOT3OAMERRSYMPERIODTHRESHOLDHI      35
    {
        DOT3OAMERRSYMPERIODTHRESHOLDHI, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 3}
    },
#define DOT3OAMERRSYMPERIODTHRESHOLDLO      36
    {
        DOT3OAMERRSYMPERIODTHRESHOLDLO, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 4}
    },
#define DOT3OAMERRSYMPERIODEVNOTIFENABLE        37
    {
        DOT3OAMERRSYMPERIODEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 5}
    },
#define DOT3OAMERRFRAMEPERIODWINDOW     38
    {
        DOT3OAMERRFRAMEPERIODWINDOW, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 6}
    },
#define DOT3OAMERRFRAMEPERIODTHRESHOLD      39
    {
        DOT3OAMERRFRAMEPERIODTHRESHOLD, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 7}
    },
#define DOT3OAMERRFRAMEPERIODEVNOTIFENABLE      40
    {
        DOT3OAMERRFRAMEPERIODEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 8}
    },
#define DOT3OAMERRFRAMEWINDOW       41
    {
        DOT3OAMERRFRAMEWINDOW, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 9}
    },
#define DOT3OAMERRFRAMETHRESHOLD        42
    {
        DOT3OAMERRFRAMETHRESHOLD, ASN_UNSIGNED, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 10}
    },
#define DOT3OAMERRFRAMEEVNOTIFENABLE        43
    {
        DOT3OAMERRFRAMEEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 11}
    },
#define DOT3OAMERRFRAMESECSSUMMARYWINDOW        44
    {
        DOT3OAMERRFRAMESECSSUMMARYWINDOW, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 12}
    },
#define DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD     45
    {
        DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 13}
    },
#define DOT3OAMERRFRAMESECSEVNOTIFENABLE        46
    {
        DOT3OAMERRFRAMESECSEVNOTIFENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 14}
    },
#define DOT3OAMDYINGGASPENABLE      47
    {
        DOT3OAMDYINGGASPENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 15}
    },
#define DOT3OAMCRITICALEVENTENABLE      48
    {
        DOT3OAMCRITICALEVENTENABLE, ASN_INTEGER, RWRITE,
        var_dot3OamEventConfigTable, 4, {1, 5, 1, 16}
    },
};

/*
 * Initializes the dot3OamMIB module
 */
void
init_dot3OamMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(dot3OamMIB_variables_oid,
                             sizeof(dot3OamMIB_variables_oid) / sizeof(oid),
                             "Dot3-OAM-MIB : dot3OamMIB");

    DEBUGMSGTL(("dot3OamMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3OamMIB", dot3OamMIB_variables, variable4,
                 dot3OamMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_dot3OamMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_dot3OamMIB(struct variable *vp,
               oid *name,
               size_t *length,
               int exact, size_t *var_len, WriteMethod **write_method)
{

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamMIB\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    int                  table_size;
    int                  idx_num;
    int                  table_index;
    dot3OamTable_entry_t table_entry;
    vtss_isid_t          isid;
    static u32           ulong_ret;
    static u8            string;

    table_size = L2_MAX_PORTS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index =  get_available_ifTableIndex (idx_num);

    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    memset(&table_entry, 0, sizeof(table_entry));

    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        if (!get_dot3OamTable_entry(isid, table_index, &table_entry)) {
            return NULL;
        }
        break;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMADMINSTATE: {
        *write_method = write_dot3OamAdminState;
        ulong_ret = table_entry.dot3OamAdminState;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMOPERSTATUS: {
        ulong_ret = table_entry.dot3OamOperStatus;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMMODE: {
        *write_method = write_dot3OamMode;
        ulong_ret = table_entry.dot3OamMode;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMMAXOAMPDUSIZE: {
        ulong_ret = table_entry.dot3OamMaxOamPduSize;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMCONFIGREVISION: {
        ulong_ret = table_entry.dot3OamConfigRevision;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMFUNCTIONSSUPPORTED: {
        string = table_entry.dot3OamFunctionsSupported;
        *var_len = sizeof(table_entry.dot3OamFunctionsSupported);
        return (u_char *)&string;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamPeerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamPeerTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    dot3OamPeerTable_entry_t table_entry;
    vtss_isid_t              isid;
    static u32               ulong_ret;
    static u8                string[SPRINT_MAX_LEN];
    static u8                peer_functions;
    int                      table_index;
    table_size = L2_MAX_PORTS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index =  get_available_ifTableIndex (idx_num);

    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    memset(&table_entry, 0, sizeof(table_entry));

    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        if (exact) {
            if (!get_dot3OamPeerTable_entry(isid, table_index, &table_entry)) {
                return NULL;
            }
        } else {
            while ((table_index <= table_size) && !get_dot3OamPeerTable_entry(isid, table_index, &table_entry)) {
                table_index++;
            }
            if (table_index > table_size) {
                return NULL;
            }
        }
        break;
    }

    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMPEERMACADDRESS: {
        memset(string, 0, sizeof(string));
        memcpy(string, table_entry.dot3OamPeerMacAddress, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE ;
        return (u_char *)string;
    }
    case DOT3OAMPEERVENDOROUI: {
        memset(string, 0, sizeof(string));
        memcpy(string, table_entry.dot3OamPeerVendorOui, LINK_OAM_VENDOR_OUI_LEN);
        *var_len = LINK_OAM_VENDOR_OUI_LEN;
        return (u_char *)string;
    }
    case DOT3OAMPEERVENDORINFO: {
        /*NOT SUPPORTED*/
        ulong_ret = table_entry.dot3OamPeerVendorInfo;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERMODE: {
        ulong_ret = table_entry.dot3OamPeerMode;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERMAXOAMPDUSIZE: {
        ulong_ret = table_entry.dot3OamPeerMaxOamPduSize;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERCONFIGREVISION: {
        ulong_ret = table_entry.dot3OamPeerConfigRevision;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMPEERFUNCTIONSSUPPORTED: {
        peer_functions = table_entry.dot3OamPeerFunctionsSupported;
        *var_len = sizeof(u8);
        return (u_char *)&peer_functions;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3OamPeerTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamLoopbackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamLoopbackTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{

    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    dot3OamLoopbackTable_entry_t table_entry;
    int                      table_index;
    vtss_isid_t              isid;

    table_size = L2_MAX_PORTS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index =  get_available_ifTableIndex (idx_num);

    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    memset(&table_entry, 0, sizeof(table_entry));
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        if (exact) {
            if (!get_dot3OamLoopbackTable_entry(isid, table_index, &table_entry)) {
                return NULL;
            }
        } else {
            while ((table_index <= table_size) && !get_dot3OamLoopbackTable_entry(isid, table_index, &table_entry)) {
                table_index++;
            }
            if (table_index > table_size) {
                return NULL;
            }
        }
        break;
    }

    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMLOOPBACKSTATUS: {
        *write_method = write_dot3OamLoopbackStatus;
        ulong_ret = table_entry.dot3OamLoopbackStatus;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMLOOPBACKIGNORERX: {
        //*write_method = write_dot3OamLoopbackIgnoreRx;
        ulong_ret = table_entry.dot3OamLoopbackIgnoreRx;
        return (u_char *)&ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamLoopbackTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamStatsTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    int                      table_index;
    vtss_isid_t              isid;


    dot3OamStatsTable_entry_t table_entry;

    table_size = L2_MAX_PORTS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];

    table_index =  get_available_ifTableIndex (idx_num);

    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    memset(&table_entry, 0, sizeof(table_entry));
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        if (!get_dot3OamStatsTable_entry(isid, table_index, &table_entry)) {
            return NULL;
        }
        break;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMINFORMATIONTX: {
        ulong_ret = table_entry.dot3OamInformationTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMINFORMATIONRX: {
        ulong_ret = table_entry.dot3OamInformationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMUNIQUEEVENTNOTIFICATIONTX: {
        ulong_ret = table_entry.dot3OamUniqueEventNotificationTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNIQUEEVENTNOTIFICATIONRX: {
        ulong_ret = table_entry.dot3OamUniqueEventNotificationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMDUPLICATEEVENTNOTIFICATIONTX: {
        ulong_ret = table_entry.dot3OamDuplicateEventNotificationTx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMDUPLICATEEVENTNOTIFICATIONRX: {
        ulong_ret = table_entry.dot3OamDuplicateEventNotificationRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMLOOPBACKCONTROLTX: {
        ulong_ret = table_entry.dot3OamLoopbackControlTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMLOOPBACKCONTROLRX: {
        ulong_ret = table_entry.dot3OamLoopbackControlRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLEREQUESTTX: {
        ulong_ret = table_entry.dot3OamVariableRequestTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMVARIABLEREQUESTRX: {
        ulong_ret = table_entry.dot3OamVariableRequestRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLERESPONSETX: {
        ulong_ret = table_entry.dot3OamVariableResponseTx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMVARIABLERESPONSERX: {
        ulong_ret = table_entry.dot3OamVariableResponseRx;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMORGSPECIFICTX: {
        ulong_ret = table_entry.dot3OamOrgSpecificTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMORGSPECIFICRX: {
        ulong_ret = table_entry.dot3OamOrgSpecificRx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNSUPPORTEDCODESTX: {
        ulong_ret = table_entry.dot3OamUnsupportedCodesTx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMUNSUPPORTEDCODESRX: {
        ulong_ret = table_entry.dot3OamUnsupportedCodesRx;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMFRAMESLOSTDUETOOAM: {
        ulong_ret = 0;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3OamEventConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot3OamMIB above.
 */
u_char         *
var_dot3OamEventConfigTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    int                      table_size;
    int                      idx_num;
    static u32               ulong_ret;
    int                      table_index;
    vtss_isid_t              isid;
    dot3OamEventConfigTable_entry_t table_entry;

    table_size = L2_MAX_PORTS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index =  get_available_ifTableIndex (idx_num);

    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    memset(&table_entry, 0, sizeof(table_entry));
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        memset(&table_entry, 0, sizeof(table_entry));
        if (!get_dot3OamEventConfigTable_entry(isid, table_index, &table_entry)) {
            return NULL;
        }
        break;
    }

    /*
    * Save this one as the "next one", if "table_index" is not sequence
    */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3OAMERRSYMPERIODWINDOWHI: {
        *write_method = write_dot3OamErrSymPeriodWindowHi;
        ulong_ret = table_entry.dot3OamErrSymPeriodWindowHi;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODWINDOWLO: {
        *write_method = write_dot3OamErrSymPeriodWindowLo;
        ulong_ret = table_entry.dot3OamErrSymPeriodWindowLo;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODTHRESHOLDHI: {
        *write_method = write_dot3OamErrSymPeriodThresholdHi;
        ulong_ret = table_entry.dot3OamErrSymPeriodThresholdHi;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODTHRESHOLDLO: {
        *write_method = write_dot3OamErrSymPeriodThresholdLo;
        ulong_ret = table_entry.dot3OamErrSymPeriodThresholdLo;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRSYMPERIODEVNOTIFENABLE: {
        //*write_method = write_dot3OamErrSymPeriodEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrSymPeriodEvNotifEnable;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMEPERIODWINDOW: {
        *write_method = write_dot3OamErrFramePeriodWindow;
        ulong_ret = table_entry.dot3OamErrFramePeriodWindow;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMEPERIODTHRESHOLD: {
        *write_method = write_dot3OamErrFramePeriodThreshold;
        ulong_ret = table_entry.dot3OamErrFramePeriodThreshold;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMEPERIODEVNOTIFENABLE: {
        //*write_method = write_dot3OamErrFramePeriodEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFramePeriodEvNotifEnable;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMEWINDOW: {
        *write_method = write_dot3OamErrFrameWindow;
        ulong_ret = table_entry.dot3OamErrFrameWindow;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMETHRESHOLD: {
        *write_method = write_dot3OamErrFrameThreshold;
        ulong_ret = table_entry.dot3OamErrFrameThreshold;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMERRFRAMEEVNOTIFENABLE: {
        //*write_method = write_dot3OamErrFrameEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFrameEvNotifEnable;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMESECSSUMMARYWINDOW: {
        *write_method = write_dot3OamErrFrameSecsSummaryWindow;
        ulong_ret = table_entry.dot3OamErrFrameSecsSummaryWindow;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD: {
        *write_method = write_dot3OamErrFrameSecsSummaryThreshold;
        ulong_ret = table_entry.dot3OamErrFrameSecsSummaryThreshold;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMERRFRAMESECSEVNOTIFENABLE: {
        //*write_method = write_dot3OamErrFrameSecsEvNotifEnable;
        ulong_ret = table_entry.dot3OamErrFrameSecsEvNotifEnable;
        return (u_char *)&ulong_ret;
    }
    case DOT3OAMDYINGGASPENABLE: {
        //*write_method = write_dot3OamDyingGaspEnable;
        ulong_ret = table_entry.dot3OamDyingGaspEnable;
        return (u_char *) &ulong_ret;
    }
    case DOT3OAMCRITICALEVENTENABLE: {
        //*write_method = write_dot3OamCriticalEventEnable;
        ulong_ret = table_entry.dot3OamCriticalEventEnable;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3OamEventConfigTable\n",
                    vp->magic));
    }
    return NULL;
}

int
write_dot3OamAdminState(int action,
                        u_char *var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char *statP, oid *name, size_t name_len)
{
    u_long                 *buf, *old_buf;
    u_long                 temp_buf, temp_old_buf;
    int                    log_rc = 0;
    vtss_isid_t            isid = 0;
    int                    port_num;
    iftable_info_t         table_info;
    vtss_rc                rc;
    size_t                 max_size;
    u_long                 intval;

    port_num = name[name_len - 1];
    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_ADMIN_ENABLED && intval != LINK_OAM_ADMIN_DISABLED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamAdminState: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        if (intval == LINK_OAM_ADMIN_ENABLED) {
            rc = eth_link_oam_mgmt_port_control_conf_set(isid, table_info.if_id, VTSS_ETH_LINK_OAM_CONTROL_ENABLE );
        } else {
            rc = eth_link_oam_mgmt_port_control_conf_set(isid, table_info.if_id, VTSS_ETH_LINK_OAM_CONTROL_DISABLE );
        }

        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamMode(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u_long          intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamMode: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR, "write to dot3OamMode: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_PASSIVE && intval != LINK_OAM_ACTIVE) {
            log_rc = snmp_log(LOG_ERR, "write to dot3OamMode: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }

        if (intval == LINK_OAM_PASSIVE) {
            rc = eth_link_oam_mgmt_port_mode_conf_set(isid, table_info.if_id, VTSS_ETH_LINK_OAM_MODE_PASSIVE);
        } else {
            rc = eth_link_oam_mgmt_port_mode_conf_set(isid, table_info.if_id, VTSS_ETH_LINK_OAM_MODE_ACTIVE);
        }

        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamLoopbackStatus(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    u_long                 *buf, *old_buf;
    u_long                 temp_buf, temp_old_buf;
    size_t                 max_size;
    u_long                 intval;
    vtss_rc                rc;
    int                    log_rc;
    vtss_isid_t            isid = 0;
    u32                    port_num;
    iftable_info_t         table_info;
    int                    loopback;
    int                    table_index;
    dot3OamLoopbackTable_entry_t table_entry;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != LINK_OAM_INITIATING_LOOPBACK && intval != LINK_OAM_TERMINATING_LOOPBACK) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamLoopbackStatus: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        table_index = get_available_ifTableIndex(port_num);

        if (!get_dot3OamLoopbackTable_entry(isid, table_index, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }

        if (intval == LINK_OAM_INITIATING_LOOPBACK ) {
            loopback = TRUE;
        } else {
            loopback = FALSE;
        }

        if (table_entry.dot3OamLoopbackStatus != LINK_OAM_NO_LOOPBACK &&
            table_entry.dot3OamLoopbackStatus != LINK_OAM_REMOTE_LOOPBACK) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (table_entry.dot3OamLoopbackStatus != LINK_OAM_NO_LOOPBACK &&
            intval == LINK_OAM_INITIATING_LOOPBACK) {
            return SNMP_ERR_COMMITFAILED;
        }
        rc = eth_link_oam_mgmt_port_remote_loopback_oper_conf_set(isid, table_info.if_id,
                                                                  loopback);
        if ( rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodWindowHi(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u_long          intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;
    BOOL            little_endian;
    const int       endian = 1;
    char            *p = (char *)&endian;
    u64             temp_symbol_period;
    u8              *temp_ptr = (u8 *)&temp_symbol_period;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowHi: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowHi: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(isid, table_info.if_id, &temp_symbol_period);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_set(isid, table_info.if_id, temp_symbol_period);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodWindowLo(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u_long          intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;
    BOOL            little_endian;
    const int       endian = 1;
    char            *p = (char *)&endian;
    u64             temp_symbol_period;
    u8              *temp_ptr = (u8 *)&temp_symbol_period;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowLo: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodWindowLo: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }

        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_get(isid, table_info.if_id, &temp_symbol_period);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_window_set(isid, table_info.if_id, temp_symbol_period);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }

        *buf = *((u_long *) var_val);
        break;

    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodThresholdHi(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u_long          intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;
    const int       endian = 1;
    BOOL            little_endian;
    char            *p = (char *)&endian;
    u64             temp_symbol_threshold;
    u8              *temp_ptr = (u8 *)&temp_symbol_threshold;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdHi: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdHi: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }

        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(isid, table_info.if_id, &temp_symbol_threshold);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            memcpy(temp_ptr, &intval, sizeof(u32));
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_set(isid, table_info.if_id, temp_symbol_threshold);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrSymPeriodThresholdLo(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u_long          intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;
    const int       endian = 1;
    BOOL            little_endian;
    char            *p = (char *)&endian;
    u64             temp_symbol_threshold;
    u8              *temp_ptr = (u8 *)&temp_symbol_threshold;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u_long *) var_val);
    port_num = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdLo: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrSymPeriodThresholdLo: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }

        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        if (*p) {
            little_endian = TRUE;
        } else {
            little_endian = FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_get(isid, table_info.if_id, &temp_symbol_threshold);
        if (rc != VTSS_RC_OK) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (little_endian) {
            memcpy(temp_ptr, &intval, sizeof(u32));
        } else {
            temp_ptr += 4;
            memcpy(temp_ptr, &intval, sizeof(u32));
        }

        rc = eth_link_oam_mgmt_port_link_symbol_period_error_threshold_set(
                 isid, table_info.if_id, temp_symbol_threshold);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFramePeriodWindow(int action,
                                  u_char *var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char *statP,
                                  oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodWindow: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_frame_period_error_window_set(isid, table_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFramePeriodThreshold(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodThreshold: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFramePeriodThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_frame_period_error_threshold_set(isid, table_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot3OamErrFrameWindow(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameWindow: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_error_frame_window_set(isid, table_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameThreshold(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameThreshold: not ASN_UNSIGNED\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_error_frame_threshold_set(isid, table_info.if_id, intval);

        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameSecsSummaryWindow(int action,
                                       u_char *var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char *statP,
                                       oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > LINK_OAM_FRAME_SECS_SUMMARY_WINDOW_MAX || intval < LINK_OAM_FRAME_SECS_SUMMARY_WINDOW_MIN) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryWindow: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;

        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_window_set(isid, table_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameSecsSummaryThreshold(int action,
                                          u_char *var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char *statP,
                                          oid *name, size_t name_len)
{
    u_long          *buf, *old_buf;
    u_long          temp_buf, temp_old_buf;
    size_t          max_size;
    u32             intval;
    vtss_rc         rc;
    int             log_rc;
    vtss_isid_t     isid = 0;
    u32             port_num;
    iftable_info_t  table_info;

    buf = &temp_buf;
    old_buf = &temp_old_buf;
    max_size = sizeof(u_long);
    intval = *((u32 *) var_val);
    port_num = name[name_len - 1];


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: not ASN_INTEGER\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: bad length\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > LINK_OAM_FRAME_SECS_SUMMARY_THRESHOLD_MAX || intval <= LINK_OAM_FRAME_SECS_SUMMARY_THRESHOLD_MIN) {
            log_rc = snmp_log(LOG_ERR,
                              "write to dot3OamErrFrameSecsSummaryThreshold: bad value\n");
            SNMP_DEBUG_LOG_ERROR_OAM;
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (msg_switch_exists (isid) == FALSE) {
                continue;
            } /* end of if */
            break;
        }

        if (!get_ifTableIndex_info (port_num, &table_info)) {
            return FALSE;
        }
        rc = eth_link_oam_mgmt_port_link_error_frame_secs_summary_threshold_set(isid, table_info.if_id, intval);
        if (rc != VTSS_RC_OK && rc != ETH_LINK_OAM_RC_ALREADY_CONFIGURED) {
            return SNMP_ERR_COMMITFAILED;
        }
        *buf = *((u_long *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}


