/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

/* We *have* serialized access */

#include <main.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "ieee8023_lag_mib.h"

#include "msg_api.h"

/*
 * +++ Start (Internal implementation declarations)
 */
#include "mgmt_api.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"
#include "lacp_api.h"
#include "vtss_lacp.h"
#include "mibContextTable.h"  //mibContextTable_register

#define AGGPORTLISTMAXSTRING   100

typedef struct {
    vtss_common_macaddr_t   dot3adAggMACAddress;
    vtss_lacp_prio_t        dot3adAggActorSystemPriority;
    vtss_common_macaddr_t   dot3adAggActorSystemID;
    vtss_common_bool_t      dot3adAggAggregateOrIndividual;
    u_long                  dot3adAggActorAdminKey;
    u_long                  dot3adAggActorOperKey;
    vtss_common_macaddr_t   dot3adAggPartnerSystemID;
    vtss_lacp_prio_t        dot3adAggPartnerSystemPriority;
    u_long                  dot3adAggPartnerOperKey;
    u_long                  dot3adAggCollectorMaxDelay;
} dot3adAggTable_entry_t;

typedef struct {
    u_char                  dot3adAggPortListPorts[AGGPORTLISTMAXSTRING];
} dot3adAggPortListTable_entry_t;

typedef struct {
    vtss_lacp_prio_t        dot3adAggPortActorSystemPriority;
    vtss_common_macaddr_t   dot3adAggPortActorSystemID;
    u_long                  dot3adAggPortActorAdminKey;
    u_long                  dot3adAggPortActorOperKey;
    vtss_lacp_prio_t        dot3adAggPortPartnerOperSystemPriority;
    vtss_common_macaddr_t   dot3adAggPortPartnerOperSystemID;
    u_long                  dot3adAggPortPartnerOperKey;
    u_long                  dot3adAggPortAttachedAggID;
    u_long                  dot3adAggPortActorPort;
    u_long                  dot3adAggPortPartnerOperPort;
    vtss_lacp_prio_t        dot3adAggPortPartnerOperPortPriority;
    u_char                  dot3adAggPortActorAdminState;
    vtss_common_bool_t      dot3adAggPortAggregateOrIndividual;
} dot3adAggPortTable_entry_t;

typedef struct {
    vtss_common_counter_t   dot3adAggPortStatsLACPDUsRx;
    vtss_common_counter_t   dot3adAggPortStatsUnknownRx;
    vtss_common_counter_t   dot3adAggPortStatsIllegalRx;
    vtss_common_counter_t   dot3adAggPortStatsLACPDUsTx;
} dot3adAggPortStatsTable_entry_t;

static unsigned short   old_actor_admin_key[VTSS_ISID_CNT][VTSS_PORTS], now_actor_admin_key[VTSS_ISID_CNT][VTSS_PORTS];
static unsigned char    old_actor_admin_state[VTSS_ISID_CNT][VTSS_PORTS], now_actor_admin_state[VTSS_ISID_CNT][VTSS_PORTS];

/* Convert list to text */
char *iftable_ifindex_port_list2txt(vtss_common_bool_t *list, char *buf)
{
    int                  i, first = 1, count = 0;
    vtss_common_bool_t   member;
    char                 *p;
    vtss_port_no_t       switchport;
    vtss_isid_t          isid;
    int                  iftable_ifindex;
    iftable_info_t table_info;

    p = buf;
    *p = '\0';
    for (i = 0; i < VTSS_LACP_MAX_PORTS; i++) {
        member = list[i];
        if ((member && (count == 0 || i == VTSS_LACP_MAX_PORTS)) || (!member && count > 1)) {
            if (l2port2port(i + 1, &isid, &switchport)) {
                table_info.isid = isid;
                table_info.if_id = switchport;
                table_info.type = IFTABLE_IFINDEX_TYPE_PORT;
                if (FALSE == ifIndex_get_by_interface(&table_info)) {
                    table_info.type = IFTABLE_IFINDEX_TYPE_LLAG;
                    (void)ifIndex_get_by_interface(&table_info);
                }
                iftable_ifindex = table_info.ifIndex;
                p += sprintf(p, "%s%d",
                             first ? "" : count > (member ? 1 : 2) ? "-" : ",",
                             member ? iftable_ifindex : (iftable_ifindex - 1));
                first = 0;
            }
        }
        if (member) {
            count++;
        } else {
            count = 0;
        }
    }
    return buf;
}

BOOL get_dot3adAggTable_entry(int table_index, dot3adAggTable_entry_t *table_entry_p)
{
    iftable_info_t                  table_info;
    vtss_lacp_system_config_t       lacp_system_config;
    vtss_lacp_portstatus_t          lacp_portstatus;
    l2_port_no_t                    l2port;
    vtss_lacp_agid_t                aid;
    vtss_lacp_aggregatorstatus_t    lacp_aggregatorstatus;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    /* Search valid LACP LAG */
    for (aid = VTSS_PORT_NO_START; aid < (VTSS_LACP_MAX_AGGR + VTSS_PORT_NO_START); aid++) {
        if (lacp_mgmt_aggr_status_get(aid, &lacp_aggregatorstatus)) {
            if (lacp_to_aggr_id(aid) == table_info.if_id) {
                break;    // Found LACP LAG
            }
        }
    }

    if (aid >= VTSS_LACP_MAX_AGGR) { // Not found LACP LAG
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(dot3adAggTable_entry_t));

    /* Get system priority and system MAC */
    if (lacp_mgmt_system_conf_get(&lacp_system_config) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->dot3adAggActorSystemPriority = lacp_system_config.system_prio;
    vtss_os_get_systemmac(&table_entry_p->dot3adAggActorSystemID);
    table_entry_p->dot3adAggAggregateOrIndividual = TRUE;   // Always TRUE

    /* Get OID dot3adAggMACAddress */
    for (l2port = VTSS_PORT_NO_START; l2port < (VTSS_LACP_MAX_PORTS + VTSS_PORT_NO_START); l2port++) {
        if (lacp_aggregatorstatus.port_list[l2port - VTSS_PORT_NO_START]) {
            vtss_os_get_portmac(l2port, &table_entry_p->dot3adAggMACAddress);
            // get Actor AdminKey and OperKey
            if (lacp_mgmt_port_status_get(l2port, &lacp_portstatus) != VTSS_OK) {
                return FALSE;
            }
            table_entry_p->dot3adAggActorAdminKey = lacp_portstatus.actor_admin_port_key;
            table_entry_p->dot3adAggActorOperKey = lacp_portstatus.actor_oper_port_key;
            break;
        }
    }

    memcpy(&table_entry_p->dot3adAggPartnerSystemID, &lacp_aggregatorstatus.partner_oper_system, sizeof(vtss_common_macaddr_t));
    table_entry_p->dot3adAggPartnerSystemPriority = lacp_aggregatorstatus.partner_oper_system_priority;
    table_entry_p->dot3adAggPartnerOperKey = lacp_aggregatorstatus.partner_oper_key;
    table_entry_p->dot3adAggCollectorMaxDelay = 0;   // Always 0

    return TRUE;
}

BOOL get_dot3adAggPortListTable_entry(int table_index, dot3adAggPortListTable_entry_t *table_entry_p)
{
    iftable_info_t                 table_info;
    vtss_lacp_agid_t               aid;
    vtss_lacp_aggregatorstatus_t   lacp_aggregatorstatus;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    /* Search valid LACP LAG */
    for (aid = VTSS_PORT_NO_START; aid < (VTSS_LACP_MAX_AGGR + VTSS_PORT_NO_START); aid++) {
        if (lacp_mgmt_aggr_status_get(aid, &lacp_aggregatorstatus)) {
            if (lacp_to_aggr_id(aid) == table_info.if_id) {
                break;    // Found LACP LAG
            }
        }
    }

    if (aid >= VTSS_LACP_MAX_AGGR) { // Not found LACP LAG
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(dot3adAggPortListTable_entry_t));

    (void) iftable_ifindex_port_list2txt(lacp_aggregatorstatus.port_list, (char *) table_entry_p->dot3adAggPortListPorts);

    return TRUE;
}

extern aggr_mgmt_group_no_t mgmt_aggr_no2id(aggr_mgmt_group_no_t aggr_no);

BOOL get_dot3adAggPortTable_entry(int table_index, dot3adAggPortTable_entry_t *table_entry_p)
{
    iftable_info_t                 table_info;
    vtss_lacp_system_config_t      lacp_system_config;
    vtss_lacp_portstatus_t         lacp_portstatus;
    vtss_lacp_aggregatorstatus_t   lacp_aggregatorstatus;
    vtss_lacp_port_config_t        lacp_port_config;
    aggr_mgmt_group_no_t           aggID_ifindex;
    vtss_usid_t                    usid = 1;
#if VTSS_SWITCH_STACKABLE
    usid = (table_index - 1) / IFTABLE_IFINDEX_SWITCH_INTERVAL + 1;
#endif /* VTSS_SWITCH_STACKABLE */

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(dot3adAggPortTable_entry_t));

    if (lacp_mgmt_port_conf_get(table_info.isid, table_info.if_id, &lacp_port_config) != VTSS_OK) {
        return FALSE;
    }
    aggID_ifindex = aggr_mgmt_get_port_aggr_id(table_info.isid, table_info.if_id);

    table_entry_p->dot3adAggPortActorAdminKey = lacp_port_config.port_key;
    table_entry_p->dot3adAggPortActorAdminState = lacp_port_config.enable_lacp;

    if (lacp_mgmt_port_status_get(L2PORT2PORT(table_info.isid, table_info.if_id), &lacp_portstatus) != VTSS_OK) {
        return FALSE;
    }
    if (aggID_ifindex == 0) {
        aggID_ifindex = lacp_to_aggr_id(lacp_portstatus.actor_port_aggregator_identifier);
    }
    if ((lacp_portstatus.port_enabled != VTSS_COMMON_BOOL_TRUE) && (aggID_ifindex == 0)) {
        return TRUE;
    }

    table_entry_p->dot3adAggPortActorOperKey = lacp_portstatus.actor_oper_port_key;
    table_entry_p->dot3adAggPortAttachedAggID = mgmt_aggr_no2id(lacp_to_aggr_id(lacp_portstatus.actor_port_aggregator_identifier));

    if (AGGR_MGMT_GROUP_IS_LAG(aggID_ifindex)) {
        table_info.isid = topo_usid2isid(usid);
        table_info.if_id = mgmt_aggr_id2no(aggID_ifindex);
        table_info.type = IFTABLE_IFINDEX_TYPE_LLAG;
        (void)ifIndex_get_by_interface(&table_info);
        table_entry_p->dot3adAggPortAttachedAggID = table_info.ifIndex;
    } else {
        table_info.isid = topo_usid2isid(usid);
        table_info.if_id = mgmt_aggr_id2no(aggID_ifindex);
        table_info.type = IFTABLE_IFINDEX_TYPE_GLAG;
        (void)ifIndex_get_by_interface(&table_info);
        table_entry_p->dot3adAggPortAttachedAggID = table_info.ifIndex;
    }

    table_entry_p->dot3adAggPortActorPort = lacp_portstatus.port_number;
    table_entry_p->dot3adAggPortPartnerOperPort = lacp_portstatus.partner_oper_port_number;
    table_entry_p->dot3adAggPortPartnerOperPortPriority = lacp_portstatus.partner_oper_port_priority;
    table_entry_p->dot3adAggPortAggregateOrIndividual = lacp_portstatus.port_enabled;

    /* Get system priority and system MAC */
    if (lacp_mgmt_system_conf_get(&lacp_system_config) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->dot3adAggPortActorSystemPriority = lacp_system_config.system_prio;
    vtss_os_get_systemmac(&table_entry_p->dot3adAggPortActorSystemID);

    (void)lacp_mgmt_aggr_status_get(lacp_portstatus.actor_port_aggregator_identifier, &lacp_aggregatorstatus);

    table_entry_p->dot3adAggPortPartnerOperSystemPriority = lacp_aggregatorstatus.partner_oper_system_priority;
    memcpy(&table_entry_p->dot3adAggPortPartnerOperSystemID, &lacp_aggregatorstatus.partner_oper_system, sizeof(vtss_common_macaddr_t));
    table_entry_p->dot3adAggPortPartnerOperKey = lacp_aggregatorstatus.partner_oper_key;

    return TRUE;
}

BOOL get_dot3adAggPortStatsTable_entry(int table_index, dot3adAggPortStatsTable_entry_t *table_entry_p)
{
    iftable_info_t           table_info;
    vtss_lacp_portstatus_t   lacp_portstatus;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(dot3adAggPortStatsTable_entry_t));

    if (lacp_mgmt_port_status_get(L2PORT2PORT(table_info.isid, table_info.if_id), &lacp_portstatus) != VTSS_OK) {
        return FALSE;
    }

    if (lacp_portstatus.port_enabled != VTSS_COMMON_BOOL_TRUE) {
        return TRUE;
    }

    table_entry_p->dot3adAggPortStatsLACPDUsRx = lacp_portstatus.port_stats.lacp_frame_recvs;
    table_entry_p->dot3adAggPortStatsUnknownRx = lacp_portstatus.port_stats.unknown_frame_recvs;
    table_entry_p->dot3adAggPortStatsIllegalRx = lacp_portstatus.port_stats.illegal_frame_recvs;
    table_entry_p->dot3adAggPortStatsLACPDUsTx = lacp_portstatus.port_stats.lacp_frame_xmits;

    return TRUE;
}

/*
 * --- End (Internal implementation declarations)
 */

/*
 * lagMIBObjects_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             lagMIBObjects_variables_oid[] =
{ 1, 2, 840, 10006, 300, 43, 1 };

/*
 * variable4 lagMIBObjects_variables:
 *   this variable defines function callbacks and type return information
 *   for the lagMIBObjects mib section
 */

struct variable4 lagMIBObjects_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
//#define DOT3ADAGGINDEX                                        1
//    {DOT3ADAGGINDEX, ASN_INTEGER, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 1}},
#define DOT3ADAGGMACADDRESS                                 2
    {DOT3ADAGGMACADDRESS, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 2}},
#define DOT3ADAGGACTORSYSTEMPRIORITY                        3
    {DOT3ADAGGACTORSYSTEMPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggTable, 4, {1, 1, 1, 3}},
#define DOT3ADAGGACTORSYSTEMID                              4
    {DOT3ADAGGACTORSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 4}},
#define DOT3ADAGGAGGREGATEORINDIVIDUAL                      5
    {DOT3ADAGGAGGREGATEORINDIVIDUAL, ASN_INTEGER, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 5}},
#define DOT3ADAGGACTORADMINKEY                              6
    {DOT3ADAGGACTORADMINKEY, ASN_INTEGER, RWRITE, var_dot3adAggTable, 4, {1, 1, 1, 6}},
#define DOT3ADAGGACTOROPERKEY                               7
    {DOT3ADAGGACTOROPERKEY, ASN_INTEGER, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 7}},
#define DOT3ADAGGPARTNERSYSTEMID                            8
    {DOT3ADAGGPARTNERSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 8}},
#define DOT3ADAGGPARTNERSYSTEMPRIORITY                      9
    {DOT3ADAGGPARTNERSYSTEMPRIORITY, ASN_INTEGER, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 9}},
#define DOT3ADAGGPARTNEROPERKEY                             10
    {DOT3ADAGGPARTNEROPERKEY, ASN_INTEGER, RONLY, var_dot3adAggTable, 4, {1, 1, 1, 10}},
#define DOT3ADAGGCOLLECTORMAXDELAY                          11
    {DOT3ADAGGCOLLECTORMAXDELAY, ASN_INTEGER, RWRITE, var_dot3adAggTable, 4, {1, 1, 1, 11}},
#define DOT3ADAGGPORTLISTPORTS                              12
    {DOT3ADAGGPORTLISTPORTS, ASN_OCTET_STR, RONLY, var_dot3adAggPortListTable, 4, {1, 2, 1, 1}},
//#define DOT3ADAGGPORTINDEX                                    13
//    {DOT3ADAGGPORTINDEX, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 1}},
#define DOT3ADAGGPORTACTORSYSTEMPRIORITY                    14
    {DOT3ADAGGPORTACTORSYSTEMPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 2}},
#define DOT3ADAGGPORTACTORSYSTEMID                          15
    {DOT3ADAGGPORTACTORSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 3}},
#define DOT3ADAGGPORTACTORADMINKEY                          16
    {DOT3ADAGGPORTACTORADMINKEY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 4}},
#define DOT3ADAGGPORTACTOROPERKEY                           17
    {DOT3ADAGGPORTACTOROPERKEY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 5}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY             18
    {DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 6}},
#endif
#define DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY              19
    {DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 7}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTPARTNERADMINSYSTEMID                   20
    {DOT3ADAGGPORTPARTNERADMINSYSTEMID, ASN_OCTET_STR, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 8}},
#endif
#define DOT3ADAGGPORTPARTNEROPERSYSTEMID                    21
    {DOT3ADAGGPORTPARTNEROPERSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 9}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTPARTNERADMINKEY                        22
    {DOT3ADAGGPORTPARTNERADMINKEY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 10}},
#endif
#define DOT3ADAGGPORTPARTNEROPERKEY                         23
    {DOT3ADAGGPORTPARTNEROPERKEY, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 11}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTSELECTEDAGGID                          24
    {DOT3ADAGGPORTSELECTEDAGGID, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 12}},
#endif
#define DOT3ADAGGPORTATTACHEDAGGID                          25
    {DOT3ADAGGPORTATTACHEDAGGID, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 13}},
#define DOT3ADAGGPORTACTORPORT                              26
    {DOT3ADAGGPORTACTORPORT, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 14}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTACTORPORTPRIORITY                      27
    {DOT3ADAGGPORTACTORPORTPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 15}},
#define DOT3ADAGGPORTPARTNERADMINPORT                       28
    {DOT3ADAGGPORTPARTNERADMINPORT, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 16}},
#endif
#define DOT3ADAGGPORTPARTNEROPERPORT                        29
    {DOT3ADAGGPORTPARTNEROPERPORT, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 17}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTPARTNERADMINPORTPRIORITY               30
    {DOT3ADAGGPORTPARTNERADMINPORTPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 18}},
#endif
#define DOT3ADAGGPORTPARTNEROPERPORTPRIORITY                31
    {DOT3ADAGGPORTPARTNEROPERPORTPRIORITY, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 19}},
#define DOT3ADAGGPORTACTORADMINSTATE                        32
    {DOT3ADAGGPORTACTORADMINSTATE, ASN_OCTET_STR, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 20}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTACTOROPERSTATE                         33
    {DOT3ADAGGPORTACTOROPERSTATE, ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 21}},
#define DOT3ADAGGPORTPARTNERADMINSTATE                      34
    {DOT3ADAGGPORTPARTNERADMINSTATE, ASN_OCTET_STR, RWRITE, var_dot3adAggPortTable, 4, {2, 1, 1, 22}},
#define DOT3ADAGGPORTPARTNEROPERSTATE                       35
    {DOT3ADAGGPORTPARTNEROPERSTATE, ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 23}},
#endif
#define DOT3ADAGGPORTAGGREGATEORINDIVIDUAL                  36
    {DOT3ADAGGPORTAGGREGATEORINDIVIDUAL, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 4, {2, 1, 1, 24}},
#define DOT3ADAGGPORTSTATSLACPDUSRX                         37
    {DOT3ADAGGPORTSTATSLACPDUSRX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 1}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTSTATSMARKERPDUSRX                      38
    {DOT3ADAGGPORTSTATSMARKERPDUSRX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 2}},
#define DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX              39
    {DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 3}},
#endif
#define DOT3ADAGGPORTSTATSUNKNOWNRX                         40
    {DOT3ADAGGPORTSTATSUNKNOWNRX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 4}},
#define DOT3ADAGGPORTSTATSILLEGALRX                         41
    {DOT3ADAGGPORTSTATSILLEGALRX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 5}},
#define DOT3ADAGGPORTSTATSLACPDUSTX                         42
    {DOT3ADAGGPORTSTATSLACPDUSTX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 6}},
#if 0 /* Not supported in E-StaX34 project */
#define DOT3ADAGGPORTSTATSMARKERPDUSTX                      43
    {DOT3ADAGGPORTSTATSMARKERPDUSTX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 7}},
#define DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX              44
    {DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX, ASN_COUNTER, RONLY, var_dot3adAggPortStatsTable, 4, {2, 2, 1, 8}},
#define DOT3ADAGGPORTDEBUGRXSTATE                           45
    {DOT3ADAGGPORTDEBUGRXSTATE, ASN_INTEGER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 1}},
#define DOT3ADAGGPORTDEBUGLASTRXTIME                        46
    {DOT3ADAGGPORTDEBUGLASTRXTIME, ASN_TIMETICKS, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 2}},
#define DOT3ADAGGPORTDEBUGMUXSTATE                          47
    {DOT3ADAGGPORTDEBUGMUXSTATE, ASN_INTEGER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 3}},
#define DOT3ADAGGPORTDEBUGMUXREASON                         48
    {DOT3ADAGGPORTDEBUGMUXREASON, ASN_OCTET_STR, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 4}},
#define DOT3ADAGGPORTDEBUGACTORCHURNSTATE                   49
    {DOT3ADAGGPORTDEBUGACTORCHURNSTATE, ASN_INTEGER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 5}},
#define DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE                 50
    {DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE, ASN_INTEGER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 6}},
#define DOT3ADAGGPORTDEBUGACTORCHURNCOUNT                   51
    {DOT3ADAGGPORTDEBUGACTORCHURNCOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 7}},
#define DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT                 52
    {DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 8}},
#define DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT          53
    {DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 9}},
#define DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT        54
    {DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 10}},
#define DOT3ADAGGPORTDEBUGACTORCHANGECOUNT                  55
    {DOT3ADAGGPORTDEBUGACTORCHANGECOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 11}},
#define DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT                56
    {DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT, ASN_COUNTER, RONLY, var_dot3adAggPortDebugTable, 4, {2, 3, 1, 12}},
#endif
#define DOT3ADTABLESLASTCHANGED                             57
    {DOT3ADTABLESLASTCHANGED, ASN_TIMETICKS, RONLY, var_lagMIBObjects, 1, {3}},
};


/*
 * Initializes the lagMIBObjects module
 */
void
init_lagMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(lagMIBObjects_variables_oid,
                             sizeof(lagMIBObjects_variables_oid) / sizeof(oid),
                             "IEEE8023-LAG-MIB : lagMIBObjects");

    DEBUGMSGTL(("lagMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("lagMIBObjects", lagMIBObjects_variables, variable4,
                 lagMIBObjects_variables_oid);

    /*
     * place any other initialization junk you need here
     */
    memset(old_actor_admin_key, 0, sizeof(old_actor_admin_key));
    memset(old_actor_admin_state, 0, sizeof(old_actor_admin_state));
}

/*
 * var_lagMIBObjects():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_lagMIBObjects(struct variable *vp,
                  oid *name,
                  size_t *length,
                  int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */
    static u_long ulong_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADTABLESLASTCHANGED: {
        vtss_lacp_agid_t               aid;
        vtss_lacp_aggregatorstatus_t   lacp_aggregatorstatus;

        /* Aggregation status */
        for (aid = VTSS_PORT_NO_START; aid < (VTSS_LACP_MAX_PORTS + VTSS_PORT_NO_START); aid++) {
            if (lacp_mgmt_aggr_status_get(aid, &lacp_aggregatorstatus)) {
                break;
            }
        }

        ulong_ret = lacp_aggregatorstatus.secs_since_last_change * 100;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_lagMIBObjects\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3adAggTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lagMIBObjects above.
 */
u_char         *
var_dot3adAggTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                      table_size;
    int                      idx_num;
    int                      table_index;
    dot3adAggTable_entry_t   table_entry;
    static u_char            string[VTSS_COMMON_MACADDR_SIZE];
    static u_long            ulong_ret;

    *write_method = 0; /* assume it isnt writable for the time being */
    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_lag_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_dot3adAggTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADAGGMACADDRESS: {
        memcpy(string, &table_entry.dot3adAggMACAddress, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE;

        return (u_char *) string;
    }
    case DOT3ADAGGACTORSYSTEMPRIORITY: {
        //*write_method = write_dot3adAggActorSystemPriority;
        ulong_ret = table_entry.dot3adAggActorSystemPriority;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGACTORSYSTEMID: {
        memcpy(string, &table_entry.dot3adAggActorSystemID, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE;

        return (u_char *) string;
    }
    case DOT3ADAGGAGGREGATEORINDIVIDUAL: {
        if (table_entry.dot3adAggAggregateOrIndividual == TRUE) {
            ulong_ret = 1;
        } else if (table_entry.dot3adAggAggregateOrIndividual == FALSE) {
            ulong_ret = 2;
        } else {
            return NULL;
        }

        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGACTORADMINKEY: {
        //*write_method = write_dot3adAggActorAdminKey;
        ulong_ret = table_entry.dot3adAggActorAdminKey;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGACTOROPERKEY: {
        ulong_ret = table_entry.dot3adAggActorOperKey;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPARTNERSYSTEMID: {
        memcpy(string, &table_entry.dot3adAggPartnerSystemID, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE;

        return (u_char *) string;
    }
    case DOT3ADAGGPARTNERSYSTEMPRIORITY: {
        ulong_ret = table_entry.dot3adAggPartnerSystemPriority;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPARTNEROPERKEY: {
        ulong_ret = table_entry.dot3adAggPartnerOperKey;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGCOLLECTORMAXDELAY: {
        //*write_method = write_dot3adAggCollectorMaxDelay;
        ulong_ret = table_entry.dot3adAggCollectorMaxDelay;
        return (u_char *) & ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot3adAggTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3adAggPortListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lagMIBObjects above.
 */
u_char         *
var_dot3adAggPortListTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                              table_size;
    int                              idx_num;
    int                              table_index;
    dot3adAggPortListTable_entry_t   table_entry;
    static char                      string[AGGPORTLISTMAXSTRING];

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_lag_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_dot3adAggPortListTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADAGGPORTLISTPORTS: {
        strcpy(string, (char *) table_entry.dot3adAggPortListPorts);
        *var_len = strlen(string);

        return (u_char *) string;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3adAggPortListTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3adAggPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lagMIBObjects above.
 */
u_char         *
var_dot3adAggPortTable(struct variable *vp,
                       oid *name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                          table_size;
    int                          idx_num;
    int                          table_index;
    dot3adAggPortTable_entry_t   table_entry;
    static u_char                string[VTSS_COMMON_MACADDR_SIZE];
    static u_long                ulong_ret;
    static u_char                uchar_ret;

    *write_method = 0; /* assume it isnt writable for the time being */
    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_lport_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_dot3adAggPortTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADAGGPORTACTORSYSTEMPRIORITY: {
        //*write_method = write_dot3adAggPortActorSystemPriority;
        ulong_ret = table_entry.dot3adAggPortActorSystemPriority;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTACTORSYSTEMID: {
        memcpy(string, &table_entry.dot3adAggPortActorSystemID, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE;

        return (u_char *) string;
    }
    case DOT3ADAGGPORTACTORADMINKEY: {
        *write_method = write_dot3adAggPortActorAdminKey;
        ulong_ret = table_entry.dot3adAggPortActorAdminKey;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTACTOROPERKEY: {
        //*write_method = write_dot3adAggPortActorOperKey;
        ulong_ret = table_entry.dot3adAggPortActorOperKey;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY: {
        //*write_method = write_dot3adAggPortPartnerAdminSystemPriority;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY: {
        ulong_ret = table_entry.dot3adAggPortPartnerOperSystemPriority;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTPARTNERADMINSYSTEMID: {
        //*write_method = write_dot3adAggPortPartnerAdminSystemID;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTPARTNEROPERSYSTEMID: {
        memcpy(string, &table_entry.dot3adAggPortPartnerOperSystemID, VTSS_COMMON_MACADDR_SIZE);
        *var_len = VTSS_COMMON_MACADDR_SIZE;

        return (u_char *) string;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTPARTNERADMINKEY: {
        //*write_method = write_dot3adAggPortPartnerAdminKey;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTPARTNEROPERKEY: {
        ulong_ret = table_entry.dot3adAggPortPartnerOperKey;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTSELECTEDAGGID: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTATTACHEDAGGID: {
        ulong_ret = table_entry.dot3adAggPortAttachedAggID;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTACTORPORT: {
        ulong_ret = table_entry.dot3adAggPortActorPort;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTACTORPORTPRIORITY: {
        //*write_method = write_dot3adAggPortActorPortPriority;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTPARTNERADMINPORT: {
        //*write_method = write_dot3adAggPortPartnerAdminPort;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTPARTNEROPERPORT: {
        ulong_ret = table_entry.dot3adAggPortPartnerOperPort;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTPARTNERADMINPORTPRIORITY: {
        //*write_method = write_dot3adAggPortPartnerAdminPortPriority;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTPARTNEROPERPORTPRIORITY: {
        ulong_ret = table_entry.dot3adAggPortPartnerOperPortPriority;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTACTORADMINSTATE: {
        *write_method = write_dot3adAggPortActorAdminState;
        /* Only implement lacpActivity */
        uchar_ret = table_entry.dot3adAggPortActorAdminState << 7;
        return (u_char *) & uchar_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTACTOROPERSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTPARTNERADMINSTATE: {
        //*write_method = write_dot3adAggPortPartnerAdminState;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTPARTNEROPERSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTAGGREGATEORINDIVIDUAL: {
        if (table_entry.dot3adAggPortAggregateOrIndividual == TRUE) {
            ulong_ret = 1;
        } else if (table_entry.dot3adAggPortAggregateOrIndividual == FALSE) {
            ulong_ret = 2;
        } else {
            return NULL;
        }

        return (u_char *) & ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3adAggPortTable\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_dot3adAggPortStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lagMIBObjects above.
 */
u_char         *
var_dot3adAggPortStatsTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                               table_size;
    int                               idx_num;
    int                               table_index;
    dot3adAggPortStatsTable_entry_t   table_entry;
    static u_long                     ulong_ret;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_lport_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_dot3adAggPortStatsTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADAGGPORTSTATSLACPDUSRX: {
        ulong_ret = table_entry.dot3adAggPortStatsLACPDUsRx;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTSTATSMARKERPDUSRX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    case DOT3ADAGGPORTSTATSUNKNOWNRX: {
        ulong_ret = table_entry.dot3adAggPortStatsUnknownRx;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTSTATSILLEGALRX: {
        ulong_ret = table_entry.dot3adAggPortStatsIllegalRx;
        return (u_char *) & ulong_ret;
    }
    case DOT3ADAGGPORTSTATSLACPDUSTX: {
        ulong_ret = table_entry.dot3adAggPortStatsLACPDUsTx;
        return (u_char *) & ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case DOT3ADAGGPORTSTATSMARKERPDUSTX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3adAggPortStatsTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_dot3adAggPortDebugTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_lagMIBObjects above.
 */
u_char         *
var_dot3adAggPortDebugTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //dot3adAggPortDebugTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_dot3adAggPortDebugTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_dot3adAggPortDebugTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT3ADAGGPORTDEBUGRXSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGLASTRXTIME: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGMUXSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGMUXREASON: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGACTORCHURNSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGACTORCHURNCOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGACTORCHANGECOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_dot3adAggPortDebugTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif

#if 0 /* Not supported in E-StaX34 project */
int
write_dot3adAggActorSystemPriority(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorSystemPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorSystemPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorSystemPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggActorAdminKey(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorAdminKey: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorAdminKey: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggActorAdminKey: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggCollectorMaxDelay(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggCollectorMaxDelay: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggCollectorMaxDelay: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggCollectorMaxDelay: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorSystemPriority(int action,
                                       u_char *var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char *statP,
                                       oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorSystemPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorSystemPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorSystemPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot3adAggPortActorAdminKey(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    unsigned short  *buf, *old_buf;
    size_t          max_size;
    long            intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(long);
    intval = *((long *) var_val);
    int                       if_num;
    iftable_info_t            table_info;
    vtss_lacp_port_config_t   lacp_port_config;

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminKey: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminKey: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 0 || intval > 65535) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminKey: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        return SNMP_ERR_NOERROR;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        return SNMP_ERR_NOERROR;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        return SNMP_ERR_NOERROR;
    }
    }

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (PORT_NO_IS_STACK(table_info.if_id)) {
            if (action == UNDO) {
                return SNMP_ERR_NOERROR;
            } else {
                return SNMP_ERR_NOTWRITABLE;
            }
        }
        buf = &now_actor_admin_key[table_info.isid - VTSS_ISID_START][table_info.if_id];
        old_buf = &old_actor_admin_key[table_info.isid - VTSS_ISID_START][table_info.if_id];
        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
    default:
        return SNMP_ERR_NOTWRITABLE;
    }

    switch (action) {
    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case  */
        /*
         * Save to current configuration
         */
        *buf = *((unsigned short *) var_val);
        break;
    case UNDO:
        /*
         * Back out any changes made in the ACTION case  */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    case COMMIT:
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        return SNMP_ERR_NOERROR;
    }

    if (lacp_mgmt_port_conf_get(table_info.isid, table_info.if_id, &lacp_port_config) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    lacp_port_config.port_key = *buf;

    if (lacp_mgmt_port_conf_set(table_info.isid, table_info.if_id, &lacp_port_config) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    return SNMP_ERR_NOERROR;
}

#if 0 /* Not supported in E-StaX34 project */
int
write_dot3adAggPortActorOperKey(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP,
                                oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorOperKey: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorOperKey: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorOperKey: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminSystemPriority(int action,
                                              u_char *var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char *statP,
                                              oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminSystemID(int action,
                                        u_char *var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char *statP,
                                        oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemID: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemID: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminSystemID: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminKey(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminKey: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminKey: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminKey: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorPortPriority(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorPortPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorPortPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortActorPortPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminPort(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPort: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPort: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPort: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminPortPriority(int action,
                                            u_char *var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char *statP,
                                            oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPortPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPortPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminPortPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot3adAggPortActorAdminState(int action,
                                   u_char *var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char *statP,
                                   oid *name, size_t name_len)
{
    unsigned char   *buf, *old_buf;
    size_t          max_size;
    long            intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(long);
    var_val[1] = 0;
    intval = *var_val - 48;
    int                       if_num;
    iftable_info_t            table_info;
    vtss_lacp_port_config_t   lacp_port_config;

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminState: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminState: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 0 && intval != 1) {
            (void) snmp_log(LOG_ERR,
                            "write to dot3adAggPortActorAdminState: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        return SNMP_ERR_NOERROR;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        return SNMP_ERR_NOERROR;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        return SNMP_ERR_NOERROR;
    }
    }

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (PORT_NO_IS_STACK(table_info.if_id)) {
            if (action == UNDO) {
                return SNMP_ERR_NOERROR;
            } else {
                return SNMP_ERR_NOTWRITABLE;
            }
        }
        buf = &now_actor_admin_state[table_info.isid - VTSS_ISID_START][table_info.if_id];
        old_buf = &old_actor_admin_state[table_info.isid - VTSS_ISID_START][table_info.if_id];
        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
    default:
        return SNMP_ERR_NOTWRITABLE;
    }

    switch (action) {
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val);
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        return SNMP_ERR_NOERROR;
    }
    }

    if (lacp_mgmt_port_conf_get(table_info.isid, table_info.if_id, &lacp_port_config) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    lacp_port_config.enable_lacp = *buf - 48;

    if (lacp_mgmt_port_conf_set(table_info.isid, table_info.if_id, &lacp_port_config) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    return SNMP_ERR_NOERROR;
}

#if 0 /* Not supported in E-StaX34 project */
int
write_dot3adAggPortPartnerAdminState(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminState: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminState: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to dot3adAggPortPartnerAdminState: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

