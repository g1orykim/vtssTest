/* -----------------------------------------------------------------------------

 Portions of this software may have been derived from the UCD-SNMP
 project,  <http://www.net-snmp.org/>  from the University of
 California at Davis, which was originally based on the Carnegie Mellon
 University SNMP implementation.  Portions of this software are therefore
 covered by the appropriate copyright disclaimers included herein.

 The release used was version 5.0.11.2 of June 2008.  "net-snmp-5.0.11.2"

 -------------------------------------------------------------------------------
*/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */

#include "vtss_snmp_api.h"
#include "rfc3414_usm.h"
#include "ucd_snmp_rfc3414_usm.h"
#include "ucd_snmp_callout.h"   //ucd_snmp_callout_malloc(), ucd_snmp_callout_free()


/*
 * +++ Start (Internal implementation declarations)
 */
#if RFC3414_SUPPORTED_USMUSER
/* usmUser ----------------------------------------------------------*/
static oid usmNoAuthProtocol[]      = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 1 };
static oid usmHMACMD5AuthProtocol[] = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 2 };
static oid usmHMACSHAAuthProtocol[] = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 3 };
static oid usmNoPrivProtocol[]      = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };
static oid usmDESPrivProtocol[]     = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };
static long old_usmUserSpinLock = 0, now_usmUserSpinLock = 0;
#endif /* RFC3414_SUPPORTED_USMUSER */
/*
 * --- End (Internal implementation declarations)
 */

#if RFC3414_SUPPORTED_USMSTATS
/* usmStats ----------------------------------------------------------*/
/*
 * usmStats_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             usmStats_variables_oid[] = { 1, 3, 6, 1, 6, 3, 15, 1, 1 };

/*
 * variable4 usmStats_variables:
 *   this variable defines function callbacks and type return information
 *   for the usmStats mib section
 */

struct variable4 usmStats_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define USMSTATSUNSUPPORTEDSECLEVELS    1
    {USMSTATSUNSUPPORTEDSECLEVELS, ASN_COUNTER, RONLY, var_usmStats, 1, {1}},
#define USMSTATSNOTINTIMEWINDOWS        2
    {USMSTATSNOTINTIMEWINDOWS, ASN_COUNTER, RONLY, var_usmStats, 1, {2}},
#define USMSTATSUNKNOWNUSERNAMES        3
    {USMSTATSUNKNOWNUSERNAMES, ASN_COUNTER, RONLY, var_usmStats, 1, {3}},
#define USMSTATSUNKNOWNENGINEIDS        4
    {USMSTATSUNKNOWNENGINEIDS, ASN_COUNTER, RONLY, var_usmStats, 1, {4}},
#define USMSTATSWRONGDIGESTS            5
    {USMSTATSWRONGDIGESTS, ASN_COUNTER, RONLY, var_usmStats, 1, {5}},
#define USMSTATSDECRYPTIONERRORS        6
    {USMSTATSDECRYPTIONERRORS, ASN_COUNTER, RONLY, var_usmStats, 1, {6}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the usmStats module
 */
void
ucd_snmp_init_usmStats(void)
{
    DEBUGMSGTL(("usmStats", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("usmStats", usmStats_variables, variable4,
                 usmStats_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_usmStats():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_usmStats(struct variable *vp,
             oid *name,
             size_t *length,
             int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long long_ret;
    int tmagic = vp->magic - 1;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case USMSTATSUNKNOWNENGINEIDS:
    case USMSTATSNOTINTIMEWINDOWS:
    case USMSTATSDECRYPTIONERRORS:
    case USMSTATSWRONGDIGESTS:
    case USMSTATSUNSUPPORTEDSECLEVELS:
    case USMSTATSUNKNOWNUSERNAMES: {
        long_ret = snmp_get_statistic(tmagic + STAT_USM_STATS_START);
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_usmStats\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* RFC3414_SUPPORTED_USMSTATS */

#if RFC3414_SUPPORTED_USMUSER
/* usmUser ----------------------------------------------------------*/
/*
 * usmUser_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             usmUser_variables_oid[] = { 1, 3, 6, 1, 6, 3, 15, 1, 2 };

/*
 * variable4 usmUser_variables:
 *   this variable defines function callbacks and type return information
 *   for the usmUser mib section
 */

struct variable4 usmUser_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define USMUSERSPINLOCK             1
    {USMUSERSPINLOCK, ASN_INTEGER, RWRITE, var_usmUser, 1, {1}},
#define USMUSERSECURITYNAME         2
    {USMUSERSECURITYNAME, ASN_OCTET_STR, RONLY, var_usmUserTable, 3, {2, 1, 3}},
#define USMUSERCLONEFROM            3
    {USMUSERCLONEFROM, ASN_OBJECT_ID, RWRITE, var_usmUserTable, 3, {2, 1, 4}},
#define USMUSERAUTHPROTOCOL         4
    {USMUSERAUTHPROTOCOL, ASN_OBJECT_ID, RWRITE, var_usmUserTable, 3, {2, 1, 5}},
#define USMUSERAUTHKEYCHANGE        5
    {USMUSERAUTHKEYCHANGE, ASN_OCTET_STR, RWRITE, var_usmUserTable, 3, {2, 1, 6}},
#define USMUSEROWNAUTHKEYCHANGE     6
    {USMUSEROWNAUTHKEYCHANGE, ASN_OCTET_STR, RWRITE, var_usmUserTable, 3, {2, 1, 7}},
#define USMUSERPRIVPROTOCOL         7
    {USMUSERPRIVPROTOCOL, ASN_OBJECT_ID, RWRITE, var_usmUserTable, 3, {2, 1, 8}},
#define USMUSERPRIVKEYCHANGE        8
    {USMUSERPRIVKEYCHANGE, ASN_OCTET_STR, RWRITE, var_usmUserTable, 3, {2, 1, 9}},
#define USMUSEROWNPRIVKEYCHANGE     9
    {USMUSEROWNPRIVKEYCHANGE, ASN_OCTET_STR, RWRITE, var_usmUserTable, 3, {2, 1, 10}},
#define USMUSERPUBLIC               10
    {USMUSERPUBLIC, ASN_OCTET_STR, RWRITE, var_usmUserTable, 3, {2, 1, 11}},
#define USMUSERSTORAGETYPE          11
    {USMUSERSTORAGETYPE, ASN_INTEGER, RWRITE, var_usmUserTable, 3, {2, 1, 12}},
#define USMUSERSTATUS               12
    {USMUSERSTATUS, ASN_INTEGER, RWRITE, var_usmUserTable, 3, {2, 1, 13}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the usmUser module
 */
void
ucd_snmp_init_usmUser(void)
{
    DEBUGMSGTL(("usmUser", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("usmUser", usmUser_variables, variable4,
                 usmUser_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/****************************************************************************
 * usm_generate_OID
 *
 * Parameters:
 *  *prefix     (I) OID prefix to the usmUser table entry.
 *   prefixLen  (I)
 *  *conf       (I) Pointer to a user entry in the SNMPv3 users table(managed layer).
 *  *length     (O) Length of generated index OID.
 *
 * Returns:
 *  Pointer to the OID index for the user (conf)  -OR-
 *  NULL on failure.
 *
 *
 * Generate the index OID for a given usmUser name.  'length' is set to
 * the length of the index OID.
 *
 * Index OID format is:
 *
 *    <...prefix>.<engineID_length>.<engineID>.<user_name_length>.<user_name>
 */
oid *
usm_generate_OID(oid *prefix, size_t prefixLen, snmpv3_users_conf_t *conf,
                 size_t *length)
{
    oid *indexOid;
    int i;

    *length = 2 + conf->engineid_len + strlen(conf->user_name) + prefixLen;
    indexOid = (oid *)ucd_snmp_callout_malloc(*length * sizeof(oid));
    if (indexOid) {
        memmove(indexOid, prefix, prefixLen * sizeof (oid));

        indexOid[prefixLen] = conf->engineid_len;
        for (i = 0; i < (int)conf->engineid_len; i++) {
            indexOid[prefixLen + 1 + i] = (oid) conf->engineid[i];
        }

        indexOid[prefixLen + conf->engineid_len + 1] = strlen(conf->user_name);
        for (i = 0; i < (int)strlen(conf->user_name); i++) {
            indexOid[prefixLen + conf->engineid_len + 2 + i] = (oid) conf->user_name[i];
        }
    }
    return indexOid;

}  /* end usm_generate_OID() */

/*
 * var_usmUser():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_usmUser(struct variable *vp,
            oid *name,
            size_t *length,
            int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static long long_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case USMUSERSPINLOCK: {
        //*write_method = write_usmUserSpinLock;
        long_ret = now_usmUserSpinLock;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_usmUser\n",
                    vp->magic));
    }
    return NULL;
}

/*
 * var_usmUserTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_usmUser above.
 */
u_char         *
var_usmUserTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    static long         long_ret;
    static u_char       string[SPRINT_MAX_LEN];
    static oid          objid[MAX_OID_LEN];
    char                userName[SNMPV3_MAX_NAME_LEN] = { 0 };
    int                 userNameLen = 0;
    char                engineId[100] = { 0 };
    int                 engineIdLen = 0;
    oid                 *op;
    size_t              len = 0;
    char                *cp;
    snmpv3_users_conf_t conf, temp_conf;
    vtss_rc             rc = !VTSS_OK;
    int                 found = 0, i;
    oid                 *indexOid;

    *write_method = 0;           /* assume it isnt writable for the time being */
    *var_len = sizeof(long_ret); /* assume an integer and change later if not */
    memset(&conf, 0x0, sizeof(conf));
    memset(&temp_conf, 0x0, sizeof(temp_conf));

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if (exact) {
        if (*length < 14) {
            return NULL;
        }

        op = name + 12;
        len = engineIdLen = *op++;
        cp = engineId;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
            *cp++ = (char) * op++;
        }
        len = *op++;
        if (len < 0 || len > SNMPV3_MAX_NAME_LEN) {
            return 0;
        }
        cp = userName;
        while (len-- > 0) {
            if (*op > 255) {
                return 0; /* illegal value */
            }
            *cp++ = (char) * op++;
        }
        *cp = 0;
        if (op != name + *length) {
            return NULL;
        }

        memcpy(conf.engineid, engineId, engineIdLen);
        conf.engineid_len = engineIdLen;
        strcpy(conf.user_name, userName);
        rc = snmpv3_mgmt_users_conf_get(&conf, FALSE);
    } else {
        op = name + 12;
        if (op >= name + *length) {
        } else {
            engineIdLen = *op++;
            if (engineIdLen < 0 || engineIdLen > MAX_OID_LEN) {
                return 0;
            }
            len = ((*length - 13) >= engineIdLen) ? engineIdLen : (*length - 13);
            cp = engineId;
            while (len-- > 0) {
                if (*op > 255) {
                    return 0; /* illegal value */
                }
                *cp++ = (char) * op++;
            }
        }
        if (op >= name + *length) {
        } else {
            userNameLen = *op++;
            if (userNameLen < 0 || userNameLen > SNMPV3_MAX_NAME_LEN) {
                return 0;
            }
            len = ((*length - 13 - (engineIdLen + 1)) >= userNameLen) ? userNameLen : (*length - 13 - (engineIdLen + 1));
            cp = userName;
            while (len-- > 0) {
                if (*op > 255) {
                    return 0; /* illegal value */
                }
                *cp++ = (char) * op++;
            }
            *cp = 0;
        }

        strcpy(conf.user_name, SNMPV3_CONF_ACESS_GETFIRST);
        while ((rc = snmpv3_mgmt_users_conf_get(&conf, TRUE)) == VTSS_OK) {
            if (conf.engineid_len > engineIdLen ||
                (conf.engineid_len == engineIdLen && memcmp(conf.engineid, engineId, conf.engineid_len) > 0) ||
                (conf.engineid_len == engineIdLen && (!memcmp(conf.engineid, engineId, conf.engineid_len)) && strlen(conf.user_name) > userNameLen) ||
                (conf.engineid_len == engineIdLen && (!memcmp(conf.engineid, engineId, conf.engineid_len)) && strlen(conf.user_name) == userNameLen && strcmp(conf.user_name, userName) > 0)) {
                if (found == 0) {
                    found = 1;
                    temp_conf = conf;
                } else if (conf.engineid_len < temp_conf.engineid_len ||
                           (conf.engineid_len == temp_conf.engineid_len && memcmp(conf.engineid, temp_conf.engineid, conf.engineid_len) < 0) ||
                           (conf.engineid_len == temp_conf.engineid_len && (!memcmp(conf.engineid, temp_conf.engineid, conf.engineid_len)) && strlen(conf.user_name) < strlen(temp_conf.user_name)) ||
                           (conf.engineid_len == temp_conf.engineid_len && (!memcmp(conf.engineid, temp_conf.engineid, conf.engineid_len)) && strlen(conf.user_name) == strlen(temp_conf.user_name) && strcmp(conf.user_name, temp_conf.user_name) < 0)) {
                    temp_conf = conf;
                }
            }
        }
        if (found) {
            conf = temp_conf;
            rc = VTSS_OK;
        }

        if (rc == VTSS_OK) {
            indexOid = usm_generate_OID(vp->name, vp->namelen, &conf, &len);
            *length = len;
            memmove(name, indexOid, len * sizeof(oid));
            DEBUGMSGTL(("usmUser", "Found user: %s - ", conf.user_name));
            for (i = 0; i < (int)conf.engineid_len; i++) {
                DEBUGMSG(("usmUser", " %x", conf.engineid[i]));
            }
            DEBUGMSG(("usmUser", "\n  -> OID: "));
            DEBUGMSGOID(("usmUser", indexOid, len));
            DEBUGMSG(("usmUser", "\n"));
            ucd_snmp_callout_free(indexOid);
        }
    }

    if (rc != VTSS_OK) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case USMUSERSECURITYNAME: {
        strcpy(string, conf.user_name);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case USMUSERCLONEFROM: {
        //*write_method = write_usmUserCloneFrom;
        /* When this object is read, the ZeroDotZero OID is returned. */
        objid[0] = 0;
        objid[1] = 0;
        *var_len = sizeof(oid) * 2;
        return (u_char *) objid;
    }
    case USMUSERAUTHPROTOCOL: {
        //*write_method = write_usmUserAuthProtocol;
        *var_len = sizeof(usmNoAuthProtocol);
        if (conf.auth_protocol == SNMP_MGMT_AUTH_PROTO_NONE) {
            return (u_char *) usmNoAuthProtocol;
        } else if (conf.auth_protocol == SNMP_MGMT_AUTH_PROTO_MD5) {
            return (u_char *) usmHMACMD5AuthProtocol;
        } else {
            return (u_char *) usmHMACSHAAuthProtocol;
        }
    }
    case USMUSERAUTHKEYCHANGE: {
        //*write_method = write_usmUserAuthKeyChange;
        *string = 0; /* always return a NULL string */
        *var_len = 0;
        return string;
    }
    case USMUSEROWNAUTHKEYCHANGE: {
        //*write_method = write_usmUserOwnAuthKeyChange;
        *string = 0; /* always return a NULL string */
        *var_len = 0;
        return string;
    }
    case USMUSERPRIVPROTOCOL: {
        //*write_method = write_usmUserPrivProtocol;
        *var_len = sizeof(usmNoPrivProtocol);
        if (conf.auth_protocol == SNMP_MGMT_AUTH_PROTO_NONE) {
            return (u_char *) usmNoPrivProtocol;
        } else {
            return (u_char *) usmDESPrivProtocol;
        }
    }
    case USMUSERPRIVKEYCHANGE: {
        //*write_method = write_usmUserPrivKeyChange;
        *string = 0; /* always return a NULL string */
        *var_len = 0;
        return string;
    }
    case USMUSEROWNPRIVKEYCHANGE: {
        //*write_method = write_usmUserOwnPrivKeyChange;
        *string = 0; /* always return a NULL string */
        *var_len = 0;
        return string;
    }
    case USMUSERPUBLIC: {
        //*write_method = write_usmUserPublic;
        *string = 0;
        *var_len = 0; /* return an empty string if the public string hasn't been defined yet */
        return string;
    }
    case USMUSERSTORAGETYPE: {
        //*write_method = write_usmUserStorageType;
        long_ret = conf.storage_type;
        return (u_char *) &long_ret;
    }
    case USMUSERSTATUS: {
        //*write_method = write_usmUserStatus;
        long_ret = conf.status;
        return (u_char *) &long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_usmUserTable\n",
                    vp->magic));
    }
    return NULL;
}

int
write_usmUserSpinLock(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;
    int             max_size;
    long            intval;

    buf = &old_usmUserSpinLock;
    old_buf = &now_usmUserSpinLock;
    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to usmUserSpinLock: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserSpinLock: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval > 2147483647) {
            snmp_log(LOG_ERR, "write to usmUserSpinLock: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        if (intval != *buf) {
            return SNMP_ERR_INCONSISTENTVALUE;
        }
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val);
        if (*buf == 2147483647) {
            *buf = 0;
        } else {
            *buf = *buf + 1;
        }
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserCloneFrom(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    oid            *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(oid);     /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to usmUserCloneFrom: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserCloneFrom: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserCloneFrom: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((oid *) var_val);  /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserAuthProtocol(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP, oid *name, size_t name_len)
{
    oid            *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(oid);     /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to usmUserAuthProtocol: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserAuthProtocol: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserAuthProtocol: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((oid *) var_val);  /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserAuthKeyChange(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to usmUserAuthKeyChange: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserAuthKeyChange: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserAuthKeyChange: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserOwnAuthKeyChange(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to usmUserOwnAuthKeyChange: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserOwnAuthKeyChange: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserOwnAuthKeyChange: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserPrivProtocol(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP, oid *name, size_t name_len)
{
    oid            *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(oid);     /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to usmUserPrivProtocol: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserPrivProtocol: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserPrivProtocol: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((oid *) var_val);  /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserPrivKeyChange(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to usmUserPrivKeyChange: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserPrivKeyChange: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserPrivKeyChange: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserOwnPrivKeyChange(int action,
                              u_char *var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to usmUserOwnPrivKeyChange: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserOwnPrivKeyChange: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserOwnPrivKeyChange: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserPublic(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to usmUserPublic: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to usmUserPublic: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to usmUserPublic: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserStorageType(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to usmUserStorageType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to usmUserStorageType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to usmUserStorageType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_usmUserStatus(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to usmUserStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to usmUserStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to usmUserStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC3414_SUPPORTED_USMUSER */

