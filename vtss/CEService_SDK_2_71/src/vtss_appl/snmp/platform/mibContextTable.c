/*
 *
 * Vitesse Switch Software.
 *
 * Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 * Rights Reserved.
 *
 * Unpublished rights reserved under the copyright laws of the United States of
 * America, other countries and international treaties. Permission to use, copy,
 * store and modify, the software and its source code is granted. Permission to
 * integrate into other products, disclose, transmit and distribute the software
 * in an absolute machine readable format (e.g. HEX file) is also granted.  The
 * source code of the software may not be disclosed, transmitted or distributed
 * without the written permission of Vitesse. The software and its source code
 * may only be used in products utilizing the Vitesse switch products.
 *
 * This copyright notice must appear in any copy, modification, disclosure,
 * transmission or distribution of the software. Vitesse retains all ownership,
 * copyright, trade secret and proprietary rights in the software.
 *
 * THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 * INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 *
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/snmp_api.h>  /* snmp_oid_compare()            */

#include "vtss_snmp_api.h"
#include "mibContextTable.h"
#include "vtss_avl_tree_api.h"

/* Trace module */
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#define VTSS_TRACE_MODULE_ID        VTSS_MODULE_ID_SNMP
#define VTSS_TRACE_GRP_DEFAULT      0
#define TRACE_GRP_CRIT              1
#define TRACE_GRP_CNT               2

/* mutex for global protection */
#include "critd_api.h"
static critd_t mibContextTable_global_critd_mutex;

#if (VTSS_TRACE_ENABLED)
#define MIBCONTEXTTABLE_CRIT_ENTER() critd_enter(&mibContextTable_global_critd_mutex, TRACE_GRP_CRIT, VTSS_TRACE_LVL_NOISE, __FILE__, __LINE__)
#define MIBCONTEXTTABLE_CRIT_EXIT()  critd_exit( &mibContextTable_global_critd_mutex, TRACE_GRP_CRIT, VTSS_TRACE_LVL_NOISE, __FILE__, __LINE__)
#else
#define MIBCONTEXTTABLE_CRIT_ENTER() critd_enter(&mibContextTable_global_critd_mutex)
#define MIBCONTEXTTABLE_CRIT_EXIT()  critd_exit( &mibContextTable_global_critd_mutex)
#endif /* VTSS_TRACE_ENABLED */

//static mibContextTable_entry_t mibContextTable[MIBCONTEXTTABLE_MAX_ENTRY_CNT];
static BOOL mibContextTable_global_init_flag = FALSE;

/* AVL Tree utility library */
static i32 MIBCONTEXTTABLE_entry_compare_func(void *elm1, void *elm2);

// Create two ACL tree to maintain the same database(mibContextTable) with different entry key
VTSS_AVL_TREE(MIBCONTEXTTABLE_global_table, "SNMP_MIBCONTEXTTABLE", VTSS_MODULE_ID_SNMP, MIBCONTEXTTABLE_entry_compare_func, MIBCONTEXTTABLE_MAX_ENTRY_CNT)

#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP    // VTSS_MALLOC()


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/

static i32 MIBCONTEXTTABLE_entry_compare_func(void *element1, void *element2)
{
    mibContextTable_entry_t *elm1 = (mibContextTable_entry_t *)element1;
    mibContextTable_entry_t *elm2 = (mibContextTable_entry_t *)element2;
    int                 strcmp_rc, oid_cmp_rc;

    if ((strcmp_rc = strcmp(elm1->mib_name, elm2->mib_name)) > 0) {
        return 1;
    } else if (strcmp_rc < 0) {
        return -1;
    } else if ((oid_cmp_rc = snmp_oid_compare(elm1->oid, elm1->oid_len, elm2->oid, elm2->oid_len)) > 0) {
        return 1;
    } else if (oid_cmp_rc < 0) {
        return -1;
    } else {
        return 0;
    }
}


/******************************************************************************/
// Initial function
/******************************************************************************/
/**
  * \brief Initialize mibContextTable semaphore for critical regions.
  **/
void
mibContextTable_init(void)
{
    T_D("enter");

    if (mibContextTable_global_init_flag) {
        return;
    }
    mibContextTable_global_init_flag = TRUE;

    /* Create semaphore for critical regions */
    critd_init(&mibContextTable_global_critd_mutex, "mibContextTable_global_critd_mutex", VTSS_MODULE_ID_SNMP, VTSS_TRACE_MODULE_ID, CRITD_TYPE_MUTEX);
    if (vtss_avl_tree_init(&MIBCONTEXTTABLE_global_table) != TRUE) {
        T_E("mibContextTable - Initialize fail");
    }
    MIBCONTEXTTABLE_CRIT_EXIT();

    T_D("exit");
}


/******************************************************************************/
//
// mibContextTable entry register
//
/******************************************************************************/
/**
  * \brief Register table entry of mibContextTable
  *
  * \param oidin  [IN]: The MIB OID which will register to mibContextTable
  * \param oidlen [IN]: The OID length of input parameter "oidin"
  * \param descr  [IN]: The desciption of MIB node. Format: <MIB_File_Name> : <Scalar_or_Table_Name>
  **/
void mibContextTable_register(oid *oidin, size_t oidlen, const char *descr)
{
    mibContextTable_entry_t *entry_p;
    char                    mib_name[MIBCONTEXTTABLE_STR_LEN_MAX + 1];
    char                    *delimit = ":", *ch_p;

    /* Check input parameters */
    if (oidlen > MIBCONTEXTTABLE_OID_LEN_MAX ||
        strlen(descr) >= MIBCONTEXTTABLE_STR_LEN_MAX) {
        T_E("mibContextTable - Input parameter out of valid range");
        return;
    }

    /* Allocate memory for table entry */
    if ((entry_p = (mibContextTable_entry_t *)VTSS_MALLOC(sizeof(*entry_p))) == NULL) {
        T_E("mibContextTable - Memory allocated fail");
        return;
    }

    /* Fill table entry elements */
    memset(entry_p, 0, sizeof(*entry_p));
    memcpy(entry_p->oid, oidin, sizeof(oid) * oidlen);
    entry_p->oid_len = oidlen;
    strcpy(entry_p->descr, descr);
    entry_p->descr_len = strlen(descr);

    strcpy(mib_name, descr);
    if ((ch_p = strtok(mib_name, delimit)) != NULL) {
        strcpy(entry_p->mib_name, ch_p);
    }

    /* Add to AVL tree */
    MIBCONTEXTTABLE_CRIT_ENTER();
    if (vtss_avl_tree_add(&MIBCONTEXTTABLE_global_table, entry_p) != TRUE) {
        VTSS_FREE(entry_p);
        T_W("Register SNMP supported MIBs failed");
    }
    MIBCONTEXTTABLE_CRIT_EXIT();
}


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Getnext table entry by MIB name of mibContextTableEntry
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
mibContextTableEntry_getnext_by_mib_name(mibContextTable_entry_t *table_entry)
{
    int                 rc = -1;
    mibContextTable_entry_t  *entry_p = table_entry;

    T_D("enter");

    MIBCONTEXTTABLE_CRIT_ENTER();
    if (vtss_avl_tree_get(&MIBCONTEXTTABLE_global_table, (void **) &entry_p, VTSS_AVL_TREE_GET_NEXT) == TRUE) {
        rc = 0;
        *table_entry = *entry_p;
    }
    MIBCONTEXTTABLE_CRIT_EXIT();

    T_D("exit");
    return rc;
}
