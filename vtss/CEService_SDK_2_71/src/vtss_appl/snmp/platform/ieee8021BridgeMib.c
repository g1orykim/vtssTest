/*
 *
 * Vitesse Switch Software.
 *
 * Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 * Rights Reserved.
 *
 * Unpublished rights reserved under the copyright laws of the United States of
 * America, other countries and international treaties. Permission to use, copy,
 * store and modify, the software and its source code is granted. Permission to
 * integrate into other products, disclose, transmit and distribute the software
 * in an absolute machine readable format (e.g. HEX file) is also granted.  The
 * source code of the software may not be disclosed, transmitted or distributed
 * without the written permission of Vitesse. The software and its source code
 * may only be used in products utilizing the Vitesse switch products.
 *
 * This copyright notice must appear in any copy, modification, disclosure,
 * transmission or distribution of the software. Vitesse retains all ownership,
 * copyright, trade secret and proprietary rights in the software.
 *
 * THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 * INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 *
 */

//Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//      Revise the "FIXME" parts to make it as a completed code.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */

#include "vtss_snmp_api.h"
#include "ieee8021BridgeMib.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_ieee8021BridgeMib.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_ieee8021BridgeMib.h"
#endif                          /* SNMP_HAS_UCD_SNMP */
#include "mibContextTable.h"         // mibContextTable_register()
#include "snmp_mib_redefine.h"  // snmp_mib_redefine_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>

#include "mgmt_api.h"
#include "misc_api.h" //iport2uport()
#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "mstp_api.h"

// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

#define IEEE8021BRIDGECOMPONENTID       1
#define IEEE8021BRIDGECOMPONENT_CNT     1


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-BRIDGE-MIB:ieee8021BridgeBasePortTable.
  **/
void
ieee8021BridgeMib_init(void)
{
    T_D("enter");

    /*
     * Register SysORTable
     */
    oid             ieee8021BridgeBasePortTable_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 2, 1, 1, 4 };
    mibContextTable_register(ieee8021BridgeBasePortTable_oid,
                             sizeof(ieee8021BridgeBasePortTable_oid) /
                             sizeof(oid),
                             "IEEE8021-BRIDGE-MIB : ieee8021BridgeBasePortTable");

#if defined(SNMP_HAS_UCD_SNMP)
    ucd_snmp_init_ieee8021BridgeBasePortTable();
#elif defined(SNMP_HAS_NET_SNMP)
    net_snmp_init_ieee8021BridgeBasePortTable();
#endif                          /* SNMP_HAS_UCD_SNMP */

    /*
     * Register snmpMibRedefineTable
     */


    // ieee8021BridgeBasePortIfIndex
    oid             ieee8021BridgeBasePortIfIndex_variables_oid[] =
    { 1, 3, 111, 2, 802, 1, 1, 2, 1, 1, 4, 1, 3 };
    snmp_mib_redefine_register(ieee8021BridgeBasePortIfIndex_variables_oid,
                               sizeof
                               (ieee8021BridgeBasePortIfIndex_variables_oid)
                               / sizeof(oid),
                               "IEEE8021-BRIDGE-MIB : ieee8021BridgeBasePortIfIndex",
                               "InterfaceIndexOrZero",
                               SNMP_MIB_ACCESS_TYPE_RWRITE,
                               SNMP_MIB_ACCESS_TYPE_RONLY, FALSE,
                               "{0 2147483647}");

    T_D("exit");
}


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/
static int IEEE8021BRIDGE_BasePortTableEntryKey_getnext(u_long *componentId, u_long *basePort)
{
    u_long tmp_componentId;
    dot1Port_info_t info;
    if ( *componentId > IEEE8021BRIDGECOMPONENT_CNT ) {
        return VTSS_RC_ERROR;
    }

    if ( *componentId  < IEEE8021BRIDGECOMPONENTID) {
        tmp_componentId = 1;
        info.dot1port = DOT1PORT_NO_NONE;
    } else {
        tmp_componentId = *componentId;
        info.dot1port = *basePort;
    }

    if (FALSE == dot1Port_get_next(&info)) {
        return VTSS_RC_ERROR;
    }
    *componentId = tmp_componentId;
    *basePort = info.dot1port;
    return VTSS_RC_OK;

}

static int IEEE8021BRIDGE_BasePortTableEntryKey_get(u_long *componentId, u_long *basePort)
{
    u_long tmp_componentId;
    u_long tmp_basePort;

    if ( *componentId > IEEE8021BRIDGECOMPONENT_CNT || *componentId < IEEE8021BRIDGECOMPONENTID ) {
        return VTSS_RC_ERROR;
    }

    if (*basePort == VTSS_VID_NULL) {
        return VTSS_RC_ERROR;
    }
    tmp_componentId = *componentId;
    tmp_basePort = *basePort - 1;


    if (VTSS_RC_OK != IEEE8021BRIDGE_BasePortTableEntryKey_getnext(&tmp_componentId, &tmp_basePort)) {
        return VTSS_RC_ERROR;
    }

    if (tmp_componentId != *componentId || tmp_basePort != *basePort) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static void IEEE8021BRIDGE_BasePortTable_update(vtss_isid_t isid, vtss_port_no_t port_idx, ieee8021BridgeBasePortTable_entry_t *table_entry_p)
{
    vtss_port_counters_t    counters;
    vlan_port_conf_t        port_conf;
    BOOL                    enable;
    mstp_port_param_t       conf;
    mstp_port_mgmt_status_t status, *ps = &status;

    if (FALSE == mstp_get_port_config(isid, port_idx, &enable, &conf)) {
        T_E("mstp_get_port_config: error(%d, %u)", isid, port_idx);
    }

    if (FALSE == mstp_get_port_status(0, L2PORT2PORT(isid, port_idx), ps)) {
        T_E("mstp_get_port_status: error(0, %u", L2PORT2PORT(isid, port_idx));
    }

    (void) port_mgmt_counters_get(isid, port_idx, &counters);
    (void) vlan_mgmt_port_conf_get(isid, port_idx, &port_conf, VLAN_USER_STATIC);

    table_entry_p->ieee8021BridgeBasePortDelayExceededDiscards.low = 0;
    table_entry_p->ieee8021BridgeBasePortMtuExceededDiscards.low   += counters.rmon.rx_etherStatsOversizePkts;
    table_entry_p->ieee8021BridgeBasePortCapabilities[0] = (char)0xe0;
    table_entry_p->ieee8021BridgeBasePortTypeCapabilities_len = 1;
    table_entry_p->ieee8021BridgeBasePortTypeCapabilities[0] = (char)0x82;
    table_entry_p->ieee8021BridgeBasePortTypeCapabilities_len = 1;
    table_entry_p->ieee8021BridgeBasePortType = VLAN_PORT_TYPE_UNAWARE == port_conf.port_type ? 8 : VLAN_PORT_TYPE_C == port_conf.port_type ? 2 : 1;
    table_entry_p->ieee8021BridgeBasePortExternal = 1;
    table_entry_p->ieee8021BridgeBasePortAdminPointToPoint = conf.adminPointToPointMAC == P2P_AUTO ? 3 : conf.adminPointToPointMAC == P2P_FORCETRUE ? 1 :
                                                             conf.adminPointToPointMAC == P2P_FORCEFALSE ? 2 : 0;
    table_entry_p->ieee8021BridgeBasePortOperPointToPoint = ps->core.operPointToPointMAC ? 1 : 2;

}

static int IEEE8021BRIDGE_BasePortTableEntry_get(ieee8021BridgeBasePortTable_entry_t *table_entry)
{
    iftable_info_t      ifIndex_info;
    dot1Port_info_t     dot1Port_info;
    port_iter_t         pit;
    switch_iter_t       sit;
    aggr_mgmt_group_member_t aggr_members;

    dot1Port_info.dot1port = table_entry->ieee8021BridgeBasePort;

    (void) dot1Port_get(&dot1Port_info);

    ifIndex_info.isid = dot1Port_info.isid;
    ifIndex_info.if_id = dot1Port_info.if_id;

    switch (dot1Port_info.type) {
    case DOT1PORT_TYPE_PORT:
        ifIndex_info.type = IFTABLE_IFINDEX_TYPE_PORT;
        break;
    case DOT1PORT_TYPE_LLAG:
        ifIndex_info.type = IFTABLE_IFINDEX_TYPE_LLAG;
        break;
    case DOT1PORT_TYPE_GLAG:
        ifIndex_info.type = IFTABLE_IFINDEX_TYPE_GLAG;
        break;
    case DOT1PORT_TYPE_UNDEF:
    default:
        return VTSS_RC_ERROR;
    }

    (void) ifIndex_get_by_interface(&ifIndex_info);

    table_entry->ieee8021BridgeBasePortIfIndex = ifIndex_info.ifIndex;

    switch (dot1Port_info.type) {
    case DOT1PORT_TYPE_PORT:
        IEEE8021BRIDGE_BasePortTable_update(dot1Port_info.isid, dot1Port_info.if_id, table_entry);
#if VTSS_SWITCH_STACKABLE
        (void)snprintf(table_entry->ieee8021BridgeBasePortName, sizeof(table_entry->ieee8021BridgeBasePortName),
                       "Switch %2d - Port %2u", topo_isid2usid(dot1Port_info.isid), (u32)iport2uport(dot1Port_info.if_id));
#else
        (void)snprintf(table_entry->ieee8021BridgeBasePortName, sizeof(table_entry->ieee8021BridgeBasePortName),
                       "Port %2u", iport2uport(dot1Port_info.if_id));
#endif /* VTSS_SWITCH_STACKABLE */
        break;
    case DOT1PORT_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(dot1Port_info.isid, dot1Port_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(dot1Port_info.isid, dot1Port_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

        (void)port_iter_init(&pit, NULL, dot1Port_info.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            IEEE8021BRIDGE_BasePortTable_update(dot1Port_info.isid, pit.iport, table_entry);
        }

#if VTSS_SWITCH_STACKABLE
        (void)snprintf(table_entry->ieee8021BridgeBasePortName, sizeof(table_entry->ieee8021BridgeBasePortName),
                       "Switch %2d - Local Link Aggregations %2lu", topo_isid2usid(dot1Port_info.isid), dot1Port_info.if_id);
#else
        (void)snprintf(table_entry->ieee8021BridgeBasePortName, sizeof(table_entry->ieee8021BridgeBasePortName),
                       "Link Aggregations %2lu", dot1Port_info.if_id);
#endif /* VTSS_SWITCH_STACKABLE */

        break;
    case DOT1PORT_TYPE_GLAG:
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (aggr_mgmt_port_members_get(sit.isid, mgmt_aggr_id2no(dot1Port_info.if_id), &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                IEEE8021BRIDGE_BasePortTable_update(sit.isid, pit.iport, table_entry);
            }
        }
        (void)snprintf(table_entry->ieee8021BridgeBasePortName, sizeof(table_entry->ieee8021BridgeBasePortName),
                       "Global Link Aggregations %lu", dot1Port_info.if_id);
        break;
    case DOT1PORT_TYPE_UNDEF:
    default:
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;

}


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021BridgeBasePortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021BridgeBasePortTableEntry_getfirst
(ieee8021BridgeBasePortTable_entry_t *table_entry)
{
    u_long tmp_componentId = 0;
    u_long tmp_basePort = 0;

    T_D("enter");

    if (VTSS_RC_OK != IEEE8021BRIDGE_BasePortTableEntryKey_getnext(&tmp_componentId, &tmp_basePort)) {
        return -1;
    }
    table_entry->ieee8021BridgeBasePortComponentId = tmp_componentId;
    table_entry->ieee8021BridgeBasePort = tmp_basePort;

    T_D("exit");
    return IEEE8021BRIDGE_BasePortTableEntry_get(table_entry);
}

/**
  * \brief Get/Getnext table entry of ieee8021BridgeBasePortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021BridgeBasePortTableEntry_get(ieee8021BridgeBasePortTable_entry_t *
                                     table_entry, int getnext)
{
    u_long tmp_componentId = table_entry->ieee8021BridgeBasePortComponentId;
    u_long tmp_basePort = table_entry->ieee8021BridgeBasePort;

    T_D("enter");
    if (getnext) {
        if (VTSS_RC_OK != IEEE8021BRIDGE_BasePortTableEntryKey_getnext(&tmp_componentId, &tmp_basePort)) {
            return -1;
        }
    } else {
        if (VTSS_RC_OK != IEEE8021BRIDGE_BasePortTableEntryKey_get(&tmp_componentId, &tmp_basePort)) {
            T_E("VTSS_RC_ERROR");
            return -1;
        }
    }

    table_entry->ieee8021BridgeBasePortComponentId = tmp_componentId;
    table_entry->ieee8021BridgeBasePort = tmp_basePort;

    T_D("exit");
    return IEEE8021BRIDGE_BasePortTableEntry_get(table_entry);
}

/**
  * \brief Set table entry of ieee8021BridgeBasePortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021BridgeBasePortTableEntry_set(ieee8021BridgeBasePortTable_entry_t *
                                     table_entry)
{
    dot1Port_info_t     info;
    mstp_port_param_t   conf;
    BOOL                enable;
    port_iter_t         pit;
    switch_iter_t       sit;
    aggr_mgmt_group_member_t aggr_members;

    T_D("enter");

    info.dot1port = table_entry->ieee8021BridgeBasePort;
    (void) dot1Port_get(&info);

    switch (info.type) {
    case DOT1PORT_TYPE_PORT:
        if (FALSE == mstp_get_port_config(info.isid, info.if_id, &enable, &conf)) {
            T_E("mstp_get_port_config: error(%d, %lu)", info.isid, info.if_id);
            return -1;
        }

        conf.adminPointToPointMAC =  table_entry->ieee8021BridgeBasePortAdminPointToPoint == 3 ? P2P_AUTO : table_entry->ieee8021BridgeBasePortAdminPointToPoint == 2 ? P2P_FORCEFALSE :
                                     table_entry->ieee8021BridgeBasePortAdminPointToPoint == 1 ? P2P_FORCETRUE : 0;

        if (FALSE == mstp_set_port_config(info.isid, info.if_id, enable, &conf)) {
            T_E("mstp_get_port_config: error(%d, %lu)", info.isid, info.if_id);
            return -1;
        }
        break;
    case DOT1PORT_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(info.isid, info.if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(info.isid, info.if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return -1;
        }

        (void)port_iter_init(&pit, NULL, info.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            if (FALSE == mstp_get_port_config(info.isid, pit.iport, &enable, &conf)) {
                T_E("mstp_get_port_config: error(%d, %u)", info.isid, pit.iport);
                return -1;
            }

            conf.adminPointToPointMAC =  table_entry->ieee8021BridgeBasePortAdminPointToPoint == 3 ? P2P_AUTO : table_entry->ieee8021BridgeBasePortAdminPointToPoint == 2 ? P2P_FORCEFALSE :
                                         table_entry->ieee8021BridgeBasePortAdminPointToPoint == 1 ? P2P_FORCETRUE : 0;

            if (FALSE == mstp_set_port_config(info.isid, pit.iport, enable, &conf)) {
                T_E("mstp_get_port_config: error(%d, %u)", info.isid, pit.iport);
                return -1;
            }

        }
        break;
    case DOT1PORT_TYPE_GLAG:
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (aggr_mgmt_port_members_get(sit.isid, mgmt_aggr_id2no(info.if_id), &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (FALSE == mstp_get_port_config(sit.isid, pit.iport, &enable, &conf)) {
                    T_E("mstp_get_port_config: error(%d, %u)", sit.isid, pit.iport);
                    return -1;
                }

                conf.adminPointToPointMAC =  table_entry->ieee8021BridgeBasePortAdminPointToPoint == 3 ? P2P_AUTO : table_entry->ieee8021BridgeBasePortAdminPointToPoint == 2 ? P2P_FORCEFALSE :
                                             table_entry->ieee8021BridgeBasePortAdminPointToPoint == 1 ? P2P_FORCETRUE : 0;

                if (FALSE == mstp_set_port_config(sit.isid, pit.iport, enable, &conf)) {
                    T_E("mstp_get_port_config: error(%d, %u)", sit.isid, pit.iport);
                    return -1;
                }
            }
        }
        break;
    case DOT1PORT_TYPE_UNDEF:
    default:
        return -1;

    }

    T_D("exit");
    return 0;
}
