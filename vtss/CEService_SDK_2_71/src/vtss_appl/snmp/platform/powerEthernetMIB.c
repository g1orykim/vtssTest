/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.4 2010/03/15 13:55:22 pchen Exp $
 */

#include <main.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/drv_api.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "misc_api.h"
#include "powerEthernetMIB.h"
#include "l2proto_api.h"
#include "msg_api.h"
#include "ifIndex_api.h"
#include "poe_api.h"
#include "poe_custom_api.h"
#include "cli_trace_def.h"
#include "mibContextTable.h"  //mibContextTable_register

/*
 * The entry data structure for pethPsePortTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            pethPsePortGroupIndex;
    long            pethPsePortIndex;

    /*
     * Entry columns
     */
    long            pethPsePortAdminEnable;
    long            pethPsePortPowerPairsControlAbility;
    long            pethPsePortPowerPairs;
    long            pethPsePortDetectionStatus;
    long            pethPsePortPowerPriority;
    u_long          pethPsePortMPSAbsentCounter;
    char            pethPsePortType[SPRINT_MAX_LEN];
    size_t          pethPsePortType_len;
    long            pethPsePortPowerClassifications;
    u_long          pethPsePortInvalidSignatureCounter;
    u_long          pethPsePortPowerDeniedCounter;
    u_long          pethPsePortOverLoadCounter;
    u_long          pethPsePortShortCounter;
} pethPsePortTable_entry_t;
/*
 * The entry data structure for pethMainPseTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            pethMainPseGroupIndex;

    /*
     * Entry columns
     */
    u_long          pethMainPsePower;
    long            pethMainPseOperStatus;
    u_long          pethMainPseConsumptionPower;
    long            pethMainPseUsageThreshold;
} pethMainPseTable_entry_t;
/*
 * The entry data structure for pethNotificationControlTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            pethNotificationControlGroupIndex;

    /*
     * Entry columns
     */
    long            pethNotificationControlEnable;
} pethNotificationControlTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
    char            string_ret[SPRINT_MAX_LEN];
    u_long          ulong_ret;
} ucdSnmp_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ucdSnmp_return_t global_ret;     /* static variables for retuning */

/*
 * powerEthernetMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             powerEthernetMIB_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 105 };



/*
 * variable powerEthernetMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the powerEthernetMIB mib section
 */

struct variable7 powerEthernetMIB_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

    /*#define PETHPSEPORTGROUPINDEX     1
        {PETHPSEPORTGROUPINDEX, ASN_INTEGER, RONLY, var_pethPsePortTable, 4,
         {1, 1, 1, 1}},
    #define PETHPSEPORTINDEX        2
        {PETHPSEPORTINDEX, ASN_INTEGER, RONLY, var_pethPsePortTable, 4,
         {1, 1, 1, 2}},*/
#define PETHPSEPORTADMINENABLE      3
    {
        PETHPSEPORTADMINENABLE, ASN_INTEGER, RWRITE, var_pethPsePortTable, 4,
        {1, 1, 1, 3}
    },
#define PETHPSEPORTPOWERPAIRSCONTROLABILITY     4
    {
        PETHPSEPORTPOWERPAIRSCONTROLABILITY, ASN_INTEGER, RONLY,
        var_pethPsePortTable, 4, {1, 1, 1, 4}
    },
#define PETHPSEPORTPOWERPAIRS       5
    {
        PETHPSEPORTPOWERPAIRS, ASN_INTEGER, RWRITE, var_pethPsePortTable, 4,
        {1, 1, 1, 5}
    },
#define PETHPSEPORTDETECTIONSTATUS      6
    {
        PETHPSEPORTDETECTIONSTATUS, ASN_INTEGER, RONLY, var_pethPsePortTable,
        4, {1, 1, 1, 6}
    },
#define PETHPSEPORTPOWERPRIORITY        7
    {
        PETHPSEPORTPOWERPRIORITY, ASN_INTEGER, RWRITE, var_pethPsePortTable,
        4, {1, 1, 1, 7}
    },
#define PETHPSEPORTMPSABSENTCOUNTER     8
    {
        PETHPSEPORTMPSABSENTCOUNTER, ASN_COUNTER, RONLY, var_pethPsePortTable,
        4, {1, 1, 1, 8}
    },
#define PETHPSEPORTTYPE     9
    {
        PETHPSEPORTTYPE, ASN_OCTET_STR, RWRITE, var_pethPsePortTable, 4,
        {1, 1, 1, 9}
    },
#define PETHPSEPORTPOWERCLASSIFICATIONS     10
    {
        PETHPSEPORTPOWERCLASSIFICATIONS, ASN_INTEGER, RONLY,
        var_pethPsePortTable, 4, {1, 1, 1, 10}
    },
#define PETHPSEPORTINVALIDSIGNATURECOUNTER      11
    {
        PETHPSEPORTINVALIDSIGNATURECOUNTER, ASN_COUNTER, RONLY,
        var_pethPsePortTable, 4, {1, 1, 1, 11}
    },
#define PETHPSEPORTPOWERDENIEDCOUNTER       12
    {
        PETHPSEPORTPOWERDENIEDCOUNTER, ASN_COUNTER, RONLY,
        var_pethPsePortTable, 4, {1, 1, 1, 12}
    },
#define PETHPSEPORTOVERLOADCOUNTER      13
    {
        PETHPSEPORTOVERLOADCOUNTER, ASN_COUNTER, RONLY, var_pethPsePortTable,
        4, {1, 1, 1, 13}
    },
#define PETHPSEPORTSHORTCOUNTER     14
    {
        PETHPSEPORTSHORTCOUNTER, ASN_COUNTER, RONLY, var_pethPsePortTable, 4,
        {1, 1, 1, 14}
    },
#define PETHMAINPSEGROUPINDEX       15
    {
        PETHMAINPSEGROUPINDEX, ASN_INTEGER, RONLY, var_pethMainPseTable, 5,
        {1, 3, 1, 1, 1}
    },
#define PETHMAINPSEPOWER        16
    {
        PETHMAINPSEPOWER, ASN_GAUGE, RONLY, var_pethMainPseTable, 5,
        {1, 3, 1, 1, 2}
    },
#define PETHMAINPSEOPERSTATUS       17
    {
        PETHMAINPSEOPERSTATUS, ASN_INTEGER, RONLY, var_pethMainPseTable, 5,
        {1, 3, 1, 1, 3}
    },
#define PETHMAINPSECONSUMPTIONPOWER     18
    {
        PETHMAINPSECONSUMPTIONPOWER, ASN_GAUGE, RONLY, var_pethMainPseTable,
        5, {1, 3, 1, 1, 4}
    },
#define PETHMAINPSEUSAGETHRESHOLD       19
    {
        PETHMAINPSEUSAGETHRESHOLD, ASN_INTEGER, RWRITE, var_pethMainPseTable,
        5, {1, 3, 1, 1, 5}
    },
    /*#define PETHNOTIFICATIONCONTROLGROUPINDEX       20
        {
            PETHNOTIFICATIONCONTROLGROUPINDEX, ASN_INTEGER, RONLY,
            var_pethNotificationControlTable, 5, {1, 4, 1, 1, 1}
        },
    #define PETHNOTIFICATIONCONTROLENABLE       21
        {
            PETHNOTIFICATIONCONTROLENABLE, ASN_INTEGER, RWRITE,
            var_pethNotificationControlTable, 5, {1, 4, 1, 1, 2}
        },*/
};
/********************************************************************
  * Purpose   : Retrieves the stack id of the switch.
  * Arguments : idx_num: Given stack id number.
  * Re-Entrant: Must be Re-entrant.
  ********************************************************************/

u32 get_available_group_index(u32 idx_num)
{
    u32 isid;
    for (isid = idx_num == 0 ? 1 : idx_num; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists (isid)) {
            continue;
        }
        return topo_isid2usid(isid);
    }
    return VTSS_ISID_END;
}

BOOL get_pethPsePortTable_entry(i32 usid, i32 uport, pethPsePortTable_entry_t *table_entry)
{
    poe_status_t           poe_status;
    poe_custom_entry_t     hw_cfg;
    poe_local_conf_t       conf;
    vtss_port_no_t         iport = uport2iport(uport);
    vtss_isid_t            isid = topo_usid2isid(usid);

    memset(&hw_cfg, 0, sizeof(hw_cfg));
    memset(&poe_status, 0, sizeof(poe_status));
    memset(&conf, 0, sizeof(conf));

    poe_mgmt_get_status(isid, &poe_status);
    poe_mgmt_get_local_config(&conf, isid);
    hw_cfg = poe_custom_get_hw_config(iport, &hw_cfg);

    if (!hw_cfg.available) {
        return FALSE;
    }
    table_entry->pethPsePortGroupIndex = usid;
    table_entry->pethPsePortAdminEnable = (conf.poe_mode[iport] == POE_MODE_POE_DISABLED) ? PSE_PORT_ADMIN_OFF : PSE_PORT_ADMIN_ON ;
    table_entry->pethPsePortPowerPairsControlAbility = hw_cfg.pse_pairs_control_ability ? PSE_PORT_POWER_CONTROL_ENABLE : PSE_PORT_POWER_CONTROL_DISABLE;
    table_entry->pethPsePortPowerPairs = (hw_cfg.pse_power_pair == PSE_PORT_POWER_PAIR_SIGNAL) ? PSE_PORT_POWER_PAIR_SIGNAL : PSE_PORT_POWER_PAIR_SPARE;
    table_entry->pethPsePortDetectionStatus = PSE_PORT_DETECTION_DISABLED;
    if (conf.priority[iport] == LOW) {
        table_entry->pethPsePortPowerPriority = PSE_PORT_POWER_PRIORITY_LOW;
    } else if (conf.priority[iport] == HIGH) {
        table_entry->pethPsePortPowerPriority = PSE_PORT_POWER_PRIORITY_HIGH;
    } else {
        table_entry->pethPsePortPowerPriority = PSE_PORT_POWER_PRIORITY_CRITICAL;
    }

    table_entry->pethPsePortMPSAbsentCounter = 0;
    memset(table_entry->pethPsePortType, 0, sizeof(table_entry->pethPsePortType));
    table_entry->pethPsePortPowerClassifications = poe_status.pd_class[iport] + 1; // since  0 is not defined in the MIB
    table_entry->pethPsePortInvalidSignatureCounter = 0;
    table_entry->pethPsePortPowerDeniedCounter = 0;
    table_entry->pethPsePortOverLoadCounter = 0;
    table_entry->pethPsePortShortCounter = 0;
    return TRUE;
}
/*
 * Initializes the powerEthernetMIB module
 */
void
init_powerEthernetMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(powerEthernetMIB_variables_oid,
                             sizeof(powerEthernetMIB_variables_oid) / sizeof(oid),
                             "POWER-ETHERNET-MIB : powerEthernetMIB");

    DEBUGMSGTL(("powerEthernetMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("powerEthernetMIB", powerEthernetMIB_variables, variable7,
                 powerEthernetMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_powerEthernetMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_powerEthernetMIB(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_powerEthernetMIB\n",
                    vp->magic));
    }
    return NULL;
}

static int
getfirst_pethPsePortTableEntry(pethPsePortTable_entry_t *table_entry)
{
    i32                    usid;
    i32                    uport;
    u32                    isid = 1;
    iftable_info_t         table_info;

    table_info.ifIndex = 0;
    if (FALSE == ifIndex_get_next(&table_info)) {
        return 1;
    }
    uport = iport2uport(table_info.if_id);

    usid = get_available_group_index(isid);

    table_entry->pethPsePortGroupIndex = usid;
    table_entry->pethPsePortIndex = 1;
    if (!get_pethPsePortTable_entry(usid, uport, table_entry)) {
        return 1;
    }
    return 0;
}

static int
get_pethPsePortTableEntry(pethPsePortTable_entry_t *table_entry,
                          BOOL getnext, int table_size)
{
    /*
     * FIXME : return non-zero value when fail
     */
    i32                    usid;
    i32                    uport;

    if (getnext) {
        table_entry->pethPsePortIndex++;
        if (table_entry->pethPsePortIndex > table_size) {
            table_entry->pethPsePortGroupIndex++;
            table_entry->pethPsePortIndex = 1;
        }
    }

    if (!VTSS_ISID_LEGAL(table_entry->pethPsePortGroupIndex)) {
        return 1;
    }

    usid = get_available_group_index(table_entry->pethPsePortGroupIndex);

    if ( VTSS_ISID_END == usid ) {
        return 1;
    }

    if (table_entry->pethPsePortIndex > (long)port_isid_port_count(topo_usid2isid(usid))) {
        return 1;
    }

    uport = table_entry->pethPsePortIndex;

    if (!get_pethPsePortTable_entry(usid, uport, table_entry)) {
        return 1;
    }

    return 0;
}

static int
set_pethPsePortTableEntry(pethPsePortTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    iftable_info_t   table_info;
    poe_local_conf_t conf;

    table_info.type = IFTABLE_IFINDEX_TYPE_PORT;
    table_info.isid = topo_usid2isid (table_entry->pethPsePortGroupIndex);
    table_info.if_id = uport2iport(table_entry->pethPsePortIndex);

    if ( FALSE == ifIndex_get_by_interface( &table_info ) ) {
        return FALSE;
    }

    poe_mgmt_get_local_config(&conf, table_entry->pethPsePortGroupIndex);
    if (table_entry->pethPsePortAdminEnable == PSE_PORT_ADMIN_OFF) {
        conf.poe_mode[table_info.if_id] = POE_MODE_POE_DISABLED;
    } else {
        conf.poe_mode[table_info.if_id] = POE_MODE_POE;
    }
    if (table_entry->pethPsePortPowerPriority == PSE_PORT_POWER_PRIORITY_CRITICAL) {
        conf.priority[table_info.if_id] = CRITICAL;
    } else if (table_entry->pethPsePortPowerPriority == PSE_PORT_POWER_PRIORITY_HIGH) {
        conf.priority[table_info.if_id] = HIGH;
    } else {
        conf.priority[table_info.if_id] = LOW;
    }

    poe_mgmt_set_local_config(&conf, table_entry->pethPsePortGroupIndex);

    return 0;
}

static int
parse_pethPsePortTable(oid *name,
                       size_t *length,
                       int exact, pethPsePortTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_pethPsePortTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->pethPsePortGroupIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->pethPsePortIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_pethPsePortTable(oid *name,
                         size_t *length,
                         pethPsePortTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->pethPsePortGroupIndex;
    name[name_pos++] = (oid) table_entry->pethPsePortIndex;
    *length = name_pos;
    return 0;
}

/*
 * var_pethPsePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
u_char         *
var_pethPsePortTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    pethPsePortTable_entry_t table_entry;
    int             table_size = VTSS_FRONT_PORT_COUNT;
    int i;
    int rtest;

    *write_method = NULL;

    for (i = 0, rtest = 0;
         i < (i32) vp->namelen && i < (i32) (*length) && !rtest; i++) {
        if (name[i] != vp->name[i]) {
            if (name[i] < vp->name[i]) {
                rtest = -1;
            } else {
                rtest = 1;
            }
        }
    }

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;
    memset(&table_entry, 0, sizeof(table_entry));

    if (rtest < 0) {
        memset((char *)name, 0, *length);
        memcpy((char *) name, (char *) vp->name,
               (int) (vp->namelen * sizeof(oid)));
        *length = vp->namelen;
    } else if (rtest > 0) {
        return NULL;
    }

    if ((rc =
             parse_pethPsePortTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_pethPsePortTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_pethPsePortTableEntry
                (&table_entry, exact ? FALSE : TRUE, table_size)) {
                return NULL;
            }
            if (fillobj_pethPsePortTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    /* case PETHPSEPORTGROUPINDEX:
         {
             global_ret.long_ret = table_entry.pethPsePortGroupIndex;
             *var_len = sizeof(global_ret.long_ret);
             return (u_char *) & global_ret.long_ret;
         }
     case PETHPSEPORTINDEX:
         {
             global_ret.long_ret = table_entry.pethPsePortIndex;
             *var_len = sizeof(global_ret.long_ret);
             return (u_char *) & global_ret.long_ret;
         }*/
    case PETHPSEPORTADMINENABLE: {
        *write_method = write_pethPsePortAdminEnable;
        global_ret.long_ret = table_entry.pethPsePortAdminEnable;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTPOWERPAIRSCONTROLABILITY: {
        global_ret.long_ret =
            table_entry.pethPsePortPowerPairsControlAbility;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTPOWERPAIRS: {
        // *write_method = write_pethPsePortPowerPairs;
        global_ret.long_ret = table_entry.pethPsePortPowerPairs;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTDETECTIONSTATUS: {
        global_ret.long_ret = table_entry.pethPsePortDetectionStatus;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTPOWERPRIORITY: {
        *write_method = write_pethPsePortPowerPriority;
        global_ret.long_ret = table_entry.pethPsePortPowerPriority;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTMPSABSENTCOUNTER: {
        global_ret.ulong_ret = table_entry.pethPsePortMPSAbsentCounter;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHPSEPORTTYPE: {
        //*write_method = write_pethPsePortType;
        strcpy(global_ret.string_ret, table_entry.pethPsePortType);
        *var_len = strlen(global_ret.string_ret);
        return (u_char *) global_ret.string_ret;
    }
    case PETHPSEPORTPOWERCLASSIFICATIONS: {
        global_ret.long_ret =
            table_entry.pethPsePortPowerClassifications;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHPSEPORTINVALIDSIGNATURECOUNTER: {
        global_ret.ulong_ret =
            table_entry.pethPsePortInvalidSignatureCounter;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHPSEPORTPOWERDENIEDCOUNTER: {
        global_ret.ulong_ret =
            table_entry.pethPsePortPowerDeniedCounter;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHPSEPORTOVERLOADCOUNTER: {
        global_ret.ulong_ret = table_entry.pethPsePortOverLoadCounter;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHPSEPORTSHORTCOUNTER: {
        global_ret.ulong_ret = table_entry.pethPsePortShortCounter;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_pethPsePortTable\n",
                    vp->magic));
    }
    return NULL;
}

/********************************************************************
  * Purpose   : Retrieves the total power used by the switch module
                in the stack.
  * Arguments : idx_num: stack id number.
  * Re-Entrant: Must be Re-entrant.
********************************************************************/

u32 get_total_power(poe_status_t *poe_status)
{
    u32 port;
    u32 total_power = 0;
    for (port = 0; port < VTSS_FRONT_PORT_COUNT; port++) {
        total_power += poe_status->power_used[port];
    }
    return total_power;
}
/********************************************************************
   * Purpose   : Retrieves the Main PSE table contents
   * Arguments : isid: stack id,table_entry: Pointer to the entire table
                 entry.
   * Re-Entrant: Must be Re-entrant.
********************************************************************/
BOOL get_pethMainPseTable_entry(i32 isid, pethMainPseTable_entry_t *table_entry)
{
    poe_status_t           poe_status;
    poe_custom_entry_t     hw_cfg;
    poe_local_conf_t       conf;
    u32                    chip;

    if (!msg_switch_exists (isid)) {
        return FALSE;
    }

    memset(&hw_cfg, 0, sizeof(hw_cfg));
    memset(&poe_status, 0, sizeof(poe_status));
    memset(&conf, 0, sizeof(conf));
    poe_mgmt_get_local_config(&conf, isid);
    poe_mgmt_get_status(isid, &poe_status);
    chip = poe_is_chip_found(0);
    table_entry->pethMainPsePower = conf.primary_power_supply;
    table_entry->pethMainPseOperStatus = ((chip != NO_POE_CHIPSET_FOUND) ? MAIN_PSE_POWER_ON : MAIN_PSE_POWER_OFF);
    table_entry->pethMainPseConsumptionPower = get_total_power(&poe_status);
    table_entry->pethMainPseUsageThreshold = 1; //since 0 is not defined for this object in the MIB
    return TRUE;
}

static int
getfirst_pethMainPseTableEntry(pethMainPseTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    i32                    table_index_1;
    u32                    isid = 1;

    table_index_1 = get_available_group_index(isid);

    if ( VTSS_ISID_END == table_index_1 ) {
        return 1;
    }

    table_entry->pethMainPseGroupIndex = isid;

    if (!get_pethMainPseTable_entry(table_index_1, table_entry)) {
        return 1;
    }
    return 0;
}

static int
get_pethMainPseTableEntry(pethMainPseTable_entry_t *table_entry,
                          BOOL getnext, int table_size)
{
    /*
     * FIXME : return non-zero value when fail
     */
    i32                    table_index_1;

    if (getnext) {
        table_entry->pethMainPseGroupIndex++;
        if (table_entry->pethMainPseGroupIndex > table_size) {
            return 1;
        } else {
            table_index_1 = get_available_group_index(table_entry->pethMainPseGroupIndex);
        }
    } else {
        table_index_1 = get_available_group_index(table_entry->pethMainPseGroupIndex);
    }

    if ( VTSS_ISID_END == table_index_1 ) {
        return 1;
    }

    if (!get_pethMainPseTable_entry(table_index_1, table_entry)) {
        return 1;
    }
    return 0;
}

static int
set_pethMainPseTableEntry(pethMainPseTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_pethMainPseTable(oid *name,
                       size_t *length,
                       int exact, pethMainPseTable_entry_t *table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    if (exact && *length < (10 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_pethMainPseTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->pethMainPseGroupIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_pethMainPseTable(oid *name,
                         size_t *length,
                         pethMainPseTable_entry_t *table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] = (oid) table_entry->pethMainPseGroupIndex;
    *length = name_pos;

    return 0;
}

/*
 * var_pethMainPseTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
u_char         *
var_pethMainPseTable(struct variable *vp,
                     oid *name,
                     size_t *length,
                     int exact,
                     size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    pethMainPseTable_entry_t table_entry;
    int             i, rtest;
    int             table_size = 1;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    for (i = 0, rtest = 0;
         i < (i32) vp->namelen && i < (i32) (*length) && !rtest; i++) {
        if (name[i] != vp->name[i]) {
            if (name[i] < vp->name[i]) {
                rtest = -1;
            } else {
                rtest = 1;
            }
        }
    }

    if (rtest < 0) {
        memset((char *)name, 0, *length);
        memcpy((char *) name, (char *) vp->name,
               (int) (vp->namelen * sizeof(oid)));
        *length = vp->namelen;
    } else if (rtest > 0) {
        return NULL;
    }


    if ((rc = parse_pethMainPseTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_pethMainPseTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_pethMainPseTableEntry
                (&table_entry, exact ? FALSE : TRUE, table_size)) {
                return NULL;
            }
            if (fillobj_pethMainPseTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    /* case PETHMAINPSEGROUPINDEX: {
         global_ret.long_ret = table_entry.pethMainPseGroupIndex;
         *var_len = sizeof(global_ret.long_ret);
         return (u_char *) & global_ret.long_ret;
     }*/
    case PETHMAINPSEPOWER: {
        global_ret.ulong_ret = table_entry.pethMainPsePower;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHMAINPSEOPERSTATUS: {
        global_ret.long_ret = table_entry.pethMainPseOperStatus;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    case PETHMAINPSECONSUMPTIONPOWER: {
        global_ret.ulong_ret = table_entry.pethMainPseConsumptionPower;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }
    case PETHMAINPSEUSAGETHRESHOLD: {
        *write_method = write_pethMainPseUsageThreshold;
        global_ret.long_ret = table_entry.pethMainPseUsageThreshold;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_pethMainPseTable\n",
                    vp->magic));
    }
    return NULL;
}
#if 0  // Noitfication table not supported
static int
getfirst_pethNotificationControlTableEntry
(pethNotificationControlTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_pethNotificationControlTableEntry(pethNotificationControlTable_entry_t
                                      * table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_pethNotificationControlTableEntry(pethNotificationControlTable_entry_t
                                      * table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_pethNotificationControlTable(oid *name,
                                   size_t *length,
                                   int exact,
                                   pethNotificationControlTable_entry_t *
                                   table_entry)
{
    size_t          op_pos = 10 + 2;
    oid            *op = (oid *) (name + op_pos);

    if (exact && *length < (10 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_pethNotificationControlTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->pethNotificationControlGroupIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_pethNotificationControlTable(oid *name,
                                     size_t *length,
                                     pethNotificationControlTable_entry_t *
                                     table_entry)
{
    int             name_pos = 10 + 2;

    name[name_pos++] =
        (oid) table_entry->pethNotificationControlGroupIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_pethNotificationControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_powerEthernetMIB above.
 */
u_char         *
var_pethNotificationControlTable(struct variable *vp,
                                 oid *name,
                                 size_t *length,
                                 int exact,
                                 size_t *var_len,
                                 WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    pethNotificationControlTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if ((rc =
             parse_pethNotificationControlTable(name, length, exact,
                                                &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_pethNotificationControlTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_pethNotificationControlTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_pethNotificationControlTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }


    // fill in object part of name for current entry

    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    /*case PETHNOTIFICATIONCONTROLGROUPINDEX: {
        global_ret.long_ret =
            table_entry.pethNotificationControlGroupIndex;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }
        case PETHNOTIFICATIONCONTROLENABLE: {
    *write_method = write_pethNotificationControlEnable;
    global_ret.long_ret =
        table_entry.pethNotificationControlEnable;
    *var_len = sizeof(global_ret.long_ret);
    return (u_char *) & global_ret.long_ret;
        }*/
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_pethNotificationControlTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif
int
write_pethPsePortAdminEnable(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    pethPsePortTable_entry_t table_entry;
    int             table_size = L2_MAX_PORTS;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortAdminEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortAdminEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortAdminEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethPsePortTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethPsePortTableEntry(&table_entry, FALSE, table_size)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.pethPsePortAdminEnable = set_value;
        if (set_pethPsePortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_pethPsePortPowerPairs(int action,
                            u_char *var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    pethPsePortTable_entry_t table_entry;
    int             table_size = L2_MAX_PORTS;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPairs: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPairs: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPairs: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethPsePortTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethPsePortTableEntry(&table_entry, FALSE, table_size)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.pethPsePortPowerPairs = set_value;
        if (set_pethPsePortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_pethPsePortPowerPriority(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    pethPsePortTable_entry_t table_entry;
    int             table_size = L2_MAX_PORTS;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPriority: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPriority: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2 && set_value != 3) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortPowerPriority: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethPsePortTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethPsePortTableEntry(&table_entry, FALSE, table_size)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.pethPsePortPowerPriority = set_value;
        if (set_pethPsePortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_pethPsePortType(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    pethPsePortTable_entry_t table_entry;
    int             table_size = L2_MAX_PORTS;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortType: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR,
                            "write to pethPsePortType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_len > 255) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethPsePortTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethPsePortTableEntry(&table_entry, FALSE, table_size)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.pethPsePortType, var_val, var_val_len);
        table_entry.pethPsePortType_len = var_val_len;
        if (set_pethPsePortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_pethMainPseUsageThreshold(int action,
                                u_char *var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char *statP,
                                oid *name, size_t name_len)
{
    long            set_value =  *(long *) var_val;
    pethMainPseTable_entry_t table_entry;
    int             table_size = 1;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to pethMainPseUsageThreshold: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethMainPseUsageThreshold: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if ((*var_val < 1) || (*var_val > 99)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethMainPseUsageThreshold: wrong value\n");
            return SNMP_ERR_BADVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethMainPseTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethMainPseTableEntry(&table_entry, FALSE, table_size)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.pethMainPseUsageThreshold = set_value;
        if (set_pethMainPseTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#if 0 // Noitfication table not supported

int
write_pethNotificationControlEnable(int action,
                                    u_char *var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char *statP,
                                    oid *name, size_t name_len)
{
    long            set_value = *(long *) var_val;
    pethNotificationControlTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to pethNotificationControlEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to pethNotificationControlEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1 && set_value != 2) {
            (void) snmp_log(LOG_ERR,
                            "write to pethNotificationControlEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_pethNotificationControlTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_pethNotificationControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.pethNotificationControlEnable = set_value;
        if (set_pethNotificationControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

