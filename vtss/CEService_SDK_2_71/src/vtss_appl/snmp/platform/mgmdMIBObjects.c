/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 *
 * * Note: this file originally auto-generated by mib2c using
 * *        : mib2c.old-api.conf,v 1.5 2010/07/19 09:20:45 annapurna Exp $
 */

#include <main.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif  /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else   /* 
*/
#include <strings.h>
#endif  /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include "mgmdMIBObjects.h"

#include "msg_api.h"
#include "l2proto_api.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"
#include "conf_api.h"
#include "ip2_api.h"

#ifdef VTSS_SW_OPTION_IPMC
#include "ipmc_api.h"
#else
#ifdef VTSS_SW_OPTION_MLDSNP
#include "mldsnp.h"
#endif /* VTSS_SW_OPTION_MLDSNP */
#ifdef VTSS_SW_OPTION_IGMPS
#include "igmps.h"
#endif /* VTSS_SW_OPTION_IGMPS */
#endif /* VTSS_SW_OPTION_IPMC */
#include "mibContextTable.h"  //mibContextTable_register

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP

typedef enum {
    InetAddressType_unknown = 0,
    InetAddressType_ipv4,
    InetAddressType_ipv6
} vtss_InetAddressType_t;

typedef enum {
    IPMC_UNKNOWN = 0,
    IGMP_MODE,
    MLD_MODE
} multicast_mode_t;

/*lint -esym(459, old_ipmc) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
/*lint -esym(459, new_ipmc) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
struct {
    uchar querier_state;
    uchar ipmc_state;

} old_ipmc, new_ipmc;
#define IFINDEX_IS_VALID_VLAN(ifindex)  (((ifindex) >= IFTABLE_IFINDEX_VLAN_START) && ((ifindex) <= IFTABLE_IFINDEX_VLAN_END))


/*
 *
 * * The entry data structure for mgmdHostInterfaceTable
 */
typedef struct {

    /*
    * Entry keys
    */
    long        mgmdHostInterfaceIfIndex;
    long        mgmdHostInterfaceQuerierType;

    /*
    * Entry columns
    */
    char            mgmdHostInterfaceQuerier[SPRINT_MAX_LEN];
    size_t mgmdHostInterfaceQuerier_len;
    long mgmdHostInterfaceStatus;
    u_long mgmdHostInterfaceVersion;
    u_long mgmdHostInterfaceVersion1QuerierTimer;
    u_long mgmdHostInterfaceVersion2QuerierTimer;
    u_long mgmdHostInterfaceVersion3Robustness;
} mgmdHostInterfaceTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterInterfaceTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterInterfaceIfIndex;
    long mgmdRouterInterfaceQuerierType;

    /*
     * Entry columns
     */
    char            mgmdRouterInterfaceQuerier[SPRINT_MAX_LEN];
    size_t mgmdRouterInterfaceQuerier_len;
    u_long mgmdRouterInterfaceQueryInterval;
    long mgmdRouterInterfaceStatus;
    u_long mgmdRouterInterfaceVersion;
    u_long mgmdRouterInterfaceQueryMaxResponseTime;
    u_long mgmdRouterInterfaceQuerierUpTime;
    u_long mgmdRouterInterfaceQuerierExpiryTime;
    u_long mgmdRouterInterfaceWrongVersionQueries;
    u_long mgmdRouterInterfaceJoins;
    long mgmdRouterInterfaceProxyIfIndex;
    u_long mgmdRouterInterfaceGroups;
    u_long mgmdRouterInterfaceRobustness;
    u_long mgmdRouterInterfaceLastMemberQueryInterval;
    u_long mgmdRouterInterfaceLastMemberQueryCount;
    u_long mgmdRouterInterfaceStartupQueryCount;
    u_long mgmdRouterInterfaceStartupQueryInterval;
} mgmdRouterInterfaceTable_entry_t;

/*
 *
 * * The entry data structure for mgmdHostCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdHostCacheAddressType;
    char mgmdHostCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdHostCacheAddress_len;
    long mgmdHostCacheIfIndex;

    /*
     * Entry columns
     */
    u_long mgmdHostCacheUpTime;
    char mgmdHostCacheLastReporter[SPRINT_MAX_LEN];
    size_t mgmdHostCacheLastReporter_len;
    long mgmdHostCacheSourceFilterMode;
} mgmdHostCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterCacheAddressType;
    char mgmdRouterCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterCacheAddress_len;
    long mgmdRouterCacheIfIndex;

    /*
     * Entry columns
     */
    char            mgmdRouterCacheLastReporter[SPRINT_MAX_LEN];
    size_t mgmdRouterCacheLastReporter_len;
    u_long mgmdRouterCacheUpTime;
    u_long mgmdRouterCacheExpiryTime;
    u_long mgmdRouterCacheExcludeModeExpiryTimer;
    u_long mgmdRouterCacheVersion1HostTimer;
    u_long mgmdRouterCacheVersion2HostTimer;
    long mgmdRouterCacheSourceFilterMode;
} mgmdRouterCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdInverseHostCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdInverseHostCacheIfIndex;
    long mgmdInverseHostCacheAddressType;
    char mgmdInverseHostCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdInverseHostCacheAddress_len;

    /*
     * Entry columns
     */
} mgmdInverseHostCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdInverseRouterCacheTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdInverseRouterCacheIfIndex;
    long mgmdInverseRouterCacheAddressType;
    char mgmdInverseRouterCacheAddress[SPRINT_MAX_LEN];
    size_t mgmdInverseRouterCacheAddress_len;

    /*
     * Entry columns
     */
} mgmdInverseRouterCacheTable_entry_t;

/*
 *
 * * The entry data structure for mgmdHostSrcListTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdHostSrcListAddressType;
    char mgmdHostSrcListAddress[SPRINT_MAX_LEN];
    size_t mgmdHostSrcListAddress_len;
    long mgmdHostSrcListIfIndex;
    char mgmdHostSrcListHostAddress[SPRINT_MAX_LEN];
    size_t mgmdHostSrcListHostAddress_len;

    /*
     * Entry columns
     */
    u_long mgmdHostSrcListExpire;

} mgmdHostSrcListTable_entry_t;

/*
 *
 * * The entry data structure for mgmdRouterSrcListTable
 */
typedef struct {

    /*
     * Entry keys
     */
    long            mgmdRouterSrcListAddressType;
    char mgmdRouterSrcListAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterSrcListAddress_len;
    long mgmdRouterSrcListIfIndex;
    char mgmdRouterSrcListHostAddress[SPRINT_MAX_LEN];
    size_t mgmdRouterSrcListHostAddress_len;

    /*
     * Entry columns
     */
    u_long mgmdRouterSrcListExpire;

} mgmdRouterSrcListTable_entry_t;


/*
 *
 * * The return data structure
 */
typedef struct {

    long           long_ret;
    char string_ret[SPRINT_MAX_LEN];
    u_long ulong_ret;
} ucdSnmp_return_t;


/*
 *
 * * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ucdSnmp_return_t global_ret;     /* static variables for retuning */

/*
 *
 * * mgmdMIBObjects_variables_oid:
 * *   this is the top level oid that we want to register under.  This
 * *   is essentially a prefix, with the suffix appearing in the
 * *   variable below.
 */

oid mgmdMIBObjects_variables_oid[] = {
    1, 3, 6, 1, 2, 1, 185, 1
};





/*
 *
 * * variable mgmdMIBObjects_variables:
 * *   this variable defines function callbacks and type return information
 * *   for the mgmdMIBObjects mib section
 */

struct variable4 mgmdMIBObjects_variables[] = {
    /*
     *
     * * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define MGMDHOSTINTERFACEQUERIER        1
    {
        MGMDHOSTINTERFACEQUERIER, ASN_OCTET_STR, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 3}
    },
#define MGMDHOSTINTERFACESTATUS     2
    {
        MGMDHOSTINTERFACESTATUS, ASN_INTEGER, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 4}
    },
#define MGMDHOSTINTERFACEVERSION        3
    {
        MGMDHOSTINTERFACEVERSION, ASN_UNSIGNED, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 5}
    },
#define MGMDHOSTINTERFACEVERSION1QUERIERTIMER       4
    {
        MGMDHOSTINTERFACEVERSION1QUERIERTIMER, ASN_TIMETICKS, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 6}
    },
#define MGMDHOSTINTERFACEVERSION2QUERIERTIMER       5
    {
        MGMDHOSTINTERFACEVERSION2QUERIERTIMER, ASN_TIMETICKS, RONLY,
        var_mgmdHostInterfaceTable, 3, {1, 1, 7}
    },
#define MGMDHOSTINTERFACEVERSION3ROBUSTNESS     6
    {
        MGMDHOSTINTERFACEVERSION3ROBUSTNESS, ASN_UNSIGNED, RWRITE,
        var_mgmdHostInterfaceTable, 3, {1, 1, 8}
    },
#define MGMDROUTERINTERFACEQUERIER      7
    {
        MGMDROUTERINTERFACEQUERIER, ASN_OCTET_STR, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 3}
    },
#define MGMDROUTERINTERFACEQUERYINTERVAL        8
    {
        MGMDROUTERINTERFACEQUERYINTERVAL, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 4}
    },
#define MGMDROUTERINTERFACESTATUS       9
    {
        MGMDROUTERINTERFACESTATUS, ASN_INTEGER, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 5}
    },
#define MGMDROUTERINTERFACEVERSION      10
    {
        MGMDROUTERINTERFACEVERSION, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 6}
    },
#define MGMDROUTERINTERFACEQUERYMAXRESPONSETIME     11
    {
        MGMDROUTERINTERFACEQUERYMAXRESPONSETIME, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 7}
    },
#define MGMDROUTERINTERFACEQUERIERUPTIME        12
    {
        MGMDROUTERINTERFACEQUERIERUPTIME, ASN_TIMETICKS, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 8}
    },
#define MGMDROUTERINTERFACEQUERIEREXPIRYTIME        13
    {
        MGMDROUTERINTERFACEQUERIEREXPIRYTIME, ASN_TIMETICKS, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 9}
    },
#define MGMDROUTERINTERFACEWRONGVERSIONQUERIES      14
    {
        MGMDROUTERINTERFACEWRONGVERSIONQUERIES, ASN_COUNTER, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 10}
    },
#define MGMDROUTERINTERFACEJOINS        15
    {
        MGMDROUTERINTERFACEJOINS, ASN_COUNTER, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 11}
    },
#define MGMDROUTERINTERFACEPROXYIFINDEX     16
    {
        MGMDROUTERINTERFACEPROXYIFINDEX, ASN_INTEGER, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 12}
    },
#define MGMDROUTERINTERFACEGROUPS       17
    {
        MGMDROUTERINTERFACEGROUPS, ASN_GAUGE, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 13}
    },
#define MGMDROUTERINTERFACEROBUSTNESS       18
    {
        MGMDROUTERINTERFACEROBUSTNESS, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 14}
    },
#define MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL      19
    {
        MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL, ASN_UNSIGNED, RWRITE,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 15}
    },
#define MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT     20
    {
        MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 16}
    },
#define MGMDROUTERINTERFACESTARTUPQUERYCOUNT        21
    {
        MGMDROUTERINTERFACESTARTUPQUERYCOUNT, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 17}
    },
#define MGMDROUTERINTERFACESTARTUPQUERYINTERVAL     22
    {
        MGMDROUTERINTERFACESTARTUPQUERYINTERVAL, ASN_UNSIGNED, RONLY,
        var_mgmdRouterInterfaceTable, 3, {2, 1, 18}
    },
    /*#define MGMDHOSTCACHEUPTIME       23
        {MGMDHOSTCACHEUPTIME, ASN_TIMETICKS, RONLY, var_mgmdHostCacheTable, 3,
         {3, 1, 4}},
    #define MGMDHOSTCACHELASTREPORTER       24
        {MGMDHOSTCACHELASTREPORTER, ASN_OCTET_STR, RONLY,
         var_mgmdHostCacheTable, 3, {3, 1, 5}},
    #define MGMDHOSTCACHESOURCEFILTERMODE       25
        {MGMDHOSTCACHESOURCEFILTERMODE, ASN_INTEGER, RONLY,
         var_mgmdHostCacheTable, 3, {3, 1, 6}},
    #define MGMDROUTERCACHELASTREPORTER     26
        {MGMDROUTERCACHELASTREPORTER, ASN_OCTET_STR, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 4}},
    #define MGMDROUTERCACHEUPTIME       27
        {MGMDROUTERCACHEUPTIME, ASN_TIMETICKS, RONLY, var_mgmdRouterCacheTable,
         3, {4, 1, 5}},
    #define MGMDROUTERCACHEEXPIRYTIME       28
        {MGMDROUTERCACHEEXPIRYTIME, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 6}},
    #define MGMDROUTERCACHEEXCLUDEMODEEXPIRYTIMER       29
        {MGMDROUTERCACHEEXCLUDEMODEEXPIRYTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 7}},
    #define MGMDROUTERCACHEVERSION1HOSTTIMER        30
        {MGMDROUTERCACHEVERSION1HOSTTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 8}},
    #define MGMDROUTERCACHEVERSION2HOSTTIMER        31
        {MGMDROUTERCACHEVERSION2HOSTTIMER, ASN_TIMETICKS, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 9}},
    #define MGMDROUTERCACHESOURCEFILTERMODE     32
        {MGMDROUTERCACHESOURCEFILTERMODE, ASN_INTEGER, RONLY,
         var_mgmdRouterCacheTable, 3, {4, 1, 10}},
    #define MGMDINVERSEHOSTCACHEADDRESS     33
        {MGMDINVERSEHOSTCACHEADDRESS, ASN_OCTET_STR, RONLY,
         var_mgmdInverseHostCacheTable, 3, {5, 1, 3}},
    #define MGMDINVERSEROUTERCACHEADDRESS       34
        {MGMDINVERSEROUTERCACHEADDRESS, ASN_OCTET_STR, RONLY,
         var_mgmdInverseRouterCacheTable, 3, {6, 1, 3}},
    #define MGMDHOSTSRCLISTEXPIRE       35
        {MGMDHOSTSRCLISTEXPIRE, ASN_TIMETICKS, RONLY, var_mgmdHostSrcListTable,
         3, {7, 1, 5}},
    #define MGMDROUTERSRCLISTEXPIRE     36
        {MGMDROUTERSRCLISTEXPIRE, ASN_TIMETICKS, RONLY,
         var_mgmdRouterSrcListTable, 3, {8, 1, 5}}, */
};

void get_multicast_mode(int vlanid, int *mode, int InetAddressType)
{

    *mode = IPMC_UNKNOWN;
    BOOL multi_cast_state = 0;
    vtss_isid_t                  isid = 0;
#ifdef VTSS_SW_OPTION_IPMC
    ipmc_intf_query_host_version_t   intf_version_entry;

    intf_version_entry.vid = vlanid;
    for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        }
        switch (InetAddressType) {

        case InetAddressType_ipv4:
            if (ipmc_mgmt_get_intf_version(isid, &intf_version_entry, IPMC_IP_VERSION_IGMP) == VTSS_OK) {
                if (ipmc_mgmt_get_mode(&multi_cast_state, IPMC_IP_VERSION_IGMP) == VTSS_RC_OK) {
                    if (multi_cast_state) {
                        *mode = IGMP_MODE;
                    }
                }
            }
            break;

        case InetAddressType_ipv6:
            if (ipmc_mgmt_get_intf_version(isid, &intf_version_entry, IPMC_IP_VERSION_MLD) == VTSS_OK) {
                if (ipmc_mgmt_get_mode(&multi_cast_state, IPMC_IP_VERSION_MLD) == VTSS_RC_OK) {
                    if (multi_cast_state) {
                        *mode = MLD_MODE;
                    }
                }
            }
            break;

        default:
            break;
        }
    }

#endif /* VTSS_SW_OPTION_IPMC */
}


/*
 *
 * * Initializes the mgmdMIBObjects module
 */
void
init_mgmdMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(mgmdMIBObjects_variables_oid,
                             sizeof(mgmdMIBObjects_variables_oid) / sizeof(oid),
                             "MGMD-MIB : mgmdMIBObjects");

    DEBUGMSGTL(("mgmdMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("mgmdMIBObjects", mgmdMIBObjects_variables, variable4, mgmdMIBObjects_variables_oid);


    /*
     * place any other initialization junk you need here
     */
}
#if 0

/*
 *
 * * var_mgmdMIBObjects():
 * *   This function is called every time the agent gets a request for
 * *   a scalar variable that might be found within your mib section
 * *   registered above.  It is up to you to do the right thing and
 * *   return the correct value.
 * *     You should also correct the value of "var_len" if necessary.
 * *
 * *   Please see the documentation for more information about writing
 * *   module extensions, and check out the examples in the examples
 * *   and mibII directories.
 */
u_char *
var_mgmdMIBObjects(struct variable *vp,
                   oid *name,

                   size_t *length,
                   int exact,

                   size_t *var_len,

                   WriteMethod **write_method)
{


    *write_method = NULL;

    if (header_generic(vp, name, length, exact, var_len, write_method) ==
        MATCH_FAILED) {

        return NULL;

    }




    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    default:

        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_mgmdMIBObjects\n",
                    vp->magic));

    }

    return NULL;

}
#endif

BOOL get_mgmdHostInterfaceTable_entry(i32 table_index_1, i32 table_index_2, mgmdHostInterfaceTable_entry_t *table_entry)

{
    ipmc_prot_intf_entry_param_t    intf_param;
    u_char   ip4_addr[4];
    vtss_ipv4_t     ipv4_value = 0;      /* IPv4 address */
    vtss_isid_t     isid = 0;
    int             mode = 0;
    BOOL            vlan_state = 0, dummy = 0;
    ushort          vlan = 0;
#ifdef VTSS_SW_OPTION_IPMC
    ipmc_intf_query_host_version_t  intf_version_entry;
    ipmc_ip_version_t               ipmc_ip_version = 0;
    iftable_info_t                  if_info;

    if_info.ifIndex = table_index_1;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ||
        ipmc_mgmt_get_intf_info(VTSS_ISID_GLOBAL, if_info.if_id, &intf_param, table_index_2 == IGMP_MODE ? IPMC_IP_VERSION_IGMP : IPMC_IP_VERSION_MLD)) {
        return FALSE;
    }

    vlan = if_info.if_id;

    memset(table_entry, 0x0, sizeof(mgmdHostInterfaceTable_entry_t));
    memset(&intf_version_entry, 0x0, sizeof(ipmc_intf_query_host_version_t));
    mode = table_index_2;
    if (mode) {
        table_entry->mgmdHostInterfaceQuerierType =  mode;
        table_entry->mgmdHostInterfaceIfIndex =  table_index_1;
        table_entry->mgmdHostInterfaceVersion2QuerierTimer =  100;
        table_entry->mgmdHostInterfaceVersion3Robustness =  2;

        if (mode == IGMP_MODE) {
            u32 tmp;
            memcpy(&tmp, (u8 *)&intf_param.active_querier + 12, sizeof(ipv4_value));
            ipv4_value = htonl(tmp);
        }

        if (mode == MLD_MODE) {
            ipmc_ip_version =   IPMC_IP_VERSION_MLD;
#ifdef VTSS_SW_OPTION_IPV6
            table_entry->mgmdHostInterfaceQuerier_len = 16;
            // FIXME: Please fix me!
            memcpy(table_entry->mgmdHostInterfaceQuerier, &intf_param.active_querier, table_entry->mgmdHostInterfaceQuerier_len);
#endif
        } else {
            ipmc_ip_version = IPMC_IP_VERSION_IGMP;
            table_entry->mgmdHostInterfaceQuerier_len = 4;
            ip4_addr[0] = (ipv4_value >> 24) & 0xff;
            ip4_addr[1] = (ipv4_value >> 16) & 0xff;
            ip4_addr[2] = (ipv4_value >> 8) & 0xff;
            ip4_addr[3] =  ipv4_value & 0xff;
            memcpy(table_entry->mgmdHostInterfaceQuerier, (char *)ip4_addr, table_entry->mgmdHostInterfaceQuerier_len);
        }
    }

    for (isid = VTSS_ISID_START;
         isid < VTSS_ISID_END;
         isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        }

        memset(&intf_version_entry, 0x0, sizeof(ipmc_intf_query_host_version_t));
        intf_version_entry.vid = vlan;
        if (ipmc_mgmt_get_intf_version(isid, &intf_version_entry, ipmc_ip_version) != VTSS_OK) {
            return FALSE;
        }

        table_entry->mgmdHostInterfaceVersion = intf_version_entry.host_version;
    }

    if (ipmc_mgmt_get_intf_state_querier(TRUE, &vlan, &vlan_state, &dummy, 0, ipmc_ip_version) != VTSS_OK) {
        return FALSE;
    }

    if (mode && vlan_state) {
        table_entry->mgmdHostInterfaceStatus = SNMP_ROW_ACTIVE;
    } else {
        table_entry->mgmdHostInterfaceStatus = SNMP_ROW_NOTINSERVICE;
    }

    if (table_entry->mgmdHostInterfaceVersion == 0) {
        table_entry->mgmdHostInterfaceVersion = 3;
    }
#endif
    return TRUE;
}



static int
getfirst_mgmdHostInterfaceTableEntry(mgmdHostInterfaceTable_entry_t *
                                     table_entry)
{

    i32             table_index_1, table_index_2;
    int             mode = IPMC_UNKNOWN;
    int             querier_type = 1;
    iftable_info_t  if_info;

    /* table_index_1 denotes ifIndex of this vlan, table_index_2 denotes
     * querier type
     */
    if_info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    if (FALSE == ifIndex_get_first_by_type(&if_info)) {
        T_E("get ifIndex fail");
        return 1;
    }

    do {
        get_multicast_mode((int)if_info.if_id, &mode, querier_type);
        if (mode == IPMC_UNKNOWN) {
            if (querier_type < 2) {
                querier_type++;
            } else {
                querier_type = 1;
                if ((FALSE == ifIndex_get_next(&if_info)) ||
                    (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type)) {
                    return 1;
                }
            }
        }
    } while (mode == IPMC_UNKNOWN);

    table_index_1 = if_info.ifIndex;
    table_index_2 = mode;
    if (!get_mgmdHostInterfaceTable_entry(table_index_1, table_index_2, table_entry)) {
        return 1;
    }
    return 0;
}


static int
get_mgmdHostInterfaceTableEntry(mgmdHostInterfaceTable_entry_t *
                                table_entry, BOOL getnext)
{
    i32             table_index_1;
    i32             table_index_2;
    int             mode = IPMC_UNKNOWN;
    iftable_info_t  if_info;

    if ((!table_entry) ||
        (table_entry->mgmdHostInterfaceQuerierType > 2)) {
        return 1;
    }

    /* check if the current ifIndex is valid, the API will set if_info.if_id to
     * vid which we can use for getting mode directly.
     */
    if_info.ifIndex = table_entry->mgmdHostInterfaceIfIndex;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ) {
        return 1;
    }

    if (getnext) {
        /* in get next, first bump the QT, if it goes over 2 we need to run a
         * loop to find the next VLAN for which any mode is active.
         * we break when we find a good combo or we run out of VLANs.
         */
        table_entry->mgmdHostInterfaceQuerierType++;
        if (table_entry->mgmdHostInterfaceQuerierType > 2) {
            if ((FALSE == ifIndex_get_next(&if_info)) ||
                (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type)) {
                return 1;
            }
            table_entry->mgmdHostInterfaceQuerierType = 1;
        }

        do {
            /* get mode for this vid-QT combo */
            get_multicast_mode((int) if_info.if_id, &mode, table_entry->mgmdHostInterfaceQuerierType);
            /* if success, break */
            /* else, bump QT and try */
            if (mode == IPMC_UNKNOWN) {
                if (table_entry->mgmdHostInterfaceQuerierType < 2) {
                    table_entry->mgmdHostInterfaceQuerierType++;
                } else {
                    /* it is likely that there is a VLAN for which neither v4 nor
                     * v6 is enabled, in this case move the next VLAN.
                     * if this is the last VLAN, return 1.
                     */
                    if ((FALSE == ifIndex_get_next(&if_info)) ||
                        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type)) {
                        return 1;
                    }
                    table_entry->mgmdHostInterfaceQuerierType = 1;
                }
            }
        } while (IPMC_UNKNOWN == mode);
    } else {
        get_multicast_mode((int) if_info.if_id, &mode, table_entry->mgmdHostInterfaceQuerierType);
    }

    table_index_1 = if_info.ifIndex;
    table_index_2 = mode;
    if (!get_mgmdHostInterfaceTable_entry(table_index_1, table_index_2, table_entry)) {
        return 1;
    }
    return 0;
}


static int
set_mgmdHostInterfaceTableEntry(mgmdHostInterfaceTable_entry_t *
                                table_entry)
{
    BOOL global_state;
    ushort vlan;
    int mode;
    long set_val = 0;
    ipmc_ip_version_t   ipmc_ip_version;
    iftable_info_t if_info;

    if ((!table_entry) ||
        (table_entry->mgmdHostInterfaceQuerierType > 2)) {
        return 1;
    }

    if_info.ifIndex = table_entry->mgmdHostInterfaceIfIndex;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ) {
        return 1;
    }

    vlan = if_info.if_id;
    set_val = table_entry->mgmdHostInterfaceStatus;
    get_multicast_mode((int)vlan, &mode, (int)table_entry->mgmdHostInterfaceQuerierType);
    ipmc_ip_version = mode;
    if (ipmc_mgmt_get_intf_state_querier(TRUE, &vlan, &old_ipmc.ipmc_state, &old_ipmc.querier_state, 0, ipmc_ip_version) != VTSS_OK) {
        return SNMP_ERR_BADVALUE;
    }

    /* Enable or Disable IGMPS state? */
    if (set_val == SNMP_ROW_ACTIVE) {
        new_ipmc.ipmc_state = 1;
    } else if (set_val == SNMP_ROW_NOTINSERVICE) {
        new_ipmc.ipmc_state = 0;
    } else {
        return SNMP_ERR_INCONSISTENTVALUE;
    }

    /* Enable Global IGMPS (if disabled) and VLAN IGMPS is enabled */
    if (ipmc_mgmt_get_mode(&global_state, ipmc_ip_version) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    if (!global_state) {
        global_state = 1;
        if (new_ipmc.ipmc_state) {
            if (ipmc_mgmt_set_mode(&global_state, ipmc_ip_version) != VTSS_OK) {
                return SNMP_ERR_INCONSISTENTVALUE;
            }
        }
    }

    if (old_ipmc.ipmc_state == new_ipmc.ipmc_state) {
        return 0;    /* Nothing to do  */
    }

    /* The querier state is never touched but the igmps_mgmt_set_vlan_state_querier wants to include it */
    new_ipmc.querier_state = old_ipmc.querier_state;

    /* Set the state    */
    if (ipmc_mgmt_set_intf_state_querier(IPMC_OP_SET, vlan, &new_ipmc.ipmc_state, &new_ipmc.querier_state, ipmc_ip_version) != VTSS_OK) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }
    return 0;
}

static int
parse_mgmdHostInterfaceTable(oid *name,
                             size_t *length,
                             int exact,

                             mgmdHostInterfaceTable_entry_t *
                             table_entry)
{
    size_t         op_pos = 9 + 2;
    oid *op = (oid *) (name + op_pos);

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_mgmdHostInterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1;              /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->mgmdHostInterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (*length > op_pos) {
        table_entry->mgmdHostInterfaceQuerierType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}


static int
fillobj_mgmdHostInterfaceTable(oid *name,
                               size_t *length,

                               mgmdHostInterfaceTable_entry_t *
                               table_entry)
{

    int            name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->mgmdHostInterfaceIfIndex;

    name[name_pos++] = (oid) table_entry->mgmdHostInterfaceQuerierType;

    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdHostInterfaceTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdHostInterfaceTable(struct variable *vp,
                           oid *name,
                           size_t *length,
                           int exact,
                           size_t *var_len,
                           WriteMethod **write_method)
{
    int            rc;
    oid newname[MAX_OID_LEN];
    size_t         newname_len;
    mgmdHostInterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;
    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_mgmdHostInterfaceTable(name, length, exact,
                                          &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {       /* getfirst */
        if (fillobj_mgmdHostInterfaceTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_mgmdHostInterfaceTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }

            if (fillobj_mgmdHostInterfaceTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }

            if (exact) {
                break;
            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case MGMDHOSTINTERFACEQUERIER: {
        memcpy(global_ret.string_ret,
               table_entry.mgmdHostInterfaceQuerier, table_entry.mgmdHostInterfaceQuerier_len);
        *var_len = table_entry.mgmdHostInterfaceQuerier_len;

        return (u_char *) global_ret.string_ret;
    }
    case MGMDHOSTINTERFACESTATUS: {
        *write_method = write_mgmdHostInterfaceStatus;
        global_ret.long_ret = table_entry.mgmdHostInterfaceStatus;
        *var_len = sizeof(global_ret.long_ret);

        return (u_char *) & global_ret.long_ret;
    }
    case MGMDHOSTINTERFACEVERSION: {
        *write_method = NULL; //write_mgmdHostInterfaceVersion;
        global_ret.ulong_ret = table_entry.mgmdHostInterfaceVersion;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION1QUERIERTIMER: {
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion1QuerierTimer;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION2QUERIERTIMER: {
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion2QuerierTimer;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    case MGMDHOSTINTERFACEVERSION3ROBUSTNESS: {
        *write_method = NULL; //write_mgmdHostInterfaceVersion3Robustness;
        global_ret.ulong_ret =
            table_entry.mgmdHostInterfaceVersion3Robustness;
        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdHostInterfaceTable\n",
                    vp->magic));
    }

    return NULL;
}

BOOL get_mgmdRouterInterfaceTable_entry(i32 table_index_1, i32 table_index_2, mgmdRouterInterfaceTable_entry_t *table_entry)
{
    ipmc_prot_intf_entry_param_t    intf_param;
    u_char  ip4_addr[4];
    vtss_ipv4_t     ipv4_value = 0;      /* IPv4 address */
    BOOL vlan_state = 0, dummy = 0, proxy_mode = 0;
    vtss_isid_t                  isid = 0;
    ushort vlan = 0;
    int mode = 0;
#ifdef VTSS_SW_OPTION_IPMC
    ipmc_intf_query_host_version_t   intf_version_entry;
    ipmc_ip_version_t   ipmc_ip_version = 0;
    ipmc_prot_intf_entry_param_t    vid_entry;
    ipmc_prot_intf_group_entry_t    group_vid_entry;
    iftable_info_t                  if_info;

    if_info.ifIndex = table_index_1;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ||
        ipmc_mgmt_get_intf_info(VTSS_ISID_GLOBAL, if_info.if_id, &intf_param, table_index_2 == IGMP_MODE ? IPMC_IP_VERSION_IGMP : IPMC_IP_VERSION_MLD)) {
        return FALSE;
    }
    vlan = if_info.if_id;

    memset(table_entry, 0x0, sizeof(mgmdRouterInterfaceTable_entry_t));
    memset(&intf_version_entry, 0x0, sizeof(ipmc_ip_version_t));
    memset(&vid_entry, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
    memset(&group_vid_entry, 0x0, sizeof(ipmc_prot_intf_group_entry_t));
    ////////////////////////router interface table////////////////////////////////
    table_entry->mgmdRouterInterfaceIfIndex =  table_index_1;
    mode = table_index_2;
    table_entry->mgmdRouterInterfaceQueryInterval = 125;
    table_entry->mgmdRouterInterfaceVersion = 3;
    table_entry->mgmdRouterInterfaceQueryMaxResponseTime = 100;
    table_entry->mgmdRouterInterfaceJoins =  table_entry->mgmdRouterInterfaceIfIndex;

    if (mode) {
        table_entry->mgmdRouterInterfaceQuerierType = mode;
        ipmc_ip_version = mode;
        if (mode == IGMP_MODE) {
            u32 tmp;
            memcpy(&tmp, (u8 *)&intf_param.active_querier + 12, sizeof(ipv4_value));
            ipv4_value = htonl(tmp);
        }
        if (mode == MLD_MODE) {  // MLD   /***************Querier*****/
#ifdef VTSS_SW_OPTION_IPV6
            table_entry->mgmdRouterInterfaceQuerier_len = 16;
            // FIXME: Please fix me!
            memcpy(table_entry->mgmdRouterInterfaceQuerier, &intf_param.active_querier, table_entry->mgmdRouterInterfaceQuerier_len);
#endif
        } else {

            /***************Querier*****/
            table_entry->mgmdRouterInterfaceQuerier_len = 4;
            ip4_addr[0] = (ipv4_value >> 24) & 0xff;
            ip4_addr[1] = (ipv4_value >> 16) & 0xff;
            ip4_addr[2] = (ipv4_value >> 8) & 0xff;
            ip4_addr[3] =  ipv4_value & 0xff;

            memcpy(table_entry->mgmdRouterInterfaceQuerier, (char *)ip4_addr, table_entry->mgmdRouterInterfaceQuerier_len);
        }
    }

    for (isid = VTSS_ISID_START;
         isid < VTSS_ISID_END;
         isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        }
        memset(&intf_version_entry, 0x0, sizeof(ipmc_intf_query_host_version_t));
        intf_version_entry.vid = vlan;
        if (ipmc_mgmt_get_intf_version(isid, &intf_version_entry, ipmc_ip_version) != VTSS_OK) {
            return FALSE;
        }

        table_entry->mgmdRouterInterfaceVersion = intf_version_entry.query_version;
        if (ipmc_mgmt_get_intf_state_querier(TRUE, &vlan, &vlan_state, &dummy, 0, ipmc_ip_version) == VTSS_OK) {
            memset(&vid_entry, 0, sizeof(ipmc_prot_intf_entry_param_t));
            if (ipmc_mgmt_get_intf_info(isid, vlan, &vid_entry, ipmc_ip_version) != VTSS_OK) {
                continue;
            }

            table_entry->mgmdRouterInterfaceVersion = 3;
            table_entry->mgmdRouterInterfaceJoins = table_entry->mgmdRouterInterfaceIfIndex;
            table_entry->mgmdRouterInterfaceQuerierExpiryTime =   vid_entry.querier.timeout;
            table_entry->mgmdRouterInterfaceProxyIfIndex = 0;
            table_entry->mgmdRouterInterfaceJoins +=  vid_entry.stats.igmp_v1_membership_join + vid_entry.stats.igmp_v2_membership_join +
                                                      vid_entry.stats.igmp_v3_membership_join + vid_entry.stats.mld_v1_membership_report + vid_entry.stats.mld_v2_membership_report;

            table_entry->mgmdRouterInterfaceQueryMaxResponseTime = vid_entry.querier.MaxResTime; //def val =100
            table_entry->mgmdRouterInterfaceQuerierUpTime =  vid_entry.querier.QuerierUpTime;
            table_entry->mgmdRouterInterfaceQuerierExpiryTime =   vid_entry.querier.OtherQuerierTimeOut;
            table_entry->mgmdRouterInterfaceWrongVersionQueries = vid_entry.stats.igmp_error_pkt + vid_entry.stats.mld_error_pkt;
            table_entry->mgmdRouterInterfaceProxyIfIndex = 0;

            table_entry->mgmdRouterInterfaceRobustness =  vid_entry.querier.RobustVari;
            table_entry->mgmdRouterInterfaceLastMemberQueryInterval =  vid_entry.querier.LastQryItv;
            table_entry->mgmdRouterInterfaceLastMemberQueryCount =  vid_entry.querier.LastQryCnt;
            table_entry->mgmdRouterInterfaceStartupQueryCount =  vid_entry.querier.StartUpCnt;
            table_entry->mgmdRouterInterfaceStartupQueryInterval = vid_entry.querier.StartUpItv;

            if (mode && vlan_state) {
                table_entry->mgmdRouterInterfaceStatus = SNMP_ROW_ACTIVE;
            } else {
                table_entry->mgmdRouterInterfaceStatus = SNMP_ROW_NOTINSERVICE;
            }
        }
        memset(&group_vid_entry, 0, sizeof(ipmc_prot_intf_group_entry_t));
        if (ipmc_mgmt_get_next_intf_group_info (isid, vlan, &group_vid_entry, ipmc_ip_version) == VTSS_OK) {
            table_entry->mgmdRouterInterfaceGroups = table_entry->mgmdRouterInterfaceIfIndex;
            if (group_vid_entry.vid == table_entry->mgmdRouterInterfaceIfIndex) {
                table_entry->mgmdRouterInterfaceGroups++;
            }
        }
        if (ipmc_mgmt_get_proxy(&proxy_mode, ipmc_ip_version) == VTSS_OK) {
            if (proxy_mode) {
                table_entry->mgmdRouterInterfaceProxyIfIndex = table_entry->mgmdRouterInterfaceIfIndex;
            }
        }

    }
#endif

    return TRUE;
}


static int
getfirst_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *
                                       table_entry)
{
    i32             table_index_1, table_index_2;
    int             mode = 0;
    int             querier_type = 1;
    iftable_info_t  if_info;

    /* table_index_1 denotes ifIndex of this vlan, table_index_2 denotes
     * querier type
     */

    if_info.type = IFTABLE_IFINDEX_TYPE_VLAN;
    if (FALSE == ifIndex_get_first_by_type(&if_info)) {
        return 1;
    }

    do {
        get_multicast_mode((int)if_info.if_id, &mode, (int)querier_type);
        if (mode == IPMC_UNKNOWN) {
            /* it is possible that snooping may not be enabled for first VLAN
             * so we must cycle to the first VLAN for which it is enabled and
             * test for both modes every time.
             */
            querier_type++;
            if (querier_type > 2) {
                querier_type = 1;
                if ((FALSE == ifIndex_get_next(&if_info)) ||
                    (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ) {
                    return 1;
                }
            }
        }
    } while (mode == IPMC_UNKNOWN);

    table_index_1 = if_info.ifIndex;
    table_index_2 = mode;

    if (!get_mgmdRouterInterfaceTable_entry(table_index_1, table_index_2, table_entry)) {
        return 1;
    }
    return 0;
}


static int
get_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *
                                  table_entry, BOOL getnext)
{
    i32             table_index_1, table_index_2;
    int             mode = 0;
    iftable_info_t  if_info;

    if ((!table_entry) ||
        (table_entry->mgmdRouterInterfaceQuerierType > 2)) {
        return 1;
    }

    /* check if the current ifIndex is valid, the API will set if_info.if_id to
     * vid which we can use for getting mode directly.
     */
    if_info.ifIndex = table_entry->mgmdRouterInterfaceIfIndex;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ) {
        return 1;
    }

    if (getnext) {
        /* in get next, first bump the QT, if it goes over 2 we need to run a
         * loop to find the next VLAN for which any mode is active.
         * we break when we find a good combo or we run out of VLANs.
         */
        table_entry->mgmdRouterInterfaceQuerierType++;
        if (table_entry->mgmdRouterInterfaceQuerierType > 2) {
            if ((FALSE == ifIndex_get_next(&if_info)) ||
                (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type)) {
                return 1;
            }
            table_entry->mgmdRouterInterfaceQuerierType = 1;
        }

        do {
            /* get mode for this vid-QT combo */
            get_multicast_mode((int) if_info.if_id, &mode, table_entry->mgmdRouterInterfaceQuerierType);
            /* if success, break */
            /* else, bump QT and try */
            if (mode == IPMC_UNKNOWN) {
                if (table_entry->mgmdRouterInterfaceQuerierType < 2) {
                    table_entry->mgmdRouterInterfaceQuerierType++;
                } else {
                    /* it is likely that there is a VLAN for which neither v4 nor
                     * v6 is enabled, in this case move the next VLAN.
                     * if this is the last VLAN, return 1.
                     */
                    if ((FALSE == ifIndex_get_next(&if_info)) ||
                        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type)) {
                        return 1;
                    }
                    table_entry->mgmdRouterInterfaceQuerierType = 1;
                }
            }
        } while (IPMC_UNKNOWN == mode);
    } else {
        get_multicast_mode((int) if_info.if_id, &mode, table_entry->mgmdRouterInterfaceQuerierType);
    }

    table_index_1 = if_info.ifIndex;
    table_index_2 = mode;
    if (!get_mgmdRouterInterfaceTable_entry(table_index_1, table_index_2, table_entry)) {
        return 1;
    }
    return 0;
}


static int
set_mgmdRouterInterfaceTableEntry(mgmdRouterInterfaceTable_entry_t *
                                  table_entry)
{

    BOOL                state, querier, next = TRUE;
    vtss_isid_t         isid;
    ipmc_ip_version_t   ipmc_ip_version = 0;
#ifdef VTSS_SW_OPTION_SMB_IPMC
    ipmc_prot_intf_entry_param_t vid_entry;
#endif /* VTSS_SW_OPTION_SMB_IPMC */
    vtss_vid_t      vid;
    iftable_info_t  if_info;

    if ((!table_entry) ||
        (table_entry->mgmdRouterInterfaceQuerierType > 2)) {
        return 1;
    }

    if_info.ifIndex = table_entry->mgmdRouterInterfaceIfIndex;
    if ((!ifIndex_get (&if_info)) ||
        (IFTABLE_IFINDEX_TYPE_VLAN != if_info.type) ) {
        return 1;
    }

    for (isid = VTSS_ISID_START;
         isid < VTSS_ISID_END;
         isid++) {
        if (!msg_switch_exists(isid)) {
            continue;
        }

        vid = 0;
        ipmc_ip_version = table_entry->mgmdRouterInterfaceQuerierType;
        while (ipmc_mgmt_get_intf_state_querier(TRUE, &vid, &state, &querier, next, ipmc_ip_version) == VTSS_OK) {

            if (vid != if_info.if_id) {
                continue;
            }

#ifdef VTSS_SW_OPTION_SMB_IPMC

            memset(&vid_entry, 0x0, sizeof(ipmc_prot_intf_entry_param_t));
            if (ipmc_mgmt_get_intf_info(isid, vid, &vid_entry, ipmc_ip_version) == VTSS_OK) {
                if (table_entry->mgmdRouterInterfaceRobustness) {
                    vid_entry.querier.RobustVari = table_entry->mgmdRouterInterfaceRobustness;
                }
                if (table_entry->mgmdRouterInterfaceQueryInterval) {
                    vid_entry.querier.QueryIntvl = table_entry->mgmdRouterInterfaceQueryInterval; ;
                }
                if (table_entry->mgmdRouterInterfaceQueryMaxResponseTime) {
                    vid_entry.querier.MaxResTime = table_entry->mgmdRouterInterfaceQueryMaxResponseTime;
                }
                if (table_entry->mgmdRouterInterfaceLastMemberQueryInterval) {
                    vid_entry.querier.LastQryItv = table_entry->mgmdRouterInterfaceLastMemberQueryInterval;
                }
                if (ipmc_mgmt_set_intf_info(isid, &vid_entry, ipmc_ip_version) != VTSS_OK) {
                    return SNMP_ERR_BADVALUE;
                }
            }

#endif /* VTSS_SW_OPTION_SMB_IPMC */
        }
    }
    return 0;
}


static int
parse_mgmdRouterInterfaceTable(oid *name,
                               size_t *length,
                               int exact,

                               mgmdRouterInterfaceTable_entry_t *
                               table_entry)
{
    size_t         op_pos = 9 + 2;
    oid *op = (oid *) (name + op_pos);

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_mgmdRouterInterfaceTableEntry(table_entry)) {
            return -1;
        }
        return 1;              /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->mgmdRouterInterfaceIfIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (*length > op_pos) {
        table_entry->mgmdRouterInterfaceQuerierType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}


static int
fillobj_mgmdRouterInterfaceTable(oid *name,
                                 size_t *length,
                                 mgmdRouterInterfaceTable_entry_t *
                                 table_entry)
{
    int            name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->mgmdRouterInterfaceIfIndex;
    name[name_pos++] = (oid) table_entry->mgmdRouterInterfaceQuerierType;

    *length = name_pos;
    return 0;
}


/*
 *
 * * var_mgmdRouterInterfaceTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdRouterInterfaceTable(struct variable *vp,
                             oid *name,
                             size_t *length,
                             int exact,
                             size_t *var_len,
                             WriteMethod **write_method)
{
    int            rc;
    oid newname[MAX_OID_LEN];
    size_t         newname_len;
    mgmdRouterInterfaceTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc =
             parse_mgmdRouterInterfaceTable(name, length, exact,
                                            &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {       /* getfirst */
        if (fillobj_mgmdRouterInterfaceTable
            (newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_mgmdRouterInterfaceTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }

            if (fillobj_mgmdRouterInterfaceTable
                (newname, &newname_len, &table_entry)) {
                return NULL;
            }

            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case MGMDROUTERINTERFACEQUERIER: {
        memcpy(global_ret.string_ret,
               table_entry.mgmdRouterInterfaceQuerier, table_entry.mgmdRouterInterfaceQuerier_len);
        *var_len = table_entry.mgmdRouterInterfaceQuerier_len;
        return (u_char *) global_ret.string_ret;
    }

    case MGMDROUTERINTERFACEQUERYINTERVAL: {
        *write_method = write_mgmdRouterInterfaceQueryInterval;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTATUS: {
        *write_method = NULL; //write_mgmdRouterInterfaceStatus;
        global_ret.long_ret = table_entry.mgmdRouterInterfaceStatus;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }

    case MGMDROUTERINTERFACEVERSION: {
        *write_method = NULL; //write_mgmdRouterInterfaceVersion;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceVersion;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERYMAXRESPONSETIME: {
        *write_method = write_mgmdRouterInterfaceQueryMaxResponseTime;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQueryMaxResponseTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERIERUPTIME: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQuerierUpTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEQUERIEREXPIRYTIME: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceQuerierExpiryTime;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEWRONGVERSIONQUERIES: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceWrongVersionQueries;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEJOINS: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceJoins;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEPROXYIFINDEX: {
        *write_method =  NULL ; //write_mgmdRouterInterfaceProxyIfIndex;
        global_ret.long_ret = table_entry.mgmdRouterInterfaceProxyIfIndex;
        *var_len = sizeof(global_ret.long_ret);
        return (u_char *) & global_ret.long_ret;
    }

    case MGMDROUTERINTERFACEGROUPS: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceGroups;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACEROBUSTNESS: {
        *write_method = write_mgmdRouterInterfaceRobustness;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceRobustness;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACELASTMEMBERQUERYINTERVAL: {
        *write_method = write_mgmdRouterInterfaceLastMemberQueryInterval;
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceLastMemberQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACELASTMEMBERQUERYCOUNT: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceLastMemberQueryCount;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTARTUPQUERYCOUNT: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceStartupQueryCount;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    case MGMDROUTERINTERFACESTARTUPQUERYINTERVAL: {
        global_ret.ulong_ret = table_entry.mgmdRouterInterfaceStartupQueryInterval;
        *var_len = sizeof(global_ret.ulong_ret);
        return (u_char *) & global_ret.ulong_ret;
    }

    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdRouterInterfaceTable\n",
                    vp->magic));
    }

    return NULL;
}

#if 0

static int
getfirst_mgmdHostCacheTableEntry(mgmdHostCacheTable_entry_t *
                                 table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdHostCacheTableEntry(mgmdHostCacheTable_entry_t *table_entry,
                            BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdHostCacheTable(oid *name,
                         size_t *length,
                         int exact,

                         mgmdHostCacheTable_entry_t *table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 4)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdHostCacheTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdHostCacheAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdHostCacheAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdHostCacheAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }

    if (*length > op_pos) {

        table_entry->mgmdHostCacheIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdHostCacheTable(oid *name,
                           size_t *length,

                           mgmdHostCacheTable_entry_t *table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdHostCacheAddressType;

    len = (int) table_entry->mgmdHostCacheAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdHostCacheAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdHostCacheAddress;

    }

    name[name_pos++] = (oid) table_entry->mgmdHostCacheIfIndex;


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdHostCacheTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdHostCacheTable(struct variable *vp,
                       oid *name,

                       size_t *length,
                       int exact,

                       size_t *var_len,

                       WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdHostCacheTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdHostCacheTable(name, length, exact,
                                      &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdHostCacheTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdHostCacheTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdHostCacheTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDHOSTCACHEUPTIME:

    {

        global_ret.ulong_ret = table_entry.mgmdHostCacheUpTime;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDHOSTCACHELASTREPORTER:

    {

        strcpy(global_ret.string_ret,
               table_entry.mgmdHostCacheLastReporter);

        *var_len = strlen(global_ret.string_ret);

        return (u_char *) global_ret.string_ret;

    }

    case MGMDHOSTCACHESOURCEFILTERMODE:

    {

        global_ret.long_ret =
            table_entry.mgmdHostCacheSourceFilterMode;

        *var_len = sizeof(global_ret.long_ret);

        return (u_char *) & global_ret.long_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdHostCacheTable\n",
                    vp->magic));

    }

    return NULL;

}

static int
getfirst_mgmdRouterCacheTableEntry(mgmdRouterCacheTable_entry_t *
                                   table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdRouterCacheTableEntry(mgmdRouterCacheTable_entry_t *table_entry,
                              BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdRouterCacheTable(oid *name,
                           size_t *length,
                           int exact,

                           mgmdRouterCacheTable_entry_t *table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 4)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdRouterCacheTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdRouterCacheAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdRouterCacheAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdRouterCacheAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }

    if (*length > op_pos) {

        table_entry->mgmdRouterCacheIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdRouterCacheTable(oid *name,
                             size_t *length,

                             mgmdRouterCacheTable_entry_t *table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdRouterCacheAddressType;

    len = (int) table_entry->mgmdRouterCacheAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdRouterCacheAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdRouterCacheAddress;

    }

    name[name_pos++] = (oid) table_entry->mgmdRouterCacheIfIndex;


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdRouterCacheTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdRouterCacheTable(struct variable *vp,
                         oid *name,

                         size_t *length,
                         int exact,

                         size_t *var_len,

                         WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdRouterCacheTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdRouterCacheTable(name, length, exact,
                                        &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdRouterCacheTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdRouterCacheTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdRouterCacheTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDROUTERCACHELASTREPORTER:

    {

        strcpy(global_ret.string_ret,
               table_entry.mgmdRouterCacheLastReporter);

        *var_len = strlen(global_ret.string_ret);

        return (u_char *) global_ret.string_ret;

    }

    case MGMDROUTERCACHEUPTIME:

    {

        global_ret.ulong_ret = table_entry.mgmdRouterCacheUpTime;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDROUTERCACHEEXPIRYTIME:

    {

        global_ret.ulong_ret = table_entry.mgmdRouterCacheExpiryTime;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDROUTERCACHEEXCLUDEMODEEXPIRYTIMER:

    {

        global_ret.ulong_ret =
            table_entry.mgmdRouterCacheExcludeModeExpiryTimer;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDROUTERCACHEVERSION1HOSTTIMER:

    {

        global_ret.ulong_ret =
            table_entry.mgmdRouterCacheVersion1HostTimer;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDROUTERCACHEVERSION2HOSTTIMER:

    {

        global_ret.ulong_ret =
            table_entry.mgmdRouterCacheVersion2HostTimer;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    case MGMDROUTERCACHESOURCEFILTERMODE:

    {

        global_ret.long_ret =
            table_entry.mgmdRouterCacheSourceFilterMode;

        *var_len = sizeof(global_ret.long_ret);

        return (u_char *) & global_ret.long_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdRouterCacheTable\n",
                    vp->magic));

    }

    return NULL;

}

static int
getfirst_mgmdInverseHostCacheTableEntry(mgmdInverseHostCacheTable_entry_t *
                                        table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdInverseHostCacheTableEntry(mgmdInverseHostCacheTable_entry_t *
                                   table_entry, BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdInverseHostCacheTable(oid *name,
                                size_t *length,
                                int exact,

                                mgmdInverseHostCacheTable_entry_t *
                                table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 4)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdInverseHostCacheTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdInverseHostCacheIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    if (*length > op_pos) {

        table_entry->mgmdInverseHostCacheAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdInverseHostCacheAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdInverseHostCacheAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdInverseHostCacheTable(oid *name,
                                  size_t *length,

                                  mgmdInverseHostCacheTable_entry_t *
                                  table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdInverseHostCacheIfIndex;

    name[name_pos++] = (oid) table_entry->mgmdInverseHostCacheAddressType;

    len = (int) table_entry->mgmdInverseHostCacheAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdInverseHostCacheAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdInverseHostCacheAddress;

    }


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdInverseHostCacheTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdInverseHostCacheTable(struct variable *vp,

                              oid *name,
                              size_t *length,

                              int exact,
                              size_t *var_len,

                              WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdInverseHostCacheTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdInverseHostCacheTable(name, length, exact,
                                             &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdInverseHostCacheTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdInverseHostCacheTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdInverseHostCacheTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDINVERSEHOSTCACHEADDRESS:

    {

        strcpy(global_ret.string_ret,
               table_entry.mgmdInverseHostCacheAddress);

        *var_len = strlen(global_ret.string_ret);

        return (u_char *) global_ret.string_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdInverseHostCacheTable\n",
                    vp->magic));

    }

    return NULL;

}

static int
getfirst_mgmdInverseRouterCacheTableEntry
(mgmdInverseRouterCacheTable_entry_t *table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdInverseRouterCacheTableEntry(mgmdInverseRouterCacheTable_entry_t *
                                     table_entry, BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdInverseRouterCacheTable(oid *name,
                                  size_t *length,
                                  int exact,

                                  mgmdInverseRouterCacheTable_entry_t *
                                  table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 4)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdInverseRouterCacheTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdInverseRouterCacheIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    if (*length > op_pos) {

        table_entry->mgmdInverseRouterCacheAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdInverseRouterCacheAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdInverseRouterCacheAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdInverseRouterCacheTable(oid *name,
                                    size_t *length,

                                    mgmdInverseRouterCacheTable_entry_t *
                                    table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdInverseRouterCacheIfIndex;

    name[name_pos++] =
        (oid) table_entry->mgmdInverseRouterCacheAddressType;

    len = (int) table_entry->mgmdInverseRouterCacheAddress_len;

    name[name_pos++] =
        (oid) table_entry->mgmdInverseRouterCacheAddress_len;

    while (len-- > 0) {

        name[name_pos++] =
            (oid) table_entry->mgmdInverseRouterCacheAddress;

    }


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdInverseRouterCacheTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdInverseRouterCacheTable(struct variable *vp,

                                oid *name,
                                size_t *length,

                                int exact,
                                size_t *var_len,

                                WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdInverseRouterCacheTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdInverseRouterCacheTable(name, length, exact,
                                               &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdInverseRouterCacheTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdInverseRouterCacheTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdInverseRouterCacheTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDINVERSEROUTERCACHEADDRESS:

    {

        strcpy(global_ret.string_ret,
               table_entry.mgmdInverseRouterCacheAddress);

        *var_len = strlen(global_ret.string_ret);

        return (u_char *) global_ret.string_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdInverseRouterCacheTable\n",
                    vp->magic));

    }

    return NULL;

}

static int
getfirst_mgmdHostSrcListTableEntry(mgmdHostSrcListTable_entry_t *
                                   table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdHostSrcListTableEntry(mgmdHostSrcListTable_entry_t *table_entry,
                              BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdHostSrcListTable(oid *name,
                           size_t *length,
                           int exact,

                           mgmdHostSrcListTable_entry_t *table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 6)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdHostSrcListTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdHostSrcListAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdHostSrcListAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdHostSrcListAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }

    if (*length > op_pos) {

        table_entry->mgmdHostSrcListIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdHostSrcListHostAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdHostSrcListHostAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdHostSrcListTable(oid *name,
                             size_t *length,

                             mgmdHostSrcListTable_entry_t *table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdHostSrcListAddressType;

    len = (int) table_entry->mgmdHostSrcListAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdHostSrcListAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdHostSrcListAddress;

    }

    name[name_pos++] = (oid) table_entry->mgmdHostSrcListIfIndex;

    len = (int) table_entry->mgmdHostSrcListHostAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdHostSrcListHostAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdHostSrcListHostAddress;

    }


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdHostSrcListTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdHostSrcListTable(struct variable *vp,
                         oid *name,

                         size_t *length,
                         int exact,

                         size_t *var_len,

                         WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdHostSrcListTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdHostSrcListTable(name, length, exact,
                                        &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdHostSrcListTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdHostSrcListTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdHostSrcListTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDHOSTSRCLISTEXPIRE:

    {

        global_ret.ulong_ret = table_entry.mgmdHostSrcListExpire;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdHostSrcListTable\n",
                    vp->magic));

    }

    return NULL;

}

static int
getfirst_mgmdRouterSrcListTableEntry(mgmdRouterSrcListTable_entry_t *
                                     table_entry)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
get_mgmdRouterSrcListTableEntry(mgmdRouterSrcListTable_entry_t *
                                table_entry, BOOL getnext)
{

    /*
     *
     * * FIXME : return non-zero value when fail
     */
    return 0;

}


static int
parse_mgmdRouterSrcListTable(oid *name,
                             size_t *length,
                             int exact,

                             mgmdRouterSrcListTable_entry_t *
                             table_entry)
{

    size_t         op_pos = 9 + 2;

    oid *op = (oid *) (name + op_pos);

    u_char *cp = NULL;

    int            len = 0;


    if (exact && *length < (9 + 1 + 6)) {

        return -1;

    } else if (!exact && *length <= op_pos) {

        if (getfirst_mgmdRouterSrcListTableEntry(table_entry)) {

            return -1;

        }

        return 1;              /* getfirst */

    }


    memset(table_entry, 0, sizeof(*table_entry));

    if (*length > op_pos) {

        table_entry->mgmdRouterSrcListAddressType = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdRouterSrcListAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdRouterSrcListAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }

    if (*length > op_pos) {

        table_entry->mgmdRouterSrcListIfIndex = (long) * op++;

        op_pos++;

    } else if (exact) {

        return -1;

    } else {

        return 0;

    }

    len = (int) * op++;

    op_pos++;

    table_entry->mgmdRouterSrcListHostAddress_len = (char) len;

    cp = (u_char *) & table_entry->mgmdRouterSrcListHostAddress;

    while (len-- > 0) {

        if (*length > op_pos) {

            *cp++ = (u_char) * op++;

            op_pos++;

        } else if (exact) {

            return -1;

        } else {

            return 0;

        }

    }


    if (exact && *length != op_pos) {

        return -1;

    }


    return 0;

}


static int
fillobj_mgmdRouterSrcListTable(oid *name,
                               size_t *length,

                               mgmdRouterSrcListTable_entry_t *
                               table_entry)
{

    int            name_pos = 9 + 2;

    int            len = 0;


    name[name_pos++] = (oid) table_entry->mgmdRouterSrcListAddressType;

    len = (int) table_entry->mgmdRouterSrcListAddress_len;

    name[name_pos++] = (oid) table_entry->mgmdRouterSrcListAddress_len;

    while (len-- > 0) {

        name[name_pos++] = (oid) table_entry->mgmdRouterSrcListAddress;

    }

    name[name_pos++] = (oid) table_entry->mgmdRouterSrcListIfIndex;

    len = (int) table_entry->mgmdRouterSrcListHostAddress_len;

    name[name_pos++] =
        (oid) table_entry->mgmdRouterSrcListHostAddress_len;

    while (len-- > 0) {

        name[name_pos++] =
            (oid) table_entry->mgmdRouterSrcListHostAddress;

    }


    *length = name_pos;

    return 0;

}



/*
 *
 * * var_mgmdRouterSrcListTable():
 * *   Handle this table separately from the scalar value case.
 * *   The workings of this are basically the same as for var_mgmdMIBObjects above.
 */
u_char *
var_mgmdRouterSrcListTable(struct variable *vp,
                           oid *name,

                           size_t *length,
                           int exact,

                           size_t *var_len,

                           WriteMethod **write_method)
{

    int            rc;

    oid newname[MAX_OID_LEN];

    size_t         newname_len;

    mgmdRouterSrcListTable_entry_t table_entry;


    *write_method = NULL;

    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));

    newname_len = vp->namelen;


    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {

        memcpy(name, vp->name, sizeof(oid) * vp->namelen);

        *length = vp->namelen;

    }


    if ((rc =
             parse_mgmdRouterSrcListTable(name, length, exact,
                                          &table_entry)) < 0) {

        return NULL;

    } else if (rc > 0) {       /* getfirst */

        if (fillobj_mgmdRouterSrcListTable
            (newname, &newname_len, &table_entry)) {

            return NULL;

        }

    } else {

        do {

            if (get_mgmdRouterSrcListTableEntry
                (&table_entry, exact ? FALSE : TRUE)) {

                return NULL;

            }

            if (fillobj_mgmdRouterSrcListTable
                (newname, &newname_len, &table_entry)) {

                return NULL;

            }

            if (exact) {

                break;

            }

            rc = snmp_oid_compare(newname, newname_len, name, *length);

        } while (rc < 0);

    }


    /*
     *
     * * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));

    *length = newname_len;


    /*
     *
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case MGMDROUTERSRCLISTEXPIRE:

    {

        global_ret.ulong_ret = table_entry.mgmdRouterSrcListExpire;

        *var_len = sizeof(global_ret.ulong_ret);

        return (u_char *) & global_ret.ulong_ret;

    }

    default:

        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_mgmdRouterSrcListTable\n",
                    vp->magic));

    }

    return NULL;

}

#endif
int
write_mgmdHostInterfaceStatus(int action,
                              u_char *var_val,

                              u_char var_val_type,
                              size_t var_val_len,

                              u_char *statP,
                              oid *name,

                              size_t name_len)
{
    long           set_value = var_val ? *((long *) var_val) : 0;
    mgmdHostInterfaceTable_entry_t table_entry;

    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_INTEGER) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceStatus: not ASN_INTEGER\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(long)) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceStatus: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceStatus: bad value\n");

            return SNMP_ERR_WRONGVALUE;

        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdHostInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdHostInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdHostInterfaceStatus = set_value;

        if (set_mgmdHostInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}

#if 1
int
write_mgmdHostInterfaceVersion(int action,
                               u_char *var_val,

                               u_char var_val_type,
                               size_t var_val_len,

                               u_char *statP,
                               oid *name,

                               size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdHostInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceVersion: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceVersion: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         * * if (set_value < min_value || set_value > max_value) {
         * *  (void) snmp_log(LOG_ERR, "write to mgmdHostInterfaceTable: bad value\n");
         * *   return SNMP_ERR_WRONGVALUE;
         * * }
         */
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdHostInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdHostInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdHostInterfaceVersion = set_value;

        if (set_mgmdHostInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}


int
write_mgmdHostInterfaceVersion3Robustness(int action,
                                          u_char *var_val,

                                          u_char var_val_type,

                                          size_t var_val_len,

                                          u_char *statP,
                                          oid *name,

                                          size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdHostInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceVersion3Robustness: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdHostInterfaceVersion3Robustness: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         * * if (set_value < min_value || set_value > max_value) {
         * *  (void) snmp_log(LOG_ERR, "write to mgmdHostInterfaceTable: bad value\n");
         * *   return SNMP_ERR_WRONGVALUE;
         * * }
         */
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdHostInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdHostInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdHostInterfaceVersion3Robustness = set_value;

        if (set_mgmdHostInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}

#endif
int
write_mgmdRouterInterfaceQueryInterval(int action,
                                       u_char *var_val,

                                       u_char var_val_type,

                                       size_t var_val_len,

                                       u_char *statP,
                                       oid *name,

                                       size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryInterval: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryInterval: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         */
        if (set_value < 1 || set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceQueryInterval = set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}

#if 0
int
write_mgmdRouterInterfaceStatus(int action,
                                u_char *var_val,

                                u_char var_val_type,
                                size_t var_val_len,

                                u_char *statP,
                                oid *name,

                                size_t name_len)
{

    long           set_value = var_val ? *((long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_INTEGER) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: not ASN_INTEGER\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(long)) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceStatus: bad value\n");

            return SNMP_ERR_WRONGVALUE;

        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceStatus = set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}


int
write_mgmdRouterInterfaceVersion(int action,
                                 u_char *var_val,

                                 u_char var_val_type,
                                 size_t var_val_len,

                                 u_char *statP,
                                 oid *name,

                                 size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceVersion: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceVersion: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         * * if (set_value < min_value || set_value > max_value) {
         * *  (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
         * *   return SNMP_ERR_WRONGVALUE;
         * * }
         */
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceVersion = set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}
#endif


int
write_mgmdRouterInterfaceQueryMaxResponseTime(int action,

                                              u_char *var_val,

                                              u_char var_val_type,

                                              size_t var_val_len,

                                              u_char *statP,
                                              oid *name,

                                              size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryMaxResponseTime: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceQueryMaxResponseTime: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         *
         */
        if (set_value < 1 || set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceQueryMaxResponseTime =
            set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}


#if 0
int
write_mgmdRouterInterfaceProxyIfIndex(int action,
                                      u_char *var_val,

                                      u_char var_val_type,

                                      size_t var_val_len,
                                      u_char *statP,

                                      oid *name,
                                      size_t name_len)
{

    long           set_value = var_val ? *((long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_INTEGER) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceProxyIfIndex: not ASN_INTEGER\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(long)) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceProxyIfIndex: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceProxyIfIndex = set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}
#endif

int
write_mgmdRouterInterfaceRobustness(int action,
                                    u_char *var_val,

                                    u_char var_val_type,

                                    size_t var_val_len,
                                    u_char *statP,

                                    oid *name,
                                    size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceRobustness: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceRobustness: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         *
         */
        if ((set_value <= 1) || (set_value > 0xFF)) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case UNDO:

    {

        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }

    case COMMIT:

    {

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {

            return SNMP_ERR_COMMITFAILED;

        }

        table_entry.mgmdRouterInterfaceRobustness = set_value;

        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {

            return SNMP_ERR_COMMITFAILED;

        }

        break;

    }

    }

    return SNMP_ERR_NOERROR;

}


int
write_mgmdRouterInterfaceLastMemberQueryInterval(int action,

                                                 u_char *var_val,

                                                 u_char var_val_type,

                                                 size_t var_val_len,

                                                 u_char *statP,

                                                 oid *name,

                                                 size_t name_len)
{

    u_long set_value = var_val ? *((u_long *) var_val) : 0;

    mgmdRouterInterfaceTable_entry_t table_entry;


    switch (action) {

    case RESERVE1:

    {

        if (var_val_type != ASN_UNSIGNED) {

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceLastMemberQueryInterval: not ASN_UNSIGNED\n");

            return SNMP_ERR_WRONGTYPE;

        }

        if (var_val_len > sizeof(u_long)) {        /* FIXME */

            (void) snmp_log(LOG_ERR,
                            "write to mgmdRouterInterfaceLastMemberQueryInterval: bad length\n");

            return SNMP_ERR_WRONGLENGTH;

        }

        /*
         *
         * * FIXME : check the valid range
         * *
         *
         */
        if (set_value < 1 || set_value > 0x7C00) {
            (void) snmp_log(LOG_ERR, "write to mgmdRouterInterfaceTable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    }

    case RESERVE2:

    {

        /*
         *
         * * Allocate memory and similar resources
         */
        break;

    }

    case FREE:

    {

        /*
         *
         * *Release any resources that have been allocated
         */
        break;

    }

    case ACTION:

    {

        /*
         *
         * * The variable has been stored in 'value' for you to use,
         * * and you have just been asked to do something with it.
         * * Note that anything done here must be reversable in the UNDO case
         */
        /*
         *
         * * Save to current configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;

    }
    case UNDO: {
        /*
         *
         * * Back out any changes made in the ACTION case
         */
        /*
         *
         * * Restore current configuration from old configuration
         */
        /*
         *
         * * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */
        /*
         *
         * * Update old configuration
         */
        /*
         *
         * * In EstaX project, we set new configuration directly
         */
        if (parse_mgmdRouterInterfaceTable
            (name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if (get_mgmdRouterInterfaceTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        table_entry.mgmdRouterInterfaceLastMemberQueryInterval = set_value;
        if (set_mgmdRouterInterfaceTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    }
    return SNMP_ERR_NOERROR;
}

//#endif

