/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h> /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc2613_smon.h"
#include "ifIndex_api.h"
#include "vtss_rowStatus.h"
#include "vtss_free_list_api.h"
#include "vtss_avl_tree_api.h"
#ifdef VTSS_SW_OPTION_RSPAN
#include "rspan_api.h"
#else
#include "mirror_api.h"
#endif
#include "msg_api.h"
#include "critd_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#include "vtss_snmp.h"
#define SNMP_ASN_OCTET_STR_MAX_LEN  256  /* FIXME : Re-define it if needed */


#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
#define DATASOURCERMONCAPS_LEN  1
#define DATASOURCECOPYCAPS_LEN  1

#define COUNT_ERR_FRAMES            0x80  /* (1 << 7) */
#define COUNT_ALL_GOOD_FRAMES       0x40  /* (1 << 6) */
#define COUNT_ANY_RMON_TABLES       0x20  /* (1 << 5) */
#define BABY_GIANTS_COUNT_AS_GOOD   0x10  /* (1 << 4) */


#define COPY_SOURCE_PORT            0x80  /* (1 << 7) */
#define COPY_DEST_PORT              0x40  /* (1 << 6) */
#define COPY_SRC_TX_TRAFFIC         0x20  /* (1 << 5) */
#define COPY_SRC_RX_TRAFFIC         0x10  /* (1 << 4) */
#define COUNT_DEST_DROP_EVENTS      0x08  /* (1 << 3) */
#define COPY_ERR_FRAMES             0x04  /* (1 << 2) */
#define COPY_UNALTERED_FRAMES       0x02  /* (1 << 1) */
#define COPY_ALL_GOOD_FRAMES        0x01  /* (1 << 0) */

enum {
    COPY_RX_ONLY = 1,
    COPY_TX_ONLY,
    COPY_BOTH,
    COPY_END
} portCopy_dir_e;
/*
 * The entry data structure for dataSourceCapsTable
 */
typedef struct {
    /* Entry keys */
    oid             dataSourceCapsObject[MAX_OID_LEN];
    size_t              dataSourceCapsObject_len;

    /* Entry columns */
    char             dataSourceRmonCaps[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              dataSourceRmonCaps_len;
    char             dataSourceCopyCaps[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              dataSourceCopyCaps_len;
    long             dataSourceCapsIfIndex;
} dataSourceCapsTable_entry_t;
/*
 * The entry data structure for smonVlanStatsControlTable
 */
typedef struct {
    /* Entry keys */
    long           smonVlanStatsControlIndex;

    /* Entry columns */
    oid             smonVlanStatsControlDataSource[MAX_OID_LEN];
    size_t              smonVlanStatsControlDataSource_len;
    u_long             smonVlanStatsControlCreateTime;
    char             smonVlanStatsControlOwner[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              smonVlanStatsControlOwner_len;
    long             smonVlanStatsControlStatus;
} smonVlanStatsControlTable_entry_t;
/*
 * The entry data structure for smonVlanIdStatsTable
 */
typedef struct {
    /* Entry keys */
    long           smonVlanStatsControlIndex;
    long           smonVlanIdStatsId;

    /* Entry columns */
    u_long             smonVlanIdStatsTotalPkts;
    u_long             smonVlanIdStatsTotalOverflowPkts;
    struct counter64    smonVlanIdStatsTotalHCPkts;
    u_long             smonVlanIdStatsTotalOctets;
    u_long             smonVlanIdStatsTotalOverflowOctets;
    struct counter64    smonVlanIdStatsTotalHCOctets;
    u_long             smonVlanIdStatsNUcastPkts;
    u_long             smonVlanIdStatsNUcastOverflowPkts;
    struct counter64    smonVlanIdStatsNUcastHCPkts;
    u_long             smonVlanIdStatsNUcastOctets;
    u_long             smonVlanIdStatsNUcastOverflowOctets;
    struct counter64    smonVlanIdStatsNUcastHCOctets;
    u_long             smonVlanIdStatsCreateTime;
} smonVlanIdStatsTable_entry_t;
/*
 * The entry data structure for smonPrioStatsControlTable
 */
typedef struct {
    /* Entry keys */
    long           smonPrioStatsControlIndex;

    /* Entry columns */
    oid             smonPrioStatsControlDataSource[MAX_OID_LEN];
    size_t              smonPrioStatsControlDataSource_len;
    u_long             smonPrioStatsControlCreateTime;
    char             smonPrioStatsControlOwner[SNMP_ASN_OCTET_STR_MAX_LEN];
    size_t              smonPrioStatsControlOwner_len;
    long             smonPrioStatsControlStatus;
} smonPrioStatsControlTable_entry_t;
/*
 * The entry data structure for smonPrioStatsTable
 */
typedef struct {
    /* Entry keys */
    long           smonPrioStatsControlIndex;
    long           smonPrioStatsId;

    /* Entry columns */
    u_long             smonPrioStatsPkts;
    u_long             smonPrioStatsOverflowPkts;
    struct counter64    smonPrioStatsHCPkts;
    u_long             smonPrioStatsOctets;
    u_long             smonPrioStatsOverflowOctets;
    struct counter64    smonPrioStatsHCOctets;
} smonPrioStatsTable_entry_t;
/*
 * The entry data structure for portCopyTable
 */
typedef struct {
    /* Entry keys */
    long           portCopySource;
    long           portCopyDest;

    /* Entry columns */
    u_long             portCopyDestDropEvents;
    long             portCopyDirection;
    long             portCopyStatus;
} portCopyTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SNMP_ASN_OCTET_STR_MAX_LEN];
    oid                 objid_ret[MAX_OID_LEN];
    size_t              objid_len_ret;
    struct counter64    c64_ret;
    u_long              ulong_ret;
} switchRMON_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, switchRMON_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static switchRMON_return_t switchRMON_global_ret; /* static variables for retuning */

/*
 * switchRMON_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid switchRMON_variables_oid[] = {1, 3, 6, 1, 2, 1, 16, 22};



/*
 * variable switchRMON_variables:
 *   this variable defines function callbacks and type return information
 *   for the switchRMON mib section
 */

struct variable7 switchRMON_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */

#define DATASOURCERMONCAPS      1
    {DATASOURCERMONCAPS, ASN_OCTET_STR, RONLY, var_dataSourceCapsTable, 5, {1, 1, 1, 1, 2}},
#define DATASOURCECOPYCAPS      2
    {DATASOURCECOPYCAPS, ASN_OCTET_STR, RONLY, var_dataSourceCapsTable, 5, {1, 1, 1, 1, 3}},
#define DATASOURCECAPSIFINDEX       3
    {DATASOURCECAPSIFINDEX, ASN_INTEGER, RONLY, var_dataSourceCapsTable, 5, {1, 1, 1, 1, 4}},

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
#define SMONVLANSTATSCONTROLDATASOURCE      4
    {SMONVLANSTATSCONTROLDATASOURCE, ASN_OBJECT_ID, RWRITE, var_smonVlanStatsControlTable, 5, {1, 2, 1, 1, 2}},
#define SMONVLANSTATSCONTROLCREATETIME      5
    {SMONVLANSTATSCONTROLCREATETIME, ASN_TIMETICKS, RONLY, var_smonVlanStatsControlTable, 5, {1, 2, 1, 1, 3}},
#if 0
#define SMONVLANSTATSCONTROLOWNER       6
    {SMONVLANSTATSCONTROLOWNER, ASN_OCTET_STR, RWRITE, var_smonVlanStatsControlTable, 5, {1, 2, 1, 1, 4}},
#endif
#define SMONVLANSTATSCONTROLSTATUS      7
    {SMONVLANSTATSCONTROLSTATUS, ASN_INTEGER, RWRITE, var_smonVlanStatsControlTable, 5, {1, 2, 1, 1, 5}},
#define SMONVLANIDSTATSTOTALPKTS        8
    {SMONVLANIDSTATSTOTALPKTS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 2}},
#define SMONVLANIDSTATSTOTALOVERFLOWPKTS        9
    {SMONVLANIDSTATSTOTALOVERFLOWPKTS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 3}},
#define SMONVLANIDSTATSTOTALHCPKTS      10
    {SMONVLANIDSTATSTOTALHCPKTS, ASN_COUNTER64, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 4}},
#define SMONVLANIDSTATSTOTALOCTETS      11
    {SMONVLANIDSTATSTOTALOCTETS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 5}},
#define SMONVLANIDSTATSTOTALOVERFLOWOCTETS      12
    {SMONVLANIDSTATSTOTALOVERFLOWOCTETS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 6}},
#define SMONVLANIDSTATSTOTALHCOCTETS        13
    {SMONVLANIDSTATSTOTALHCOCTETS, ASN_COUNTER64, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 7}},
#define SMONVLANIDSTATSNUCASTPKTS       14
    {SMONVLANIDSTATSNUCASTPKTS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 8}},
#define SMONVLANIDSTATSNUCASTOVERFLOWPKTS       15
    {SMONVLANIDSTATSNUCASTOVERFLOWPKTS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 9}},
#define SMONVLANIDSTATSNUCASTHCPKTS     16
    {SMONVLANIDSTATSNUCASTHCPKTS, ASN_COUNTER64, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 10}},
#define SMONVLANIDSTATSNUCASTOCTETS     17
    {SMONVLANIDSTATSNUCASTOCTETS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 11}},
#define SMONVLANIDSTATSNUCASTOVERFLOWOCTETS     18
    {SMONVLANIDSTATSNUCASTOVERFLOWOCTETS, ASN_COUNTER, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 12}},
#define SMONVLANIDSTATSNUCASTHCOCTETS       19
    {SMONVLANIDSTATSNUCASTHCOCTETS, ASN_COUNTER64, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 13}},
#define SMONVLANIDSTATSCREATETIME       20
    {SMONVLANIDSTATSCREATETIME, ASN_TIMETICKS, RONLY, var_smonVlanIdStatsTable, 5, {1, 2, 2, 1, 14}},
#define SMONPRIOSTATSCONTROLDATASOURCE      21
    {SMONPRIOSTATSCONTROLDATASOURCE, ASN_OBJECT_ID, RWRITE, var_smonPrioStatsControlTable, 5, {1, 2, 3, 1, 2}},
#define SMONPRIOSTATSCONTROLCREATETIME      22
    {SMONPRIOSTATSCONTROLCREATETIME, ASN_TIMETICKS, RONLY, var_smonPrioStatsControlTable, 5, {1, 2, 3, 1, 3}},
#define SMONPRIOSTATSCONTROLOWNER       23
    {SMONPRIOSTATSCONTROLOWNER, ASN_OCTET_STR, RWRITE, var_smonPrioStatsControlTable, 5, {1, 2, 3, 1, 4}},
#define SMONPRIOSTATSCONTROLSTATUS      24
    {SMONPRIOSTATSCONTROLSTATUS, ASN_INTEGER, RWRITE, var_smonPrioStatsControlTable, 5, {1, 2, 3, 1, 5}},
#define SMONPRIOSTATSPKTS       25
    {SMONPRIOSTATSPKTS, ASN_COUNTER, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 2}},
#define SMONPRIOSTATSOVERFLOWPKTS       26
    {SMONPRIOSTATSOVERFLOWPKTS, ASN_COUNTER, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 3}},
#define SMONPRIOSTATSHCPKTS     27
    {SMONPRIOSTATSHCPKTS, ASN_COUNTER64, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 4}},
#define SMONPRIOSTATSOCTETS     28
    {SMONPRIOSTATSOCTETS, ASN_COUNTER, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 5}},
#define SMONPRIOSTATSOVERFLOWOCTETS     29
    {SMONPRIOSTATSOVERFLOWOCTETS, ASN_COUNTER, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 6}},
#define SMONPRIOSTATSHCOCTETS       30
    {SMONPRIOSTATSHCOCTETS, ASN_COUNTER64, RONLY, var_smonPrioStatsTable, 5, {1, 2, 4, 1, 7}},
#endif /* VTSS_FEATURE_VLAN_COUNTERS */
#define PORTCOPYDESTDROPEVENTS      31
    {PORTCOPYDESTDROPEVENTS, ASN_COUNTER, RONLY, var_portCopyTable, 5, {1, 3, 1, 1, 3}},
#define PORTCOPYDIRECTION       32
    {PORTCOPYDIRECTION, ASN_INTEGER, RWRITE, var_portCopyTable, 5, {1, 3, 1, 1, 4}},
#define PORTCOPYSTATUS      33
    {PORTCOPYSTATUS, ASN_INTEGER, RWRITE, var_portCopyTable, 5, {1, 3, 1, 1, 5}},
};

#define SMON_STAT_MAX_ROW_SIZE         128
#define SMON_PORT_COPY_MAX_ROW_SIZE    128

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
static i32 vlan_stats_ctrl_entry_compare_func(void *elm1, void *elm2);
static BOOL                                 vlan_stats_ctrl_entry_list_created_done = FALSE;
static rowEntry_cap_t                       vlan_stats_caps = {ROWENTRY_NO_SET, 0, 0, 0};
VTSS_FREE_LIST(smon_vlan_counter_free_list, smonVlanStatsControlTable_entry_t, SMON_PORT_COPY_MAX_ROW_SIZE)
VTSS_AVL_TREE(smon_vlan_counter_avlt, "SNMP_SMON_vlan_counter", VTSS_MODULE_ID_SNMP, vlan_stats_ctrl_entry_compare_func, SMON_PORT_COPY_MAX_ROW_SIZE)
#endif /* VTSS_FEATURE_VLAN_COUNTERS */

static i32 portCpy_entry_compare_func(void *elm1, void *elm2);
static BOOL                                 portCpy_entry_list_created_done = FALSE;
static rowEntry_cap_t                       portCpy_caps = {ROWENTRY_NO_SET , 0, 0, 0};
VTSS_FREE_LIST(smon_port_copy_free_list, portCopyTable_entry_t, SMON_PORT_COPY_MAX_ROW_SIZE)
VTSS_AVL_TREE(smon_port_copy_avlt, "SNMP_SMON_port_copy", VTSS_MODULE_ID_SNMP, portCpy_entry_compare_func, SMON_PORT_COPY_MAX_ROW_SIZE)

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
static smonVlanStatsControlTable_entry_t *smon_vlan_counter_free_list_malloc(void)
{
    return vtss_free_list_malloc(&smon_vlan_counter_free_list);
}

static void smon_vlan_counter_free_list_free(smonVlanStatsControlTable_entry_t *entry)
{
    (void) vtss_free_list_free(&smon_vlan_counter_free_list, entry);
}

static void smon_vlan_counter_free_list_init(void)
{
    (void) vtss_free_list_init(&smon_vlan_counter_free_list);
}

/* if elm1 lager than elm2, return 1, else if elm1 smaller than elm2, return -1, otherwise return 0 */
static i32 vlan_stats_ctrl_entry_compare_func(void *elm1, void *elm2)
{
    smonVlanStatsControlTable_entry_t *in_list = elm1;
    smonVlanStatsControlTable_entry_t *new_entry = elm2;

    if (in_list->smonVlanStatsControlIndex > new_entry->smonVlanStatsControlIndex) {
        return 1;
    } else if (in_list->smonVlanStatsControlIndex < new_entry->smonVlanStatsControlIndex) {
        return -1;
    } else {
        return 0;
    }

}
#endif /* VTSS_FEATURE_VLAN_COUNTERS */

static portCopyTable_entry_t *smon_port_copy_free_list_malloc(void)
{
    return vtss_free_list_malloc(&smon_port_copy_free_list);
}

static void smon_port_copy_free_list_free(portCopyTable_entry_t *entry)
{
    (void) vtss_free_list_free(&smon_port_copy_free_list, entry);
}

static void smon_port_copy_free_list_init(void)
{
    (void) vtss_free_list_init(&smon_port_copy_free_list);
}

/* if elm1 lager than elm2, return 1, else if elm1 smaller than elm2, return -1, otherwise return 0 */
static i32 portCpy_entry_compare_func(void *elm1, void *elm2)
{
    portCopyTable_entry_t *in_list = elm1;
    portCopyTable_entry_t *new_entry = elm2;

    if (in_list->portCopySource > new_entry->portCopySource) {
        return 1;
    } else if (in_list->portCopySource < new_entry->portCopySource) {
        return -1;
    } else {
        return in_list->portCopyDest > new_entry->portCopyDest ? 1 : in_list->portCopyDest < new_entry->portCopyDest ? -1 : 0;
    }

}


/*
 * Initializes the switchRMON module
 */
void
init_switchRMON(void)
{
    // Register mibContextTable
    mibContextTable_register(switchRMON_variables_oid,
                             sizeof(switchRMON_variables_oid) / sizeof(oid),
                             "SMON-MIB : switchRMON");

    DEBUGMSGTL(("switchRMON", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("switchRMON", switchRMON_variables, variable7,
                 switchRMON_variables_oid);

    /* place any other initialization junk you need here */

    if (FALSE == portCpy_entry_list_created_done) {
        if (TRUE == vtss_avl_tree_init(&smon_port_copy_avlt)) {
            smon_port_copy_free_list_init();
            portCpy_entry_list_created_done = TRUE;
        }
    }

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
    if (FALSE == vlan_stats_ctrl_entry_list_created_done) {
        if (TRUE == vtss_avl_tree_init(&smon_vlan_counter_avlt)) {
            smon_vlan_counter_free_list_init();
            vlan_stats_ctrl_entry_list_created_done = TRUE;
        }

    }
    smon_create_stat_default_entry ();
#endif /* VTSS_FEATURE_VLAN_COUNTERS */

}

/*
 * var_switchRMON():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_switchRMON(struct variable *vp,
               oid     *name,
               size_t  *length,
               int     exact,
               size_t  *var_len,
               WriteMethod **write_method)
{

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }


    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_switchRMON\n", vp->magic));
    }
    return NULL;
}

static BOOL get_next_datasource ( oid *key, size_t *key_len, ifIndex_type_t  *type)
{
    oid datasource[]        = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
    size_t datasource_len   = sizeof(datasource) / sizeof(oid);
    iftable_info_t info;
    info.ifIndex = 0;
    (void) ifIndex_get_next(&info);

    datasource[datasource_len - 1 ] = info.ifIndex;

    if (*key_len < datasource_len) {
        if (memcmp(key, datasource, *key_len * sizeof(oid)) > 0) {
            return FALSE;
        }

        goto get_OK;
    } else {
        if (memcmp(key, datasource, (datasource_len - 1)* sizeof(oid)) > 0) {
            return FALSE;
        } else if (memcmp(key, datasource, (datasource_len - 1)* sizeof(oid)) < 0 ) { /* get first */
            goto get_OK;
        } else { /* get next */
            info.ifIndex = key[datasource_len - 1];
            if ( FALSE == ifIndex_get_next(&info)) {
                return FALSE;
            } else {
                datasource[datasource_len - 1] = info.ifIndex;
                goto get_OK;
            }
        }
    }

get_OK:

    memcpy(key, datasource, datasource_len * sizeof(oid));
    *key_len = datasource_len;
    *type = info.type;

    return TRUE;

}

#ifdef  VTSS_SW_OPTION_RSPAN
static BOOL is_rspan_mode(void)
{
    rspan_switch_conf_t conf;
    if (rspan_mgmt_is_rspan_enabled()) {
        (void) rspan_mgmt_conf_get( &conf);
        if (conf.type != RSPAN_SWITCH_TYPE_DEFAULT ) {
            return TRUE;
        }
    }
    return FALSE;
}
#endif

static void get_dataSourceCapsTableEntryByKey( dataSourceCapsTable_entry_t *table_entry, ifIndex_type_t  *type)
{
    table_entry->dataSourceRmonCaps_len = DATASOURCERMONCAPS_LEN;
    table_entry->dataSourceCopyCaps_len = DATASOURCECOPYCAPS_LEN;

    memset(table_entry->dataSourceRmonCaps, 0, DATASOURCERMONCAPS_LEN);
    memset(table_entry->dataSourceCopyCaps, 0, DATASOURCECOPYCAPS_LEN);
    if (IFTABLE_IFINDEX_TYPE_PORT == *type) {
        table_entry->dataSourceRmonCaps[0] = (char) (COUNT_ERR_FRAMES | COUNT_ALL_GOOD_FRAMES | COUNT_ANY_RMON_TABLES | BABY_GIANTS_COUNT_AS_GOOD);
#ifdef  VTSS_SW_OPTION_RSPAN
        if ( FALSE == is_rspan_mode()) {
            /* portCopy capability is all 0s if RSPAN is enabled */
            table_entry->dataSourceCopyCaps[0] = (char) (COPY_SOURCE_PORT | COPY_DEST_PORT | COPY_SRC_TX_TRAFFIC | COPY_SRC_RX_TRAFFIC | COPY_UNALTERED_FRAMES | COPY_ALL_GOOD_FRAMES);
        }
#else
        table_entry->dataSourceCopyCaps[0] = (char) (COPY_SOURCE_PORT | COPY_DEST_PORT | COPY_SRC_TX_TRAFFIC | COPY_SRC_RX_TRAFFIC | COPY_UNALTERED_FRAMES | COPY_ALL_GOOD_FRAMES);
#endif
    } else if (IFTABLE_IFINDEX_TYPE_VLAN == *type) {
        table_entry->dataSourceRmonCaps[0] = (char) (COUNT_ALL_GOOD_FRAMES | COUNT_ANY_RMON_TABLES | BABY_GIANTS_COUNT_AS_GOOD);
    }
    table_entry->dataSourceCapsIfIndex =  table_entry->dataSourceCapsObject[table_entry->dataSourceCapsObject_len - 1];
}

static int
getfirst_dataSourceCapsTableEntry(dataSourceCapsTable_entry_t *table_entry)
{
    ifIndex_type_t  type;
    table_entry->dataSourceCapsObject[0] = 1;
    table_entry->dataSourceCapsObject_len = 1;
    if ( FALSE == get_next_datasource(table_entry->dataSourceCapsObject, &table_entry->dataSourceCapsObject_len, &type)) {
        return VTSS_RC_ERROR;
    }
    get_dataSourceCapsTableEntryByKey(table_entry, &type);
    return VTSS_RC_OK;
}

static int
get_dataSourceCapsTableEntry(dataSourceCapsTable_entry_t *table_entry, BOOL getnext)
{
    ifIndex_type_t  type;
    oid             dataSource[MAX_OID_LEN];
    size_t          dataSource_len;

    if (FALSE == getnext) {
        memcpy(dataSource, table_entry->dataSourceCapsObject, table_entry->dataSourceCapsObject_len * sizeof(oid));
        dataSource_len = table_entry->dataSourceCapsObject_len;
        if (dataSource[dataSource_len - 1] > 0) {
            --dataSource[dataSource_len - 1];
        } else {
            --dataSource_len;
        }

        if (FALSE == get_next_datasource(dataSource, &dataSource_len, &type) || dataSource_len != table_entry->dataSourceCapsObject_len ||
            memcmp(dataSource, table_entry->dataSourceCapsObject, table_entry->dataSourceCapsObject_len * sizeof(oid))) {
            return VTSS_RC_ERROR;
        }
        memcpy(table_entry->dataSourceCapsObject, dataSource, dataSource_len * sizeof(oid));
        table_entry->dataSourceCapsObject_len = dataSource_len;
    } else {
        if (FALSE == get_next_datasource(table_entry->dataSourceCapsObject, &table_entry->dataSourceCapsObject_len, &type)) {
            return VTSS_RC_ERROR;
        }
    }

    get_dataSourceCapsTableEntryByKey(table_entry, &type);
    return VTSS_RC_OK;
}

static int
parse_dataSourceCapsTable(oid     *name,
                          size_t  *length,
                          int     exact,
                          dataSourceCapsTable_entry_t *table_entry)
{
    size_t          op_pos = 11 + 2;
    oid            *op = (oid *) (name + op_pos);
    oid            *cp = NULL;
    int             len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dataSourceCapsTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    len = (int )(*length) - op_pos;
    table_entry->dataSourceCapsObject_len = (oid) len;
    cp = table_entry->dataSourceCapsObject;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dataSourceCapsTable(oid     *name,
                            size_t  *length,
                            dataSourceCapsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    len = (int) table_entry->dataSourceCapsObject_len;
    while (len-- > 0) {
        name[name_pos++] = table_entry->dataSourceCapsObject[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_dataSourceCapsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_dataSourceCapsTable(struct variable *vp,
                        oid     *name,
                        size_t  *length,
                        int     exact,
                        size_t  *var_len,
                        WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dataSourceCapsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dataSourceCapsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dataSourceCapsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dataSourceCapsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dataSourceCapsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DATASOURCERMONCAPS: {
        *var_len = table_entry.dataSourceRmonCaps_len;
        memcpy(switchRMON_global_ret.string_ret, table_entry.dataSourceRmonCaps, *var_len);
        switchRMON_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) switchRMON_global_ret.string_ret;
    }
    case DATASOURCECOPYCAPS: {
        *var_len = table_entry.dataSourceCopyCaps_len;
        memcpy(switchRMON_global_ret.string_ret, table_entry.dataSourceCopyCaps, *var_len);
        switchRMON_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) switchRMON_global_ret.string_ret;
    }
    case DATASOURCECAPSIFINDEX: {
        switchRMON_global_ret.long_ret = table_entry.dataSourceCapsIfIndex;
        *var_len = sizeof(switchRMON_global_ret.long_ret);
        return (u_char *) &switchRMON_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dataSourceCapsTable\n", vp->magic));
    }
    return NULL;
}

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
static BOOL get_next_smonVlanStatsControlTableEntryByKey (smonVlanStatsControlTable_entry_t *entry)
{
    smonVlanStatsControlTable_entry_t *temp_entry_p = entry;

    if (vtss_avl_tree_get(&smon_vlan_counter_avlt, (void **) &temp_entry_p, VTSS_AVL_TREE_GET_NEXT) != TRUE) {
        return FALSE;
    }
    memcpy(entry, temp_entry_p, sizeof(smonVlanStatsControlTable_entry_t));

    return TRUE;
}

static BOOL get_smonVlanStatsControlTableEntryByKey (smonVlanStatsControlTable_entry_t *entry)
{
    smonVlanStatsControlTable_entry_t *temp_entry_p = entry;

    if (vtss_avl_tree_get(&smon_vlan_counter_avlt, (void **) &temp_entry_p, VTSS_AVL_TREE_GET) != TRUE) {
        return FALSE;
    }
    memcpy(entry, temp_entry_p, sizeof(smonVlanStatsControlTable_entry_t));

    return TRUE;

}


static int
getfirst_smonVlanStatsControlTableEntry(smonVlanStatsControlTable_entry_t *table_entry)
{
    table_entry->smonVlanStatsControlIndex = 0;
    if ( FALSE == get_next_smonVlanStatsControlTableEntryByKey(table_entry)) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
get_smonVlanStatsControlTableEntry(smonVlanStatsControlTable_entry_t *table_entry, BOOL getnext)
{
    if (getnext) {
        if (FALSE == get_next_smonVlanStatsControlTableEntryByKey(table_entry)) {
            return VTSS_RC_ERROR;
        }
    } else {
        if ( FALSE == get_smonVlanStatsControlTableEntryByKey(table_entry)) {
            return VTSS_RC_ERROR;
        }
    }

    return VTSS_RC_OK;
}

static long datasource_2_vlanid(oid  *data_source, size_t data_source_len)
{
    iftable_info_t          info;
    info.ifIndex = data_source[data_source_len - 1];
    (void) ifIndex_get_valid(&info);
    return info.if_id;

}

static BOOL apply_smonVlanStatsControlTableEntry (smonVlanStatsControlTable_entry_t *table_entry)
{
    snmp_rmon_stat_entry_t stored_entry;


    stored_entry.valid = 1;
    stored_entry.ctrl_index = table_entry->smonVlanStatsControlIndex;
    stored_entry.if_index = table_entry->smonVlanStatsControlDataSource[table_entry->smonVlanStatsControlDataSource_len - 1];

    (void) vtss_vlan_counters_clear(NULL, datasource_2_vlanid(table_entry->smonVlanStatsControlDataSource, table_entry->smonVlanStatsControlDataSource_len));
    if (snmp_mgmt_smon_stat_entry_set(&stored_entry) != VTSS_OK) {
        return FALSE;
    }
    return TRUE;
}

static BOOL deactive_smonVlanStatsControlTableEntry (smonVlanStatsControlTable_entry_t *table_entry)
{
    snmp_rmon_stat_entry_t stored_entry;

    stored_entry.ctrl_index = table_entry->smonVlanStatsControlIndex;
    if (snmp_mgmt_smon_stat_entry_get(&stored_entry, FALSE) != VTSS_OK) {
        return TRUE;
    } else {
        stored_entry.valid = 0;
    }

    if (snmp_mgmt_smon_stat_entry_set(&stored_entry) != VTSS_OK) {
        return FALSE;
    }
    return TRUE;
}

static BOOL smonVlanStatsControlTable_entry_valid (smonVlanStatsControlTable_entry_t *table_entry)
{
    oid datasource[]        = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
    size_t datasource_len   = sizeof(datasource) / sizeof(oid);
    iftable_info_t info;

    if (datasource_len != table_entry->smonVlanStatsControlDataSource_len ||
        memcmp (datasource, table_entry->smonVlanStatsControlDataSource, sizeof(oid) * (datasource_len - 1 ))) {
        return FALSE;
    }

    info.ifIndex = table_entry->smonVlanStatsControlDataSource[datasource_len - 1];
    if ( FALSE == ifIndex_get_valid(&info) || info.type != IFTABLE_IFINDEX_TYPE_VLAN) {
        return FALSE;
    }
    return TRUE;

}

static int
set_smonVlanStatsControlTableEntry(smonVlanStatsControlTable_entry_t *table_entry)
{
    switch (table_entry->smonVlanStatsControlStatus) {
    case SNMP_ROW_ACTIVE:
        if ( FALSE == smonVlanStatsControlTable_entry_valid(table_entry) || FALSE == apply_smonVlanStatsControlTableEntry(table_entry)) {
            return VTSS_RC_ERROR;
        }
        table_entry->smonVlanStatsControlCreateTime = msg_uptime_get(VTSS_ISID_LOCAL) * 100;
        break;
    case SNMP_ROW_NOTREADY:
    case SNMP_ROW_NOTINSERVICE:
    case SNMP_ROW_NONEXISTENT:
        (void) deactive_smonVlanStatsControlTableEntry(table_entry);
        break;
    default:
        break;
    }

    if ( SNMP_ROW_NONEXISTENT == table_entry->smonVlanStatsControlStatus) {
        smonVlanStatsControlTable_entry_t *temp_entry_p = table_entry;

        if (vtss_avl_tree_delete(&smon_vlan_counter_avlt, (void **) &temp_entry_p) == TRUE) {
            smon_vlan_counter_free_list_free(temp_entry_p);
        }
    } else {
        smonVlanStatsControlTable_entry_t *temp_entry_p = table_entry;

        if (vtss_avl_tree_get(&smon_vlan_counter_avlt, (void **) &temp_entry_p, VTSS_AVL_TREE_GET) != TRUE) { // entry not existing
            // allocate new entry buffer
            if ((temp_entry_p = smon_vlan_counter_free_list_malloc()) == NULL) {
                return VTSS_RC_ERROR;
            }
            memcpy(temp_entry_p, table_entry, sizeof(smonVlanStatsControlTable_entry_t));
            if (vtss_avl_tree_add(&smon_vlan_counter_avlt, (void *) temp_entry_p) != TRUE) {
                smon_vlan_counter_free_list_free(temp_entry_p);
                return VTSS_RC_ERROR;
            }
        } else { // entry already existing
            // update entry data directly
            memcpy(temp_entry_p, table_entry, sizeof(smonVlanStatsControlTable_entry_t));
        }
    }

    return VTSS_RC_OK;

}

static int
parse_smonVlanStatsControlTable(oid     *name,
                                size_t  *length,
                                int     exact,
                                smonVlanStatsControlTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_smonVlanStatsControlTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->smonVlanStatsControlIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_smonVlanStatsControlTable(oid     *name,
                                  size_t  *length,
                                  smonVlanStatsControlTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->smonVlanStatsControlIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_smonVlanStatsControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_smonVlanStatsControlTable(struct variable *vp,
                              oid     *name,
                              size_t  *length,
                              int     exact,
                              size_t  *var_len,
                              WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    smonVlanStatsControlTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_smonVlanStatsControlTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_smonVlanStatsControlTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_smonVlanStatsControlTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == SMONVLANSTATSCONTROLSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_smonVlanStatsControlStatus;
                }
                return NULL;
            }
            if (fillobj_smonVlanStatsControlTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SMONVLANSTATSCONTROLDATASOURCE: {
        *write_method = write_smonVlanStatsControlDataSource;
        memcpy(switchRMON_global_ret.objid_ret, table_entry.smonVlanStatsControlDataSource, table_entry.smonVlanStatsControlDataSource_len * sizeof(oid));
        *var_len = table_entry.smonVlanStatsControlDataSource_len * sizeof(oid);
        return (u_char *) switchRMON_global_ret.objid_ret;
    }
    case SMONVLANSTATSCONTROLCREATETIME: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanStatsControlCreateTime;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
#if 0
    case SMONVLANSTATSCONTROLOWNER: {
        *write_method = write_smonVlanStatsControlOwner;
        *var_len = table_entry.smonVlanStatsControlOwner_len;
        memcpy(switchRMON_global_ret.string_ret, table_entry.smonVlanStatsControlOwner, *var_len);
        switchRMON_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) switchRMON_global_ret.string_ret;
    }
#endif
    case SMONVLANSTATSCONTROLSTATUS: {
        *write_method = write_smonVlanStatsControlStatus;
        switchRMON_global_ret.long_ret = table_entry.smonVlanStatsControlStatus;
        *var_len = sizeof(switchRMON_global_ret.long_ret);
        return (u_char *) &switchRMON_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_smonVlanStatsControlTable\n", vp->magic));
    }
    return NULL;
}

static BOOL get_next_smonVlanIdStatsTableEntryKey(smonVlanIdStatsTable_entry_t *table_entry)
{
    smonVlanStatsControlTable_entry_t ctrl_entry;
    ctrl_entry.smonVlanStatsControlIndex = table_entry->smonVlanStatsControlIndex;
    long key2;

    if (TRUE == get_smonVlanStatsControlTableEntryByKey ( &ctrl_entry) && SNMP_ROW_ACTIVE == ctrl_entry.smonVlanStatsControlStatus) {
        key2 = datasource_2_vlanid(ctrl_entry.smonVlanStatsControlDataSource, ctrl_entry.smonVlanStatsControlDataSource_len);

        if (key2 > table_entry->smonVlanIdStatsId) {
            goto get_OK;
        } else if (TRUE == get_next_smonVlanStatsControlTableEntryByKey ( &ctrl_entry) && SNMP_ROW_ACTIVE == ctrl_entry.smonVlanStatsControlStatus) {
            key2 = datasource_2_vlanid(ctrl_entry.smonVlanStatsControlDataSource, ctrl_entry.smonVlanStatsControlDataSource_len);
            goto get_OK;

        } else {
            return FALSE;
        }
    } else if ( TRUE == get_next_smonVlanStatsControlTableEntryByKey ( &ctrl_entry) && SNMP_ROW_ACTIVE == ctrl_entry.smonVlanStatsControlStatus) {
        key2 = datasource_2_vlanid(ctrl_entry.smonVlanStatsControlDataSource, ctrl_entry.smonVlanStatsControlDataSource_len);
        goto  get_OK;
    } else {
        return FALSE;
    }

get_OK:
    table_entry->smonVlanStatsControlIndex = ctrl_entry.smonVlanStatsControlIndex;
    table_entry->smonVlanIdStatsId = key2;

    return TRUE;

}

static BOOL get_smonVlanIdStatsTableEntryKey(smonVlanIdStatsTable_entry_t *entry)
{
    smonVlanIdStatsTable_entry_t tmp_entry;
    long *key1 = &tmp_entry.smonVlanStatsControlIndex, *key2 = &tmp_entry.smonVlanIdStatsId;

    tmp_entry.smonVlanStatsControlIndex = entry->smonVlanStatsControlIndex;
    tmp_entry.smonVlanIdStatsId =  entry->smonVlanIdStatsId;
    if ( 0 == *key1 ) {
        return FALSE;
    }

    if ( 0 == *key2) {
        --*key1;
        *key2 = VLAN_ID_MAX;
    } else {
        --*key2;
    }

    if (FALSE == get_next_smonVlanIdStatsTableEntryKey ( &tmp_entry) || *key1 != entry->smonVlanStatsControlIndex || *key2 != entry->smonVlanIdStatsId) {
        return FALSE;
    }
    entry->smonVlanStatsControlIndex = *key1;
    entry->smonVlanIdStatsId         = *key2;

    return TRUE;
}

static BOOL get_smonVlanIdStatsTableEntryByKey (smonVlanIdStatsTable_entry_t *entry)
{
    u64                  total;
    vtss_vlan_counters_t counter;

    memset(&counter, 0, sizeof(vtss_vlan_counters_t));
    if (vtss_vlan_counters_get(NULL, entry->smonVlanIdStatsId, &counter) != VTSS_RC_OK) {
        return FALSE;
    }

    total     = counter.rx_vlan_unicast.frames + counter.rx_vlan_multicast.frames;

    entry->smonVlanIdStatsTotalPkts         = total & 0xffffffff;
    entry->smonVlanIdStatsTotalOverflowPkts = total >> 32 & 0xffffffff;
    entry->smonVlanIdStatsTotalHCPkts.low   = entry->smonVlanIdStatsTotalPkts;
    entry->smonVlanIdStatsTotalHCPkts.high  = entry->smonVlanIdStatsTotalOverflowPkts;

    total     = counter.rx_vlan_multicast.frames + counter.rx_vlan_flood.frames;

    entry->smonVlanIdStatsNUcastPkts         = total & 0xffffffff;
    entry->smonVlanIdStatsNUcastOverflowPkts = total >> 32 & 0xffffffff;
    entry->smonVlanIdStatsNUcastHCPkts.low   = entry->smonVlanIdStatsNUcastPkts;
    entry->smonVlanIdStatsNUcastHCPkts.high  = entry->smonVlanIdStatsNUcastOverflowPkts;

    total     = counter.rx_vlan_unicast.bytes + counter.rx_vlan_multicast.bytes;

    entry->smonVlanIdStatsTotalOctets         = total & 0xffffffff;
    entry->smonVlanIdStatsTotalOverflowOctets = total >> 32 & 0xffffffff;
    entry->smonVlanIdStatsTotalHCOctets.low   = entry->smonVlanIdStatsTotalOctets;
    entry->smonVlanIdStatsTotalHCOctets.high  = entry->smonVlanIdStatsTotalOverflowOctets;

    total     = counter.rx_vlan_multicast.bytes + counter.rx_vlan_flood.bytes;
    entry->smonVlanIdStatsNUcastOctets         = total & 0xffffffff;
    entry->smonVlanIdStatsNUcastOverflowOctets = total >> 32 & 0xffffffff;
    entry->smonVlanIdStatsNUcastHCOctets.low   = entry->smonVlanIdStatsNUcastOctets;
    entry->smonVlanIdStatsNUcastHCOctets.high  = entry->smonVlanIdStatsNUcastOverflowOctets;

    return TRUE;

}

static int
getfirst_smonVlanIdStatsTableEntry(smonVlanIdStatsTable_entry_t *table_entry)
{
    table_entry->smonVlanStatsControlIndex = 0;
    table_entry->smonVlanIdStatsId = 0;

    if ( FALSE == get_next_smonVlanIdStatsTableEntryKey(table_entry))  {
        return VTSS_RC_ERROR;
    }

    if ( FALSE == get_smonVlanIdStatsTableEntryByKey (table_entry)) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
get_smonVlanIdStatsTableEntry(smonVlanIdStatsTable_entry_t *table_entry, BOOL getnext)
{
    if ( TRUE == getnext && FALSE == get_next_smonVlanIdStatsTableEntryKey(table_entry)) {
        return VTSS_RC_ERROR;
    } else if ( FALSE == getnext && FALSE == get_smonVlanIdStatsTableEntryKey(table_entry)) {
        return VTSS_RC_ERROR;
    }

    if ( FALSE == get_smonVlanIdStatsTableEntryByKey (table_entry)) {
        return VTSS_RC_ERROR;
    }
    return VTSS_RC_OK;
}

static int
parse_smonVlanIdStatsTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           smonVlanIdStatsTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_smonVlanIdStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->smonVlanStatsControlIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->smonVlanIdStatsId = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_smonVlanIdStatsTable(oid     *name,
                             size_t  *length,
                             smonVlanIdStatsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->smonVlanStatsControlIndex;
    name[name_pos++] = (oid) table_entry->smonVlanIdStatsId;

    *length = name_pos;
    return 0;
}

/*
 * var_smonVlanIdStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_smonVlanIdStatsTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    smonVlanIdStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_smonVlanIdStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_smonVlanIdStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_smonVlanIdStatsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_smonVlanIdStatsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SMONVLANIDSTATSTOTALPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsTotalPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSTOTALOVERFLOWPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsTotalOverflowPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSTOTALHCPKTS: {
        switchRMON_global_ret.c64_ret = table_entry.smonVlanIdStatsTotalHCPkts;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    case SMONVLANIDSTATSTOTALOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsTotalOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSTOTALOVERFLOWOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsTotalOverflowOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSTOTALHCOCTETS: {
        switchRMON_global_ret.c64_ret = table_entry.smonVlanIdStatsTotalHCOctets;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    case SMONVLANIDSTATSNUCASTPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsNUcastPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSNUCASTOVERFLOWPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsNUcastOverflowPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSNUCASTHCPKTS: {
        switchRMON_global_ret.c64_ret = table_entry.smonVlanIdStatsNUcastHCPkts;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    case SMONVLANIDSTATSNUCASTOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsNUcastOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSNUCASTOVERFLOWOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsNUcastOverflowOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONVLANIDSTATSNUCASTHCOCTETS: {
        switchRMON_global_ret.c64_ret = table_entry.smonVlanIdStatsNUcastHCOctets;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    case SMONVLANIDSTATSCREATETIME: {
        switchRMON_global_ret.ulong_ret = table_entry.smonVlanIdStatsCreateTime;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_smonVlanIdStatsTable\n", vp->magic));
    }
    return NULL;
}
static int
getfirst_smonPrioStatsControlTableEntry(smonPrioStatsControlTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_smonPrioStatsControlTableEntry(smonPrioStatsControlTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
set_smonPrioStatsControlTableEntry(smonPrioStatsControlTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_smonPrioStatsControlTable(oid     *name,
                                size_t  *length,
                                int     exact,
                                smonPrioStatsControlTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_smonPrioStatsControlTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->smonPrioStatsControlIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
void smon_create_stat_default_entry(void)
{
    snmp_rmon_stat_entry_t entry;
    smonVlanStatsControlTable_entry_t runTime_entry;
    oid datasource[]        = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
    size_t datasource_len   = sizeof(datasource) / sizeof(oid);

    memcpy(runTime_entry.smonVlanStatsControlDataSource, datasource, datasource_len * sizeof(oid));
    runTime_entry.smonVlanStatsControlDataSource_len = datasource_len;
    if ( TRUE == vlan_stats_ctrl_entry_list_created_done ) {
        vtss_avl_tree_destroy(&smon_vlan_counter_avlt);
        if (vtss_avl_tree_init(&smon_vlan_counter_avlt) == TRUE) {
            smon_vlan_counter_free_list_init();
        }
    } else {
        return;
    }

    /* Create default RMON statistics row entries form SNMP manager module */
    entry.ctrl_index = 0;

    while (snmp_mgmt_smon_stat_entry_get(&entry, TRUE) == VTSS_OK) {
        runTime_entry.smonVlanStatsControlIndex = entry.ctrl_index;
        runTime_entry.smonVlanStatsControlDataSource[ datasource_len - 1] = entry.if_index;
        runTime_entry.smonVlanStatsControlStatus = SNMP_ROW_ACTIVE;
        (void)set_smonVlanStatsControlTableEntry(&runTime_entry);
    }
}
#endif /* VTSS_FEATURE_VLAN_COUNTERS */

static int
fillobj_smonPrioStatsControlTable(oid     *name,
                                  size_t  *length,
                                  smonPrioStatsControlTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->smonPrioStatsControlIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_smonPrioStatsControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_smonPrioStatsControlTable(struct variable *vp,
                              oid     *name,
                              size_t  *length,
                              int     exact,
                              size_t  *var_len,
                              WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    smonPrioStatsControlTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_smonPrioStatsControlTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_smonPrioStatsControlTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_smonPrioStatsControlTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == SMONPRIOSTATSCONTROLSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_smonPrioStatsControlStatus;
                }
                return NULL;
            }
            if (fillobj_smonPrioStatsControlTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SMONPRIOSTATSCONTROLDATASOURCE: {
        *write_method = write_smonPrioStatsControlDataSource;
        memcpy(switchRMON_global_ret.objid_ret, table_entry.smonPrioStatsControlDataSource, table_entry.smonPrioStatsControlDataSource_len * sizeof(oid));
        *var_len = table_entry.smonPrioStatsControlDataSource_len * sizeof(oid);
        return (u_char *) switchRMON_global_ret.objid_ret;
    }
    case SMONPRIOSTATSCONTROLCREATETIME: {
        switchRMON_global_ret.ulong_ret = table_entry.smonPrioStatsControlCreateTime;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONPRIOSTATSCONTROLOWNER: {
        *write_method = write_smonPrioStatsControlOwner;
        *var_len = table_entry.smonPrioStatsControlOwner_len;
        memcpy(switchRMON_global_ret.string_ret, table_entry.smonPrioStatsControlOwner, *var_len);
        switchRMON_global_ret.string_ret[*var_len] = '\0';
        return (u_char *) switchRMON_global_ret.string_ret;
    }
    case SMONPRIOSTATSCONTROLSTATUS: {
        *write_method = write_smonPrioStatsControlStatus;
        switchRMON_global_ret.long_ret = table_entry.smonPrioStatsControlStatus;
        *var_len = sizeof(switchRMON_global_ret.long_ret);
        return (u_char *) &switchRMON_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_smonPrioStatsControlTable\n", vp->magic));
    }
    return NULL;
}
static int
getfirst_smonPrioStatsTableEntry(smonPrioStatsTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
get_smonPrioStatsTableEntry(smonPrioStatsTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return -1;
}

static int
parse_smonPrioStatsTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         smonPrioStatsTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_smonPrioStatsTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->smonPrioStatsControlIndex = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->smonPrioStatsId = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_smonPrioStatsTable(oid     *name,
                           size_t  *length,
                           smonPrioStatsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->smonPrioStatsControlIndex;
    name[name_pos++] = (oid) table_entry->smonPrioStatsId;

    *length = name_pos;
    return 0;
}

/*
 * var_smonPrioStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_smonPrioStatsTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    smonPrioStatsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_smonPrioStatsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_smonPrioStatsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_smonPrioStatsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_smonPrioStatsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case SMONPRIOSTATSPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonPrioStatsPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONPRIOSTATSOVERFLOWPKTS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonPrioStatsOverflowPkts;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONPRIOSTATSHCPKTS: {
        switchRMON_global_ret.c64_ret = table_entry.smonPrioStatsHCPkts;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    case SMONPRIOSTATSOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonPrioStatsOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONPRIOSTATSOVERFLOWOCTETS: {
        switchRMON_global_ret.ulong_ret = table_entry.smonPrioStatsOverflowOctets;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case SMONPRIOSTATSHCOCTETS: {
        switchRMON_global_ret.c64_ret = table_entry.smonPrioStatsHCOctets;
        *var_len = sizeof(switchRMON_global_ret.c64_ret);
        return (u_char *) &switchRMON_global_ret.c64_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_smonPrioStatsTable\n", vp->magic));
    }
    return NULL;
}
#endif /* VTSS_FEATURE_VLAN_COUNTERS */
#if 0
static BOOL portCopy_is_avaliable(long sourceIf, long destIf)
{
    oid datasource[]        = {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0};
    size_t datasource_len   = sizeof(datasource) / sizeof(oid);
    ifIndex_type_t type = IFTABLE_IFINDEX_TYPE_PORT;
    dataSourceCapsTable_entry_t table_entry;

    memcpy(table_entry.dataSourceCapsObject, datasource, sizeof(datasource));
    table_entry.dataSourceCapsObject_len = datasource_len;
    table_entry.dataSourceCapsObject[table_entry.dataSourceCapsObject_len - 1] = sourceIf;

    (void) get_dataSourceCapsTableEntryByKey( &table_entry, &type);
    if ( 0 == (table_entry.dataSourceCopyCaps[0] & COPY_SOURCE_PORT) ) {
        return FALSE;
    }

    table_entry.dataSourceCapsObject[table_entry.dataSourceCapsObject_len - 1] = destIf;

    (void) get_dataSourceCapsTableEntryByKey( &table_entry, &type);
    if ( 0 == (table_entry.dataSourceCopyCaps[0] & COPY_DEST_PORT) ) {
        return FALSE;
    }

}
#endif

static BOOL get_next_portCopyTableEntryInModule(portCopyTable_entry_t *entry)
{
    iftable_info_t          info;
    long                    source_tmp = 0, dest_tmp = 0;
    port_iter_t             pit;
    switch_iter_t           sit;
    BOOL                    notReady = FALSE, next_source = FALSE, check = FALSE;
    port_status_t           port_status;
#ifdef VTSS_SW_OPTION_RSPAN
    if (is_rspan_mode()) {
        return FALSE;
    }
#else
    mirror_conf_t           conf;
    mirror_switch_conf_t    switch_conf;

    (void) mirror_mgmt_conf_get(&conf);

    if ( VTSS_PORT_NO_NONE == conf.dst_port) {
        return FALSE;
    }

    info.type = IFTABLE_IFINDEX_TYPE_PORT;
    info.if_id = conf.dst_port;
    info.isid = conf.mirror_switch;
    (void) ifIndex_get_by_interface(&info);
    dest_tmp = info.ifIndex;

    (void) port_mgmt_status_get(info.isid, info.if_id, &port_status);
    if ( FALSE == port_status.status.link) {
        notReady = TRUE;
    }

    info.ifIndex = entry->portCopySource;

    if ( FALSE == ifIndex_get(&info) ) {
        if (FALSE == ifIndex_get_next(&info)) {
            return FALSE;
        }
        next_source = TRUE;

    }

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (sit.isid < info.isid) {
            continue;
        }
        (void) mirror_mgmt_switch_conf_get(sit.isid, &switch_conf);
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (entry->portCopyDest < dest_tmp || next_source == TRUE) {
                check = (pit.iport >= info.if_id);
            } else {
                check = (pit.iport > info.if_id);
            }
            if (check && (TRUE == switch_conf.src_enable[pit.iport] || TRUE == switch_conf.dst_enable[pit.iport])) {
                info.type = IFTABLE_IFINDEX_TYPE_PORT;
                info.if_id = pit.iport;
                info.isid = sit.isid;
                (void) ifIndex_get_by_interface(&info);
                source_tmp = info.ifIndex;

                if (TRUE == switch_conf.src_enable[pit.iport] && TRUE == switch_conf.dst_enable[pit.iport]) {
                    entry->portCopyDirection = COPY_BOTH;
                } else if (TRUE == switch_conf.src_enable[pit.iport]) {
                    entry->portCopyDirection = COPY_RX_ONLY;
                } else {
                    entry->portCopyDirection = COPY_TX_ONLY;
                }

                (void) port_mgmt_status_get(info.isid, info.if_id, &port_status);
                if ( FALSE == port_status.status.link) {
                    notReady = TRUE;
                }

                goto get_OK;
            }
        }

    }

    if ( 0 == source_tmp) {
        return FALSE;
    }

#endif

get_OK:
    entry->portCopySource = source_tmp;
    entry->portCopyDest = dest_tmp;
    entry->portCopyStatus = (TRUE == notReady) ? 3 : 1;
    entry->portCopyDestDropEvents = 0;
    return TRUE;
}

static BOOL get_portCopyTableEntryInModule(portCopyTable_entry_t *entry)
{
    portCopyTable_entry_t tmp;
    tmp.portCopySource = entry->portCopySource;
    tmp.portCopyDest = entry->portCopyDest;

    if (tmp.portCopySource == 0 || tmp.portCopyDest == 0) {
        return FALSE;
    }

    if (tmp.portCopyDest != 0) {
        --tmp.portCopyDest;
    } else {
        --tmp.portCopySource;
        tmp.portCopyDest = 65535;
    }
    if ( FALSE == get_next_portCopyTableEntryInModule(&tmp) ||
         tmp.portCopySource != entry->portCopySource || tmp.portCopyDest != entry->portCopyDest) {
        return FALSE;
    }

    memcpy(entry, &tmp, sizeof(tmp));
    return TRUE;
}


static BOOL get_next_portCopyTableEntryInTmp(portCopyTable_entry_t *entry)
{
    portCopyTable_entry_t *temp_entry_p = entry;

    if (vtss_avl_tree_get(&smon_port_copy_avlt, (void **) &temp_entry_p, VTSS_AVL_TREE_GET_NEXT) != TRUE) {
        return FALSE;
    }
    memcpy(entry, temp_entry_p, sizeof(portCopyTable_entry_t));

    return TRUE;
}

static BOOL get_portCopyTableEntryInTmp(portCopyTable_entry_t *entry)
{
    portCopyTable_entry_t tmp;
    tmp.portCopySource = entry->portCopySource;
    tmp.portCopyDest = entry->portCopyDest;

    if (tmp.portCopySource == 0 || tmp.portCopyDest == 0) {
        return FALSE;
    }

    if (tmp.portCopyDest != 0) {
        --tmp.portCopyDest;
    } else {
        --tmp.portCopySource;
        tmp.portCopyDest = 65535;
    }
    if ( FALSE == get_next_portCopyTableEntryInTmp(&tmp) ||
         tmp.portCopySource != entry->portCopySource || tmp.portCopyDest != entry->portCopyDest) {
        return FALSE;
    }

    memcpy(entry, &tmp, sizeof(tmp));
    return TRUE;
}

static BOOL get_next_portCopyTableEntryByKey(portCopyTable_entry_t *entry)
{
    portCopyTable_entry_t    entry_tmp;
    portCopyTable_entry_t    entry_mod;
    BOOL    rc_tmp, rc_mod;

    memcpy(&entry_mod, entry, sizeof(portCopyTable_entry_t));
    memcpy(&entry_tmp, entry, sizeof(portCopyTable_entry_t));
    rc_mod = get_next_portCopyTableEntryInModule( &entry_mod);
    rc_tmp = get_next_portCopyTableEntryInTmp( &entry_tmp);

    if ( FALSE == rc_mod && FALSE == rc_tmp ) {
        return FALSE;
    }

    if (rc_mod == TRUE && rc_tmp == TRUE) {
        if ( 1 == portCpy_entry_compare_func(&entry_mod, &entry_tmp)) {
            memcpy(entry, &entry_tmp, sizeof(entry_tmp));
        } else {
            memcpy(entry, &entry_mod, sizeof(entry_mod));
        }
    } else if (rc_tmp == TRUE) {
        memcpy(entry, &entry_tmp, sizeof(entry_tmp));
    } else {
        memcpy(entry, &entry_mod, sizeof(entry_mod));
    }
    return TRUE;

}

static int
getfirst_portCopyTableEntry(portCopyTable_entry_t *table_entry)
{
#ifdef VTSS_SW_OPTION_RSPAN
    if (is_rspan_mode()) {
        return VTSS_RC_ERROR;
    }
#endif

    table_entry->portCopySource = 0;
    table_entry->portCopyDest = 0;
    if ( FALSE == get_next_portCopyTableEntryByKey(table_entry)) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;

}

static int
get_portCopyTableEntry(portCopyTable_entry_t *table_entry, BOOL getnext)
{
#ifdef VTSS_SW_OPTION_RSPAN
    if (is_rspan_mode()) {
        return VTSS_RC_ERROR;
    }
#endif

    if (getnext) {
        if (FALSE == get_next_portCopyTableEntryByKey(table_entry)) {
            return VTSS_RC_ERROR;
        }
    } else {
        if ( FALSE == get_portCopyTableEntryInTmp(table_entry) && FALSE == get_portCopyTableEntryInModule(table_entry)) {
            return VTSS_RC_ERROR;
        }
    }
    return VTSS_RC_OK;
}

static BOOL apply_portCopyTableEntry (portCopyTable_entry_t *table_entry)
{
    mirror_conf_t           conf;
    mirror_switch_conf_t    switch_conf;
    iftable_info_t          info;

    (void) mirror_mgmt_conf_get(&conf);

    info.ifIndex = table_entry->portCopyDest;
    (void) ifIndex_get(&info);

    if (conf.dst_port != VTSS_PORT_NO_NONE && conf.dst_port != info.if_id) {
        return FALSE;
    } else if (conf.dst_port == VTSS_PORT_NO_NONE) {
        conf.mirror_switch = info.isid;
        conf.dst_port = info.if_id;
        (void) mirror_mgmt_conf_set(&conf);
    }

    info.ifIndex = table_entry->portCopySource;
    (void) ifIndex_get(&info);
    (void) mirror_mgmt_switch_conf_get(info.isid, &switch_conf);

    switch (table_entry->portCopyDirection) {
    case COPY_BOTH:
        switch_conf.src_enable[info.if_id] = TRUE;
        switch_conf.dst_enable[info.if_id] = TRUE;
        break;
    case COPY_RX_ONLY:
        switch_conf.src_enable[info.if_id] = TRUE;
        switch_conf.dst_enable[info.if_id] = FALSE;
        break;
    case COPY_TX_ONLY:
        switch_conf.src_enable[info.if_id] = FALSE;
        switch_conf.dst_enable[info.if_id] = TRUE;
        break;
    default:
        ;
    }
    (void) mirror_mgmt_switch_conf_set(info.isid, &switch_conf);
    return TRUE;

}

static BOOL deactive_portCopyTableEntry (portCopyTable_entry_t *table_entry)
{
    mirror_conf_t           conf;
    mirror_switch_conf_t    switch_conf;
    switch_iter_t           sit;
    port_iter_t             pit;
    BOOL                    found = FALSE;
    iftable_info_t          info;


    info.ifIndex = table_entry->portCopySource;
    (void) ifIndex_get(&info);
    (void) mirror_mgmt_switch_conf_get(info.isid, &switch_conf);

    switch_conf.src_enable[info.if_id] = FALSE;
    switch_conf.dst_enable[info.if_id] = FALSE;
    (void) mirror_mgmt_switch_conf_set(info.isid, &switch_conf);

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void) mirror_mgmt_switch_conf_get(sit.isid, &switch_conf);
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (switch_conf.src_enable[pit.iport] == TRUE || switch_conf.src_enable[pit.iport] == TRUE) {
                found = TRUE;
                break;
            }
        }
        if (found == TRUE) {
            break;
        }
    }

    if (found == FALSE) {
        conf.dst_port = VTSS_PORT_NO_NONE;
        (void) mirror_mgmt_conf_set(&conf);
    }

    return TRUE;
}

static int
set_portCopyTableEntry(portCopyTable_entry_t *table_entry)
{
#ifdef VTSS_SW_OPTION_RSPAN
#else
    switch (table_entry->portCopyStatus) {
    case SNMP_ROW_ACTIVE:
    case SNMP_ROW_NOTREADY: {
        portCopyTable_entry_t *temp_entry_p = table_entry;

        if ( FALSE == apply_portCopyTableEntry(table_entry)) {
            return VTSS_RC_ERROR;
        }

        if (vtss_avl_tree_delete(&smon_port_copy_avlt, (void **) &temp_entry_p) == TRUE) {
            smon_port_copy_free_list_free(temp_entry_p);
        }
        break;
    }
    case SNMP_ROW_NOTINSERVICE: {
        portCopyTable_entry_t *temp_entry_p = table_entry;

        if (vtss_avl_tree_get(&smon_port_copy_avlt, (void **) &temp_entry_p, VTSS_AVL_TREE_GET) != TRUE) { // entry not existing
            // allocate new entry buffer
            if ((temp_entry_p = smon_port_copy_free_list_malloc()) == NULL) {
                return VTSS_RC_ERROR;
            }
            memcpy(temp_entry_p, table_entry, sizeof(portCopyTable_entry_t));
            if (vtss_avl_tree_add(&smon_port_copy_avlt, (void *) temp_entry_p) != TRUE) {
                smon_port_copy_free_list_free(temp_entry_p);
                return VTSS_RC_ERROR;
            }
        } else { // entry already existing
            // update entry data directly
            memcpy(temp_entry_p, table_entry, sizeof(portCopyTable_entry_t));
        }

        if ( TRUE == get_portCopyTableEntryInModule(table_entry)) {
            (void) deactive_portCopyTableEntry(table_entry);
        }
        break;
    }
    case SNMP_ROW_NONEXISTENT: {
        portCopyTable_entry_t *temp_entry_p = table_entry;

        if (vtss_avl_tree_delete(&smon_port_copy_avlt, (void **) &temp_entry_p) == TRUE) {
            smon_port_copy_free_list_free(temp_entry_p);
        }
        (void) deactive_portCopyTableEntry(table_entry);
    }
    break;
    default:
        break;
    }
    return VTSS_RC_OK;
#endif
}

static int
parse_portCopyTable(oid     *name,
                    size_t  *length,
                    int     exact,
                    portCopyTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_portCopyTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->portCopySource = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->portCopyDest = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_portCopyTable(oid     *name,
                      size_t  *length,
                      portCopyTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->portCopySource;
    name[name_pos++] = (oid) table_entry->portCopyDest;

    *length = name_pos;
    return 0;
}

/*
 * var_portCopyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_switchRMON above.
 */
u_char *
var_portCopyTable(struct variable *vp,
                  oid     *name,
                  size_t  *length,
                  int     exact,
                  size_t  *var_len,
                  WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    portCopyTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_portCopyTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_portCopyTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_portCopyTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == PORTCOPYSTATUS) {
                    /* Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                       can create a new table entry. */
                    *write_method = write_portCopyStatus;
                }
                return NULL;
            }
            if (fillobj_portCopyTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case PORTCOPYDESTDROPEVENTS: {
        switchRMON_global_ret.ulong_ret = table_entry.portCopyDestDropEvents;
        *var_len = sizeof(switchRMON_global_ret.ulong_ret);
        return (u_char *) &switchRMON_global_ret.ulong_ret;
    }
    case PORTCOPYDIRECTION: {
        *write_method = write_portCopyDirection;
        switchRMON_global_ret.long_ret = table_entry.portCopyDirection;
        *var_len = sizeof(switchRMON_global_ret.long_ret);
        return (u_char *) &switchRMON_global_ret.long_ret;
    }
    case PORTCOPYSTATUS: {
        *write_method = write_portCopyStatus;
        switchRMON_global_ret.long_ret = table_entry.portCopyStatus;
        *var_len = sizeof(switchRMON_global_ret.long_ret);
        return (u_char *) &switchRMON_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_portCopyTable\n", vp->magic));
    }
    return NULL;
}

#if defined(VTSS_FEATURE_VLAN_COUNTERS)
int
write_smonVlanStatsControlDataSource(int      action,
                                     u_char   *var_val,
                                     u_char   var_val_type,
                                     size_t   var_val_len,
                                     u_char   *statP,
                                     oid      *name,
                                     size_t   name_len)
{
    smonVlanStatsControlTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlDataSource: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > MAX_OID_LEN) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlDataSource: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonVlanStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_smonVlanStatsControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        memcpy(table_entry.smonVlanStatsControlDataSource, var_val, var_val_len);
        table_entry.smonVlanStatsControlDataSource_len = var_val_len / sizeof(oid);
        if (set_smonVlanStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0
int
write_smonVlanStatsControlOwner(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    smonVlanStatsControlTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlOwner: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SNMP_ASN_OCTET_STR_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlOwner: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_len > 127) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonVlanStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_smonVlanStatsControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.smonVlanStatsControlOwner, var_val, var_val_len);
        table_entry.smonVlanStatsControlOwner_len = var_val_len;
        if (set_smonVlanStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_smonVlanStatsControlStatus(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    smonVlanStatsControlTable_entry_t    table_entry;
    rowEntry_status_t cur_state, next_state;
    rowEntry_rc_t rc;
    int rc_get;
    BOOL params_valid;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to smonVlanStatsControlStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonVlanStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        rc_get = get_smonVlanStatsControlTableEntry(&table_entry, FALSE);
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            VTSS_RC_OK != rc_get ) {
            return SNMP_ERR_COMMITFAILED;
        }

        if ( VTSS_RC_OK != rc_get) {
            cur_state = ROWENTRY_STATE_NOT_EXISTENT;
        } else {
            (void) rfc2579_2_rowEntry( table_entry.smonVlanStatsControlStatus, &cur_state);
        }

        params_valid = smonVlanStatsControlTable_entry_valid(&table_entry);
        if ( FALSE == rowStatus_nextState( cur_state, set_value, params_valid, vlan_stats_caps, &next_state, &rc)) {
            T_E("error: cur_state = %d, set_value = %lu, params_valid = %d, cpas = %d %d %d %d", cur_state, set_value, params_valid,
                vlan_stats_caps[0], vlan_stats_caps[1], vlan_stats_caps[2], vlan_stats_caps[3]);
            return SNMP_ERR_COMMITFAILED;
        }

        if ( rc != ROWENTRY_RC_NO_ERROR) {
            return rc;
        }

        (void) rowEntry_2_rfc2579( next_state, (rfc2579_status_t *) &table_entry.smonVlanStatsControlStatus );

        if (set_smonVlanStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_smonPrioStatsControlDataSource(int      action,
                                     u_char   *var_val,
                                     u_char   var_val_type,
                                     size_t   var_val_len,
                                     u_char   *statP,
                                     oid      *name,
                                     size_t   name_len)
{
    smonPrioStatsControlTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlDataSource: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > MAX_OID_LEN) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlDataSource: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonPrioStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_smonPrioStatsControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.smonPrioStatsControlDataSource, var_val, var_val_len * sizeof(oid));
        table_entry.smonPrioStatsControlDataSource_len = var_val_len;
        if (set_smonPrioStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_smonPrioStatsControlOwner(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    smonPrioStatsControlTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlOwner: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SNMP_ASN_OCTET_STR_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlOwner: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_len > 127) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonPrioStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_smonPrioStatsControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.smonPrioStatsControlOwner, var_val, var_val_len);
        table_entry.smonPrioStatsControlOwner_len = var_val_len;
        if (set_smonPrioStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_smonPrioStatsControlStatus(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    smonPrioStatsControlTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to smonPrioStatsControlStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_smonPrioStatsControlTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_smonPrioStatsControlTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.smonPrioStatsControlStatus = set_value;
        if (set_smonPrioStatsControlTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* VTSS_FEATURE_VLAN_COUNTERS */
int
write_portCopyDirection(int      action,
                        u_char   *var_val,
                        u_char   var_val_type,
                        size_t   var_val_len,
                        u_char   *statP,
                        oid      *name,
                        size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    portCopyTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to portCopyDirection: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to portCopyDirection: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
           ) {
            (void) snmp_log(LOG_ERR, "write to portCopyDirection: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_portCopyTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_portCopyTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.portCopyDirection = set_value;
        if (set_portCopyTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_portCopyStatus(int      action,
                     u_char   *var_val,
                     u_char   var_val_type,
                     size_t   var_val_len,
                     u_char   *statP,
                     oid      *name,
                     size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    portCopyTable_entry_t    table_entry;
    rowEntry_status_t cur_state, next_state;
    rowEntry_rc_t rc;


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to portCopyStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to portCopyStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to portCopyStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_portCopyTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /* Return error code when the entry isn't existing
           except for "createAndGo(4)" or "createAndWait(5)" status */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_portCopyTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }

        if ( get_portCopyTableEntry(&table_entry, FALSE)) {
            cur_state = ROWENTRY_STATE_NOT_EXISTENT;
        } else {
            (void) rfc2579_2_rowEntry( table_entry.portCopyStatus, &cur_state);
        }

        if ( FALSE == rowStatus_nextState( cur_state, set_value, TRUE, portCpy_caps, &next_state, &rc)) {
            T_E("error: cur_state = %d, set_value = %lu, params_valid = %d, cpas = %d %d %d %d", cur_state, set_value, TRUE,
                portCpy_caps[0], portCpy_caps[1], portCpy_caps[2], portCpy_caps[3]);
            return SNMP_ERR_COMMITFAILED;
        }

        if ( rc != ROWENTRY_RC_NO_ERROR) {
            return SNMP_ERR_COMMITFAILED;
        }

        (void) rowEntry_2_rfc2579( next_state, (rfc2579_status_t *) &table_entry.portCopyStatus );
        if (cur_state == ROWENTRY_STATE_NOT_EXISTENT) {
            table_entry.portCopyDirection = COPY_BOTH;
        }

        if (set_portCopyTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

