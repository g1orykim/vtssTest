/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "vtss_snmp_api.h"
#include "rfc1213_mib2.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_rfc1213_mib2.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_rfc1213_mib2.h"
#endif /* SNMP_HAS_UCD_SNMP */
#include "misc_api.h"
#include "ifIndex_api.h"
#include "rfc2863_ifmib.h"
#include "ip2_api.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"
#include "sysutil_api.h"

#ifdef VTSS_SW_OPTION_LACP
#include "lacp_api.h"
#endif                          /* VTSS_SW_OPTION_LACP */

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
/*
 * +++ Start (Internal implementation declarations)
 */
#include "vtss_snmp_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#if RFC2863_SUPPORTED_IFMIB
/* ifmib ----------------------------------------------------------*/
typedef struct {
    u_long           ifIndex;
    u_char           ifName[256];
    u_long           ifInMulticastPkts;
    u_long           ifInBroadcastPkts;
    u_long           ifOutMulticastPkts;
    u_long           ifOutBroadcastPkts;
    struct counter64 ifHCInOctets;
    struct counter64 ifHCInUcastPkts;
    struct counter64 ifHCInMulticastPkts;
    struct counter64 ifHCInBroadcastPkts;
    struct counter64 ifHCOutOctets;
    struct counter64 ifHCOutUcastPkts;
    struct counter64 ifHCOutMulticastPkts;
    struct counter64 ifHCOutBroadcastPkts;
    u_long           ifLinkUpDownTrapEnable;
    u_long           ifHighSpeed;
    /* Not supported in E-StaX34 project
    long             ifPromiscuousMode;
    long             ifConnectorPresent; */
    u_char           ifAlias[64];
    u_long           ifCounterDiscontinuityTime;
    struct counter64 ifHCInPkts; /* internal used */
    struct counter64 ifHCOutPkts; /* internal used */
} ifXTable_entry_t;

/*
 * The entry data structure for ifStackTable
 */
typedef struct {
    /*
     * Entry keys
     */
    long            ifStackHigherLayer;
    long            ifStackLowerLayer;

    /*
     * Entry columns
     */
    long            ifStackStatus;
} ifStackTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long            long_ret;
} ifStackTable_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, ifStackTable_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static ifStackTable_return_t ifStackTable_global_ret;   /* static variables for retuning */



static struct timeval ifTable_LastChange;
static BOOL old_linkupdown_trap_enable[VTSS_ISID_CNT][VTSS_PORTS], now_linkupdown_trap_enable[VTSS_ISID_CNT][VTSS_PORTS];
static ifXTable_entry_t ip_ifXTable_entry;
static BOOL register_flag = FALSE;

static BOOL update_ifXTable_entry(vtss_isid_t isid, vtss_port_no_t port_idx, ifXTable_entry_t *table_entry_p)
{
    snmp_port_conf_t         snmp_port_conf;
    port_conf_t              port_conf;
    port_status_t            port_status;
    vtss_port_counters_t     counters;

    if (snmp_mgmt_snmp_port_conf_get(isid, port_idx, &snmp_port_conf) != VTSS_OK) {
        return FALSE;
    }
    if (port_mgmt_conf_get(isid, port_idx, &port_conf) != VTSS_OK) {
        return FALSE;
    }
    if (port_mgmt_status_get(isid, port_idx, &port_status) != VTSS_OK) {
        return FALSE;
    }
    if (port_mgmt_counters_get(isid, port_idx, &counters) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->ifInMulticastPkts          += counters.if_group.ifInMulticastPkts;
    table_entry_p->ifInBroadcastPkts          += counters.if_group.ifInBroadcastPkts;
    table_entry_p->ifOutMulticastPkts         += counters.if_group.ifOutMulticastPkts;
    table_entry_p->ifOutBroadcastPkts         += counters.if_group.ifOutBroadcastPkts;
    table_entry_p->ifHCInOctets.low           += counters.if_group.ifInOctets & 0xFFFFFFFF;
    table_entry_p->ifHCInOctets.high          += counters.if_group.ifInOctets >> 32;
    table_entry_p->ifHCInUcastPkts.low        += counters.if_group.ifInUcastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCInUcastPkts.high       += counters.if_group.ifInUcastPkts >> 32;
    table_entry_p->ifHCInMulticastPkts.low    += counters.if_group.ifInMulticastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCInMulticastPkts.high   += counters.if_group.ifInMulticastPkts >> 32;
    table_entry_p->ifHCInBroadcastPkts.low    += counters.if_group.ifInBroadcastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCInBroadcastPkts.high   += counters.if_group.ifInBroadcastPkts >> 32;
    table_entry_p->ifHCOutOctets.low          += counters.if_group.ifOutOctets & 0xFFFFFFFF;
    table_entry_p->ifHCOutOctets.high         += counters.if_group.ifOutOctets >> 32;
    table_entry_p->ifHCOutUcastPkts.low       += counters.if_group.ifOutUcastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCOutUcastPkts.high      += counters.if_group.ifOutUcastPkts >> 32;
    table_entry_p->ifHCOutMulticastPkts.low   += counters.if_group.ifOutMulticastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCOutMulticastPkts.high  += counters.if_group.ifOutMulticastPkts >> 32;
    table_entry_p->ifHCOutBroadcastPkts.low   += counters.if_group.ifOutBroadcastPkts & 0xFFFFFFFF;
    table_entry_p->ifHCOutBroadcastPkts.high  += counters.if_group.ifOutBroadcastPkts >> 32;
    if (PORT_NO_IS_STACK(port_idx)) {
        table_entry_p->ifLinkUpDownTrapEnable = 2;
    } else {
        table_entry_p->ifLinkUpDownTrapEnable = snmp_port_conf.linkupdown_trap_enable ? 1 : 2;
    }
    if (port_status.status.link) { /* link_up */
        table_entry_p->ifHighSpeed += (port_status.status.speed == VTSS_SPEED_10G ? 10000 : (port_status.status.speed == VTSS_SPEED_5G ? 5000 : (port_status.status.speed == VTSS_SPEED_2500M ? 2500 : (port_status.status.speed == VTSS_SPEED_1G ? 1000 : (port_status.status.speed == VTSS_SPEED_100M ? 1000 : 10)))));
    } else { /* link_down */
        table_entry_p->ifHighSpeed += (port_conf.speed == VTSS_SPEED_10G ? 10000 : (port_conf.speed == VTSS_SPEED_5G ? 5000 : (port_conf.speed == VTSS_SPEED_2500M ? 2500 : (port_conf.speed == VTSS_SPEED_1G ? 1000 : (port_conf.speed == VTSS_SPEED_100M ? 100 : 10)))));
    }

    /* Not supported in E-StaX34 project
    table_entry_p->ifPromiscuousMode          = 0;
    table_entry_p->ifConnectorPresent         = 0; */
    //table_entry_p->ifCounterDiscontinuityTime = 0;

    return TRUE;
}

BOOL get_ifXTable_entry(int table_index, ifXTable_entry_t *table_entry_p)
{
    vtss_isid_t              isid;
    aggr_mgmt_group_member_t aggr_members;
    iftable_info_t           table_info;
    port_iter_t              pit;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(ifXTable_entry_t));
    table_entry_p->ifIndex = table_index;

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
#if VTSS_SWITCH_STACKABLE
        snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "Switch %2d - Port %2u", topo_isid2usid(table_info.isid), (u32)iport2uport(table_info.if_id));
        snprintf(table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "%2d - %2u", topo_isid2usid(table_info.isid), (u32)iport2uport(table_info.if_id));
#else
        snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "Port %2u", (u32)iport2uport(table_info.if_id));
        snprintf(table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "%2u", (u32)iport2uport(table_info.if_id));
#endif /* VTSS_SWITCH_STACKABLE */

        if (update_ifXTable_entry(table_info.isid, table_info.if_id, table_entry_p) == FALSE) {
            return FALSE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

#if VTSS_SWITCH_STACKABLE
        snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "Switch %2d - Local Link Aggregations %2lu", topo_isid2usid(table_info.isid), table_info.ifIndex);
        snprintf(table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "LLAG %2d - %2lu", topo_isid2usid(table_info.isid), table_info.ifIndex);
#else
        snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "Link Aggregations %2lu", table_info.ifIndex);
        snprintf(table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "LAG %2lu", table_info.ifIndex);
#endif /* VTSS_SWITCH_STACKABLE */

        (void)port_iter_init(&pit, NULL, table_info.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            if (update_ifXTable_entry(table_info.isid, pit.iport, table_entry_p) == FALSE) {
                return FALSE;
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "Global Link Aggregations %lu", table_info.ifIndex);
            snprintf(table_entry_p->ifAlias, sizeof(table_entry_p->ifAlias), "GLAG %lu", table_info.ifIndex);

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_ifXTable_entry(isid, pit.iport, table_entry_p) == FALSE) {
                    return FALSE;
                }
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_VLAN:
        snprintf(table_entry_p->ifName, sizeof(table_entry_p->ifName), "VLAN %4d", (int)table_info.if_id);
        strcpy(table_entry_p->ifAlias, table_entry_p->ifName);
        table_entry_p->ifLinkUpDownTrapEnable = 2;
        break;
    case IFTABLE_IFINDEX_TYPE_IP: {
        struct ifnet   *ifnet_p;

        ifnet_p = get_IpInterface(table_info.if_id);
        if (!ifnet_p) {
            return FALSE;
        }

        snprintf(ip_ifXTable_entry.ifName, sizeof(ip_ifXTable_entry.ifName), "IP Interface");
        strcpy(ip_ifXTable_entry.ifAlias, ip_ifXTable_entry.ifName);

        ip_ifXTable_entry.ifInMulticastPkts  = ifnet_p->if_imcasts;
        ip_ifXTable_entry.ifInBroadcastPkts  = ifnet_p->if_ibcasts;
        ip_ifXTable_entry.ifOutMulticastPkts = ifnet_p->if_omcasts;
        ip_ifXTable_entry.ifOutBroadcastPkts = ifnet_p->if_ibcasts;

        /* ifHCInOctets */
        if (ip_ifXTable_entry.ifHCInOctets.high == 0 && ip_ifXTable_entry.ifHCInOctets.low == 0) {
            ip_ifXTable_entry.ifHCInOctets.low = ifnet_p->if_ibytes;
        } else if (ip_ifXTable_entry.ifHCInOctets.low > ifnet_p->if_ibytes) {
            ip_ifXTable_entry.ifHCInOctets.high++;
        }
        ip_ifXTable_entry.ifHCInOctets.low = ifnet_p->if_ibytes;

        /* ifHCInMulticastPkts */
        if (ip_ifXTable_entry.ifHCInMulticastPkts.high == 0 && ip_ifXTable_entry.ifHCInMulticastPkts.low == 0) {
            ip_ifXTable_entry.ifHCInMulticastPkts.low = ifnet_p->if_imcasts;
        } else if (ip_ifXTable_entry.ifHCInMulticastPkts.low > ifnet_p->if_imcasts) {
            ip_ifXTable_entry.ifHCInMulticastPkts.high++;
        }
        ip_ifXTable_entry.ifHCInMulticastPkts.low = ifnet_p->if_imcasts;

        /* ifHCInBroadcastPkts */
        if (ip_ifXTable_entry.ifHCInBroadcastPkts.high == 0 && ip_ifXTable_entry.ifHCInBroadcastPkts.low == 0) {
            ip_ifXTable_entry.ifHCInBroadcastPkts.low = ifnet_p->if_ibcasts;
        } else if (ip_ifXTable_entry.ifHCInBroadcastPkts.low > ifnet_p->if_ibcasts) {
            ip_ifXTable_entry.ifHCInBroadcastPkts.high++;
        }
        ip_ifXTable_entry.ifHCInBroadcastPkts.low = ifnet_p->if_ibcasts;

        /* --- start of ifHCInUcastPkts = ifHCInPkts - ifHCInMulticastPkts - ifHCInBroadcastPkts */
        if (ip_ifXTable_entry.ifHCInPkts.high == 0 && ip_ifXTable_entry.ifHCInPkts.low == 0) {
            ip_ifXTable_entry.ifHCInPkts.low = ifnet_p->if_ipackets;
        } else if (ip_ifXTable_entry.ifHCInPkts.low > ifnet_p->if_ipackets) {
            ip_ifXTable_entry.ifHCInPkts.high++;
        }
        ip_ifXTable_entry.ifHCInPkts.low = ifnet_p->if_opackets;
        ip_ifXTable_entry.ifHCInUcastPkts.high = (ip_ifXTable_entry.ifHCInPkts.high > ip_ifXTable_entry.ifHCInMulticastPkts.high) ? ip_ifXTable_entry.ifHCInPkts.high - ip_ifXTable_entry.ifHCInMulticastPkts.high : 0;
        if (ip_ifXTable_entry.ifHCInPkts.low > ip_ifXTable_entry.ifHCInMulticastPkts.low) {
            ip_ifXTable_entry.ifHCInUcastPkts.high--;
            ip_ifXTable_entry.ifHCInUcastPkts.low = ip_ifXTable_entry.ifHCInPkts.low + (0xFFFFFFFF - ip_ifXTable_entry.ifHCInMulticastPkts.low) + 1;
        } else {
            ip_ifXTable_entry.ifHCInUcastPkts.low = ip_ifXTable_entry.ifHCInPkts.low - ip_ifXTable_entry.ifHCInMulticastPkts.low;
        }

        if (ip_ifXTable_entry.ifHCInPkts.high == 0 && ip_ifXTable_entry.ifHCInPkts.low == 0) {
            ip_ifXTable_entry.ifHCInPkts.low = ifnet_p->if_ipackets;
        } else if (ip_ifXTable_entry.ifHCInPkts.low > ifnet_p->if_ipackets) {
            ip_ifXTable_entry.ifHCInPkts.high++;
        }
        ip_ifXTable_entry.ifHCInPkts.low = ifnet_p->if_opackets;
        ip_ifXTable_entry.ifHCInUcastPkts.high = (ip_ifXTable_entry.ifHCInPkts.high > ip_ifXTable_entry.ifHCInBroadcastPkts.high) ? ip_ifXTable_entry.ifHCInPkts.high - ip_ifXTable_entry.ifHCInBroadcastPkts.high : 0;
        if (ip_ifXTable_entry.ifHCInPkts.low > ip_ifXTable_entry.ifHCInBroadcastPkts.low) {
            ip_ifXTable_entry.ifHCInUcastPkts.high--;
            ip_ifXTable_entry.ifHCInUcastPkts.low = ip_ifXTable_entry.ifHCInPkts.low + (0xFFFFFFFF - ip_ifXTable_entry.ifHCInBroadcastPkts.low) + 1;
        } else {
            ip_ifXTable_entry.ifHCInUcastPkts.low = ip_ifXTable_entry.ifHCInPkts.low - ip_ifXTable_entry.ifHCInBroadcastPkts.low;
        }
        /* --- end of ifHCInUcastPkts */

        /* ifHCOutOctets */
        if (ip_ifXTable_entry.ifHCOutOctets.high == 0 && ip_ifXTable_entry.ifHCOutOctets.low == 0) {
            ip_ifXTable_entry.ifHCOutOctets.low = ifnet_p->if_obytes;
        } else if (ip_ifXTable_entry.ifHCOutOctets.low > ifnet_p->if_obytes) {
            ip_ifXTable_entry.ifHCOutOctets.high++;
        }
        ip_ifXTable_entry.ifHCOutOctets.low = ifnet_p->if_obytes;

        /* ifHCOutMulticastPkts */
        if (ip_ifXTable_entry.ifHCOutMulticastPkts.high == 0 && ip_ifXTable_entry.ifHCOutMulticastPkts.low == 0) {
            ip_ifXTable_entry.ifHCOutMulticastPkts.low = ifnet_p->if_omcasts;
        } else if (ip_ifXTable_entry.ifHCOutMulticastPkts.low > ifnet_p->if_omcasts) {
            ip_ifXTable_entry.ifHCOutMulticastPkts.high++;
        }
        ip_ifXTable_entry.ifHCOutMulticastPkts.low = ifnet_p->if_omcasts;

        /* ifHCOutBroadcastPkts */
        if (ip_ifXTable_entry.ifHCOutBroadcastPkts.high == 0 && ip_ifXTable_entry.ifHCOutBroadcastPkts.low == 0) {
            ip_ifXTable_entry.ifHCOutBroadcastPkts.low = ifnet_p->if_obcasts;
        } else if (ip_ifXTable_entry.ifHCOutBroadcastPkts.low > ifnet_p->if_obcasts) {
            ip_ifXTable_entry.ifHCOutBroadcastPkts.high++;
        }
        ip_ifXTable_entry.ifHCOutBroadcastPkts.low = ifnet_p->if_obcasts;

        /* --- start of ifHCOutUcastPkts = ifHCOutPkts - ifHCOutMulticastPkts - ifHCOutBroadcastPkts */
        if (ip_ifXTable_entry.ifHCOutPkts.high == 0 && ip_ifXTable_entry.ifHCOutPkts.low == 0) {
            ip_ifXTable_entry.ifHCOutPkts.low = ifnet_p->if_opackets;
        } else if (ip_ifXTable_entry.ifHCOutPkts.low > ifnet_p->if_opackets) {
            ip_ifXTable_entry.ifHCOutPkts.high++;
        }
        ip_ifXTable_entry.ifHCOutPkts.low = ifnet_p->if_opackets;
        ip_ifXTable_entry.ifHCOutUcastPkts.high = (ip_ifXTable_entry.ifHCOutPkts.high > ip_ifXTable_entry.ifHCOutMulticastPkts.high) ? ip_ifXTable_entry.ifHCOutPkts.high - ip_ifXTable_entry.ifHCOutMulticastPkts.high : 0;
        if (ip_ifXTable_entry.ifHCOutPkts.low > ip_ifXTable_entry.ifHCOutMulticastPkts.low) {
            ip_ifXTable_entry.ifHCOutUcastPkts.high--;
            ip_ifXTable_entry.ifHCOutUcastPkts.low = ip_ifXTable_entry.ifHCOutPkts.low + (0xFFFFFFFF - ip_ifXTable_entry.ifHCOutMulticastPkts.low) + 1;
        } else {
            ip_ifXTable_entry.ifHCOutUcastPkts.low = ip_ifXTable_entry.ifHCOutPkts.low - ip_ifXTable_entry.ifHCOutMulticastPkts.low;
        }

        if (ip_ifXTable_entry.ifHCOutPkts.high == 0 && ip_ifXTable_entry.ifHCOutPkts.low == 0) {
            ip_ifXTable_entry.ifHCOutPkts.low = ifnet_p->if_opackets;
        } else if (ip_ifXTable_entry.ifHCOutPkts.low > ifnet_p->if_opackets) {
            ip_ifXTable_entry.ifHCOutPkts.high++;
        }
        ip_ifXTable_entry.ifHCOutPkts.low = ifnet_p->if_opackets;
        ip_ifXTable_entry.ifHCOutUcastPkts.high = (ip_ifXTable_entry.ifHCOutPkts.high > ip_ifXTable_entry.ifHCOutBroadcastPkts.high) ? ip_ifXTable_entry.ifHCOutPkts.high - ip_ifXTable_entry.ifHCOutBroadcastPkts.high : 0;
        if (ip_ifXTable_entry.ifHCOutPkts.low > ip_ifXTable_entry.ifHCOutBroadcastPkts.low) {
            ip_ifXTable_entry.ifHCOutUcastPkts.high--;
            ip_ifXTable_entry.ifHCOutUcastPkts.low = ip_ifXTable_entry.ifHCOutPkts.low + (0xFFFFFFFF - ip_ifXTable_entry.ifHCOutBroadcastPkts.low) + 1;
        } else {
            ip_ifXTable_entry.ifHCOutUcastPkts.low = ip_ifXTable_entry.ifHCOutPkts.low - ip_ifXTable_entry.ifHCOutBroadcastPkts.low;
        }
        /* --- end of ifHCOutUcastPkts */

        ip_ifXTable_entry.ifLinkUpDownTrapEnable     = 2;
        ip_ifXTable_entry.ifHighSpeed                = 1000;
        /* Not supported in E-StaX34 project
        ip_ifXTable_entry.ifPromiscuousMode          = 0;
        ip_ifXTable_entry.ifConnectorPresent         = 0; */
        //ip_ifXTable_entry.ifCounterDiscontinuityTime = 0;
        *table_entry_p = ip_ifXTable_entry;
        break;
    }
    default:
        return FALSE;
    }

    return TRUE;
}

static void ifmib_vlan_changed(void)
{
    struct timespec now_n;

    //James: gettimeofday(&ifTable_LastChange, NULL);
    clock_gettime(CLOCK_MONOTONIC, &now_n);
    ifTable_LastChange.tv_sec = now_n.tv_sec;
    ifTable_LastChange.tv_usec = now_n.tv_nsec / 1000;
}

static void ifmib_aggr_changed(vtss_isid_t isid, uint aggr_no)
{
    struct timespec now_n;

    //James: gettimeofday(&ifTable_LastChange, NULL);
    clock_gettime(CLOCK_MONOTONIC, &now_n);
    ifTable_LastChange.tv_sec = now_n.tv_sec;
    ifTable_LastChange.tv_usec = now_n.tv_nsec / 1000;

}
#endif /* RFC2863_SUPPORTED_IFMIB */

/*
 * --- End (Internal implementation declarations)
 */

#if RFC2863_SUPPORTED_IFMIB
/* ifmib ----------------------------------------------------------*/
/*
 * ifMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ifMIB_variables_oid[] = { 1, 3, 6, 1, 2, 1, 31 };

/*
 * variable4 ifMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the ifMIB mib section
 */

struct variable4 ifMIB_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define IFNAME                          1
    {IFNAME, ASN_OCTET_STR, RONLY, var_ifXTable, 4, {1, 1, 1, 1}},
#define IFINMULTICASTPKTS               2
    {IFINMULTICASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 2}},
#define IFINBROADCASTPKTS               3
    {IFINBROADCASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 3}},
#define IFOUTMULTICASTPKTS              4
    {IFOUTMULTICASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 4}},
#define IFOUTBROADCASTPKTS              5
    {IFOUTBROADCASTPKTS, ASN_COUNTER, RONLY, var_ifXTable, 4, {1, 1, 1, 5}},
#define IFHCINOCTETS                    6
    {IFHCINOCTETS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 6}},
#define IFHCINUCASTPKTS                 7
    {IFHCINUCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 7}},
#define IFHCINMULTICASTPKTS             8
    {IFHCINMULTICASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 8}},
#define IFHCINBROADCASTPKTS             9
    {IFHCINBROADCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 9}},
#define IFHCOUTOCTETS                   10
    {IFHCOUTOCTETS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 10}},
#define IFHCOUTUCASTPKTS                11
    {IFHCOUTUCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 11}},
#define IFHCOUTMULTICASTPKTS            12
    {IFHCOUTMULTICASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 12}},
#define IFHCOUTBROADCASTPKTS            13
    {IFHCOUTBROADCASTPKTS, ASN_COUNTER64, RONLY, var_ifXTable, 4, {1, 1, 1, 13}},
#define IFLINKUPDOWNTRAPENABLE          14
    {IFLINKUPDOWNTRAPENABLE, ASN_INTEGER, RWRITE, var_ifXTable, 4, {1, 1, 1, 14}},
#define IFHIGHSPEED                     15
    {IFHIGHSPEED, ASN_GAUGE, RONLY, var_ifXTable, 4, {1, 1, 1, 15}},
    /* Not supported in E-StaX34 project
    #define IFPROMISCUOUSMODE               16
        {IFPROMISCUOUSMODE, ASN_INTEGER, RWRITE, var_ifXTable, 4, {1, 1, 1, 16}},
    #define IFCONNECTORPRESENT              17
        {IFCONNECTORPRESENT, ASN_INTEGER, RONLY, var_ifXTable, 4, {1, 1, 1, 17}}, */
#define IFALIAS                         18
    {IFALIAS, ASN_OCTET_STR, RWRITE, var_ifXTable, 4, {1, 1, 1, 18}},
#define IFCOUNTERDISCONTINUITYTIME      19
    {IFCOUNTERDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_ifXTable, 4, {1, 1, 1, 19}},
#define IFSTACKHIGHERLAYER              20
    {IFSTACKHIGHERLAYER, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 1}},
#define IFSTACKLOWERLAYER               21
    {IFSTACKLOWERLAYER, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 2}},
#define IFSTACKSTATUS                   22
    {IFSTACKSTATUS, ASN_INTEGER, RONLY, var_ifStackTable, 4, {1, 2, 1, 3}}, /* the ifStack Table is read only in our implement  */
    /* Not supported in E-StaX34 project
    #define IFTESTID                        23
        {IFTESTID, ASN_INTEGER, RWRITE, var_ifTestTable, 4, {1, 3, 1, 1}},
    #define IFTESTSTATUS                    24
        {IFTESTSTATUS, ASN_INTEGER, RWRITE, var_ifTestTable, 4, {1, 3, 1, 2}},
    #define IFTESTTYPE                      25
        {IFTESTTYPE, ASN_OBJECT_ID, RWRITE, var_ifTestTable, 4, {1, 3, 1, 3}},
    #define IFTESTRESULT                    26
        {IFTESTRESULT, ASN_INTEGER, RONLY, var_ifTestTable, 4, {1, 3, 1, 4}},
    #define IFTESTCODE                      27
        {IFTESTCODE, ASN_OBJECT_ID, RONLY, var_ifTestTable, 4, {1, 3, 1, 5}},
    #define IFTESTOWNER                     28
        {IFTESTOWNER, ASN_OCTET_STR, RWRITE, var_ifTestTable, 4, {1, 3, 1, 6}},
    #define IFRCVADDRESSADDRESS             29
        {IFRCVADDRESSADDRESS, ASN_OCTET_STR, RONLY, var_ifRcvAddressTable, 4, {1, 4, 1, 1}},
    #define IFRCVADDRESSSTATUS              30
        {IFRCVADDRESSSTATUS, ASN_INTEGER, RWRITE, var_ifRcvAddressTable, 4, {1, 4, 1, 2}},
    #define IFRCVADDRESSTYPE                31
        {IFRCVADDRESSTYPE, ASN_INTEGER, RWRITE, var_ifRcvAddressTable, 4, {1, 4, 1, 3}}, */
#define IFTABLELASTCHANGE               32
    {IFTABLELASTCHANGE, ASN_TIMETICKS, RONLY, var_ifMIB, 2, {1, 5}},
    /* Not supported in E-StaX34 project
    #define IFSTACKLASTCHANGE               33
        {IFSTACKLASTCHANGE, ASN_TIMETICKS, RONLY, var_ifMIB, 2, {1, 6}}, */
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * Initializes the ifMIB module
 */
void
init_ifMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(ifMIB_variables_oid,
                             sizeof(ifMIB_variables_oid) / sizeof(oid),
                             "IF-MIB : ifMIB");

    DEBUGMSGTL(("ifMIB", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ifMIB", ifMIB_variables, variable4, ifMIB_variables_oid);

    /*
     * place any other initialization junk you need here
     */
    memset(&ip_ifXTable_entry, 0x0, sizeof(ip_ifXTable_entry));

    if (!register_flag) {
        /* VLAN config change register */
        vlan_membership_bulk_change_register(VTSS_MODULE_ID_SNMP, ifmib_vlan_changed);

        /* AGGR config change callback */
        aggr_change_register(ifmib_aggr_changed);

        register_flag = TRUE;
    }
}

/*
 * var_ifMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_ifMIB(struct variable *vp,
          oid *name,
          size_t *length,
          int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    static u_long ulong_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFTABLELASTCHANGE: {
        ulong_ret = (ifTable_LastChange.tv_sec * 100) + (ifTable_LastChange.tv_usec / 10000);
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFSTACKLASTCHANGE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif /* Not supported in E-StaX34 project */
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifMIB\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_ifRcvAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifRcvAddressTable(struct variable *vp,
                      oid *name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //ifRcvAddressTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];       /* FIXME */
    //table_index = get_available_ifRcvAddressTableIndex(idx_num); /* FIXME */
    //if (!get_ifRcvAddressTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFRCVADDRESSADDRESS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFRCVADDRESSSTATUS: {
        *write_method = write_ifRcvAddressStatus;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFRCVADDRESSTYPE: {
        *write_method = write_ifRcvAddressType;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_ifRcvAddressTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif /* Not supported in E-StaX34 project */

/*
 * var_ifXTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifXTable(struct variable *vp,
             oid *name,
             size_t *length,
             int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                     table_index;
    int                     table_size;
    ifXTable_entry_t        table_entry;
    int                     idx_num;
    static u_long           ulong_ret;
    static u_char           string[16];
    static struct counter64 c64;

    table_size = IFTABLE_IFINDEX_END;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_ifTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }

    if (!get_ifXTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFNAME: {
        strcpy(string, table_entry.ifName);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case IFINMULTICASTPKTS: {
        ulong_ret = table_entry.ifInMulticastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFINBROADCASTPKTS: {
        ulong_ret = table_entry.ifInBroadcastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFOUTMULTICASTPKTS: {
        ulong_ret = table_entry.ifOutMulticastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFOUTBROADCASTPKTS: {
        ulong_ret = table_entry.ifOutBroadcastPkts;
        return (u_char *) &ulong_ret;
    }
    case IFHCINOCTETS: {
        c64 = table_entry.ifHCInOctets;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINUCASTPKTS: {
        c64 = table_entry.ifHCInUcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINMULTICASTPKTS: {
        c64 = table_entry.ifHCInMulticastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCINBROADCASTPKTS: {
        c64 = table_entry.ifHCInBroadcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTOCTETS: {
        c64 = table_entry.ifHCOutOctets;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTUCASTPKTS: {
        c64 = table_entry.ifHCOutUcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTMULTICASTPKTS: {
        c64 = table_entry.ifHCOutMulticastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFHCOUTBROADCASTPKTS: {
        c64 = table_entry.ifHCOutBroadcastPkts;
        *var_len = sizeof(c64);
        return (u_char *) &c64;
    }
    case IFLINKUPDOWNTRAPENABLE: {
        iftable_info_t table_info;

        if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
            return NULL;
        }

        if (table_info.type == IFTABLE_IFINDEX_TYPE_PORT ||
            table_info.type == IFTABLE_IFINDEX_TYPE_LLAG ||
            table_info.type == IFTABLE_IFINDEX_TYPE_GLAG) {
            *write_method = write_ifLinkUpDownTrapEnable;
        }
        ulong_ret = table_entry.ifLinkUpDownTrapEnable;
        return (u_char *) &ulong_ret;
    }
    case IFHIGHSPEED: {
        ulong_ret = table_entry.ifHighSpeed;
        return (u_char *) &ulong_ret;
    }
#if 0 /* Not supported in E-StaX34 project */
    case IFPROMISCUOUSMODE: {
        *write_method = write_ifPromiscuousMode;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFCONNECTORPRESENT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
#endif /* Not supported in E-StaX34 project */
    case IFALIAS: {
        /* Not supported in E-StaX34 project,
        *write_method = write_ifAlias; */
        strcpy(string, table_entry.ifAlias);
        *var_len = strlen(string);
        return (u_char *) string;
    }
    case IFCOUNTERDISCONTINUITYTIME: {
        ulong_ret = table_entry.ifCounterDiscontinuityTime;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifXTable\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* Not supported in E-StaX34 project */
/*
 * var_ifTestTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifMIB above.
 */
u_char         *
var_ifTestTable(struct variable *vp,
                oid *name,
                size_t *length,
                int exact, size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //ifTestTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_ifTestTableIndex(idx_num); /* FIXME */
    //if (!get_ifTestTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFTESTID: {
        *write_method = write_ifTestId;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTSTATUS: {
        *write_method = write_ifTestStatus;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTTYPE: {
        *write_method = write_ifTestType;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTRESULT: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTCODE: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case IFTESTOWNER: {
        *write_method = write_ifTestOwner;
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifTestTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif  /* Not supported in E-StaX34 project */

/**
  * \brief Get the next existent IfIndex in the specific type.
  *
  * \param info [INOUT]:    The info parameter has following members\n
  *                       [IN] type: The interface type
  *                       [INOUT] ifIndex: The first ifIndex, if any
  *                       [OUT] isid: The first ISID, if the output type is neither IFINDEX_TYPE_PORT nor IFINDEX_TYPE_LLAG interface, the isid shouldn¡¦t be modified.
  *                       [OUT] if_id: The first interface ID
  * \return
  *    FALSE if there is no available ifIndex.\n
  *     Otherwise, return TRUE.
  */
BOOL ifIndex_get_next_by_type(iftable_info_t *key_info)
{
    iftable_info_t  info;
    BOOL            found = FALSE;
    info.ifIndex = key_info->ifIndex;

    switch (key_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
    case IFTABLE_IFINDEX_TYPE_LLAG:
        while (ifIndex_get_next(&info)) {
            if (info.type == key_info->type) {
                found = TRUE;
                break;
            }
            if (info.type != IFTABLE_IFINDEX_TYPE_PORT && info.type != IFTABLE_IFINDEX_TYPE_LLAG) {
                return FALSE;
            }
        }
        if (found != TRUE) {
            return FALSE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
        while (ifIndex_get_next(&info)) {
            if (info.type == key_info->type) {
                found = TRUE;
                break;
            }
            if (info.type == IFTABLE_IFINDEX_TYPE_PORT || info.type == IFTABLE_IFINDEX_TYPE_LLAG) {
                info.type = key_info->type;
                if ( FALSE == ifIndex_get_first_by_type(&info) ) {
                    return FALSE;
                }
                found = TRUE;
                break;
            }
        }
        if (found != TRUE) {
            return FALSE;
        }
        break;
    default:
        return FALSE;
    }

    memcpy(key_info, &info, sizeof(info));
    return TRUE;
}

static BOOL get_or_next_vlanMemberByPort (vtss_vid_t vid, iftable_info_t *key2_info)
{
    port_iter_t              pit;
    switch_iter_t            sit;
    vlan_mgmt_entry_t        vlan_mgmt_entry;
    BOOL                     port_found = FALSE;
    iftable_info_t           info;
    aggr_mgmt_group_no_t     tmp_aggr_no, min_llag_no = 0, min_glag_no = 0;


    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit) ) {
        if (vlan_mgmt_vlan_get(sit.isid, vid, &vlan_mgmt_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!vlan_mgmt_entry.ports[pit.iport] ) {
                continue;
            }

            tmp_aggr_no = aggr_mgmt_get_port_aggr_id (sit.isid, pit.iport);

#if (AGGR_GLAG_CNT != 0)
            if (tmp_aggr_no > 0 &&  AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr_no) ) {
                min_glag_no = min_glag_no == 0 ? tmp_aggr_no : tmp_aggr_no < min_glag_no ? tmp_aggr_no : min_glag_no;
            } else if (tmp_aggr_no > 0) {
#else
            if (tmp_aggr_no > 0) {
#endif
                min_llag_no = min_llag_no == 0 ? tmp_aggr_no : tmp_aggr_no < min_llag_no ? tmp_aggr_no : min_llag_no;
            }

            if ( sit.isid < key2_info->isid  || (sit.isid == key2_info->isid && pit.iport < key2_info->if_id)) {
                continue;
            }

            if ( 0 == tmp_aggr_no) {
                port_found = TRUE;
                break;
            }

        }
        if (port_found == TRUE ) {
            break;
        }
    }

    if ( port_found == FALSE && min_llag_no == 0 && min_glag_no == 0 ) {
        return FALSE;
    } else if (port_found == FALSE) {
#if (AGGR_GLAG_CNT != 0)
        info.if_id = (min_llag_no != 0) ? min_llag_no : min_glag_no;
        info.type = (min_llag_no != 0) ? IFTABLE_IFINDEX_TYPE_LLAG : IFTABLE_IFINDEX_TYPE_GLAG;
        if (min_llag_no) {
            info.isid = sit.isid;
        }
#else
        info.if_id = min_llag_no;
        info.type = IFTABLE_IFINDEX_TYPE_LLAG;
        info.isid = sit.isid;
#endif
    } else {
        info.if_id = pit.iport;
        info.isid = sit.isid;
        info.type = IFTABLE_IFINDEX_TYPE_PORT;
    }

    (void) ifIndex_get_by_interface(&info);
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;

}

static BOOL get_vlanMemberByLLAG (vtss_vid_t vid, iftable_info_t *key2_info)
{
    port_iter_t              pit;
    aggr_mgmt_group_member_t aggr_members;
    vlan_mgmt_entry_t        vlan_mgmt_entry;

    if (vlan_mgmt_vlan_get(key2_info->isid, vid, &vlan_mgmt_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
        return FALSE;
    }
    if ((aggr_mgmt_port_members_get(key2_info->isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
        && (aggr_mgmt_lacp_members_get(key2_info->isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
       ) {
        return FALSE;
    }

    (void)port_iter_init(&pit, NULL, key2_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
    while (port_iter_getnext(&pit)) {
        if (!aggr_members.entry.member[pit.iport] || !vlan_mgmt_entry.ports[pit.iport]) {
            continue;
        }
        return TRUE;
    }
    return FALSE;

}

static BOOL get_vlanMemberByGLAG (vtss_vid_t vid, iftable_info_t *key2_info)
{
    port_iter_t              pit;
    switch_iter_t            sit;
    aggr_mgmt_group_member_t aggr_members;
    vlan_mgmt_entry_t        vlan_mgmt_entry;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vlan_mgmt_vlan_get(sit.isid, vid, &vlan_mgmt_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
            return FALSE;
        }

        if (aggr_mgmt_port_members_get(sit.isid, key2_info->if_id, &aggr_members, FALSE) != VTSS_OK) {
            continue;
        }
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport] || !vlan_mgmt_entry.ports[pit.iport] ) {
                continue;
            }
            return TRUE;
        }
    }
    return FALSE;
}

static BOOL get_or_next_vlanMemberByGLAG (vtss_vid_t vid, iftable_info_t *key2_info)
{
    iftable_info_t info;
    memcpy(&info, key2_info, sizeof(info));
    if ( FALSE == get_vlanMemberByGLAG ( vid, &info) ) {
        while ( TRUE == ifIndex_get_next(&info)) {
            if (info.type != IFTABLE_IFINDEX_TYPE_GLAG) {
                return FALSE;
            }
            if (TRUE == get_vlanMemberByGLAG ( vid, &info)) {
                break;
            }
            continue;
        }
    }
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;
}

static BOOL get_or_next_vlanMemberByLLAG (vtss_vid_t vid, iftable_info_t *key2_info)
{
    iftable_info_t info;
    memcpy(&info, key2_info, sizeof(info));
    if ( FALSE == get_vlanMemberByLLAG ( vid, &info) ) {
        while ( TRUE == ifIndex_get_next(&info)) {
            switch (info.type) {
            case IFTABLE_IFINDEX_TYPE_LLAG:
                if (TRUE == get_vlanMemberByLLAG ( vid, &info)) {
                    break;
                }
                continue;
            case IFTABLE_IFINDEX_TYPE_PORT:
                if (FALSE == get_or_next_vlanMemberByPort(vid, &info)) {
                    return FALSE;
                }
                break;
            case IFTABLE_IFINDEX_TYPE_GLAG:
                if (FALSE == get_or_next_vlanMemberByGLAG(vid, &info)) {
                    return FALSE;
                }
                break;
            default:
                return FALSE;
            }
        }
    }
    memcpy(key2_info, &info, sizeof(info));
    return TRUE;

}


static BOOL get_next_ifStackTableByKey1( iftable_info_t *key1_info, long *ifStackLowerLayer )
{
    iftable_info_t  info;
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    switch_iter_t            sit;

    info.ifIndex = *ifStackLowerLayer;

    switch (key1_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        break;
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return FALSE;
        }

        info.type = IFTABLE_IFINDEX_TYPE_PORT;
        if (FALSE == ifIndex_get_next_by_type(&info) || info.isid != key1_info->isid ) {
            return FALSE;
        }

        (void)port_iter_init(&pit, NULL, key1_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (aggr_members.entry.member[pit.iport]) {
            }
            if (!aggr_members.entry.member[pit.iport] || pit.iport < info.if_id ) {
                continue;
            }

            info.if_id = pit.iport;
            info.type = IFTABLE_IFINDEX_TYPE_PORT;
            info.isid = key1_info->isid;
            (void) ifIndex_get_by_interface(&info);
            *ifStackLowerLayer = info.ifIndex;
            return TRUE;
        }

        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        info.type = IFTABLE_IFINDEX_TYPE_PORT;
        if (FALSE == ifIndex_get_next_by_type(&info) ) {
            return FALSE;
        }

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (sit.isid < info.isid) {
                continue;
            }
            if (aggr_mgmt_port_members_get(sit.isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport] || (sit.isid == info.isid && pit.iport < info.if_id )) {
                    continue;
                }
                info.if_id = pit.iport;
                info.type = IFTABLE_IFINDEX_TYPE_PORT;
                info.isid = sit.isid;
                (void) ifIndex_get_by_interface(&info);
                *ifStackLowerLayer = info.ifIndex;
                return TRUE;
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_VLAN:
        if (FALSE == ifIndex_get_next(&info) ) {
            return FALSE;
        }

        switch (info.type) {
        case IFTABLE_IFINDEX_TYPE_PORT:
            if (FALSE == get_or_next_vlanMemberByPort (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        case IFTABLE_IFINDEX_TYPE_LLAG:
            if (FALSE == get_or_next_vlanMemberByLLAG (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        case IFTABLE_IFINDEX_TYPE_GLAG:
            if (FALSE == get_or_next_vlanMemberByGLAG (key1_info->if_id, &info)) {
                return FALSE;
            }
            break;
        default:
            return FALSE;
        }

        *ifStackLowerLayer = info.ifIndex;
        return TRUE;
    case IFTABLE_IFINDEX_TYPE_IP:
        info.if_id = key1_info->if_id;
        info.type = IFTABLE_IFINDEX_TYPE_VLAN;
        (void) ifIndex_get_by_interface (&info);

        if ( *ifStackLowerLayer < info.ifIndex ) {
            *ifStackLowerLayer = info.ifIndex;
            return TRUE;
        }
        break;
    default:
        break;
    }

    return FALSE;

}

static BOOL get_first_ifStackTableKey1(iftable_info_t *key1_info, long *ifStackLowerLayer )
{
    iftable_info_t  info;
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    switch_iter_t            sit;

    switch (key1_info->type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        *ifStackLowerLayer = 0;
        return TRUE;
    case IFTABLE_IFINDEX_TYPE_LLAG:
        if ((aggr_mgmt_port_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(key1_info->isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            *ifStackLowerLayer = 0;
            return TRUE;
        }

        (void)port_iter_init(&pit, NULL, key1_info->isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }
            info.if_id = pit.iport;
            info.type = IFTABLE_IFINDEX_TYPE_PORT;
            info.isid = key1_info->isid;
            (void) ifIndex_get_by_interface(&info);

            *ifStackLowerLayer = info.ifIndex;
            return TRUE;
        }
        break;
    case IFTABLE_IFINDEX_TYPE_GLAG:
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (aggr_mgmt_port_members_get(sit.isid, key1_info->if_id, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport] ) {
                    continue;
                }
                info.if_id = pit.iport;
                info.type = IFTABLE_IFINDEX_TYPE_PORT;
                info.isid = sit.isid;
                (void) ifIndex_get_by_interface(&info);
                *ifStackLowerLayer = info.ifIndex;
                return TRUE;
            }
        }
        break;
    case IFTABLE_IFINDEX_TYPE_VLAN:
        info.ifIndex = 0;

        if ( FALSE == ifIndex_get_next(&info)) {
            break;
        }
        if ( FALSE == get_or_next_vlanMemberByPort(key1_info->if_id, &info)) {
            /* no available member means that the member is NULL */
            *ifStackLowerLayer = 0;
            return TRUE;
        }
        *ifStackLowerLayer = info.ifIndex;
        return TRUE;
    case IFTABLE_IFINDEX_TYPE_IP:
        info.if_id = key1_info->if_id;
        info.type = IFTABLE_IFINDEX_TYPE_VLAN;
        (void) ifIndex_get_by_interface (&info);
        *ifStackLowerLayer = info.ifIndex;
        return TRUE;
        break;
    default:
        break;
    }

    return FALSE;

}

static BOOL get_next_ifStacktTableKey(long *ifStackHigherLayer, long *ifStackLowerLayer)
{
    long            k2;
    iftable_info_t  info;
    BOOL            next_hiLayer = FALSE;

    info.ifIndex = *ifStackHigherLayer;
    if ( FALSE == ifIndex_get( &info )) {
        if (FALSE == ifIndex_get_next( &info )) {
            return FALSE;
        }
        next_hiLayer = TRUE;
    } else {
        k2 = *ifStackLowerLayer;
        if (FALSE == get_next_ifStackTableByKey1 (&info, &k2)) {
            if (FALSE == ifIndex_get_next( &info )) {
                return FALSE;
            }
            next_hiLayer = TRUE;
        }
    }

    if (next_hiLayer == TRUE) {
        if ( FALSE == get_first_ifStackTableKey1 (&info, &k2) ) {
            return FALSE;
        }
    }
    *ifStackHigherLayer = info.ifIndex;
    *ifStackLowerLayer = k2;
    return TRUE;

}

static BOOL get_ifStacktTableKey(long *ifStackHigherLayer, long *ifStackLowerLayer)
{
    long k1, k2;

    if (*ifStackHigherLayer < 1) {
        return FALSE;
    } else if (*ifStackLowerLayer < 1) {
        k1 = *ifStackHigherLayer - 1;
        k2 = IFTABLE_IFINDEX_END;
    } else {
        k1 = *ifStackHigherLayer;
        k2 =  *ifStackLowerLayer - 1;
    }

    if ( FALSE == get_next_ifStacktTableKey (&k1, &k2) ||
         *ifStackHigherLayer != k1 || *ifStackLowerLayer != k2) {
        return FALSE;
    }

    return TRUE;
}

static BOOL get_ifStackTableByKey(ifStackTable_entry_t *table_entry)
{
    table_entry->ifStackStatus = SNMP_ROW_ACTIVE;
    return TRUE;
}

static int
getfirst_ifStackTableEntry(ifStackTable_entry_t *table_entry)
{
    long k1 = 0, k2 = 0;
    if (FALSE == get_next_ifStacktTableKey(&k1, &k2)) {
        return VTSS_RC_ERROR;
    }
    table_entry->ifStackHigherLayer = k1;
    table_entry->ifStackLowerLayer = k2;
    (void) get_ifStackTableByKey(table_entry);

    return VTSS_RC_OK;
}

static int
get_ifStackTableEntry(ifStackTable_entry_t *table_entry, BOOL getnext)
{
    long k1 = table_entry->ifStackHigherLayer, k2 = table_entry->ifStackLowerLayer;

    if ( (FALSE == getnext && FALSE == get_ifStacktTableKey(&k1, &k2)) ||
         (FALSE != getnext  && FALSE == get_next_ifStacktTableKey(&k1, &k2))) {
        return VTSS_RC_ERROR;
    }

    table_entry->ifStackHigherLayer = k1;
    table_entry->ifStackLowerLayer = k2;
    (void) get_ifStackTableByKey(table_entry);

    return VTSS_RC_OK;
}

static int
set_ifStackTableEntry(ifStackTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return VTSS_RC_ERROR;
}

static int
parse_ifStackTable(oid *name,
                   size_t *length,
                   int exact, ifStackTable_entry_t *table_entry)
{
    size_t          op_pos = 9 + 2;
    oid            *op = (oid *) (name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_ifStackTableEntry(table_entry)) {
            return -1;
        }
        return 1;               /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->ifStackHigherLayer = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->ifStackLowerLayer = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        if ( VTSS_RC_OK == get_ifStackTableEntry(table_entry, FALSE) || VTSS_RC_OK == get_ifStackTableEntry(table_entry, TRUE)) {
            return 1;
        } else {
            return -1;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_ifStackTable(oid *name,
                     size_t *length, ifStackTable_entry_t *table_entry)
{
    int             name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->ifStackHigherLayer;
    name[name_pos++] = (oid) table_entry->ifStackLowerLayer;

    *length = name_pos;
    return 0;
}

/*
 * var_ifStackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ifStackTable above.
 */
u_char         *
var_ifStackTable(struct variable *vp,
                 oid *name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod **write_method)
{
    int             rc;
    oid             newname[MAX_OID_LEN];
    size_t          newname_len;
    ifStackTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name,
           (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_ifStackTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) {        /* getfirst */
        if (fillobj_ifStackTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_ifStackTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (vp->magic == IFSTACKSTATUS) {
                    /*
                     * Allow write operation for "RowStatus" or "EntryStatus" syntax that user
                     * can create a new table entry.
                     */
                    *write_method = write_ifStackStatus;
                }
                return NULL;
            }
            if (fillobj_ifStackTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname,
           (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case IFSTACKSTATUS: {
        *write_method = write_ifStackStatus;
        ifStackTable_global_ret.long_ret = table_entry.ifStackStatus;
        *var_len = sizeof(ifStackTable_global_ret.long_ret);
        return (u_char *) & ifStackTable_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifStackTable\n",
                    vp->magic));
    }
    return NULL;
}


#if 0 /* Not supported in E-StaX34 project */
int
write_ifRcvAddressStatus(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifRcvAddressType(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifRcvAddressType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not supported in E-StaX34 project */

int
write_ifLinkUpDownTrapEnable(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    BOOL                     *buf, *old_buf;
    int                      max_size;
    long                     intval;
    int                      if_num;
    iftable_info_t           table_info;
    vtss_isid_t              isid;
    snmp_port_conf_t         port_conf;
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;

    buf      = NULL;
    old_buf  = NULL;
    max_size = sizeof(long);
    intval   = *((long *) var_val);

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifLinkUpDownTrapEnable: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifLinkUpDownTrapEnable: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR,
                     "write to ifLinkUpDownTrapEnable: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        return SNMP_ERR_NOERROR;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        return SNMP_ERR_NOERROR;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        return SNMP_ERR_NOERROR;
    }
    }

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT:
        if (PORT_NO_IS_STACK(table_info.if_id)) {
            if (action == UNDO) {
                return SNMP_ERR_NOERROR;
            } else {
                return SNMP_ERR_NOTWRITABLE;
            }
        }
        buf = &now_linkupdown_trap_enable[table_info.isid - VTSS_ISID_START][table_info.if_id];
        old_buf = &old_linkupdown_trap_enable[table_info.isid - VTSS_ISID_START][table_info.if_id];
    case IFTABLE_IFINDEX_TYPE_LLAG:
    case IFTABLE_IFINDEX_TYPE_GLAG:
        break;
    case IFTABLE_IFINDEX_TYPE_VLAN:
    case IFTABLE_IFINDEX_TYPE_IP:
        if (action == UNDO) {
            return SNMP_ERR_NOERROR;
        } else {
            return SNMP_ERR_NOTWRITABLE;
        }
    default:
        break;
    }

    switch (table_info.type) {
    case IFTABLE_IFINDEX_TYPE_PORT: {
        if (action == ACTION) {
            /*
             * The variable has been stored in 'value' for you to use,
             * * and you have just been asked to do something with it.
             * * Note that anything done here must be reversable in the UNDO case
             */
            /*
             * save to current configuration
             */
            *buf = *((BOOL *) var_val);
            if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
            if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        } else if (action == UNDO) {
            /*
             * Back out any changes made in the ACTION case
             */
            /*
             * restore current configuration form old configuration
             */
            *buf = *old_buf;
            if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
            port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
            if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        } else if (action == COMMIT) {
            /*
             * update old configuration
             */
            *old_buf = *buf;
        }
        break;
    }

    case IFTABLE_IFINDEX_TYPE_LLAG: {
        if ((aggr_mgmt_port_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(table_info.isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        (void)port_iter_init(&pit, NULL, table_info.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        while (port_iter_getnext(&pit)) {
            if (!aggr_members.entry.member[pit.iport]) {
                continue;
            }

            buf = &now_linkupdown_trap_enable[table_info.isid - VTSS_ISID_START][pit.iport];
            old_buf = &old_linkupdown_trap_enable[table_info.isid - VTSS_ISID_START][pit.iport];

            if (action == ACTION) {
                /*
                 * save to current configuration
                 */
                *buf = *((BOOL *) var_val);
                if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                    return SNMP_ERR_RESOURCEUNAVAILABLE;
                }
                port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
                if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                    return SNMP_ERR_RESOURCEUNAVAILABLE;
                }
            } else if (action == UNDO) {
                /*
                 * restore current configuration form old configuration
                 */
                *buf = *old_buf;
                if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                    return SNMP_ERR_RESOURCEUNAVAILABLE;
                }
                port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
                if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                    return SNMP_ERR_RESOURCEUNAVAILABLE;
                }
            } else if (action == COMMIT) {
                /*
                 * update old configuration
                 */
                *old_buf = *buf;
            }
        }
        break;
    }

    case IFTABLE_IFINDEX_TYPE_GLAG: {
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, table_info.if_id, &aggr_members, FALSE) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }

                buf = &now_linkupdown_trap_enable[isid - VTSS_ISID_START][pit.iport];
                old_buf = &old_linkupdown_trap_enable[isid - VTSS_ISID_START][pit.iport];

                if (action == ACTION) {
                    /*
                     * save to current configuration
                     */
                    *buf = *((BOOL *) var_val);
                    if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                        return SNMP_ERR_RESOURCEUNAVAILABLE;
                    }
                    port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
                    if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                        return SNMP_ERR_RESOURCEUNAVAILABLE;
                    }
                } else if (action == UNDO) {
                    /*
                     * restore current configuration form old configuration
                     */
                    *buf = *old_buf;
                    if (snmp_mgmt_snmp_port_conf_get(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                        return SNMP_ERR_RESOURCEUNAVAILABLE;
                    }
                    port_conf.linkupdown_trap_enable = (*buf == 2 ? 0 : 1);
                    if (snmp_mgmt_snmp_port_conf_set(table_info.isid, table_info.if_id, &port_conf) != VTSS_OK) {
                        return SNMP_ERR_RESOURCEUNAVAILABLE;
                    }
                } else if (action == COMMIT) {
                    /*
                     * update old configuration
                     */
                    *old_buf = *buf;
                }
            }
        }
        break;
    }
    default:
        break;
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /* Not supported in E-StaX34 project */
int
write_ifPromiscuousMode(int action,
                        u_char *var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR,
                     "write to ifPromiscuousMode: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifAlias(int action,
              u_char *var_val,
              u_char var_val_type,
              size_t var_val_len,
              u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR, "write to ifAlias: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifAlias: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifAlias: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestId(int action,
               u_char *var_val,
               u_char var_val_type,
               size_t var_val_len,
               u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to ifTestId: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestId: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestId: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestStatus(int action,
                   u_char *var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char *statP, oid *name, size_t name_len)
{
    long           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(long);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR,
                     "write to ifTestStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestType(int action,
                 u_char *var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char *statP, oid *name, size_t name_len)
{
    oid            *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(oid);     /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OBJECT_ID) {
            snmp_log(LOG_ERR,
                     "write to ifTestType: not ASN_OBJECT_ID\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((oid *) var_val);  /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifTestOwner(int action,
                  u_char *var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char *statP, oid *name, size_t name_len)
{
    char           *buf, *old_buf;      /* FIXME */
    int             max_size;
    long            intval;

    buf = NULL;                 /* FIXME */
    old_buf = NULL;             /* FIXME */
    max_size = sizeof(char);    /* FIXME */
    intval = *((long *) var_val);       /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            snmp_log(LOG_ERR,
                     "write to ifTestOwner: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to ifTestOwner: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {   /* FIXME */
            snmp_log(LOG_ERR, "write to ifTestOwner: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         * Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        *buf = *((char *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration form old configuration
         */
        *buf = *old_buf;    /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        *old_buf = *buf;    /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* Not supported in E-StaX34 project */

int
write_ifStackStatus(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long            set_value = var_val ? *((long *) var_val) : 0;
    ifStackTable_entry_t table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4 && set_value != 5 && set_value != 6) {
            (void) snmp_log(LOG_ERR,
                            "write to ifStackStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_ifStackTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        /*
         * Return error code when the entry isn't existing
         * except for "createAndGo(4)" or "createAndWait(5)" status
         */
        if (set_value != SNMP_ROW_CREATEANDGO &&
            set_value != SNMP_ROW_CREATEANDWAIT &&
            get_ifStackTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.ifStackStatus = set_value;
        if (set_ifStackTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC2863_SUPPORTED_IFMIB */

