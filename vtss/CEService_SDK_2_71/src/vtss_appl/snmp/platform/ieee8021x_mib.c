/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h> /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h> /* utility function declarations */
#include "ieee8021x_mib.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"
#include "sysutil_api.h"

/* +++ Start (Internal implementation declarations) */
#include "dot1x_api.h"
#include "ifIndex_api.h"
#include "rfc1213_mib2.h"
#include "mibContextTable.h"  //mibContextTable_register

dot1x_glbl_cfg_t old_global_cfg, current_global_cfg;
dot1x_port_cfg_t old_port_conf, current_port_conf;


//BOOL get_dot1xPaePort_entry(int table_index, ifXTable_entry_t *table_entry_p)
//{
//    vtss_isid_t              isid;
//    vtss_port_no_t           port_idx;
//    iftable_info_t           table_info;
//
//    if (!IFINDEX_IS_LPOAG(table_index) || get_ifTableIndex_info(table_index, &table_info) == FALSE) {
//        return FALSE;
//    }
//
//    memset(table_entry_p, 0x0, sizeof(ifXTable_entry_t));
//
//    table_entry_p->ifIndex = table_index;
//
//
//
//    return TRUE;
//}

/* --- End (Internal implementation declarations) */

/*
 * ieee8021paeMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ieee8021paeMIB_variables_oid[] = {1, 0, 8802, 1, 1, 1, 1};

/*
 * variable4 ieee8021paeMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the ieee8021paeMIB mib section
 */

struct variable4 ieee8021paeMIB_variables[] = {
    /*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define DOT1XPAESYSTEMAUTHCONTROL       1
    {DOT1XPAESYSTEMAUTHCONTROL,  ASN_INTEGER,  RWRITE,  var_ieee8021paeMIB, 2,  {1, 1}},

//dot1xPaePortTable index is not-accessible OID
//#define DOT1XPAEPORTNUMBER      2
//    {DOT1XPAEPORTNUMBER,  ASN_INTEGER,  RONLY,   var_dot1xPaePortTable, 4,  {1, 2, 1, 1}},
#define DOT1XPAEPORTPROTOCOLVERSION     3
    {DOT1XPAEPORTPROTOCOLVERSION,  ASN_UNSIGNED,  RONLY,   var_dot1xPaePortTable, 4,  {1, 2, 1, 2}},
#define DOT1XPAEPORTCAPABILITIES        4
    {DOT1XPAEPORTCAPABILITIES,  ASN_OCTET_STR,  RONLY,   var_dot1xPaePortTable, 4,  {1, 2, 1, 3}},
#define DOT1XPAEPORTINITIALIZE      5
    {DOT1XPAEPORTINITIALIZE,  ASN_INTEGER,  RWRITE,  var_dot1xPaePortTable, 4,  {1, 2, 1, 4}},
#define DOT1XPAEPORTREAUTHENTICATE      6
    {DOT1XPAEPORTREAUTHENTICATE,  ASN_INTEGER,  RWRITE,  var_dot1xPaePortTable, 4,  {1, 2, 1, 5}},
//#define DOT1XAUTHPAESTATE     7
//{DOT1XAUTHPAESTATE,  ASN_INTEGER,  RONLY,   var_dot1xAuthConfigTable, 4,  {2, 1, 1, 1}},
//#define DOT1XAUTHBACKENDAUTHSTATE     8
//{DOT1XAUTHBACKENDAUTHSTATE,  ASN_INTEGER,  RONLY,   var_dot1xAuthConfigTable, 4,  {2, 1, 1, 2}},
#define DOT1XAUTHADMINCONTROLLEDDIRECTIONS      9
    {DOT1XAUTHADMINCONTROLLEDDIRECTIONS,  ASN_INTEGER,  RONLY,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 3}},
#define DOT1XAUTHOPERCONTROLLEDDIRECTIONS       10
    {DOT1XAUTHOPERCONTROLLEDDIRECTIONS,  ASN_INTEGER,  RONLY,   var_dot1xAuthConfigTable, 4,  {2, 1, 1, 4}},
#define DOT1XAUTHAUTHCONTROLLEDPORTSTATUS       11
    {DOT1XAUTHAUTHCONTROLLEDPORTSTATUS,  ASN_INTEGER,  RONLY,   var_dot1xAuthConfigTable, 4,  {2, 1, 1, 5}},
#define DOT1XAUTHAUTHCONTROLLEDPORTCONTROL      12
    {DOT1XAUTHAUTHCONTROLLEDPORTCONTROL,  ASN_INTEGER,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 6}},
#define DOT1XAUTHQUIETPERIOD        13
    {DOT1XAUTHQUIETPERIOD,  ASN_UNSIGNED,  RONLY,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 7}},
//#define DOT1XAUTHTXPERIOD     14
//{DOT1XAUTHTXPERIOD,  ASN_UNSIGNED,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 8}},
//#define DOT1XAUTHSUPPTIMEOUT      15
//{DOT1XAUTHSUPPTIMEOUT,  ASN_UNSIGNED,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 9}},
#define DOT1XAUTHSERVERTIMEOUT      16
    {DOT1XAUTHSERVERTIMEOUT,  ASN_UNSIGNED,  RONLY,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 10}},
//#define DOT1XAUTHMAXREQ       17
//{DOT1XAUTHMAXREQ,  ASN_UNSIGNED,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 11}},
#define DOT1XAUTHREAUTHPERIOD       18
    {DOT1XAUTHREAUTHPERIOD,  ASN_UNSIGNED,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 12}},
#define DOT1XAUTHREAUTHENABLED      19
    {DOT1XAUTHREAUTHENABLED,  ASN_INTEGER,  RWRITE,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 13}},
#define DOT1XAUTHKEYTXENABLED       20
    {DOT1XAUTHKEYTXENABLED,  ASN_INTEGER,  RONLY,  var_dot1xAuthConfigTable, 4,  {2, 1, 1, 14}},
#define DOT1XAUTHEAPOLFRAMESRX      21
    {DOT1XAUTHEAPOLFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 1}},
#define DOT1XAUTHEAPOLFRAMESTX      22
    {DOT1XAUTHEAPOLFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 2}},
#define DOT1XAUTHEAPOLSTARTFRAMESRX     23
    {DOT1XAUTHEAPOLSTARTFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 3}},
#define DOT1XAUTHEAPOLLOGOFFFRAMESRX        24
    {DOT1XAUTHEAPOLLOGOFFFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 4}},
#define DOT1XAUTHEAPOLRESPIDFRAMESRX        25
    {DOT1XAUTHEAPOLRESPIDFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 5}},
#define DOT1XAUTHEAPOLRESPFRAMESRX      26
    {DOT1XAUTHEAPOLRESPFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 6}},
#define DOT1XAUTHEAPOLREQIDFRAMESTX     27
    {DOT1XAUTHEAPOLREQIDFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 7}},
#define DOT1XAUTHEAPOLREQFRAMESTX       28
    {DOT1XAUTHEAPOLREQFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 8}},
#define DOT1XAUTHINVALIDEAPOLFRAMESRX       29
    {DOT1XAUTHINVALIDEAPOLFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 9}},
#define DOT1XAUTHEAPLENGTHERRORFRAMESRX     30
    {DOT1XAUTHEAPLENGTHERRORFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 10}},
#define DOT1XAUTHLASTEAPOLFRAMEVERSION      31
    {DOT1XAUTHLASTEAPOLFRAMEVERSION,  ASN_UNSIGNED,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 11}},
#define DOT1XAUTHLASTEAPOLFRAMESOURCE       32
    {DOT1XAUTHLASTEAPOLFRAMESOURCE,  ASN_OCTET_STR,  RONLY,   var_dot1xAuthStatsTable, 4,  {2, 2, 1, 12}},
// Depricated:
//#define DOT1XAUTHENTERSCONNECTING     33
//{DOT1XAUTHENTERSCONNECTING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 1}},
//#define DOT1XAUTHEAPLOGOFFSWHILECONNECTING        34
//{DOT1XAUTHEAPLOGOFFSWHILECONNECTING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 2}},
//#define DOT1XAUTHENTERSAUTHENTICATING     35
//{DOT1XAUTHENTERSAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 3}},
//#define DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING       36
//{DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 4}},
//#define DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING      37
//{DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 5}},
//#define DOT1XAUTHAUTHFAILWHILEAUTHENTICATING      38
//{DOT1XAUTHAUTHFAILWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 6}},
//// #define DOT1X-AUTH-AUTH-REAUTHS-WHILE-AUTHENTICATING       39
//// {DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 7}},
//#define DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING     40
//{DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 8}},
//#define DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING     41
//{DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 9}},
//#define DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED        42
//{DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 10}},
//#define DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED      43
//{DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 11}},
//#define DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED      44
//{DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 12}},
//#define DOT1XAUTHBACKENDRESPONSES     45
//{DOT1XAUTHBACKENDRESPONSES,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 13}},
//#define DOT1XAUTHBACKENDACCESSCHALLENGES      46
//{DOT1XAUTHBACKENDACCESSCHALLENGES,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 14}},
//#define DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT     47
//{DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 15}},
//// #define DOT1XAUTHBACKENDNONNAKRESPONSESFROMSUPPLICANT      48
//// {DOT1XAUTHBACKENDNONNAKRESPONSESFROMSUPPLICANT,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 16}},
//#define DOT1XAUTHBACKENDAUTHSUCCESSES     49
//{DOT1XAUTHBACKENDAUTHSUCCESSES,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 17}},
//#define DOT1XAUTHBACKENDAUTHFAILS     50
//{DOT1XAUTHBACKENDAUTHFAILS,  ASN_COUNTER,  RONLY,   var_dot1xAuthDiagTable, 4,  {2, 3, 1, 18}},
//#define DOT1XAUTHSESSIONOCTETSRX      51
//{DOT1XAUTHSESSIONOCTETSRX,  ASN_COUNTER64,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 1}},
//#define DOT1XAUTHSESSIONOCTETSTX      52
//{DOT1XAUTHSESSIONOCTETSTX,  ASN_COUNTER64,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 2}},
//#define DOT1XAUTHSESSIONFRAMESRX      53
//{DOT1XAUTHSESSIONFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 3}},
//#define DOT1XAUTHSESSIONFRAMESTX      54
//{DOT1XAUTHSESSIONFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 4}},
//#define DOT1XAUTHSESSIONID        55
//{DOT1XAUTHSESSIONID,  ASN_OCTET_STR,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 5}},
//#define DOT1XAUTHSESSIONAUTHENTICMETHOD       56
//{DOT1XAUTHSESSIONAUTHENTICMETHOD,  ASN_INTEGER,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 6}},
//#define DOT1XAUTHSESSIONTIME      57
//{DOT1XAUTHSESSIONTIME,  ASN_TIMETICKS,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 7}},
//#define DOT1XAUTHSESSIONTERMINATECAUSE        58
//{DOT1XAUTHSESSIONTERMINATECAUSE,  ASN_INTEGER,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2, 4, 1, 8}},
//#define DOT1XAUTHSESSIONUSERNAME      59
//{DOT1XAUTHSESSIONUSERNAME,  ASN_OCTET_STR,  RONLY,   var_dot1xAuthSessionStatsTable, 4,  {2,4, 1, 9}},
//#define DOT1XSUPPPAESTATE     60
//{DOT1XSUPPPAESTATE,  ASN_INTEGER,  RONLY,   var_dot1xSuppConfigTable, 4,  {3,1, 1, 1}},
//#define DOT1XSUPPHELDPERIOD       61
//{DOT1XSUPPHELDPERIOD,  ASN_UNSIGNED,  RWRITE,  var_dot1xSuppConfigTable, 4,  {3,1, 1, 2}},
//#define DOT1XSUPPAUTHPERIOD       62
//{DOT1XSUPPAUTHPERIOD,  ASN_UNSIGNED,  RWRITE,  var_dot1xSuppConfigTable, 4,  {3,1, 1, 3}},
//#define DOT1XSUPPSTARTPERIOD      63
//{DOT1XSUPPSTARTPERIOD,  ASN_UNSIGNED,  RWRITE,  var_dot1xSuppConfigTable, 4,  {3,1, 1, 4}},
//#define DOT1XSUPPMAXSTART     64
//{DOT1XSUPPMAXSTART,  ASN_UNSIGNED,  RWRITE,  var_dot1xSuppConfigTable, 4,  {43,1, 1, 5}},
//#define DOT1XSUPPCONTROLLEDPORTSTATUS     65
//{DOT1XSUPPCONTROLLEDPORTSTATUS,  ASN_INTEGER,  RONLY,   var_dot1xSuppConfigTable, 4,  {3,1, 1, 6}},
//#define DOT1XSUPPACCESSCTRLWITHAUTH       66
//{DOT1XSUPPACCESSCTRLWITHAUTH,  ASN_INTEGER,  RWRITE,  var_dot1xSuppConfigTable, 4,  {3,1, 1, 7}},
//#define DOT1XSUPPBACKENDSTATE     67
//{DOT1XSUPPBACKENDSTATE,  ASN_INTEGER,  RONLY,   var_dot1xSuppConfigTable, 4,  {3,1, 1, 8}},
//#define DOT1XSUPPEAPOLFRAMESRX        68
//{DOT1XSUPPEAPOLFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 1}},
//#define DOT1XSUPPEAPOLFRAMESTX        69
//{DOT1XSUPPEAPOLFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 2}},
//#define DOT1XSUPPEAPOLSTARTFRAMESTX       70
//{DOT1XSUPPEAPOLSTARTFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 3}},
//#define DOT1XSUPPEAPOLLOGOFFFRAMESTX      71
//{DOT1XSUPPEAPOLLOGOFFFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 4}},
//#define DOT1XSUPPEAPOLRESPIDFRAMESTX      72
//{DOT1XSUPPEAPOLRESPIDFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 5}},
//#define DOT1XSUPPEAPOLRESPFRAMESTX        73
//{DOT1XSUPPEAPOLRESPFRAMESTX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 6}},
//#define DOT1XSUPPEAPOLREQIDFRAMESRX       74
//{DOT1XSUPPEAPOLREQIDFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 7}},
//#define DOT1XSUPPEAPOLREQFRAMESRX     75
//{DOT1XSUPPEAPOLREQFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 8}},
//#define DOT1XSUPPINVALIDEAPOLFRAMESRX     76
//{DOT1XSUPPINVALIDEAPOLFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 9}},
//#define DOT1XSUPPEAPLENGTHERRORFRAMESRX       77
//{DOT1XSUPPEAPLENGTHERRORFRAMESRX,  ASN_COUNTER,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 10}},
//#define DOT1XSUPPLASTEAPOLFRAMEVERSION        78
//{DOT1XSUPPLASTEAPOLFRAMEVERSION,  ASN_UNSIGNED,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 11}},
//#define DOT1XSUPPLASTEAPOLFRAMESOURCE     79
//{DOT1XSUPPLASTEAPOLFRAMESOURCE,  ASN_OCTET_STR,  RONLY,   var_dot1xSuppStatsTable, 4,  {3,2, 1, 12}},
};
/* (L = length of the oidsuffix) */

/* FIXME: template declaration for compiler completed */
//static long VAR = 0, VALUE = 0;

/* Initializes the ieee8021paeMIB module */
void
init_ieee8021paeMIB(void)
{
    // Register mibContextTable
    mibContextTable_register(ieee8021paeMIB_variables_oid,
                             sizeof(ieee8021paeMIB_variables_oid) / sizeof(oid),
                             "IEEE8021-PAE-MIB : ieee8021paeMIB");

    DEBUGMSGTL(("ieee8021paeMIB", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ieee8021paeMIB", ieee8021paeMIB_variables, variable4,
                 ieee8021paeMIB_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_ieee8021paeMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_ieee8021paeMIB(struct variable *vp,
                   oid     *name,
                   size_t  *length,
                   int     exact,
                   size_t  *var_len,
                   WriteMethod **write_method)
{
    static u_long ulong_ret;

    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }


    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
    case DOT1XPAESYSTEMAUTHCONTROL: {
        /* Enable / disable global dot1x support */

        *write_method = write_dot1xPaeSystemAuthControl;

        if (dot1x_mgmt_glbl_cfg_get(&current_global_cfg) != VTSS_OK) {
            return NULL;
        }

        if (current_global_cfg.enabled) {
            ulong_ret = 1;    /* Enabled */
        } else {
            ulong_ret = 2;    /* Disabled */
        }

        return (u_char *) &ulong_ret;

    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ieee8021paeMIB\n", vp->magic));
    }
    return NULL;
}

/*
 * var_dot1xPaePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xPaePortTable(struct variable *vp,
                      oid     *name,
                      size_t  *length,
                      int     exact,
                      size_t  *var_len,
                      WriteMethod **write_method)
{
    static u_long ulong_ret;

    int table_size;
    int table_index;
    int idx_num;
    iftable_info_t table_info;

    table_size = IFTABLE_IFINDEX_END;
    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size) == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];

    table_info.ifIndex = exact ? idx_num : idx_num - 1;

    if (exact && FALSE == ifIndex_get(&table_info)) {
        return NULL;
    }

    if (!exact && FALSE == ifIndex_get_next(&table_info)) {
        return NULL;
    }

    table_index = table_info.ifIndex;

    /* Save this one as the "next one", if "table_index" is not sequence */
    name[(*length) - 1] = table_index; /* FIXME */

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
#if 0 //dot1xPaePortTable index is not-accessible OID
    case DOT1XPAEPORTNUMBER: {
        ulong_ret = table_index;
        return (u_char *) &ulong_ret;
    }
#endif
    case DOT1XPAEPORTPROTOCOLVERSION: {

        ulong_ret = 0x2;  /* RBN said so  */
        return (u_char *) &ulong_ret;

    }
    case DOT1XPAEPORTCAPABILITIES: {
        static u_char string;

        /* Authenticator capable : position 0   */
        /* Supplicant capable    : position 1   */

        /* Webstax only supports 'Authenticator',
           which is position 0 (128) which is (for some reason) the MSB */
        string = 1 << 7;
        *var_len = 1;
        return (u_char *) &string;
    }
    case DOT1XPAEPORTINITIALIZE: {
        /* Re-initilize port - return FALSE */
        *write_method = write_dot1xPaePortInitialize;

        ulong_ret = 2  /* FALSE */;
        return (u_char *) &ulong_ret;
    }
    case DOT1XPAEPORTREAUTHENTICATE: {
        /* Re-authenticate port - return FALSE */
        *write_method = write_dot1xPaePortReauthenticate;

        ulong_ret = 2  /* FALSE */;
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xPaePortTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xAuthConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xAuthConfigTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{

    static u_long ulong_ret;

    int                table_size;
    int                table_index;
    int                idx_num;
    iftable_info_t     table_info;

    *write_method = NULL;
    table_size = IFTABLE_IFINDEX_END;

    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size) == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_info.ifIndex = exact ? idx_num : idx_num - 1;

    if (exact && FALSE == ifIndex_get(&table_info)) {
        return NULL;
    }

    if (!exact && FALSE == ifIndex_get_next(&table_info)) {
        return NULL;
    }

    if (table_info.type != IFTABLE_IFINDEX_TYPE_LLAG && table_info.type != IFTABLE_IFINDEX_TYPE_PORT) {
        return NULL;
    }
    table_index = table_info.ifIndex;

    /* Save this one as the "next one", if "table_index" is not sequence */
    name[(*length) - 1] = table_index; /* FIXME */


    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return NULL;
    }


    switch (vp->magic) {

    case DOT1XAUTHADMINCONTROLLEDDIRECTIONS: {
        /* Note, not possible to write to this object - returning SNMP_ERR_NOTWRITABLE */
        //*write_method = write_dot1xAuthAdminControlledDirections;
        /*  both = 0 */
        /*  in =  1  */
        ulong_ret = 0;
        return (u_char *) &ulong_ret;

    }
    case DOT1XAUTHOPERCONTROLLEDDIRECTIONS: {
        /*  both = 0 */
        /*  in =  1  */
        ulong_ret = 0;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHAUTHCONTROLLEDPORTSTATUS: {
        dot1x_switch_status_t switch_status;
        if (dot1x_mgmt_switch_status_get(table_info.isid, &switch_status) != VTSS_OK) {
            return NULL;
        }

        /* Authorized = return 1   */
        /* Unauthorized = return 2 */

        if (switch_status.status[table_info.if_id] == NAS_PORT_STATUS_AUTHORIZED) {
            ulong_ret = 1;
        } else {
            ulong_ret = 2;
        }
        return (u_char *) &ulong_ret;

    }
    case DOT1XAUTHAUTHCONTROLLEDPORTCONTROL: {
        dot1x_switch_cfg_t  switch_conf;
        *write_method = write_dot1xAuthAuthControlledPortControl;

        if (dot1x_mgmt_switch_cfg_get(table_info.isid, &switch_conf) != VTSS_OK) {
            return NULL;
        }

        /* NAS_PORT_CONTROL_FORCE_AUTHORIZED   = return 3 */
        /* NAS_PORT_CONTROL_FORCE_UNAUTHORIZED = return 1 */
        /* NAS_PORT_CONTROL_AUTO               = return 2 */
        /* Others (MAC-based) = return 0 */

        if (switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START].admin_state == NAS_PORT_CONTROL_FORCE_AUTHORIZED) {
            ulong_ret = 3;
        } else if (switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START].admin_state == NAS_PORT_CONTROL_FORCE_UNAUTHORIZED) {
            ulong_ret = 1;
        } else if (switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START].admin_state == NAS_PORT_CONTROL_AUTO) {
            ulong_ret = 2;
        } else {
            ulong_ret = 0;
        }
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHQUIETPERIOD: {
        /* Note, not possible to write to this object - returning SNMP_ERR_NOTWRITABLE */
        //*write_method = write_dot1xAuthQuietPeriod;
        ulong_ret = 60; /* Rene says so */
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHSERVERTIMEOUT: {
        /* Note, not possible to write to this object - returning SNMP_ERR_NOTWRITABLE */
        //*write_method = write_dot1xAuthServerTimeout;
        ulong_ret = 40; /* Rene says so */
        return (u_char *) &ulong_ret;

    }
    case DOT1XAUTHREAUTHPERIOD: {
        *write_method = write_dot1xAuthReAuthPeriod;

        if (dot1x_mgmt_glbl_cfg_get(&current_global_cfg) != VTSS_OK) {
            return NULL;
        }

        ulong_ret = current_global_cfg.reauth_period_secs;
        return (u_char *) &ulong_ret;

    }
    case DOT1XAUTHREAUTHENABLED: {
        *write_method = write_dot1xAuthReAuthEnabled;

        if (dot1x_mgmt_glbl_cfg_get(&current_global_cfg) != VTSS_OK) {
            return NULL;
        }

        // The value of TruthValue is 1(true) or 2(false).
        if (current_global_cfg.reauth_enabled == TRUE) {
            ulong_ret = 1;
        } else if (current_global_cfg.reauth_enabled == FALSE) {
            ulong_ret = 2;
        } else {
            return NULL;
        }
        return (u_char *) &ulong_ret;


    }
    case DOT1XAUTHKEYTXENABLED: {
        /* Note, not possible to write to this object - returning SNMP_ERR_NOTWRITABLE */
        //*write_method = write_dot1xAuthKeyTxEnabled;
        ulong_ret = 2; /* FALSE */
        return (u_char *) &ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xAuthConfigTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xAuthStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xAuthStatsTable(struct variable *vp,
                        oid     *name,
                        size_t  *length,
                        int     exact,
                        size_t  *var_len,
                        WriteMethod **write_method)
{
    int                table_size;
    int                table_index;
    int                idx_num;
    iftable_info_t     table_info;
    dot1x_statistics_t stat;
    static u_long      ulong_ret;

    table_size = IFTABLE_IFINDEX_END;

    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size) == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_info.ifIndex = exact ? idx_num : idx_num - 1;

    if (exact && FALSE == ifIndex_get(&table_info)) {
        return NULL;
    }

    if (!exact && FALSE == ifIndex_get_next(&table_info)) {
        return NULL;
    }
    if (table_info.type != IFTABLE_IFINDEX_TYPE_LLAG && table_info.type != IFTABLE_IFINDEX_TYPE_PORT) {
        return NULL;
    }
    table_index = table_info.ifIndex;

    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return NULL;
    }

    if (dot1x_mgmt_statistics_get(table_info.isid, table_info.if_id, NULL, &stat) != VTSS_OK) {
        return NULL;
    }

    /* Save this one as the "next one", if "table_index" is not sequence */
    name[(*length) - 1] = table_index;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
    case DOT1XAUTHEAPOLFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLFRAMESTX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolFramesTx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLSTARTFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolStartFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLLOGOFFFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolLogoffFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLRESPIDFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolRespIdFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLRESPFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolRespFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLREQIDFRAMESTX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolReqIdFramesTx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPOLREQFRAMESTX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapolReqFramesTx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHINVALIDEAPOLFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthInvalidEapolFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHEAPLENGTHERRORFRAMESRX: {
        ulong_ret = stat.eapol_counters.dot1xAuthEapLengthErrorFramesRx;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHLASTEAPOLFRAMEVERSION: {
        ulong_ret = stat.eapol_counters.dot1xAuthLastEapolFrameVersion;
        return (u_char *) &ulong_ret;
    }
    case DOT1XAUTHLASTEAPOLFRAMESOURCE: {
        nas_client_info_t last_supplicant_info;
        static u_char string[ETHER_ADDR_LEN];

        if (!dot1x_mgmt_port_last_supplicant_info_get(table_info.isid, table_info.if_id, &last_supplicant_info) == VTSS_OK) {
            return NULL;
        }

        bcopy(last_supplicant_info.vid_mac.mac.addr, string, ETHER_ADDR_LEN);
        *var_len = ETHER_ADDR_LEN;

        return (u_char *) string;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xAuthStatsTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xAuthDiagTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xAuthDiagTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                table_size;
    int                table_index;
    int                idx_num;
    iftable_info_t     table_info;
    dot1x_statistics_t stat;
//    static u_long ulong_ret;

    table_size = IFTABLE_IFINDEX_END;

    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size) == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];

    table_index = get_available_ifTableIndex(idx_num);

    table_info.ifIndex = exact ? idx_num : idx_num - 1;

    if (exact && FALSE == ifIndex_get(&table_info)) {
        return NULL;
    }

    if (!exact && FALSE == ifIndex_get_next(&table_info)) {
        return NULL;
    }

    if (table_info.type != IFTABLE_IFINDEX_TYPE_LLAG && table_info.type != IFTABLE_IFINDEX_TYPE_PORT) {
        return NULL;
    }
    if (get_ifTableIndex_info(table_index, &table_info) == FALSE) {
        return NULL;
    }

    if (dot1x_mgmt_statistics_get(table_info.isid, table_info.if_id, NULL, &stat) != VTSS_OK) {
        return NULL;
    }

    /* Save this one as the "next one", if "table_index" is not sequence */
    name[(*length) - 1] = table_index;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
//    case DOT1XAUTHENTERSCONNECTING:
//    {
//        ulong_ret = stat.authEntersConnecting;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHEAPLOGOFFSWHILECONNECTING:
//    {
//        ulong_ret = stat.authEapLogoffsWhileConnecting;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHENTERSAUTHENTICATING:
//    {
//        ulong_ret = stat.authEntersAuthenticating;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING:
//    {
//        ulong_ret = stat.authAuthSuccessesWhileAuthenticating;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING:
//    {
//        ulong_ret = stat.authAuthTimeoutsWhileAuthenticating;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHFAILWHILEAUTHENTICATING:
//    {
//        ulong_ret = stat.authAuthFailWhileAuthenticating;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED:
//    {
//        ulong_ret = stat.authAuthReauthsWhileAuthenticated;
//        return (u_char*) &ulong_ret;
//
//    }
//    case DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING:
//    {
//        ulong_ret = stat.authAuthEapStartsWhileAuthenticating;
//        return (u_char*) &ulong_ret;
//
//    }
//    case DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING:
//    {
//        ulong_ret = stat.authAuthEapLogoffWhileAuthenticating;;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED:
//    {
//        ulong_ret = stat.authAuthEapStartsWhileAuthenticated;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED:
//    {
//        ulong_ret = stat.authAuthEapLogoffWhileAuthenticated;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHBACKENDRESPONSES:
//    {
//        ulong_ret = stat.backendResponses;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHBACKENDACCESSCHALLENGES:
//    {
//        ulong_ret = stat.backendAccessChallenges;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT:
//    {
//        ulong_ret = stat.backendOtherRequestsToSupplicant;
//        return (u_char*) &ulong_ret;
//    }
//
//    case DOT1XAUTHBACKENDAUTHSUCCESSES:
//    {
//        ulong_ret = stat.backendAuthSuccesses;
//        return (u_char*) &ulong_ret;
//    }
//    case DOT1XAUTHBACKENDAUTHFAILS:
//    {
//        ulong_ret = stat.backendAuthFails;
//        return (u_char*) &ulong_ret;
//    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xAuthDiagTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xAuthSessionStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xAuthSessionStatsTable(struct variable *vp,
                               oid     *name,
                               size_t  *length,
                               int     exact,
                               size_t  *var_len,
                               WriteMethod **write_method)
{
    /* variables we may use later
    static long long_ret;
    static u_long ulong_ret;
    static u_char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64; */

    int table_size;
    int idx_num;
    //dot1xAuthSessionStatsTable_entry_t table_entry; /* FIXME */

    table_size = 1; /* FIXME */

    /*
       * This assumes that the table is a 'simple' table.
       *    See the implementation documentation for the meaning of this.
       *    You will need to provide the correct value for the TABLE_SIZE parameter
       *
       * If this table does not meet the requirements for a simple table,
       *    you will need to provide the replacement code yourself.
       *    Mib2c is not smart enough to write this for you.
       *    Again, see the implementation documentation for what is required.
       */
    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1]; /* FIXME */
    //table_index = get_available_dot1xAuthSessionStatsTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_dot1xAuthSessionStatsTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /* Save this one as the "next one", if "table_index" is not sequence */
    //name[(*length) - 1] = table_index; /* FIXME */

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
//    case DOT1XAUTHSESSIONOCTETSRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONOCTETSTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONID:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONAUTHENTICMETHOD:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONTIME:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONTERMINATECAUSE:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XAUTHSESSIONUSERNAME:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xAuthSessionStatsTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xSuppConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xSuppConfigTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    /* variables we may use later
    static long long_ret;
    static u_long ulong_ret;
    static u_char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64; */

    int table_size;
    int idx_num;
    //dot1xSuppConfigTable_entry_t table_entry; /* FIXME */

    table_size = 1; /* FIXME */

    /*
       * This assumes that the table is a 'simple' table.
       *    See the implementation documentation for the meaning of this.
       *    You will need to provide the correct value for the TABLE_SIZE parameter
       *
       * If this table does not meet the requirements for a simple table,
       *    you will need to provide the replacement code yourself.
       *    Mib2c is not smart enough to write this for you.
       *    Again, see the implementation documentation for what is required.
       */
    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1]; /* FIXME */
    //table_index = get_available_dot1xSuppConfigTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_dot1xSuppConfigTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /* Save this one as the "next one", if "table_index" is not sequence */
    //name[(*length) - 1] = table_index; /* FIXME */

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
//    case DOT1XSUPPPAESTATE:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPHELDPERIOD:
//    {
//        *write_method = write_dot1xSuppHeldPeriod;
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPAUTHPERIOD:
//    {
//        *write_method = write_dot1xSuppAuthPeriod;
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPSTARTPERIOD:
//    {
//        *write_method = write_dot1xSuppStartPeriod;
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPMAXSTART:
//    {
//        *write_method = write_dot1xSuppMaxStart;
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPCONTROLLEDPORTSTATUS:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPACCESSCTRLWITHAUTH:
//    {
//        *write_method = write_dot1xSuppAccessCtrlWithAuth;
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPBACKENDSTATE:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xSuppConfigTable\n", vp->magic));
    }
    return NULL;
}
/*
 * var_dot1xSuppStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee8021paeMIB above.
 */
u_char *
var_dot1xSuppStatsTable(struct variable *vp,
                        oid     *name,
                        size_t  *length,
                        int     exact,
                        size_t  *var_len,
                        WriteMethod **write_method)
{
    /* variables we may use later
    static long long_ret;
    static u_long ulong_ret;
    static u_char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64; */

    int table_size;
    int idx_num;
    //dot1xSuppStatsTable_entry_t table_entry; /* FIXME */

    table_size = 1; /* FIXME */

    /*
       * This assumes that the table is a 'simple' table.
       *    See the implementation documentation for the meaning of this.
       *    You will need to provide the correct value for the TABLE_SIZE parameter
       *
       * If this table does not meet the requirements for a simple table,
       *    you will need to provide the replacement code yourself.
       *    Mib2c is not smart enough to write this for you.
       *    Again, see the implementation documentation for what is required.
       */
    if (header_simple_table(vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1]; /* FIXME */
    //table_index = get_available_dot1xSuppStatsTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_dot1xSuppStatsTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /* Save this one as the "next one", if "table_index" is not sequence */
    //name[(*length) - 1] = table_index; /* FIXME */

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic) {
//    case DOT1XSUPPEAPOLFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLSTARTFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLLOGOFFFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLRESPIDFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLRESPFRAMESTX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLREQIDFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPOLREQFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPINVALIDEAPOLFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPEAPLENGTHERRORFRAMESRX:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPLASTEAPOLFRAMEVERSION:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
//    case DOT1XSUPPLASTEAPOLFRAMESOURCE:
//    {
//        VAR = VALUE;  /* FIXME */
//        return (u_char*) &VAR; /* FIXME */
//    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1xSuppStatsTable\n", vp->magic));
    }
    return NULL;
}

int
write_dot1xPaeSystemAuthControl(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xPaeSystemAuthControl: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xPaeSystemAuthControl: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xPaeSystemAuthControl: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */

        if (dot1x_mgmt_glbl_cfg_get(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        memcpy(&current_global_cfg, &old_global_cfg, sizeof(old_global_cfg));

        /* If enable */
        if (*var_val == 1) {
            if (!current_global_cfg.enabled) {
                current_global_cfg.enabled = 1;
            } else {
                break;
            }
            /* else if disable */
        } else if (*var_val == 2) {
            if (current_global_cfg.enabled) {
                current_global_cfg.enabled = 0;
            } else {
                break;
            }
        } else {
            return SNMP_ERR_BADVALUE;
        }

        if (dot1x_mgmt_glbl_cfg_set(&current_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        //*buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */

        if (dot1x_mgmt_glbl_cfg_set(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        memcpy(&old_global_cfg, &current_global_cfg, sizeof(old_global_cfg));
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xPaePortInitialize(int      action,
                             u_char   *var_val,
                             u_char   var_val_type,
                             size_t   var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t   name_len)
{
    int                      max_size;
    long                     intval;
    iftable_info_t           table_info;
    int                      if_num;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }


    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        if (*var_val == TRUE) {
            if (dot1x_mgmt_reauth(table_info.isid, table_info.if_id, 0) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        }
        break;
    }
    case UNDO: {
        /* Nothing to UNDO */

        break;
    }
    case COMMIT: {

        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xPaePortReauthenticate(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    int                      max_size;
    long                     intval;
    iftable_info_t           table_info;
    int                      if_num;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xPaePortInitialize: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        if (*var_val == TRUE) {
            if (dot1x_mgmt_reauth(table_info.isid, table_info.if_id, 1) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        }

        break;
    }
    case UNDO: {
        /* Nothing to UNDO */

        break;
    }
    case COMMIT: {

        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /* Peter/2013/6/12, don't compile unused APIs. */
int
write_dot1xAuthAdminControlledDirections(int      action,
                                         u_char   *var_val,
                                         u_char   var_val_type,
                                         size_t   var_val_len,
                                         u_char   *statP,
                                         oid      *name,
                                         size_t   name_len)
{
    long *buf, *old_buf;
    int max_size;
    long intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xAuthAdminControlledDirections: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthAdminControlledDirections: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 0 && intval != 1) {
            snmp_log(LOG_ERR, "write to dot1xAuthAdminControlledDirections: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        return SNMP_ERR_NOTWRITABLE;
    }
    case UNDO: {
        break;
    }
    case COMMIT: {
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot1xAuthAuthControlledPortControl(int      action,
                                         u_char   *var_val,
                                         u_char   var_val_type,
                                         size_t   var_val_len,
                                         u_char   *statP,
                                         oid      *name,
                                         size_t   name_len)
{
    int                      max_size;
    long                     intval;
    iftable_info_t           table_info;
    int                      if_num;

    max_size = sizeof(long);
    intval = *((long *) var_val);
    dot1x_switch_cfg_t  switch_conf;

    if_num = name[name_len - 1];

    if (get_ifTableIndex_info(if_num, &table_info) == FALSE) {
        return SNMP_ERR_RESOURCEUNAVAILABLE;
    }

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xAuthAuthControlledPortControl: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthAuthControlledPortControl: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2 && intval != 3) {
            snmp_log(LOG_ERR, "write to dot1xAuthAuthControlledPortControl: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        if (dot1x_mgmt_switch_cfg_get(table_info.isid, &switch_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        old_port_conf = switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START];

        if (*var_val == 3) {
            current_port_conf.admin_state = NAS_PORT_CONTROL_FORCE_AUTHORIZED;
        } else if (*var_val == 2) {
            current_port_conf.admin_state = NAS_PORT_CONTROL_AUTO;
        } else if (*var_val == 1) {
            current_port_conf.admin_state = NAS_PORT_CONTROL_FORCE_UNAUTHORIZED;
        }

        if (old_port_conf.admin_state != current_port_conf.admin_state) {
            switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START] = current_port_conf;
            if (dot1x_mgmt_switch_cfg_set(table_info.isid, &switch_conf) != VTSS_OK) {
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            }
        }

        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration from old configuration */

        if (dot1x_mgmt_switch_cfg_get(table_info.isid, &switch_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        switch_conf.port_cfg[table_info.if_id - VTSS_PORT_NO_START] = old_port_conf;

        if (dot1x_mgmt_switch_cfg_set(table_info.isid, &switch_conf) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */

        memcpy(&old_port_conf, &current_port_conf, sizeof(old_port_conf));

        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /* Peter/2013/6/12, don't compile unused APIs. */
int
write_dot1xAuthQuietPeriod(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    u_long *buf, *old_buf;
    int max_size;
    long intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(u_long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthQuietPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthQuietPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 0 || intval > 0xffffffff) {
            snmp_log(LOG_ERR, "write to dot1xAuthQuietPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        return SNMP_ERR_NOTWRITABLE;
    }
    case UNDO: {
        break;
    }
    case COMMIT: {
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthTxPeriod(int      action,
                        u_char   *var_val,
                        u_char   var_val_type,
                        size_t   var_val_len,
                        u_char   *statP,
                        oid      *name,
                        size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthTxPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthTxPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xAuthTxPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1xAuthSuppTimeout(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthSuppTimeout: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthSuppTimeout: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xAuthSuppTimeout: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthServerTimeout(int      action,
                             u_char   *var_val,
                             u_char   var_val_type,
                             size_t   var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t   name_len)
{
    u_long *buf, *old_buf;
    int max_size;
    long intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(u_long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthServerTimeout: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthServerTimeout: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 0 || intval > 0xffffffff) {
            snmp_log(LOG_ERR, "write to dot1xAuthServerTimeout: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        return SNMP_ERR_NOTWRITABLE;
    }
    case UNDO: {
        break;
    }
    case COMMIT: {
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthMaxReq(int      action,
                      u_char   *var_val,
                      u_char   var_val_type,
                      size_t   var_val_len,
                      u_char   *statP,
                      oid      *name,
                      size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthMaxReq: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthMaxReq: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xAuthMaxReq: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
write_dot1xAuthReAuthPeriod(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
    int max_size;
    long intval;
    max_size = sizeof(u_long);

    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval < 0 || intval > 3600 ) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        if (dot1x_mgmt_glbl_cfg_get(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        memcpy(&current_global_cfg, &old_global_cfg, sizeof(old_global_cfg));

        current_global_cfg.reauth_period_secs = intval;

        if (current_global_cfg.reauth_period_secs ==
            old_global_cfg.reauth_period_secs) {
            break;
        }

        if (dot1x_mgmt_glbl_cfg_set(&current_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        if (dot1x_mgmt_glbl_cfg_set(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        memcpy(&old_global_cfg, &current_global_cfg, sizeof(old_global_cfg));
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthReAuthEnabled(int      action,
                             u_char   *var_val,
                             u_char   var_val_type,
                             size_t   var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t   name_len)
{
    int max_size;
    long intval;

    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthEnabled: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthEnabled: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        // The value of TruthValue is 1(true) or 2(false).
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xAuthReAuthEnabled: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        if (dot1x_mgmt_glbl_cfg_get(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }


        memcpy(&current_global_cfg, &old_global_cfg, sizeof(old_global_cfg));

        // The value of TruthValue is 1(true) or 2(false).
        if (intval == 1) {
            current_global_cfg.reauth_enabled = TRUE;
        } else if (intval == 2) {
            current_global_cfg.reauth_enabled = FALSE;
        } else {
            return SNMP_ERR_WRONGVALUE;
        }

        if (current_global_cfg.reauth_enabled == old_global_cfg.reauth_enabled) {
            break;
        }

        if (dot1x_mgmt_glbl_cfg_set(&current_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        if (dot1x_mgmt_glbl_cfg_set(&old_global_cfg) != VTSS_OK) {
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        }

        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        memcpy(&old_global_cfg, &current_global_cfg, sizeof(old_global_cfg));
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /* Peter/2013/6/12, don't compile unused APIs. */
write_dot1xAuthKeyTxEnabled(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
    long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL;
    old_buf = NULL;
    max_size = sizeof(long);
    intval = *((long *) var_val);

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xAuthKeyTxEnabled: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xAuthKeyTxEnabled: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) {
            snmp_log(LOG_ERR, "write to dot1xAuthKeyTxEnabled: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        return SNMP_ERR_NOTWRITABLE;
    }
    case UNDO: {
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xSuppHeldPeriod(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xSuppHeldPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xSuppHeldPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xSuppHeldPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1xSuppAuthPeriod(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xSuppAuthPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xSuppAuthPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xSuppAuthPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1xSuppStartPeriod(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xSuppStartPeriod: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xSuppStartPeriod: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xSuppStartPeriod: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1xSuppMaxStart(int      action,
                        u_char   *var_val,
                        u_char   var_val_type,
                        size_t   var_val_len,
                        u_char   *statP,
                        oid      *name,
                        size_t   name_len)
{
    u_long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(u_long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            snmp_log(LOG_ERR, "write to dot1xSuppMaxStart: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xSuppMaxStart: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xSuppMaxStart: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((u_long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1xSuppAccessCtrlWithAuth(int      action,
                                  u_char   *var_val,
                                  u_char   var_val_type,
                                  size_t   var_val_len,
                                  u_char   *statP,
                                  oid      *name,
                                  size_t   name_len)
{
    long *buf, *old_buf; /* FIXME */
    int max_size;
    long intval;

    buf = NULL; /* FIXME */
    old_buf = NULL; /* FIXME */
    max_size = sizeof(long); /* FIXME */
    intval = *((long *) var_val); /* FIXME */

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            snmp_log(LOG_ERR, "write to dot1xSuppAccessCtrlWithAuth: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > max_size) {
            snmp_log(LOG_ERR, "write to dot1xSuppAccessCtrlWithAuth: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (intval != 1 && intval != 2) { /* FIXME */
            snmp_log(LOG_ERR, "write to dot1xSuppAccessCtrlWithAuth: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /* Allocate memory and similar resources */
        break;
    }
    case FREE: {
        /* Release any resources that have been allocated */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /* Save to current configuration */
        *buf = *((long *) var_val); /* FIXME */
        break;
    }
    case UNDO: {
        /* Back out any changes made in the ACTION case */
        /* Restore current configuration form old configuration */
        *buf = *old_buf; /* FIXME */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /* Update old configuration */
        *old_buf = *buf; /* FIXME */
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif


