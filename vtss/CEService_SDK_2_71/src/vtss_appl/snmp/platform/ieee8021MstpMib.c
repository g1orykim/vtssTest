/*
 *
 * Vitesse Switch Software.
 *
 * Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 * Rights Reserved.
 *
 * Unpublished rights reserved under the copyright laws of the United States of
 * America, other countries and international treaties. Permission to use, copy,
 * store and modify, the software and its source code is granted. Permission to
 * integrate into other products, disclose, transmit and distribute the software
 * in an absolute machine readable format (e.g. HEX file) is also granted.  The
 * source code of the software may not be disclosed, transmitted or distributed
 * without the written permission of Vitesse. The software and its source code
 * may only be used in products utilizing the Vitesse switch products.
 *
 * This copyright notice must appear in any copy, modification, disclosure,
 * transmission or distribution of the software. Vitesse retains all ownership,
 * copyright, trade secret and proprietary rights in the software.
 *
 * THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 * INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 *
 */

//Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//      Revise the "FIXME" parts to make it as a completed code.

#include <main.h>
#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */

#include "vtss_snmp_api.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_ieee8021MstpMib.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_ieee8021MstpMib.h"
#endif                          /* SNMP_HAS_UCD_SNMP */
#include "mibContextTable.h"         //mibContextTable_register()
#include "mibContextTable.h"         // mibContextTable_register()
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#include "msg_api.h"
#include "mstp_api.h"
#include "ieee8021MstpMib.h"
#include "vlan_api.h"
#include "dot1Port_api.h"
#include "vtss_rowStatus.h"


// Trace module ID
#define VTSS_TRACE_MODULE_ID    VTSS_MODULE_ID_SNMP

#define SNMP_BRIDGEID_LEN   8
#define MSTID_CIST          0   /* CIST is MSTI0 - MSTID zero */

#define   SNMP_MSTP_FALSE              2
#define   SNMP_MSTP_TRUE               1
#define   SNMP_MSTP_VID_MAX            128
#define   SNMP_MSTP_CFG_DIGEST_MAX     16
#define   SNMP_MSTP_ROOT_PORT          1
#define   SNMP_MSTP_ALTERNATE_PORT     2
#define   SNMP_MSTP_DESIGNATE_PORT     3
#define   SNMP_MSTP_BACKUP_PORT        4
#define   SNMP_MSTP_PORT_ERROR         5

#define   SNMP_SET_MASK_MAX            256
#define   SNMP_SET_MASK_VAL            8

static void send_mstp_trap(u32 event_mask);
static void snmp_new_root_notification(void);
static void snmp_topology_change_notification(void);

/******************************************************************************/
//
// Local functions
//
/******************************************************************************/

/****************************************************************
 *Purpose     : Sets the mask in the appropriate bit corresponding
 *              to the value.
 *Remarks     : This function can be used in any application
 *              provided the size is specified as the size of
 *              the mask array being passed.
 *Restrictions: size should be less than or equal to size of
 *              array mask, value should
 *              be less than size of mask array *8.
 *              First bit stands for value 0
 *see also:
 *Example:
 ******************************************************************/

static void IEEE8021MSTP_setmask(u8 *mask, int value, int size)
{
    int k = SNMP_SET_MASK_MAX;

    if (value / SNMP_SET_MASK_VAL > size) {
        return;
    }
    if ((value % SNMP_SET_MASK_VAL) != 0) {
        if (value > 0 && value / SNMP_SET_MASK_VAL < size) {
            mask[value / SNMP_SET_MASK_VAL]
            |= k >> (value % SNMP_SET_MASK_VAL);
        }
    } else if (value != 0) {
        mask[(value / SNMP_SET_MASK_VAL) - 1] |= 1;
    }
}

static BOOL IEEE8021MSTP_TableEntryByKey_get(ieee8021MstpTable_entry_t *table_entry)
{
    mstp_bridge_status_t status;
    mstp_msti_config_t   msti_config;
    int                  i = 0;
    BOOL                 rc = FALSE;

    memset (&msti_config, 0, sizeof(mstp_msti_config_t));

    if ( table_entry->ieee8021MstpComponentId != 1 || table_entry->ieee8021MstpId >= N_MSTI_MAX ) {
        return FALSE;
    }
    rc = mstp_get_bridge_status (table_entry->ieee8021MstpId, &status);

    if (rc == FALSE) {
        memset(&status, 0, sizeof(status));
    }

    table_entry->ieee8021MstpBridgeId_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpBridgeId, status.bridgeId,
            table_entry->ieee8021MstpBridgeId_len);
    table_entry->ieee8021MstpTimeSinceTopologyChange =
        status.timeSinceTopologyChange * 100;
    table_entry->ieee8021MstpTopologyChanges.low = status.topologyChangeCount;
    table_entry->ieee8021MstpTopologyChanges.high = 0;
    table_entry->ieee8021MstpTopologyChange = status.topologyChange;
    table_entry->ieee8021MstpDesignatedRoot_len = sizeof(status.designatedRoot);
    memcpy (table_entry->ieee8021MstpDesignatedRoot, status.designatedRoot,
            table_entry->ieee8021MstpDesignatedRoot_len);
    table_entry->ieee8021MstpRootPathCost = status.rootPathCost;
    table_entry->ieee8021MstpRootPort = status.rootPort;


    /* Bride Identifier (Refer 13.23.2 802.1 Q 2005 Standard)
     *
     * The four significant bits of the Bridge Identifier (the settable
     * priority component) for the CIST and for each MSTI  can be modified
     * independently of the setting of the those bits for all other trees,
     * as a part of allowing full and indenpent configuration control to
     * be extended over each STP instance.
     */
    /*
     * Priority is the first 2 bytes of the bridge Id. MSB of the priority
     * is stored in the first byte of the char array.
     * Therefore copy the content in the reverse order so as to copy the
     * MSB in the right place in the long int.
     */
    table_entry->ieee8021MstpBridgePriority = mstp_get_msti_priority(table_entry->ieee8021MstpId) << 8;

    if (mstp_get_msti_config (&msti_config, NULL) == FALSE) {
        return FALSE;
    }

    table_entry->ieee8021MstpVids0_len = 128;
    table_entry->ieee8021MstpVids1_len = 128;
    table_entry->ieee8021MstpVids2_len = 128;
    table_entry->ieee8021MstpVids3_len = 128;
    for (i = 0; i < MSTP_MAX_VID; i++) {
        if (msti_config.map.map[i] == table_entry->ieee8021MstpId) {
            if (i / SNMP_MSTP_VID_MAX == 0) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids0, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids0));
            } else if (i / SNMP_MSTP_VID_MAX == 1) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids1, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids1));
            } else if (i / SNMP_MSTP_VID_MAX == 2) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids2, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids2));
            } else if (i / SNMP_MSTP_VID_MAX == 3) {
                IEEE8021MSTP_setmask((u8 *)table_entry->ieee8021MstpVids3, i % SNMP_MSTP_VID_MAX,
                                     sizeof(table_entry->ieee8021MstpVids3));
            } /* end of  else-if */
        } /* end of if */
    } /* end of for */

    table_entry->ieee8021MstpRowStatus = rc == TRUE ? RFC2579_STATE_ACTIVE : RFC2579_STATE_NOT_IN_SERVICE;

    return TRUE;
}

static BOOL IEEE8021MSTP_TableEntryByKey_getnext(ieee8021MstpTable_entry_t *table_entry)
{
    ieee8021MstpTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpComponentId > 1 || (tmp.ieee8021MstpComponentId == 1 && tmp.ieee8021MstpId >= N_MSTI_MAX )) {
        return FALSE;
    }

    if ( tmp.ieee8021MstpComponentId < 1 ) {
        tmp.ieee8021MstpComponentId = 1;
        tmp.ieee8021MstpId = 1;
    } else {
        tmp.ieee8021MstpId++;
    }
    while (tmp.ieee8021MstpId < N_MSTI_MAX && FALSE == IEEE8021MSTP_TableEntryByKey_get( &tmp )) {
        tmp.ieee8021MstpId++;
    }

    if (tmp.ieee8021MstpId == N_MSTI_MAX) {
        return FALSE;
    }
    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_CistPortTableEntryByKey_getnext(ieee8021MstpCistPortTable_entry_t *
                                                         table_entry)
{
    dot1Port_info_t   info;
    BOOL              found = FALSE, enable;
    mstp_port_mgmt_status_t      status;
    mstp_bridge_status_t bs;
    mstp_msti_port_param_t port_parm;
    mstp_port_param_t       pconf;

    if ( table_entry->ieee8021MstpCistPortComponentId > 1 ) {
        return FALSE;
    }

    if (table_entry->ieee8021MstpCistPortComponentId < 1) {
        info.dot1port = 0;
    }

    info.dot1port = table_entry->ieee8021MstpCistPortNum;

    while ( TRUE == dot1Port_get_next(&info) ) {
        T_D ("mstp_get_port_status: l2port = %d", info.dot1port - 1);
        if (TRUE == (found = mstp_get_port_status (MSTID_CIST, info.dot1port - 1, &status))) {
            break;
        }
        T_D("not found");
    }

    if ( FALSE == found ) {
        return FALSE;
    }

    if (mstp_get_msti_port_config( info.isid, MSTID_CIST,
                                   info.if_id, &port_parm ) == FALSE ) {
        return FALSE;
    }
    if (mstp_get_port_config (info.isid, info.if_id,
                              &enable, &pconf) == FALSE) {
        return FALSE;
    }

    if ( FALSE == mstp_get_bridge_status(MSTID_CIST, &bs)) {
        return FALSE;
    }

    table_entry->ieee8021MstpCistPortAdminPathCost = port_parm.adminPathCost;
    table_entry->ieee8021MstpCistPortAdminEdgePort = pconf.adminEdgePort == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortRestrictedRole = pconf.restrictedRole == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortRestrictedTcn = pconf.restrictedTcn == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortComponentId = 1;
    table_entry->ieee8021MstpCistPortNum = info.dot1port;
    table_entry->ieee8021MstpCistPortUptime = status.core.uptime * 100;
    table_entry->ieee8021MstpCistPortDesignatedRoot_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpCistPortDesignatedRoot,
            status.core.designatedRoot, table_entry->ieee8021MstpCistPortDesignatedRoot_len);
    table_entry->ieee8021MstpCistPortTopologyChangeAck = status.core.tcAck;
    /***** supplying the dummy values if port not active ---as explained in bugzilla # 3702 ******/
    if (status.active ) {
        table_entry->ieee8021MstpCistPortHelloTime = status.core.helloTime * 100;
    } else {
        table_entry->ieee8021MstpCistPortHelloTime = 200;
    }
    table_entry->ieee8021MstpCistPortOperEdgePort = status.core.operEdgePort == TRUE ? 1 : 2;
    table_entry->ieee8021MstpCistPortMacOperational =
        status.core.macOperational == TRUE ? 1 : 2;

    if (strcasecmp (status.core.rolestr, "rootport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 1;
    } else if (strcasecmp (status.core.rolestr, "alternateport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 2;
    } else if (strcasecmp (status.core.rolestr, "designatedport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 3;
    } else if (strcasecmp (status.core.rolestr, "backupport") == 0) {
        table_entry->ieee8021MstpCistPortRole = 4;
    }
    table_entry->ieee8021MstpCistPortDisputed = status.core.disputed == TRUE ? 1 : 2;

    table_entry->ieee8021MstpCistPortCistRegionalRootId_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpCistPortCistRegionalRootId,
            bs.cistRegionalRoot, table_entry->ieee8021MstpCistPortCistRegionalRootId_len);
    table_entry->ieee8021MstpCistPortCistPathCost = status.core.pathCost;

    return TRUE;

}

static BOOL IEEE8021MSTP_CistPortTableEntryByKey_get(ieee8021MstpCistPortTable_entry_t *table_entry)
{
    ieee8021MstpCistPortTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpCistPortNum ) {
        --tmp.ieee8021MstpCistPortNum;
    } else if ( tmp.ieee8021MstpCistPortComponentId ) {
        --tmp.ieee8021MstpCistPortComponentId;
        tmp.ieee8021MstpCistPortNum = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_CistPortTableEntryByKey_getnext( &tmp ) ||
         tmp.ieee8021MstpCistPortComponentId != table_entry->ieee8021MstpCistPortComponentId ||
         tmp.ieee8021MstpCistPortNum != table_entry->ieee8021MstpCistPortNum ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_getnext_vlanId(u_long *vid)
{

    vlan_mgmt_entry_t   vlan_mgmt_entry;
    vlan_mgmt_entry.vid = *vid;

    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, TRUE, VLAN_USER_ALL) != VTSS_OK) {
        return FALSE;
    }

    *vid = vlan_mgmt_entry.vid;
    return TRUE;
}


static BOOL IEEE8021MSTP_FidToMstiTableEntryByKey_getnext(ieee8021MstpFidToMstiTable_entry_t *table_entry)
{
    u_long vid = table_entry->ieee8021MstpFidToMstiFid, componentId = table_entry->ieee8021MstpFidToMstiComponentId;
    mstp_msti_config_t msti_config;

    if ( componentId > 1 ) {
        return FALSE;
    }

    if ( componentId < 1 ) {
        componentId = 1;
        vid = 0;
    }

    if ( FALSE == IEEE8021MSTP_getnext_vlanId (&vid) ) {
        return FALSE;
    }

    if (mstp_get_msti_config (&msti_config, NULL) == FALSE) {
        return FALSE;
    }

    table_entry->ieee8021MstpFidToMstiComponentId = componentId;
    table_entry->ieee8021MstpFidToMstiFid = vid;
    table_entry->ieee8021MstpFidToMstiMstId = 0 == msti_config.map.map[vid] ? N_MSTI_MAX : msti_config.map.map[vid];
    return TRUE;
}

static BOOL IEEE8021MSTP_FidToMstiTableEntryByKey_get(ieee8021MstpFidToMstiTable_entry_t *table_entry)
{
    ieee8021MstpFidToMstiTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpFidToMstiFid ) {
        --tmp.ieee8021MstpFidToMstiFid;
    } else if ( tmp.ieee8021MstpFidToMstiComponentId ) {
        --tmp.ieee8021MstpFidToMstiComponentId;
        tmp.ieee8021MstpFidToMstiFid = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext ( &tmp ) ||
         tmp.ieee8021MstpFidToMstiComponentId != table_entry->ieee8021MstpFidToMstiComponentId ||
         tmp.ieee8021MstpFidToMstiFid != table_entry->ieee8021MstpFidToMstiFid ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_VlanTableEntryByKey_getnext(ieee8021MstpVlanTable_entry_t *table_entry)
{
    u_long vid = table_entry->ieee8021MstpVlanId, componentId = table_entry->ieee8021MstpVlanComponentId;
    mstp_msti_config_t msti_config;

    if ( componentId > 1 ) {
        return FALSE;
    }

    if ( componentId < 1 ) {
        componentId = 1;
        vid = 0;
    }

    if ( FALSE == IEEE8021MSTP_getnext_vlanId (&vid) ) {
        return FALSE;
    }

    if (mstp_get_msti_config (&msti_config, NULL) == FALSE) {
        return FALSE;
    }

    table_entry->ieee8021MstpVlanComponentId = componentId;
    table_entry->ieee8021MstpVlanId = vid;
    table_entry->ieee8021MstpVlanMstId = msti_config.map.map[vid];
    return TRUE;
}

static BOOL IEEE8021MSTP_VlanTableEntryByKey_get(ieee8021MstpVlanTable_entry_t *table_entry)
{
    ieee8021MstpVlanTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpVlanId ) {
        --tmp.ieee8021MstpVlanId;
    } else if ( tmp.ieee8021MstpVlanComponentId ) {
        --tmp.ieee8021MstpVlanComponentId;
        tmp.ieee8021MstpVlanId = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_VlanTableEntryByKey_getnext ( &tmp) ||
         tmp.ieee8021MstpVlanComponentId != table_entry->ieee8021MstpVlanComponentId ||
         tmp.ieee8021MstpVlanId != table_entry->ieee8021MstpVlanId ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_PortTableEntryByDot1Port_get(ieee8021MstpPortTable_entry_t *table_entry, mstp_port_mgmt_status_t *status, dot1Port_info_t *info)
{
    mstp_msti_port_param_t  pconf;

    table_entry->ieee8021MstpPortUptime = status->core.uptime;

    if (mstp_get_msti_port_config (info->isid, table_entry->ieee8021MstpPortMstId, info->if_id, &pconf) == FALSE) {
        return FALSE;
    }

    table_entry->ieee8021MstpPortPriority = pconf.adminPortPriority;
    table_entry->ieee8021MstpPortPathCost = pconf.adminPathCost;
    table_entry->ieee8021MstpPortDesignatedRoot_len = SNMP_BRIDGEID_LEN;
    table_entry->ieee8021MstpPortDesignatedBridge_len = SNMP_BRIDGEID_LEN;
    memcpy (table_entry->ieee8021MstpPortDesignatedRoot,
            status->core.designatedRoot, SNMP_BRIDGEID_LEN);
    table_entry->ieee8021MstpPortDesignatedCost = status->core.designatedCost;
    memcpy (table_entry->ieee8021MstpPortDesignatedBridge,
            status->core.designatedBridge, SNMP_BRIDGEID_LEN);

    table_entry->ieee8021MstpPortDesignatedPort =
        atoi ((i8 *) status->core.designatedPort);

    if (strcasecmp (status->core.statestr, "Discarding ") == 0) {
        table_entry->ieee8021MstpPortState = 1;
    } else if (strcasecmp (status->core.statestr, "Disabled") == 0) {
        table_entry->ieee8021MstpPortState = 1;
    } else if (strcasecmp (status->core.statestr, "Forwarding") == 0) {
        table_entry->ieee8021MstpPortState = 4;
    } else if (strcasecmp (status->core.statestr, "Learning") == 0) {
        table_entry->ieee8021MstpPortState = 3;
    }



    if (strcasecmp (status->core.rolestr, "rootport") == 0 ) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_ROOT_PORT;
    } else if (strcasecmp (status->core.rolestr, "alternateport") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_ALTERNATE_PORT;
    } else if (strcasecmp (status->core.rolestr, "designatedport") == 0 || strcasecmp (status->core.rolestr, "MasterPort") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_DESIGNATE_PORT;
    } else if (strcasecmp (status->core.rolestr, "backupport") == 0) {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_BACKUP_PORT;
    } else {
        table_entry->ieee8021MstpPortRole = SNMP_MSTP_PORT_ERROR;  //error.
    }
    table_entry->ieee8021MstpPortDisputed = status->core.disputed;

    return TRUE;
}

static BOOL IEEE8021MSTP_CistTableEntryByKey_get (ieee8021MstpCistTable_entry_t *table_entry)
{
    mstp_bridge_status_t status;
    BOOL                 rc = FALSE;

    if (table_entry->ieee8021MstpCistComponentId != 1) {
        return FALSE;
    }
    rc = mstp_get_bridge_status (MSTID_CIST, &status);

    T_D("ieee8021MstpCistComponentId = %lu, rc = %s", table_entry->ieee8021MstpCistComponentId,
        rc ? "TRUE" : "FALSE");
    if (rc == FALSE) {
        T_E("mstp_get_bridge_status fail");
        return FALSE;
    }

    table_entry->ieee8021MstpCistBridgeIdentifier_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpCistBridgeIdentifier, status.bridgeId,
            table_entry->ieee8021MstpCistBridgeIdentifier_len);
    table_entry->ieee8021MstpCistTopologyChange = status.topologyChange ? 1 : 2;

    table_entry->ieee8021MstpCistRegionalRootIdentifier_len = sizeof(status.bridgeId);
    memcpy (table_entry->ieee8021MstpCistRegionalRootIdentifier,
            status.cistRegionalRoot, table_entry->ieee8021MstpCistRegionalRootIdentifier_len);
    table_entry->ieee8021MstpCistPathCost = status.rootPathCost;
    table_entry->ieee8021MstpCistMaxHops = (u32) status.maxHops;

    return TRUE;

}

static BOOL IEEE8021MSTP_CistTableEntryByKey_getnext (ieee8021MstpCistTable_entry_t *table_entry)
{
    ieee8021MstpCistTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpCistComponentId >= 1 ) {
        return FALSE;
    }

    tmp.ieee8021MstpCistComponentId++ ;

    (void) IEEE8021MSTP_CistTableEntryByKey_get ( &tmp);
    *table_entry = tmp;
    return TRUE;
}

static BOOL IEEE8021MSTP_PortTableEntryByKey_getnext ( ieee8021MstpPortTable_entry_t *table_entry )
{
    u8                          msti = table_entry->ieee8021MstpPortMstId;
    mstp_port_mgmt_status_t     status;
    dot1Port_info_t             info;
    BOOL                        found = FALSE;
    if (table_entry->ieee8021MstpPortComponentId > 1 ||
        (table_entry->ieee8021MstpPortComponentId == 1 && table_entry->ieee8021MstpPortMstId > N_MSTI_MAX) ) {
        return FALSE;
    }


    if (table_entry->ieee8021MstpPortComponentId < 1 ) {
        msti = 1;
        info.dot1port = 0;
    } else {
        msti = table_entry->ieee8021MstpPortMstId;
        info.dot1port = table_entry->ieee8021MstpPortNum;
    }


    T_D("msti = %d, dot1port = %d", msti, info.dot1port);
    while ( msti < N_MSTI_MAX ) {
        while ( TRUE == ( found = dot1Port_get_next( &info )) ) {
            break;
        }
        if ( TRUE == found ) {
            break;
        }
        msti++;
        info.dot1port = 0;
    }

    if ( FALSE == found ) {
        return FALSE;
    }

    if ( FALSE == mstp_get_port_status ( msti, info.dot1port - 1, &status) ) {
        memset( &status, 0, sizeof(status));
    }

    table_entry->ieee8021MstpPortComponentId = 1;
    table_entry->ieee8021MstpPortMstId = msti;
    table_entry->ieee8021MstpPortNum = info.dot1port;

    (void) IEEE8021MSTP_PortTableEntryByDot1Port_get(table_entry, &status, &info);

    return TRUE;

}

static BOOL IEEE8021MSTP_PortTableEntryByKey_get ( ieee8021MstpPortTable_entry_t *table_entry )
{
    ieee8021MstpPortTable_entry_t tmp = *table_entry;
    if ( table_entry->ieee8021MstpPortNum ) {
        --tmp.ieee8021MstpPortNum;
    } else if ( table_entry->ieee8021MstpPortMstId ) {
        --tmp.ieee8021MstpPortMstId;
        tmp.ieee8021MstpPortNum = 0xffffffff;
    } else if ( table_entry->ieee8021MstpPortComponentId ) {
        --table_entry->ieee8021MstpPortComponentId;
        tmp.ieee8021MstpPortMstId = 0xffffffff;
        tmp.ieee8021MstpPortNum = 0xffffffff;
    } else {
        return FALSE;
    }

    if ( FALSE == IEEE8021MSTP_PortTableEntryByKey_getnext( &tmp ) ||
         tmp.ieee8021MstpPortComponentId != table_entry->ieee8021MstpPortComponentId ||
         tmp.ieee8021MstpPortMstId != table_entry->ieee8021MstpPortMstId ||
         tmp.ieee8021MstpPortNum != table_entry->ieee8021MstpPortNum ) {
        return FALSE;
    }

    *table_entry = tmp;
    return TRUE;

}

static BOOL IEEE8021MSTP_ConfigIdTableEntryByKey_get (ieee8021MstpConfigIdTable_entry_t *table_entry)
{
    mstp_msti_config_t msti_config;
    u8                 config_digest[SNMP_MSTP_CFG_DIGEST_MAX];

    if ( 1 != table_entry->ieee8021MstpConfigIdComponentId ) {
        return FALSE;
    }

    if (mstp_get_msti_config (&msti_config,
                              config_digest) == FALSE) {
        return FALSE;
    }

    table_entry->ieee8021MstpConfigIdFormatSelector = 0;
    /* 802.1Q std implementation */
    table_entry->ieee8021MstpConfigurationName_len = strlen(msti_config.configname);
    table_entry->ieee8021MstpConfigurationDigest_len = SNMP_MSTP_CFG_DIGEST_MAX;
    strncpy ((i8 *) table_entry->ieee8021MstpConfigurationName,
             (i8 *) msti_config.configname,
             table_entry->ieee8021MstpConfigurationName_len);
    strncpy ((i8 *) table_entry->ieee8021MstpConfigurationDigest,
             (i8 *) config_digest, SNMP_MSTP_CFG_DIGEST_MAX);
    table_entry->ieee8021MstpRevisionLevel = msti_config.revision;

    return TRUE;
}

static BOOL IEEE8021MSTP_ConfigIdTableEntryByKey_getnext (ieee8021MstpConfigIdTable_entry_t *table_entry)
{
    ieee8021MstpConfigIdTable_entry_t tmp = *table_entry;

    if ( tmp.ieee8021MstpConfigIdComponentId >= 1 ) {
        return FALSE;
    }

    tmp.ieee8021MstpConfigIdComponentId++ ;

    (void) IEEE8021MSTP_ConfigIdTableEntryByKey_get ( &tmp);
    *table_entry = tmp;
    return TRUE;
}


/******************************************************************************/
//
// Initial function
//
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the IEEE8021-MSTP-MIB:ieee8021MstpMib.
  **/
void
ieee8021MstpMib_init(void)
{
    oid             ieee8021MstpMib_oid[] = { 1, 3, 111, 2, 802, 1, 1, 6 };

    T_D("enter");

    // Register mibContextTable
    mibContextTable_register(ieee8021MstpMib_oid,
                             sizeof(ieee8021MstpMib_oid) / sizeof(oid),
                             "IEEE8021-MSTP-MIB : ieee8021MstpMib");

#if defined(SNMP_HAS_UCD_SNMP)
    ucd_snmp_init_ieee8021MstpMib();
#elif defined(SNMP_HAS_NET_SNMP)
    net_snmp_init_ieee8021MstpMib();
#endif                          /* SNMP_HAS_UCD_SNMP */
    if (mstp_register_trap_sink(send_mstp_trap) != TRUE) {
        T_D("Could not register to MSTP Traps\n");
    }

    T_D("exit");
}

static void send_mstp_trap(u32 event_mask)
{
    int event = 1;
    if (event_mask & (event << (int) MSTP_TRAP_NEW_ROOT)) {
        snmp_new_root_notification();
    }
    if (event_mask & (event << (int) MSTP_TRAP_TOPOLOGY_CHANGE)) {
        snmp_topology_change_notification();
    }
}

static void snmp_new_root_notification(void)
{
    oid new_root_notifications_oid[] = {1, 3, 6, 1, 2, 1, 17, 0, 0};
    snmp_vars_trap_entry_t  trap_entry;

    T_D("Notification Change called for new Root detection");

    // Transmit the SNMP trap
    memset (&trap_entry, 0x0, sizeof(trap_entry));
    trap_entry.oid_len = OID_LENGTH(new_root_notifications_oid);
    new_root_notifications_oid[ trap_entry.oid_len - 1 ] = NEWROOTTRAPINST;
    memcpy (trap_entry.oid, new_root_notifications_oid,
            sizeof(oid) * trap_entry.oid_len);

    trap_entry.vars = NULL ;

    snmp_send_vars_trap(SNMP_TRAP_ENTERPRISESPECIFIC, &trap_entry);
}

static void snmp_topology_change_notification(void)
{
    oid topology_change_notifications_oid[] = {1, 3, 6, 1, 2, 1, 17, 0, 0};
    snmp_vars_trap_entry_t  trap_entry;

    T_D("Notification Change called for Topology change detection");

    // Transmit the SNMP trap
    memset(&trap_entry, 0x0, sizeof(trap_entry));
    trap_entry.oid_len = OID_LENGTH(topology_change_notifications_oid);
    topology_change_notifications_oid[ trap_entry.oid_len - 1 ] = TOPOLOGYCHANGETRAPINST;
    memcpy(trap_entry.oid, topology_change_notifications_oid,
           sizeof(oid) * trap_entry.oid_len);

    trap_entry.vars = NULL ;

    snmp_send_vars_trap(SNMP_TRAP_ENTERPRISESPECIFIC, &trap_entry);
}


/******************************************************************************/
//
// Scalar access functions
//
/******************************************************************************/


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_getfirst(ieee8021MstpCistTable_entry_t *
                                    table_entry)
{
    T_D("enter");

    table_entry->ieee8021MstpCistComponentId = 0;
    T_D("ieee8021MstpCistComponentId = %lu", table_entry->ieee8021MstpCistComponentId);
    T_D("exit");
    return TRUE == IEEE8021MSTP_CistTableEntryByKey_getnext (table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_get(ieee8021MstpCistTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_CistTableEntryByKey_getnext ( table_entry) ) ||
         (!getnext && FALSE == IEEE8021MSTP_CistTableEntryByKey_get ( table_entry)) ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpCistTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistTableEntry_set(ieee8021MstpCistTable_entry_t *table_entry)
{
    mstp_bridge_param_t bridge_params;

    T_D("enter");

    if (mstp_get_system_config(&bridge_params) == FALSE ) {
        return -1;
    }

    bridge_params.MaxHops = table_entry->ieee8021MstpCistMaxHops;
    if (mstp_set_system_config(&bridge_params) == FALSE) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_getfirst(ieee8021MstpTable_entry_t *table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpId = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_TableEntryByKey_getnext( table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_get(ieee8021MstpTable_entry_t *table_entry,
                           int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_TableEntryByKey_getnext( table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_TableEntryByKey_get( table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpTableEntry_set(ieee8021MstpTable_entry_t *table_entry)
{
    u8 priority = (u8) (table_entry->ieee8021MstpBridgePriority >> 8);

    T_D("enter");
    if ( mstp_set_msti_priority ((u8) table_entry->ieee8021MstpId, priority ) == FALSE) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_getfirst(ieee8021MstpCistPortTable_entry_t *
                                        table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpCistPortComponentId = 0;
    table_entry->ieee8021MstpCistPortNum = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_CistPortTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_get(ieee8021MstpCistPortTable_entry_t *
                                   table_entry, int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_CistPortTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_CistPortTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpCistPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpCistPortTableEntry_set(ieee8021MstpCistPortTable_entry_t *
                                   table_entry)
{
    dot1Port_info_t   info;
    mstp_msti_port_param_t port_parm;
    mstp_port_param_t pconf;
    BOOL              enable;

    T_D("enter");

    info.dot1port = table_entry->ieee8021MstpCistPortNum;
    ( void ) dot1Port_get(&info);

    if (mstp_get_msti_port_config( info.isid, MSTID_CIST,
                                   info.if_id, &port_parm ) == FALSE ) {
        return -1;
    }
    if (mstp_get_port_config (info.isid, info.if_id,
                              &enable, &pconf) == FALSE) {
        return -1;
    }

    port_parm.adminPathCost     = table_entry->ieee8021MstpCistPortAdminPathCost;
    pconf.adminEdgePort         = table_entry->ieee8021MstpCistPortAdminEdgePort == 1 ? TRUE : FALSE;
    pconf.restrictedRole        = table_entry->ieee8021MstpCistPortRestrictedRole == 1 ? TRUE : FALSE;
    pconf.restrictedTcn         = table_entry->ieee8021MstpCistPortRestrictedTcn == 1 ? TRUE : FALSE;
    if (mstp_set_msti_port_config ( info.isid, MSTID_CIST, info.if_id, &port_parm) == FALSE) {
        return VTSS_RC_ERROR;
    } /* end of if */
    if (mstp_set_port_config (info.isid, info.if_id,
                              enable, &pconf) == FALSE) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_getfirst(ieee8021MstpPortTable_entry_t *
                                    table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpPortComponentId    = 0;
    table_entry->ieee8021MstpPortMstId          = 0;
    table_entry->ieee8021MstpPortNum            = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_PortTableEntryByKey_getnext ( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_get(ieee8021MstpPortTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_PortTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_PortTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpPortTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpPortTableEntry_set(ieee8021MstpPortTable_entry_t *table_entry)
{

    dot1Port_info_t        info;
    mstp_msti_port_param_t pconf;

    T_D("enter");

    info.dot1port = table_entry->ieee8021MstpPortNum;
    ( void ) dot1Port_get( &info );

    if (mstp_get_msti_port_config (info.isid, table_entry->ieee8021MstpPortMstId, info.if_id,
                                   &pconf) == FALSE ) {
        return -1;
    }

    pconf.adminPortPriority = table_entry->ieee8021MstpPortPriority;
    pconf.adminPathCost = table_entry->ieee8021MstpPortPathCost;
    if (mstp_set_msti_port_config (info.isid, table_entry->ieee8021MstpPortMstId, info.if_id,
                                   &pconf) == FALSE ) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_getfirst(ieee8021MstpFidToMstiTable_entry_t
                                         * table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpFidToMstiComponentId = 0;
    table_entry->ieee8021MstpFidToMstiFid = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_get(ieee8021MstpFidToMstiTable_entry_t *
                                    table_entry, int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_FidToMstiTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpFidToMstiTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpFidToMstiTableEntry_set(ieee8021MstpFidToMstiTable_entry_t *
                                    table_entry)
{
    mstp_msti_config_t msti_config;

    T_D("enter");

    if (mstp_get_msti_config (&msti_config, NULL) == FALSE) {
        return -1;
    }

    msti_config.map.map[table_entry->ieee8021MstpFidToMstiFid] = N_MSTI_MAX == table_entry->ieee8021MstpFidToMstiMstId ?
                                                                 0 : table_entry->ieee8021MstpFidToMstiMstId;
    if (mstp_set_msti_config (&msti_config) == FALSE) {
        return -1;
    } /* end of if */

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpVlanTableEntry_getfirst(ieee8021MstpVlanTable_entry_t *
                                    table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpVlanComponentId = 0;
    table_entry->ieee8021MstpVlanId = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_VlanTableEntryByKey_getnext(table_entry) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpVlanTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpVlanTableEntry_get(ieee8021MstpVlanTable_entry_t *table_entry,
                               int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_VlanTableEntryByKey_getnext(table_entry)) ||
         (!getnext && FALSE == IEEE8021MSTP_VlanTableEntryByKey_get(table_entry))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Get first table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_getfirst(ieee8021MstpConfigIdTable_entry_t *
                                        table_entry)
{
    T_D("enter");
    table_entry->ieee8021MstpConfigIdComponentId = 0;
    T_D("exit");
    return TRUE == IEEE8021MSTP_ConfigIdTableEntryByKey_getnext( table_entry ) ? VTSS_RC_OK : VTSS_RC_ERROR;
}

/**
  * \brief Get/Getnext table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_get(ieee8021MstpConfigIdTable_entry_t *
                                   table_entry, int getnext)
{
    T_D("enter");

    if ( (getnext && FALSE == IEEE8021MSTP_ConfigIdTableEntryByKey_getnext( table_entry )) ||
         (!getnext && FALSE == IEEE8021MSTP_ConfigIdTableEntryByKey_get( table_entry ))) {
        return -1;
    }

    T_D("exit");
    return 0;
}

/**
  * \brief Set table entry of ieee8021MstpConfigIdTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to set the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
ieee8021MstpConfigIdTableEntry_set(ieee8021MstpConfigIdTable_entry_t *
                                   table_entry)
{
    mstp_msti_config_t msti_config;
    size_t configname_len =
        table_entry->ieee8021MstpConfigurationName_len > sizeof(msti_config.configname) - 1 ?
        sizeof(msti_config.configname) - 1 : table_entry->ieee8021MstpConfigurationName_len;

    T_D("enter");

    if (mstp_get_msti_config (&msti_config, NULL) != FALSE) {
        strncpy (msti_config.configname, table_entry->ieee8021MstpConfigurationName,
                 configname_len);
        msti_config.configname[configname_len] = 0;
        msti_config.revision = table_entry->ieee8021MstpRevisionLevel;
        if (mstp_set_msti_config (&msti_config) == FALSE) {
            return -1;
        }
    }

    T_D("exit");
    return 0;
}
