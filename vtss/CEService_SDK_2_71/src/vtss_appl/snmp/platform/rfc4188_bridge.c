/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>
//#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h> /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h> /* utility function declarations */
#include "rfc4188_bridge.h"

/* +++ Start (Internal implementation declarations) */
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
#include "topo_api.h"
#endif
#include "msg_api.h" //msg_switch_exists()
#include "misc_api.h" //iport2uport()
#include "conf_api.h"
#include "vlan_api.h"
#include "mac_api.h"
#include "ifIndex_api.h"
#include "dot1Port_api.h"
#include "mibContextTable.h"  //mibContextTable_register

#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
/* --- End (Internal implementation declarations) */

#ifdef RFC4188_SUPPORTED_DOT1DBASE
//-----------------------------------------------------------------------------
// dot1dBase
//-----------------------------------------------------------------------------
/*
 * The entry data structure for dot1dBaseBridgeAddress
 */
typedef struct {
    char             dot1dBaseBridgeAddress[6];
    size_t              dot1dBaseBridgeAddress_len;
    long             dot1dBaseNumPorts;
    long             dot1dBaseType;
} dot1dBase_scalar_t;

/*
 * The entry data structure for dot1dBasePortTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dBasePort;

    /* Entry columns */
    long             dot1dBasePortIfIndex;
    oid             dot1dBasePortCircuit[MAX_OID_LEN];
    size_t              dot1dBasePortCircuit_len;
    u_long             dot1dBasePortDelayExceededDiscards;
    u_long             dot1dBasePortMtuExceededDiscards;
} dot1dBasePortTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SPRINT_MAX_LEN];
    oid                 objid_ret[MAX_OID_LEN];
    size_t              objid_len_ret;
    u_long              ulong_ret;
} dot1dBase_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, dot1dBase_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static dot1dBase_return_t dot1dBase_global_ret; /* static variables for retuning */

/*
 * dot1dBase_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dBase_variables_oid[] = {1, 3, 6, 1, 2, 1, 17, 1};



/*
 * variable dot1dBase_variables:
 *   this variable defines function callbacks and type return information
 *   for the dot1dBase mib section
 */

struct variable4 dot1dBase_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define DOT1DBASEBRIDGEADDRESS      1
    {DOT1DBASEBRIDGEADDRESS, ASN_OCTET_STR, RONLY, var_dot1dBase, 1, {1}},
#define DOT1DBASENUMPORTS       2
    {DOT1DBASENUMPORTS, ASN_INTEGER, RONLY, var_dot1dBase, 1, {2}},
#define DOT1DBASETYPE       3
    {DOT1DBASETYPE, ASN_INTEGER, RONLY, var_dot1dBase, 1, {3}},

#define DOT1DBASEPORT       4
    {DOT1DBASEPORT, ASN_INTEGER, RONLY, var_dot1dBasePortTable, 3, {4, 1, 1}},
#define DOT1DBASEPORTIFINDEX        5
    {DOT1DBASEPORTIFINDEX, ASN_INTEGER, RONLY, var_dot1dBasePortTable, 3, {4, 1, 2}},
#define DOT1DBASEPORTCIRCUIT        6
    {DOT1DBASEPORTCIRCUIT, ASN_OBJECT_ID, RONLY, var_dot1dBasePortTable, 3, {4, 1, 3}},
#define DOT1DBASEPORTDELAYEXCEEDEDDISCARDS      7
    {DOT1DBASEPORTDELAYEXCEEDEDDISCARDS, ASN_COUNTER, RONLY, var_dot1dBasePortTable, 3, {4, 1, 4}},
#define DOT1DBASEPORTMTUEXCEEDEDDISCARDS        8
    {DOT1DBASEPORTMTUEXCEEDEDDISCARDS, ASN_COUNTER, RONLY, var_dot1dBasePortTable, 3, {4, 1, 5}},
};

/*
 * Initializes the dot1dBase module
 */
void
init_dot1dBase(void)
{
    // Register mibContextTable
    mibContextTable_register(dot1dBase_variables_oid,
                             sizeof(dot1dBase_variables_oid) / sizeof(oid),
                             "BRIDGE-MIB : dot1dBase");

    DEBUGMSGTL(("dot1dBase", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dBase", dot1dBase_variables, variable4,
                 dot1dBase_variables_oid);

    /* place any other initialization junk you need here */
}


static void get_dot1dBaseNumPorts(u_long *port_count_p)
{
    ulong          if_number = 0;
    dot1Port_info_t table_info;

    table_info.dot1port = 0;
    while (TRUE == dot1Port_get_next( &table_info )) {
        if_number++;
    }
    *port_count_p = if_number;
}


static int
get_dot1dBaseScalar(dot1dBase_scalar_t *scalar_entry)
{
    conf_board_t board_conf;

    (void)conf_mgmt_board_get(&board_conf);
    bcopy(board_conf.mac_address, scalar_entry->dot1dBaseBridgeAddress, 6);
    scalar_entry->dot1dBaseBridgeAddress_len = 6;
    get_dot1dBaseNumPorts((u_long *)&scalar_entry->dot1dBaseNumPorts);
    scalar_entry->dot1dBaseType = 2;

    return 0;
}

/*
 * var_dot1dBase():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_dot1dBase(struct variable *vp,
              oid     *name,
              size_t  *length,
              int     exact,
              size_t  *var_len,
              WriteMethod **write_method)
{
    dot1dBase_scalar_t dot1dBase_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (get_dot1dBaseScalar(&dot1dBase_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DBASEBRIDGEADDRESS: {
        memcpy(dot1dBase_global_ret.string_ret, dot1dBase_scalar_entry.dot1dBaseBridgeAddress, dot1dBase_scalar_entry.dot1dBaseBridgeAddress_len);
        *var_len = dot1dBase_scalar_entry.dot1dBaseBridgeAddress_len;
        return (u_char *) dot1dBase_global_ret.string_ret;
    }
    case DOT1DBASENUMPORTS: {
        dot1dBase_global_ret.long_ret = dot1dBase_scalar_entry.dot1dBaseNumPorts;
        *var_len = sizeof(dot1dBase_global_ret.long_ret);
        return (u_char *) &dot1dBase_global_ret.long_ret;
    }
    case DOT1DBASETYPE: {
        dot1dBase_global_ret.long_ret = dot1dBase_scalar_entry.dot1dBaseType;
        *var_len = sizeof(dot1dBase_global_ret.long_ret);
        return (u_char *) &dot1dBase_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dBase\n", vp->magic));
    }
    return NULL;
}

static BOOL update_dot1dBasePortTable_entry(vtss_isid_t isid, vtss_port_no_t port_idx, dot1dBasePortTable_entry_t *table_entry_p)
{
    vtss_port_counters_t counters;

    if (!msg_switch_exists(isid)) {
        /* if the interface not exist, the counters always equal 0 */
        return TRUE;
    }
    if (port_mgmt_counters_get(isid, port_idx, &counters) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->dot1dBasePortDelayExceededDiscards = 0;
    table_entry_p->dot1dBasePortMtuExceededDiscards   += counters.rmon.rx_etherStatsOversizePkts;

    return TRUE;
}

static int
getfirst_dot1dBasePortTableEntry(dot1dBasePortTable_entry_t *table_entry)
{
    iftable_info_t              ifIndex_info;
    dot1Port_info_t             dot1Port_info;

    dot1Port_info.dot1port = 0;

    if ( FALSE == dot1Port_get_next(&dot1Port_info) ) {
        return VTSS_RC_ERROR;
    }

    ifIndex_info.isid = dot1Port_info.isid;
    ifIndex_info.if_id = dot1Port_info.if_id;
    ifIndex_info.type = dot1Port_info.type;

    (void) ifIndex_get_by_interface(&ifIndex_info);

    table_entry->dot1dBasePort = dot1Port_info.dot1port;
    table_entry->dot1dBasePortIfIndex = ifIndex_info.ifIndex;
    memset(table_entry->dot1dBasePortCircuit, 0, MAX_OID_LEN);
    table_entry->dot1dBasePortCircuit_len = 2;

    if (FALSE == update_dot1dBasePortTable_entry(dot1Port_info.isid, dot1Port_info.if_id, table_entry)) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
get_dot1dBasePortTableEntry(dot1dBasePortTable_entry_t *table_entry, BOOL getnext)
{
    iftable_info_t           ifIndex_info;
    dot1Port_info_t          dot1Port_info;
    vtss_port_no_t           port_idx;
    aggr_mgmt_group_no_t     aggr_no;
    aggr_mgmt_group_member_t aggr_members;
    port_iter_t              pit;
    vtss_isid_t              isid = 0;
    dot1Port_info.dot1port = table_entry->dot1dBasePort;

    if (getnext) {
        if ( FALSE == dot1Port_get_next(&dot1Port_info) ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if ( FALSE == dot1Port_get(&dot1Port_info) ) {
            return VTSS_RC_ERROR;
        }
    }

    ifIndex_info.isid = dot1Port_info.isid;
    ifIndex_info.if_id = dot1Port_info.if_id;
    ifIndex_info.type = dot1Port_info.type;

    if (FALSE == ifIndex_get_by_interface(&ifIndex_info)) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1dBasePort = dot1Port_info.dot1port;
    table_entry->dot1dBasePortIfIndex = ifIndex_info.ifIndex;
    memset(table_entry->dot1dBasePortCircuit, 0, MAX_OID_LEN);
    table_entry->dot1dBasePortCircuit_len = 2;
    table_entry->dot1dBasePortDelayExceededDiscards = 0;
    table_entry->dot1dBasePortMtuExceededDiscards   = 0;

    switch (dot1Port_info.type) {
    case DOT1PORT_TYPE_PORT:
        if ( FALSE == update_dot1dBasePortTable_entry (dot1Port_info.isid, dot1Port_info.if_id, table_entry) ) {
            return VTSS_RC_ERROR;
        }
        break;
    case DOT1PORT_TYPE_LLAG:
        aggr_no = dot1Port_info.if_id;
        if ((aggr_mgmt_port_members_get(dot1Port_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(dot1Port_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)
#endif
           ) {

            /* get error mean that the aggr_no is LACP mode and no ports link up  */
            table_entry->dot1dBasePortIfIndex = ifIndex_info.ifIndex;
            table_entry->dot1dBasePortCircuit_len           = 2;
            table_entry->dot1dBasePortDelayExceededDiscards = 0;
            table_entry->dot1dBasePortMtuExceededDiscards   = 0 ;
            return VTSS_RC_OK;
        }

        for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_START + port_isid_port_count(dot1Port_info.isid); port_idx++) {
            if (!aggr_members.entry.member[port_idx]) {
                continue;
            }
            if (update_dot1dBasePortTable_entry(dot1Port_info.isid, port_idx, table_entry) == FALSE) {
                return VTSS_RC_ERROR;
            }
        }
        break;
    case DOT1PORT_TYPE_GLAG:
        aggr_no = dot1Port_info.if_id;
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, aggr_no, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_dot1dBasePortTable_entry(isid, pit.iport, table_entry) == FALSE) {
                    return FALSE;
                }
            }
        }

        break;
    default:
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
parse_dot1dBasePortTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         dot1dBasePortTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dBasePortTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dBasePortTable(oid     *name,
                           size_t  *length,
                           dot1dBasePortTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dBasePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dBase above.
 */
u_char *
var_dot1dBasePortTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1dBasePortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1dBasePortTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1dBasePortTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dBasePortTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dBasePortTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DBASEPORT: {
        dot1dBase_global_ret.long_ret = table_entry.dot1dBasePort;
        *var_len = sizeof(dot1dBase_global_ret.long_ret);
        return (u_char *) &dot1dBase_global_ret.long_ret;
    }
    case DOT1DBASEPORTIFINDEX: {
        dot1dBase_global_ret.long_ret = table_entry.dot1dBasePortIfIndex;
        *var_len = sizeof(dot1dBase_global_ret.long_ret);
        return (u_char *) &dot1dBase_global_ret.long_ret;
    }
    case DOT1DBASEPORTCIRCUIT: {
        memcpy(dot1dBase_global_ret.objid_ret, table_entry.dot1dBasePortCircuit, table_entry.dot1dBasePortCircuit_len * sizeof(oid));
        *var_len = table_entry.dot1dBasePortCircuit_len * sizeof(oid);
        return (u_char *) dot1dBase_global_ret.objid_ret;
    }
    case DOT1DBASEPORTDELAYEXCEEDEDDISCARDS: {
        dot1dBase_global_ret.ulong_ret = table_entry.dot1dBasePortDelayExceededDiscards;
        *var_len = sizeof(dot1dBase_global_ret.ulong_ret);
        return (u_char *) &dot1dBase_global_ret.ulong_ret;
    }
    case DOT1DBASEPORTMTUEXCEEDEDDISCARDS: {
        dot1dBase_global_ret.ulong_ret = table_entry.dot1dBasePortMtuExceededDiscards;
        *var_len = sizeof(dot1dBase_global_ret.ulong_ret);
        return (u_char *) &dot1dBase_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dBasePortTable\n", vp->magic));
    }
    return NULL;
}
#endif /* RFC4188_SUPPORTED_DOT1DBASE */


#ifdef RFC4188_SUPPORTED_DOT1DTP
//-----------------------------------------------------------------------------
// dot1dTp
//-----------------------------------------------------------------------------
/*
 * The entry data structure for dot1dTpLearnedEntryDiscards
 */
typedef struct {
    u_long             dot1dTpLearnedEntryDiscards;
    long             dot1dTpAgingTime;
} dot1dTp_scalar_t;

/*
 * The entry data structure for dot1dTpFdbTable
 */
typedef struct {
    /* Entry keys */
    char             dot1dTpFdbAddress[6];
    size_t              dot1dTpFdbAddress_len;

    /* Entry columns */
    long             dot1dTpFdbPort;
    long             dot1dTpFdbStatus;
} dot1dTpFdbTable_entry_t;
/*
 * The entry data structure for dot1dTpPortTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dTpPort;

    /* Entry columns */
    long             dot1dTpPortMaxInfo;
    u_long             dot1dTpPortInFrames;
    u_long             dot1dTpPortOutFrames;
    u_long             dot1dTpPortInDiscards;
} dot1dTpPortTable_entry_t;
/*
 * The entry data structure for dot1dTpHCPortTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dTpPort;

    /* Entry columns */
    struct counter64    dot1dTpHCPortInFrames;
    struct counter64    dot1dTpHCPortOutFrames;
    struct counter64    dot1dTpHCPortInDiscards;
} dot1dTpHCPortTable_entry_t;
/*
 * The entry data structure for dot1dTpPortOverflowTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dTpPort;

    /* Entry columns */
    u_long             dot1dTpPortInOverflowFrames;
    u_long             dot1dTpPortOutOverflowFrames;
    u_long             dot1dTpPortInOverflowDiscards;
} dot1dTpPortOverflowTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SPRINT_MAX_LEN];
    struct counter64    c64_ret;
    u_long              ulong_ret;
} dot1dTp_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, dot1dTp_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static dot1dTp_return_t dot1dTp_global_ret; /* static variables for retuning */

/*
 * dot1dTp_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dTp_variables_oid[] = {1, 3, 6, 1, 2, 1, 17, 4};



/*
 * variable dot1dTp_variables:
 *   this variable defines function callbacks and type return information
 *   for the dot1dTp mib section
 */

struct variable4 dot1dTp_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#define DOT1DTPLEARNEDENTRYDISCARDS     1
//Not implement yet
//{DOT1DTPLEARNEDENTRYDISCARDS, ASN_COUNTER, RONLY, var_dot1dTp, 1, {1}},
#define DOT1DTPAGINGTIME        2
//Not implement yet
    {DOT1DTPAGINGTIME, ASN_INTEGER, RWRITE, var_dot1dTp, 1, {2}},

#define DOT1DTPFDBADDRESS       3
    {DOT1DTPFDBADDRESS, ASN_OCTET_STR, RONLY, var_dot1dTpFdbTable, 3, {3, 1, 1}},
#define DOT1DTPFDBPORT      4
    {DOT1DTPFDBPORT, ASN_INTEGER, RONLY, var_dot1dTpFdbTable, 3, {3, 1, 2}},
#define DOT1DTPFDBSTATUS        5
    {DOT1DTPFDBSTATUS, ASN_INTEGER, RONLY, var_dot1dTpFdbTable, 3, {3, 1, 3}},
#define DOT1DTPPORT     6
    {DOT1DTPPORT, ASN_INTEGER, RONLY, var_dot1dTpPortTable, 3, {4, 1, 1}},
#define DOT1DTPPORTMAXINFO      7
    {DOT1DTPPORTMAXINFO, ASN_INTEGER, RONLY, var_dot1dTpPortTable, 3, {4, 1, 2}},
#define DOT1DTPPORTINFRAMES     8
    {DOT1DTPPORTINFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortTable, 3, {4, 1, 3}},
#define DOT1DTPPORTOUTFRAMES        9
    {DOT1DTPPORTOUTFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortTable, 3, {4, 1, 4}},
#define DOT1DTPPORTINDISCARDS       10
    {DOT1DTPPORTINDISCARDS, ASN_COUNTER, RONLY, var_dot1dTpPortTable, 3, {4, 1, 5}},
#if 0
#define DOT1DTPHCPORTINFRAMES       11
    {DOT1DTPHCPORTINFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 1}},
#define DOT1DTPHCPORTOUTFRAMES      12
    {DOT1DTPHCPORTOUTFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 2}},
#define DOT1DTPHCPORTINDISCARDS     13
    {DOT1DTPHCPORTINDISCARDS, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 3}},
#define DOT1DTPPORTINOVERFLOWFRAMES     14
    {DOT1DTPPORTINOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 1}},
#define DOT1DTPPORTOUTOVERFLOWFRAMES        15
    {DOT1DTPPORTOUTOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 2}},
#define DOT1DTPPORTINOVERFLOWDISCARDS       16
    {DOT1DTPPORTINOVERFLOWDISCARDS, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 3}},
#endif
};

/*
 * Initializes the dot1dTp module
 */
void
init_dot1dTp(void)
{
    // Register mibContextTable
    mibContextTable_register(dot1dTp_variables_oid,
                             sizeof(dot1dTp_variables_oid) / sizeof(oid),
                             "BRIDGE-MIB : dot1dTp");

    DEBUGMSGTL(("dot1dTp", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dTp", dot1dTp_variables, variable4,
                 dot1dTp_variables_oid);

    /* place any other initialization junk you need here */
}


static int
get_dot1dTpScalar(dot1dTp_scalar_t *scalar_entry)
{
    mac_age_conf_t age_conf;

    age_conf.mac_age_time = 0;
    if ( VTSS_RC_OK != mac_mgmt_age_time_get(&age_conf) ) {
        return VTSS_RC_ERROR;
    }

    scalar_entry->dot1dTpAgingTime = age_conf.mac_age_time;
    /* dot1dTpLearnedEntryDiscards is not supported yet */
    scalar_entry->dot1dTpLearnedEntryDiscards = 0;

    return VTSS_RC_OK;
}

static int
set_dot1dTpScalar(dot1dTp_scalar_t *scalar_entry)
{
    mac_age_conf_t age_conf;

    if ( VTSS_RC_OK != mac_mgmt_age_time_get(&age_conf) ) {
        return VTSS_RC_ERROR;
    }
    age_conf.mac_age_time = scalar_entry->dot1dTpAgingTime;

    if ( VTSS_RC_OK != mac_mgmt_age_time_set(&age_conf) ) {
        return VTSS_RC_ERROR;
    }

    return 0;
}
/*
 * var_dot1dTp():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_dot1dTp(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    dot1dTp_scalar_t dot1dTp_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (get_dot1dTpScalar(&dot1dTp_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPLEARNEDENTRYDISCARDS: {
        dot1dTp_global_ret.ulong_ret = dot1dTp_scalar_entry.dot1dTpLearnedEntryDiscards;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    case DOT1DTPAGINGTIME: {
        *write_method = write_dot1dTpAgingTime;
        dot1dTp_global_ret.long_ret = dot1dTp_scalar_entry.dot1dTpAgingTime;
        *var_len = sizeof(dot1dTp_global_ret.long_ret);
        return (u_char *) &dot1dTp_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dTp\n", vp->magic));
    }
    return NULL;
}

static int FdbCompareFunc (void *mac1, void *mac2)
{
    return memcmp(mac1, mac2, 6);
}

static int get_next_dot1dTpFdbTableEntry_by_mac (vtss_vid_mac_t *vid_mac)
{
    mac_mgmt_table_stack_t  tmp, buf;
    vlan_mgmt_entry_t       vlan_mgmt_entry;
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_addr_type_t    mac_type;

    memset(&vid_mac_in, 0, sizeof(vtss_vid_mac_t));
    memset(&tmp, 0, sizeof(mac_mgmt_table_stack_t));
    memset(&vlan_mgmt_entry, 0, sizeof(vlan_mgmt_entry_t));
    memset(&mac_type, 0, sizeof(mac_type));
    BOOL found = FALSE;

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

next_vid:
    while ( VTSS_OK == vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_mgmt_entry.vid, &vlan_mgmt_entry, TRUE, VLAN_USER_ALL)) {
        /* get  the first MAC entry in the specific VLAN ID */

        vid_mac_in.vid = vlan_mgmt_entry.vid;
        memcpy(vid_mac_in.mac.addr, vid_mac->mac.addr, 6);

        if (mac_mgmt_stack_get_next(&vid_mac_in, &buf, &mac_type, TRUE) != VTSS_OK || vid_mac_in.vid != buf.vid_mac.vid ) {
            T_D("next vid");
            goto next_vid;
        }

        while (FdbCompareFunc (buf.vid_mac.mac.addr, vid_mac->mac.addr) <= 0) {
            T_D("next mac");
            memcpy(vid_mac_in.mac.addr, buf.vid_mac.mac.addr, 6);
            if (mac_mgmt_stack_get_next(&vid_mac_in, &buf, &mac_type, TRUE) != VTSS_OK  || vid_mac_in.vid != buf.vid_mac.vid) {
                goto next_vid;
            }
            continue;
        }


        found = TRUE;


        if ( FdbCompareFunc(tmp.vid_mac.mac.addr, buf.vid_mac.mac.addr) > 0 || FdbCompareFunc(tmp.vid_mac.mac.addr, vid_mac->mac.addr) <= 0 ) {
            memcpy(&tmp, &buf, sizeof(mac_mgmt_table_stack_t));
            tmp.vid_mac.vid = buf.vid_mac.vid;
        }


    }

    if ( TRUE == found ) {
        memcpy(vid_mac->mac.addr, tmp.vid_mac.mac.addr, 6);
        vid_mac->vid = tmp.vid_mac.vid;
    } else {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;

}

static int get_dot1dTpFdbTableEntry_by_mac (vtss_vid_mac_t *vid_mac)
{
    vtss_vid_mac_t buf;
    unsigned char *ptr =  buf.mac.addr;
    int i = 0;
    memcpy(ptr, vid_mac->mac.addr, 6);

    for (i = 5; i >= 0; i-- ) {
        if (*(ptr + i) != 0x0 ) {
            --*(ptr + i);
            break;
        } else {
            *(ptr + i) = 0xff;
        }
    }

    if (get_next_dot1dTpFdbTableEntry_by_mac(&buf) != VTSS_RC_OK || memcmp(ptr, vid_mac->mac.addr, 6)) {
        return VTSS_RC_ERROR;
    }

    memcpy(vid_mac->mac.addr, ptr, 6);
    vid_mac->vid = buf.vid;
    return VTSS_RC_OK;
}

void get_TpFdbPort_by_port( vtss_isid_t isid, vtss_port_no_t iport, long *tpFdbPort)
{
    dot1Port_info_t             info;
    aggr_mgmt_group_member_t    aggr_members;
    BOOL                        found = FALSE;
    aggr_mgmt_group_no_t        tmp_aggr;

    for (tmp_aggr = AGGR_MGMT_GROUP_NO_START; tmp_aggr < AGGR_MGMT_GROUP_NO_END; tmp_aggr++) {
        if ((aggr_mgmt_port_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {

            continue;
        }
        if (aggr_members.entry.member[iport] == TRUE) {
            found = TRUE;
            break;
        }
    }


    info.isid = isid;
    if ( FALSE == found ) {
        info.if_id = iport;
        info.type = DOT1PORT_TYPE_PORT;
    } else {
        info.if_id = tmp_aggr;
        info.type = AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr) ? DOT1PORT_TYPE_GLAG : DOT1PORT_TYPE_LLAG;
    }
//    T_E("info.isid = %d, info.if_id = %d, info.type = %d", info.isid, info.if_id, info.type);
    (void) dot1Port_get_by_interface(&info);
//    T_E("info.dot1port = %d", info.dot1port);

    *tpFdbPort = info.dot1port;
}

static int
getfirst_dot1dTpFdbTableEntry(dot1dTpFdbTable_entry_t *table_entry)
{
    int                     learned = 0;
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    vtss_mac_table_entry_t  isid_mac_entry;
    port_iter_t             pit;
    switch_iter_t           sit;
    vtss_isid_t             isid;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));
    memset(&mac_type, 0, sizeof(mac_type));
#if 0
    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;
#endif

    if (VTSS_RC_OK != get_next_dot1dTpFdbTableEntry_by_mac(&vid_mac_in)) {
        return VTSS_RC_ERROR;
    }

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, FALSE) == VTSS_OK) {
        memcpy(table_entry->dot1dTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1dTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    learned = 1;
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
                    if (vtss_stacking_enabled()) {
                        isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
                    } else {
                        isid = sit.isid;
                    }
#else
                    isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */
                    get_TpFdbPort_by_port(isid, pit.iport, &table_entry->dot1dTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->dot1dTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->dot1dTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->dot1dTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->dot1dTpFdbStatus = 1;    /* other   */
        }
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
get_dot1dTpFdbTableEntry(dot1dTpFdbTable_entry_t *table_entry, BOOL getnext)
{
    int                     learned = 0;
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    port_iter_t             pit;
    switch_iter_t           sit;
    vtss_isid_t             isid;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));
    memset(&mac_type, 0, sizeof(mac_type));
#if 0
    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;
#endif

    memcpy(vid_mac_in.mac.addr, table_entry->dot1dTpFdbAddress, 6);

    if (getnext) {
        if ( VTSS_RC_OK != get_next_dot1dTpFdbTableEntry_by_mac(&vid_mac_in) ) {
            return VTSS_RC_ERROR;
        }

    } else {
        if ( VTSS_RC_OK != get_dot1dTpFdbTableEntry_by_mac(&vid_mac_in) ) {
            return VTSS_RC_ERROR;
        }

    }

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, FALSE) == VTSS_OK) {
        memcpy(table_entry->dot1dTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);

        table_entry->dot1dTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    learned = 1;
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
                    if (vtss_stacking_enabled()) {
                        isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
                    } else {
                        isid = sit.isid;
                    }
#else
                    isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */
                    get_TpFdbPort_by_port(isid, pit.iport, &table_entry->dot1dTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->dot1dTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->dot1dTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->dot1dTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->dot1dTpFdbStatus = 1;    /* other   */
        }
        return 0;
    } else {
        return 1;
    }
}

static int
parse_dot1dTpFdbTable(oid     *name,
                      size_t  *length,
                      int     exact,
                      dot1dTpFdbTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTpFdbTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    len = 6;
    table_entry->dot1dTpFdbAddress_len = (char) len;
    cp = (u_char *)table_entry->dot1dTpFdbAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTpFdbTable(oid     *name,
                        size_t  *length,
                        dot1dTpFdbTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;
    int     len = 0, idx = 0;

    len = (int) table_entry->dot1dTpFdbAddress_len;
    while (len-- > 0) {
        name[name_pos++] = (u_char) table_entry->dot1dTpFdbAddress[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTpFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dTp above.
 */
u_char *
var_dot1dTpFdbTable(struct variable *vp,
                    oid     *name,
                    size_t  *length,
                    int     exact,
                    size_t  *var_len,
                    WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1dTpFdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1dTpFdbTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1dTpFdbTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTpFdbTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTpFdbTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPFDBADDRESS: {
        memcpy(dot1dTp_global_ret.string_ret, table_entry.dot1dTpFdbAddress, 6);
        *var_len = 6;
        return (u_char *) dot1dTp_global_ret.string_ret;
    }
    case DOT1DTPFDBPORT: {
        dot1dTp_global_ret.long_ret = table_entry.dot1dTpFdbPort;
        *var_len = sizeof(dot1dTp_global_ret.long_ret);
        return (u_char *) &dot1dTp_global_ret.long_ret;
    }
    case DOT1DTPFDBSTATUS: {
        dot1dTp_global_ret.long_ret = table_entry.dot1dTpFdbStatus;
        *var_len = sizeof(dot1dTp_global_ret.long_ret);
        return (u_char *) &dot1dTp_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dTpFdbTable\n", vp->magic));
    }
    return NULL;
}

static BOOL update_dot1dTpPortTable_entry(vtss_isid_t isid, vtss_port_no_t port_idx, dot1dTpPortTable_entry_t *table_entry_p)
{
    vtss_port_counters_t counters;
    port_conf_t              port_conf;
    if (!msg_switch_exists(isid)) {
        /* if the interface not exist, the counters always equal 0 */
        return TRUE;
    }

    if (port_mgmt_counters_get(isid, port_idx, &counters) != VTSS_OK) {
        return FALSE;
    }

    if (port_mgmt_conf_get(isid, port_idx, &port_conf) != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->dot1dTpPortMaxInfo     = !table_entry_p->dot1dTpPortMaxInfo ? (long)port_conf.max_length :
                                            (table_entry_p->dot1dTpPortMaxInfo >= (long)port_conf.max_length) ? table_entry_p->dot1dTpPortMaxInfo : (long)port_conf.max_length;
    table_entry_p->dot1dTpPortInFrames   += counters.rmon.rx_etherStatsPkts;
    table_entry_p->dot1dTpPortOutFrames  += counters.rmon.tx_etherStatsPkts;
    table_entry_p->dot1dTpPortInDiscards  += counters.if_group.ifInDiscards;

    return TRUE;
}

static int
getfirst_dot1dTpPortTableEntry(dot1dTpPortTable_entry_t *table_entry)
{
    dot1Port_info_t              table_info;
    table_info.dot1port = 0;
    if ( FALSE == dot1Port_get_next(&table_info) ) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1dTpPort = table_info.dot1port;
    if ( FALSE == update_dot1dTpPortTable_entry (table_info.isid, table_info.if_id, table_entry) ) {
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
get_dot1dTpPortTableEntry(dot1dTpPortTable_entry_t *table_entry, BOOL getnext)
{
    vtss_port_no_t              port_idx;
    aggr_mgmt_group_no_t        aggr_no;
    aggr_mgmt_group_member_t    aggr_members;
    dot1Port_info_t             table_info;
    port_iter_t              pit;
    vtss_isid_t              isid = 0;

    table_info.dot1port = table_entry->dot1dTpPort;
    if (getnext) {
        if ( FALSE == dot1Port_get_next(&table_info) ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if ( FALSE == dot1Port_get(&table_info) ) {
            return VTSS_RC_ERROR;
        }
    }

    table_entry->dot1dTpPort = table_info.dot1port;
    table_entry->dot1dTpPortMaxInfo = 0;

    switch (table_info.type) {
    case DOT1PORT_TYPE_PORT:
        if ( FALSE == update_dot1dTpPortTable_entry (table_info.isid, table_info.if_id, table_entry) ) {
            return VTSS_RC_ERROR;
        }
        break;
    case DOT1PORT_TYPE_LLAG:
        aggr_no = table_info.if_id;

#ifdef VTSS_SW_OPTION_LACP
        /* if the aggr_no is LACP mode and no ports up in the LACP ID, Operation status is down */
        if ((aggr_mgmt_port_members_get(table_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)
            && (aggr_mgmt_lacp_members_get(table_info.isid, aggr_no, &aggr_members, FALSE) != VTSS_OK)) {

            table_entry->dot1dTpPortMaxInfo  = 1518;
            table_entry->dot1dTpPortInFrames   = 0;
            table_entry->dot1dTpPortOutFrames  = 0;
            table_entry->dot1dTpPortInDiscards = 0;
            return VTSS_RC_OK;
        }
#endif

        for (port_idx = VTSS_PORT_NO_START; port_idx < VTSS_PORT_NO_START + port_isid_port_count(table_info.isid); port_idx++) {
            if (!aggr_members.entry.member[port_idx]) {
                continue;
            }
            if (update_dot1dTpPortTable_entry(table_info.isid, port_idx, table_entry) == FALSE) {
                return VTSS_RC_ERROR;
            }
        }
        break;
    case DOT1PORT_TYPE_GLAG:
        aggr_no = table_info.if_id;
        for (isid = VTSS_ISID_START; isid < VTSS_ISID_END; isid++) {
            if (!msg_switch_exists(isid)) {
                continue;
            }

            if (aggr_mgmt_port_members_get(isid, aggr_no, &aggr_members, FALSE) != VTSS_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (!aggr_members.entry.member[pit.iport]) {
                    continue;
                }
                if (update_dot1dTpPortTable_entry(isid, pit.iport, table_entry) == FALSE) {
                    return FALSE;
                }
            }
        }
        break;

    default:
        return VTSS_RC_ERROR;
    }

    return VTSS_RC_OK;
}

static int
parse_dot1dTpPortTable(oid     *name,
                       size_t  *length,
                       int     exact,
                       dot1dTpPortTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTpPortTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dTpPort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTpPortTable(oid     *name,
                         size_t  *length,
                         dot1dTpPortTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->dot1dTpPort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dTp above.
 */
u_char *
var_dot1dTpPortTable(struct variable *vp,
                     oid     *name,
                     size_t  *length,
                     int     exact,
                     size_t  *var_len,
                     WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1dTpPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1dTpPortTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1dTpPortTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTpPortTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTpPortTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPPORT: {
        dot1dTp_global_ret.long_ret = table_entry.dot1dTpPort;
        *var_len = sizeof(dot1dTp_global_ret.long_ret);
        return (u_char *) &dot1dTp_global_ret.long_ret;
    }
    case DOT1DTPPORTMAXINFO: {
        dot1dTp_global_ret.long_ret = table_entry.dot1dTpPortMaxInfo;
        *var_len = sizeof(dot1dTp_global_ret.long_ret);
        return (u_char *) &dot1dTp_global_ret.long_ret;
    }
    case DOT1DTPPORTINFRAMES: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortInFrames;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    case DOT1DTPPORTOUTFRAMES: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortOutFrames;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    case DOT1DTPPORTINDISCARDS: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortInDiscards;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dTpPortTable\n", vp->magic));
    }
    return NULL;
}

#if 0
static int
getfirst_dot1dTpHCPortTableEntry(dot1dTpHCPortTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1dTpHCPortTableEntry(dot1dTpHCPortTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1dTpHCPortTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         dot1dTpHCPortTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTpHCPortTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->dot1dTpPort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTpHCPortTable(oid     *name,
                           size_t  *length,
                           dot1dTpHCPortTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->dot1dTpPort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTpHCPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dTp above.
 */
u_char *
var_dot1dTpHCPortTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1dTpHCPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1dTpHCPortTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1dTpHCPortTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTpHCPortTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTpHCPortTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPHCPORTINFRAMES: {
        dot1dTp_global_ret.c64_ret = table_entry.dot1dTpHCPortInFrames;
        *var_len = sizeof(dot1dTp_global_ret.c64_ret);
        return (u_char *) &dot1dTp_global_ret.c64_ret;
    }
    case DOT1DTPHCPORTOUTFRAMES: {
        dot1dTp_global_ret.c64_ret = table_entry.dot1dTpHCPortOutFrames;
        *var_len = sizeof(dot1dTp_global_ret.c64_ret);
        return (u_char *) &dot1dTp_global_ret.c64_ret;
    }
    case DOT1DTPHCPORTINDISCARDS: {
        dot1dTp_global_ret.c64_ret = table_entry.dot1dTpHCPortInDiscards;
        *var_len = sizeof(dot1dTp_global_ret.c64_ret);
        return (u_char *) &dot1dTp_global_ret.c64_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dTpHCPortTable\n", vp->magic));
    }
    return NULL;
}
static int
getfirst_dot1dTpPortOverflowTableEntry(dot1dTpPortOverflowTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1dTpPortOverflowTableEntry(dot1dTpPortOverflowTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1dTpPortOverflowTable(oid     *name,
                               size_t  *length,
                               int     exact,
                               dot1dTpPortOverflowTable_entry_t *table_entry)
{
    size_t  op_pos = 9 + 2;
    oid     *op = (oid *)(name + op_pos);

    if (exact && *length < (9 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1dTpPortOverflowTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    memset(table_entry, 0, sizeof(*table_entry));
    if (*length > op_pos) {
        table_entry->dot1dTpPort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1dTpPortOverflowTable(oid     *name,
                                 size_t  *length,
                                 dot1dTpPortOverflowTable_entry_t *table_entry)
{
    int     name_pos = 9 + 2;

    name[name_pos++] = (oid) table_entry->dot1dTpPort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1dTpPortOverflowTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_dot1dTp above.
 */
u_char *
var_dot1dTpPortOverflowTable(struct variable *vp,
                             oid     *name,
                             size_t  *length,
                             int     exact,
                             size_t  *var_len,
                             WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1dTpPortOverflowTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1dTpPortOverflowTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1dTpPortOverflowTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1dTpPortOverflowTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1dTpPortOverflowTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1DTPPORTINOVERFLOWFRAMES: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortInOverflowFrames;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    case DOT1DTPPORTOUTOVERFLOWFRAMES: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortOutOverflowFrames;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    case DOT1DTPPORTINOVERFLOWDISCARDS: {
        dot1dTp_global_ret.ulong_ret = table_entry.dot1dTpPortInOverflowDiscards;
        *var_len = sizeof(dot1dTp_global_ret.ulong_ret);
        return (u_char *) &dot1dTp_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1dTpPortOverflowTable\n", vp->magic));
    }
    return NULL;
}
#endif

int
write_dot1dTpAgingTime(int      action,
                       u_char   *var_val,
                       u_char   var_val_type,
                       size_t   var_val_len,
                       u_char   *statP,
                       oid      *name,
                       size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1dTp_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1dTpAgingTime: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1dTpAgingTime: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1dTpScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1dTpAgingTime = set_value;
        if (set_dot1dTpScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}
#endif /* RFC4188_SUPPORTED_DOT1DTP */


/*
 * Initializes the dot1dBridge module
 */
void
init_dot1dBridge(void)
{
    init_dot1dBase();
    init_dot1dTp();
}

