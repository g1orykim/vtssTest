/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <main.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h> /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h> /* utility function declarations */
#include "rfc2674_q_bridge.h"

#include "msg_api.h"
#include "misc_api.h"
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
#include "topo_api.h"
#endif

/* +++ Start (Internal implementation declarations) */
#include "vlan_api.h"
#include "mac_api.h"
#include "dot1Port_api.h"
#include "mibContextTable.h"  //mibContextTable_register
/* --- End (Internal implementation declarations) */


#define VTSS_TRACE_MODULE_ID VTSS_MODULE_ID_SNMP
/*
 * The entry data structure for dot1qVlanVersionNumber
 */
typedef struct {
    long             dot1qVlanVersionNumber;
    long             dot1qMaxVlanId;
    u_long             dot1qMaxSupportedVlans;
    u_long             dot1qNumVlans;
    long             dot1qGvrpStatus;
} dot1qBase_scalar_t;

/*
 * The entry data structure for dot1qVlanNumDeletes
 */
typedef struct {
    u_long             dot1qVlanNumDeletes;
    long             dot1qNextFreeLocalVlanIndex;
    long             dot1qConstraintSetDefault;
    long             dot1qConstraintTypeDefault;
} dot1qVlan_scalar_t;

/*
 * The entry data structure for dot1qFdbTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qFdbId;

    /* Entry columns */
    u_long             dot1qFdbDynamicCount;
} dot1qFdbTable_entry_t;
/*
 * The entry data structure for dot1qTpFdbTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qFdbId;
    char             dot1qTpFdbAddress[6];
    size_t              dot1qTpFdbAddress_len;

    /* Entry columns */
    long             dot1qTpFdbPort;
    long             dot1qTpFdbStatus;
} dot1qTpFdbTable_entry_t;
/*
 * The entry data structure for dot1qTpGroupTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanIndex;
    char             dot1qTpGroupAddress[6];
    size_t              dot1qTpGroupAddress_len;

    /* Entry columns */
    char             dot1qTpGroupEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qTpGroupEgressPorts_len;
    char             dot1qTpGroupLearnt[SPRINT_MAX_LEN];
    size_t              dot1qTpGroupLearnt_len;
} dot1qTpGroupTable_entry_t;
/*
 * The entry data structure for dot1qForwardAllTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanIndex;

    /* Entry columns */
    char             dot1qForwardAllPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardAllPorts_len;
    char             dot1qForwardAllStaticPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardAllStaticPorts_len;
    char             dot1qForwardAllForbiddenPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardAllForbiddenPorts_len;
} dot1qForwardAllTable_entry_t;
/*
 * The entry data structure for dot1qForwardUnregisteredTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanIndex;

    /* Entry columns */
    char             dot1qForwardUnregisteredPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardUnregisteredPorts_len;
    char             dot1qForwardUnregisteredStaticPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardUnregisteredStaticPorts_len;
    char             dot1qForwardUnregisteredForbiddenPorts[SPRINT_MAX_LEN];
    size_t              dot1qForwardUnregisteredForbiddenPorts_len;
} dot1qForwardUnregisteredTable_entry_t;
/*
 * The entry data structure for dot1qStaticUnicastTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qFdbId;
    char             dot1qStaticUnicastAddress[6];
    size_t              dot1qStaticUnicastAddress_len;
    long           dot1qStaticUnicastReceivePort;

    /* Entry columns */
    char             dot1qStaticUnicastAllowedToGoTo[SPRINT_MAX_LEN];
    size_t              dot1qStaticUnicastAllowedToGoTo_len;
    long             dot1qStaticUnicastStatus;
} dot1qStaticUnicastTable_entry_t;
/*
 * The entry data structure for dot1qStaticMulticastTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanIndex;
    char             dot1qStaticMulticastAddress[6];
    size_t              dot1qStaticMulticastAddress_len;
    long           dot1qStaticMulticastReceivePort;

    /* Entry columns */
    char             dot1qStaticMulticastStaticEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qStaticMulticastStaticEgressPorts_len;
    char             dot1qStaticMulticastForbiddenEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qStaticMulticastForbiddenEgressPorts_len;
    long             dot1qStaticMulticastStatus;
} dot1qStaticMulticastTable_entry_t;
/*
 * The entry data structure for dot1qVlanCurrentTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanTimeMark;
    u_long           dot1qVlanIndex;

    /* Entry columns */
    u_long             dot1qVlanFdbId;
    char             dot1qVlanCurrentEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qVlanCurrentEgressPorts_len;
    char             dot1qVlanCurrentUntaggedPorts[SPRINT_MAX_LEN];
    size_t              dot1qVlanCurrentUntaggedPorts_len;
    long             dot1qVlanStatus;
    u_long             dot1qVlanCreationTime;
} dot1qVlanCurrentTable_entry_t;
/*
 * The entry data structure for dot1qVlanStaticTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qVlanIndex;

    /* Entry columns */
    char             dot1qVlanStaticName[SPRINT_MAX_LEN];
    size_t              dot1qVlanStaticName_len;
    char             dot1qVlanStaticEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qVlanStaticEgressPorts_len;
    char             dot1qVlanForbiddenEgressPorts[SPRINT_MAX_LEN];
    size_t              dot1qVlanForbiddenEgressPorts_len;
    char             dot1qVlanStaticUntaggedPorts[SPRINT_MAX_LEN];
    size_t              dot1qVlanStaticUntaggedPorts_len;
    long             dot1qVlanStaticRowStatus;
} dot1qVlanStaticTable_entry_t;
/*
 * The entry data structure for dot1qPortVlanTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dBasePort;

    /* Entry columns */
    u_long             dot1qPvid;
    long             dot1qPortAcceptableFrameTypes;
    long             dot1qPortIngressFiltering;
    long             dot1qPortGvrpStatus;
    u_long             dot1qPortGvrpFailedRegistrations;
    char             dot1qPortGvrpLastPduOrigin[6];
    size_t              dot1qPortGvrpLastPduOrigin_len;
    long             dot1qPortRestrictedVlanRegistration;
} dot1qPortVlanTable_entry_t;
/*
 * The entry data structure for dot1qPortVlanStatisticsTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dBasePort;
    u_long           dot1qVlanIndex;

    /* Entry columns */
    u_long             dot1qTpVlanPortInFrames;
    u_long             dot1qTpVlanPortOutFrames;
    u_long             dot1qTpVlanPortInDiscards;
    u_long             dot1qTpVlanPortInOverflowFrames;
    u_long             dot1qTpVlanPortOutOverflowFrames;
    u_long             dot1qTpVlanPortInOverflowDiscards;
} dot1qPortVlanStatisticsTable_entry_t;
/*
 * The entry data structure for dot1qPortVlanHCStatisticsTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dBasePort;
    u_long           dot1qVlanIndex;

    /* Entry columns */
    struct counter64    dot1qTpVlanPortHCInFrames;
    struct counter64    dot1qTpVlanPortHCOutFrames;
    struct counter64    dot1qTpVlanPortHCInDiscards;
} dot1qPortVlanHCStatisticsTable_entry_t;
/*
 * The entry data structure for dot1qLearningConstraintsTable
 */
typedef struct {
    /* Entry keys */
    u_long           dot1qConstraintVlan;
    long           dot1qConstraintSet;

    /* Entry columns */
    long             dot1qConstraintType;
    long             dot1qConstraintStatus;
} dot1qLearningConstraintsTable_entry_t;
/*
 * The entry data structure for dot1vProtocolGroupTable
 */
typedef struct {
    /* Entry keys */
    long           dot1vProtocolTemplateFrameType;
    char             dot1vProtocolTemplateProtocolValue[SPRINT_MAX_LEN];
    size_t              dot1vProtocolTemplateProtocolValue_len;

    /* Entry columns */
    long             dot1vProtocolGroupId;
    long             dot1vProtocolGroupRowStatus;
} dot1vProtocolGroupTable_entry_t;
/*
 * The entry data structure for dot1vProtocolPortTable
 */
typedef struct {
    /* Entry keys */
    long           dot1dBasePort;
    long           dot1vProtocolPortGroupId;

    /* Entry columns */
    long             dot1vProtocolPortGroupVid;
    long             dot1vProtocolPortRowStatus;
} dot1vProtocolPortTable_entry_t;

/*
 * The return data structure
 */
typedef struct {
    long                long_ret;
    char                string_ret[SPRINT_MAX_LEN];
    struct counter64    c64_ret;
    u_long              ulong_ret;
} qBridgeMIB_return_t;

/*
 * The UCD-SNMP engine need a address point for processing get opertion
 */
/*lint -esym(459, qBridgeMIB_global_ret) */ /* Process one packet at the same time, therefore unprotected access is acceptable */
static qBridgeMIB_return_t qBridgeMIB_global_ret; /* static variables for retuning */

/*
 * qBridgeMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid qBridgeMIB_variables_oid[] = {1, 3, 6, 1, 2, 1, 17, 7};



/*
 * variable qBridgeMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the qBridgeMIB mib section
 */

struct variable7 qBridgeMIB_variables[] = {
    /*
     * magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if 0
#define DOT1QVLANVERSIONNUMBER      1
    {DOT1QVLANVERSIONNUMBER, ASN_INTEGER, RONLY, var_qBridgeMIB, 3, {1, 1, 1}},
#endif
#define DOT1QMAXVLANID      2
    {DOT1QMAXVLANID, ASN_INTEGER, RONLY, var_qBridgeMIB, 3, {1, 1, 2}},
#define DOT1QMAXSUPPORTEDVLANS      3
    {DOT1QMAXSUPPORTEDVLANS, ASN_UNSIGNED, RONLY, var_qBridgeMIB, 3, {1, 1, 3}},
#define DOT1QNUMVLANS       4
    {DOT1QNUMVLANS, ASN_UNSIGNED, RONLY, var_qBridgeMIB, 3, {1, 1, 4}},
#if 0
#define DOT1QGVRPSTATUS     5
    {DOT1QGVRPSTATUS, ASN_INTEGER, RWRITE, var_qBridgeMIB, 3, {1, 1, 5}},
#endif
#define DOT1QFDBDYNAMICCOUNT        10
    {DOT1QFDBDYNAMICCOUNT, ASN_COUNTER, RONLY, var_dot1qFdbTable, 5, {1, 2, 1, 1, 2}},
#define DOT1QTPFDBPORT      11
    {DOT1QTPFDBPORT, ASN_INTEGER, RONLY, var_dot1qTpFdbTable, 5, {1, 2, 2, 1, 2}},
#define DOT1QTPFDBSTATUS        12
    {DOT1QTPFDBSTATUS, ASN_INTEGER, RONLY, var_dot1qTpFdbTable, 5, {1, 2, 2, 1, 3}},
#define DOT1QTPGROUPEGRESSPORTS     13
    {DOT1QTPGROUPEGRESSPORTS, ASN_OCTET_STR, RONLY, var_dot1qTpGroupTable, 5, {1, 2, 3, 1, 2}},
#define DOT1QTPGROUPLEARNT      14
    {DOT1QTPGROUPLEARNT, ASN_OCTET_STR, RONLY, var_dot1qTpGroupTable, 5, {1, 2, 3, 1, 3}},
#if 0
#define DOT1QFORWARDALLPORTS        15
    {DOT1QFORWARDALLPORTS, ASN_OCTET_STR, RONLY, var_dot1qForwardAllTable, 5, {1, 2, 4, 1, 1}},
#define DOT1QFORWARDALLSTATICPORTS      16
    {DOT1QFORWARDALLSTATICPORTS, ASN_OCTET_STR, RWRITE, var_dot1qForwardAllTable, 5, {1, 2, 4, 1, 2}},
#define DOT1QFORWARDALLFORBIDDENPORTS       17
    {DOT1QFORWARDALLFORBIDDENPORTS, ASN_OCTET_STR, RWRITE, var_dot1qForwardAllTable, 5, {1, 2, 4, 1, 3}},
#define DOT1QFORWARDUNREGISTEREDPORTS       18
    {DOT1QFORWARDUNREGISTEREDPORTS, ASN_OCTET_STR, RONLY, var_dot1qForwardUnregisteredTable, 5, {1, 2, 5, 1, 1}},
#define DOT1QFORWARDUNREGISTEREDSTATICPORTS     19
    {DOT1QFORWARDUNREGISTEREDSTATICPORTS, ASN_OCTET_STR, RWRITE, var_dot1qForwardUnregisteredTable, 5, {1, 2, 5, 1, 2}},
#define DOT1QFORWARDUNREGISTEREDFORBIDDENPORTS      20
    {DOT1QFORWARDUNREGISTEREDFORBIDDENPORTS, ASN_OCTET_STR, RWRITE, var_dot1qForwardUnregisteredTable, 5, {1, 2, 5, 1, 3}},
#endif
#define DOT1QSTATICUNICASTALLOWEDTOGOTO     21
    {DOT1QSTATICUNICASTALLOWEDTOGOTO, ASN_OCTET_STR, RWRITE, var_dot1qStaticUnicastTable, 5, {1, 3, 1, 1, 3}},
#define DOT1QSTATICUNICASTSTATUS        22
    {DOT1QSTATICUNICASTSTATUS, ASN_INTEGER, RWRITE, var_dot1qStaticUnicastTable, 5, {1, 3, 1, 1, 4}},
#define DOT1QSTATICMULTICASTSTATICEGRESSPORTS       23
    {DOT1QSTATICMULTICASTSTATICEGRESSPORTS, ASN_OCTET_STR, RWRITE, var_dot1qStaticMulticastTable, 5, {1, 3, 2, 1, 3}},
#if 0
#define DOT1QSTATICMULTICASTFORBIDDENEGRESSPORTS        24
    {DOT1QSTATICMULTICASTFORBIDDENEGRESSPORTS, ASN_OCTET_STR, RWRITE, var_dot1qStaticMulticastTable, 5, {1, 3, 2, 1, 4}},
#endif
#define DOT1QSTATICMULTICASTSTATUS      25
    {DOT1QSTATICMULTICASTSTATUS, ASN_INTEGER, RWRITE, var_dot1qStaticMulticastTable, 5, {1, 3, 2, 1, 5}},
#define DOT1QVLANNUMDELETES     6
    {DOT1QVLANNUMDELETES, ASN_COUNTER, RONLY, var_qBridgeMIB, 3, {1, 4, 1}},


#define DOT1QVLANFDBID      26
    {DOT1QVLANFDBID, ASN_UNSIGNED, RONLY, var_dot1qVlanCurrentTable, 5, {1, 4, 2, 1, 3}},
#define DOT1QVLANCURRENTEGRESSPORTS     27
    {DOT1QVLANCURRENTEGRESSPORTS, ASN_OCTET_STR, RONLY, var_dot1qVlanCurrentTable, 5, {1, 4, 2, 1, 4}},
#define DOT1QVLANCURRENTUNTAGGEDPORTS       28
    {DOT1QVLANCURRENTUNTAGGEDPORTS, ASN_OCTET_STR, RONLY, var_dot1qVlanCurrentTable, 5, {1, 4, 2, 1, 5}},
#define DOT1QVLANSTATUS     29
    {DOT1QVLANSTATUS, ASN_INTEGER, RONLY, var_dot1qVlanCurrentTable, 5, {1, 4, 2, 1, 6}},
#if 0
#define DOT1QVLANCREATIONTIME       30
    {DOT1QVLANCREATIONTIME, ASN_TIMETICKS, RONLY, var_dot1qVlanCurrentTable, 5, {1, 4, 2, 1, 7}},
#endif
#define DOT1QVLANSTATICNAME     31
    {DOT1QVLANSTATICNAME, ASN_OCTET_STR, RWRITE, var_dot1qVlanStaticTable, 5, {1, 4, 3, 1, 1}},
#define DOT1QVLANSTATICEGRESSPORTS      32
    {DOT1QVLANSTATICEGRESSPORTS, ASN_OCTET_STR, RWRITE, var_dot1qVlanStaticTable, 5, {1, 4, 3, 1, 2}},
#if 0
#define DOT1QVLANFORBIDDENEGRESSPORTS       33
    {DOT1QVLANFORBIDDENEGRESSPORTS, ASN_OCTET_STR, RWRITE, var_dot1qVlanStaticTable, 5, {1, 4, 3, 1, 3}},
#endif
#define DOT1QVLANSTATICUNTAGGEDPORTS        34
    {DOT1QVLANSTATICUNTAGGEDPORTS, ASN_OCTET_STR, RWRITE, var_dot1qVlanStaticTable, 5, {1, 4, 3, 1, 4}},
#define DOT1QVLANSTATICROWSTATUS        35
    {DOT1QVLANSTATICROWSTATUS, ASN_INTEGER, RWRITE, var_dot1qVlanStaticTable, 5, {1, 4, 3, 1, 5}},
#define DOT1QNEXTFREELOCALVLANINDEX     7
    {DOT1QNEXTFREELOCALVLANINDEX, ASN_INTEGER, RONLY, var_qBridgeMIB, 3, {1, 4, 4}},

#define DOT1QPVID       36
    {DOT1QPVID, ASN_UNSIGNED, RWRITE, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 1}},
#define DOT1QPORTACCEPTABLEFRAMETYPES       37
    {DOT1QPORTACCEPTABLEFRAMETYPES, ASN_INTEGER, RWRITE, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 2}},
#define DOT1QPORTINGRESSFILTERING       38
    {DOT1QPORTINGRESSFILTERING, ASN_INTEGER, RWRITE, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 3}},
#if 0
#define DOT1QPORTGVRPSTATUS     39
    {DOT1QPORTGVRPSTATUS, ASN_INTEGER, RWRITE, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 4}},
#define DOT1QPORTGVRPFAILEDREGISTRATIONS        40
    {DOT1QPORTGVRPFAILEDREGISTRATIONS, ASN_COUNTER, RONLY, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 5}},
#define DOT1QPORTGVRPLASTPDUORIGIN      41
    {DOT1QPORTGVRPLASTPDUORIGIN, ASN_OCTET_STR, RONLY, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 6}},
#define DOT1QPORTRESTRICTEDVLANREGISTRATION     42
    {DOT1QPORTRESTRICTEDVLANREGISTRATION, ASN_INTEGER, RWRITE, var_dot1qPortVlanTable, 5, {1, 4, 5, 1, 7}},
#define DOT1QTPVLANPORTINFRAMES     43
    {DOT1QTPVLANPORTINFRAMES, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 1}},
#define DOT1QTPVLANPORTOUTFRAMES        44
    {DOT1QTPVLANPORTOUTFRAMES, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 2}},
#define DOT1QTPVLANPORTINDISCARDS       45
    {DOT1QTPVLANPORTINDISCARDS, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 3}},
#define DOT1QTPVLANPORTINOVERFLOWFRAMES     46
    {DOT1QTPVLANPORTINOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 4}},
#define DOT1QTPVLANPORTOUTOVERFLOWFRAMES        47
    {DOT1QTPVLANPORTOUTOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 5}},
#define DOT1QTPVLANPORTINOVERFLOWDISCARDS       48
    {DOT1QTPVLANPORTINOVERFLOWDISCARDS, ASN_COUNTER, RONLY, var_dot1qPortVlanStatisticsTable, 5, {1, 4, 6, 1, 6}},
#define DOT1QTPVLANPORTHCINFRAMES       49
    {DOT1QTPVLANPORTHCINFRAMES, ASN_COUNTER64, RONLY, var_dot1qPortVlanHCStatisticsTable, 5, {1, 4, 7, 1, 1}},
#define DOT1QTPVLANPORTHCOUTFRAMES      50
    {DOT1QTPVLANPORTHCOUTFRAMES, ASN_COUNTER64, RONLY, var_dot1qPortVlanHCStatisticsTable, 5, {1, 4, 7, 1, 2}},
#define DOT1QTPVLANPORTHCINDISCARDS     51
    {DOT1QTPVLANPORTHCINDISCARDS, ASN_COUNTER64, RONLY, var_dot1qPortVlanHCStatisticsTable, 5, {1, 4, 7, 1, 3}},
#define DOT1QCONSTRAINTTYPE     52
    {DOT1QCONSTRAINTTYPE, ASN_INTEGER, RWRITE, var_dot1qLearningConstraintsTable, 5, {1, 4, 8, 1, 3}},
#define DOT1QCONSTRAINTSTATUS       53
    {DOT1QCONSTRAINTSTATUS, ASN_INTEGER, RWRITE, var_dot1qLearningConstraintsTable, 5, {1, 4, 8, 1, 4}},

#define DOT1QCONSTRAINTSETDEFAULT       8
    {DOT1QCONSTRAINTSETDEFAULT, ASN_INTEGER, RWRITE, var_qBridgeMIB, 3, {1, 4, 9}},
#define DOT1QCONSTRAINTTYPEDEFAULT      9
    {DOT1QCONSTRAINTTYPEDEFAULT, ASN_INTEGER, RWRITE, var_qBridgeMIB, 3, {1, 4, 10}},

#define DOT1VPROTOCOLGROUPID        54
    {DOT1VPROTOCOLGROUPID, ASN_INTEGER, RWRITE, var_dot1vProtocolGroupTable, 5, {1, 5, 1, 1, 3}},
#define DOT1VPROTOCOLGROUPROWSTATUS     55
    {DOT1VPROTOCOLGROUPROWSTATUS, ASN_INTEGER, RWRITE, var_dot1vProtocolGroupTable, 5, {1, 5, 1, 1, 4}},
#define DOT1VPROTOCOLPORTGROUPVID       56
    {DOT1VPROTOCOLPORTGROUPVID, ASN_INTEGER, RWRITE, var_dot1vProtocolPortTable, 5, {1, 5, 2, 1, 2}},
#define DOT1VPROTOCOLPORTROWSTATUS      57
    {DOT1VPROTOCOLPORTROWSTATUS, ASN_INTEGER, RWRITE, var_dot1vProtocolPortTable, 5, {1, 5, 2, 1, 3}},
#endif
};

/*
 * Initializes the qBridgeMIB module
 */
void
init_rfc2674_q_bridge(void)
{
    // Register mibContextTable
    mibContextTable_register(qBridgeMIB_variables_oid,
                             sizeof(qBridgeMIB_variables_oid) / sizeof(oid),
                             "Q-BRIDGE-MIB : qBridgeMIB");

    DEBUGMSGTL(("qBridgeMIB", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("qBridgeMIB", qBridgeMIB_variables, variable7,
                 qBridgeMIB_variables_oid);

    /* place any other initialization junk you need here */
}

static int get_numVlans(void)
{
    vlan_mgmt_entry_t  conf;
    vtss_vid_t vid = VTSS_VID_NULL;
    u_long no_of_vlans = 0;
    while (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vid, &conf, 1, VLAN_USER_STATIC) == VTSS_OK) {
        vid = conf.vid;
        no_of_vlans++;
    }
    return no_of_vlans;
}

static int
get_dot1qBaseScalar(dot1qBase_scalar_t *scalar_entry)
{
    scalar_entry->dot1qMaxVlanId = VLAN_ID_MAX;            // Maximum VLAN ID we can configure
    scalar_entry->dot1qMaxSupportedVlans = VLAN_ENTRY_CNT; // Number of VLANs we can configure
    scalar_entry->dot1qNumVlans = get_numVlans();
    return 0;
}

static int
set_dot1qBaseScalar(dot1qBase_scalar_t *scalar_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qVlanScalar(dot1qVlan_scalar_t *scalar_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1qVlanScalar(dot1qVlan_scalar_t *scalar_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}
/*
 * var_qBridgeMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char *
var_qBridgeMIB(struct variable *vp,
               oid     *name,
               size_t  *length,
               int     exact,
               size_t  *var_len,
               WriteMethod **write_method)
{
    dot1qBase_scalar_t dot1qBase_scalar_entry;
    dot1qVlan_scalar_t dot1qVlan_scalar_entry;

    *write_method = NULL;
    if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED) {
        return NULL;
    }

    if (get_dot1qBaseScalar(&dot1qBase_scalar_entry)) {
        return NULL;
    }
    if (get_dot1qVlanScalar(&dot1qVlan_scalar_entry)) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if 0
    case DOT1QVLANVERSIONNUMBER: {
        qBridgeMIB_global_ret.long_ret = dot1qBase_scalar_entry.dot1qVlanVersionNumber;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
#endif
    case DOT1QMAXVLANID: {
        qBridgeMIB_global_ret.long_ret = dot1qBase_scalar_entry.dot1qMaxVlanId;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QMAXSUPPORTEDVLANS: {
        qBridgeMIB_global_ret.ulong_ret = dot1qBase_scalar_entry.dot1qMaxSupportedVlans;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QNUMVLANS: {
        qBridgeMIB_global_ret.ulong_ret = dot1qBase_scalar_entry.dot1qNumVlans;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
#if 0
    case DOT1QGVRPSTATUS: {
        *write_method = write_dot1qGvrpStatus;
        qBridgeMIB_global_ret.long_ret = dot1qBase_scalar_entry.dot1qGvrpStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QVLANNUMDELETES: {
        qBridgeMIB_global_ret.ulong_ret = dot1qVlan_scalar_entry.dot1qVlanNumDeletes;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QNEXTFREELOCALVLANINDEX: {
        qBridgeMIB_global_ret.long_ret = dot1qVlan_scalar_entry.dot1qNextFreeLocalVlanIndex;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QCONSTRAINTSETDEFAULT: {
        *write_method = write_dot1qConstraintSetDefault;
        qBridgeMIB_global_ret.long_ret = dot1qVlan_scalar_entry.dot1qConstraintSetDefault;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QCONSTRAINTTYPEDEFAULT: {
        *write_method = write_dot1qConstraintTypeDefault;
        qBridgeMIB_global_ret.long_ret = dot1qVlan_scalar_entry.dot1qConstraintTypeDefault;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_qBridgeMIB\n", vp->magic));
    }
    return NULL;
}

static int get_next_dot1qFdbId(vtss_vid_t *vid)
{
    vlan_mgmt_entry_t vlan_entry;

    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, *vid, &vlan_entry, TRUE, VLAN_USER_ALL)
        != VTSS_OK) {
        return VTSS_RC_ERROR;
    }
    *vid = vlan_entry.vid;
    return VTSS_RC_OK;
}

static int
getfirst_dot1qFdbTableEntry(dot1qFdbTable_entry_t *table_entry)
{
    vtss_vid_t vid = VTSS_VID_NULL;
    mac_table_stats_t stats;

    if (get_next_dot1qFdbId (&vid) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    if (mac_mgmt_table_vlan_stats_get(VTSS_ISID_LOCAL, vid, &stats) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1qFdbId = vid;
    table_entry->dot1qFdbDynamicCount = stats.learned_total;

    return VTSS_RC_OK;
}

static int
get_dot1qFdbTableEntry(dot1qFdbTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_t vid = getnext ? table_entry->dot1qFdbId : table_entry->dot1qFdbId - 1;
    mac_table_stats_t stats;

    if (get_next_dot1qFdbId (&vid) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    if ( !getnext && vid != table_entry->dot1qFdbId ) {
        return VTSS_RC_ERROR;
    }

    if (mac_mgmt_table_vlan_stats_get(VTSS_ISID_LOCAL, vid, &stats) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1qFdbId = vid;
    table_entry->dot1qFdbDynamicCount = stats.learned_total;
    return 0;
}

static int
parse_dot1qFdbTable(oid     *name,
                    size_t  *length,
                    int     exact,
                    dot1qFdbTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qFdbTableEntry(table_entry)) {
            return -1;
        }
        return 2; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qFdbId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qFdbTable(oid     *name,
                      size_t  *length,
                      dot1qFdbTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qFdbId;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qFdbTable(struct variable *vp,
                  oid     *name,
                  size_t  *length,
                  int     exact,
                  size_t  *var_len,
                  WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qFdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qFdbTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qFdbTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qFdbTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qFdbTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QFDBDYNAMICCOUNT: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qFdbDynamicCount;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qFdbTable\n", vp->magic));
    }
    return NULL;
}

void get_1qTpFdbPort_by_port( vtss_isid_t isid, vtss_port_no_t iport, long *qTpFdbPort)
{
    dot1Port_info_t             info;
    aggr_mgmt_group_member_t    aggr_members;
    BOOL                        found = FALSE;
    aggr_mgmt_group_no_t        tmp_aggr;

    for (tmp_aggr = AGGR_MGMT_GROUP_NO_START; tmp_aggr < AGGR_MGMT_GROUP_NO_END; tmp_aggr++) {
        if ((aggr_mgmt_port_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#ifdef VTSS_SW_OPTION_LACP
            && (aggr_mgmt_lacp_members_get(isid, tmp_aggr, &aggr_members, FALSE) != VTSS_OK)
#endif /* VTSS_SW_OPTION_LACP */
           ) {

            continue;
        }
        if (aggr_members.entry.member[iport] == TRUE) {
            found = TRUE;
            break;
        }
    }


    info.isid = isid;
    if ( FALSE == found ) {
        info.if_id = iport;
        info.type = DOT1PORT_TYPE_PORT;
    } else {
        info.if_id = tmp_aggr;
        info.type = AGGR_MGMT_GROUP_IS_GLAG(tmp_aggr) ? DOT1PORT_TYPE_GLAG : DOT1PORT_TYPE_LLAG;
    }
    if ( FALSE == dot1Port_get_by_interface(&info) ) {
        return;
    }

    *qTpFdbPort = info.dot1port;
}




static int
getfirst_dot1qTpFdbTableEntry(dot1qTpFdbTable_entry_t *table_entry)
{
    int                     learned = 0;
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    vtss_mac_table_entry_t  isid_mac_entry;
    port_iter_t             pit;
    switch_iter_t           sit;
    vtss_isid_t             isid;


    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, TRUE) == VTSS_OK) {
        table_entry->dot1qFdbId = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    learned = 1;
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
                    if (vtss_stacking_enabled()) {
                        isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
                    } else {
                        isid = sit.isid;
                    }
#else
                    isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */
                    get_1qTpFdbPort_by_port(isid, pit.iport, &table_entry->dot1qTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->dot1qTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->dot1qTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->dot1qTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->dot1qTpFdbStatus = 1;    /* other   */
        }
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
get_dot1qTpFdbTableEntry(dot1qTpFdbTable_entry_t *table_entry, BOOL getnext)
{
    int                     learned = 0;
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    port_iter_t             pit;
    switch_iter_t           sit;
    vtss_isid_t             isid;

    /* Search only for UC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 0;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    vid_mac_in.vid = table_entry->dot1qFdbId;
    memcpy(vid_mac_in.mac.addr, table_entry->dot1qTpFdbAddress, 6);

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK) {
        table_entry->dot1qFdbId = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qTpFdbAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qTpFdbAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }

            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    learned = 1;
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
                    if (vtss_stacking_enabled()) {
                        isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
                    } else {
                        isid = sit.isid;
                    }
#else
                    isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */
                    get_1qTpFdbPort_by_port(isid, pit.iport, &table_entry->dot1qTpFdbPort);
                    goto search_end;
                }
            }
        }

search_end:
        if ((mac_entry.copy_to_cpu) && (!mac_entry.locked)) {
            table_entry->dot1qTpFdbStatus = 4;    /* self    */
        } else if (mac_entry.locked) {
            table_entry->dot1qTpFdbStatus = 5;    /* mgmt    */
        } else if (learned) {
            table_entry->dot1qTpFdbStatus = 3;    /* learned */
        } else {
            table_entry->dot1qTpFdbStatus = 1;    /* other   */
        }
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
parse_dot1qTpFdbTable(oid     *name,
                      size_t  *length,
                      int     exact,
                      dot1qTpFdbTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qTpFdbTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qFdbId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->dot1qTpFdbAddress_len = (char) len;
    cp = (u_char *)table_entry->dot1qTpFdbAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qTpFdbTable(oid     *name,
                        size_t  *length,
                        dot1qTpFdbTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->dot1qFdbId;
    len = (int) table_entry->dot1qTpFdbAddress_len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->dot1qTpFdbAddress[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qTpFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qTpFdbTable(struct variable *vp,
                    oid     *name,
                    size_t  *length,
                    int     exact,
                    size_t  *var_len,
                    WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qTpFdbTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qTpFdbTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qTpFdbTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qTpFdbTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qTpFdbTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QTPFDBPORT: {
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qTpFdbPort;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QTPFDBSTATUS: {
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qTpFdbStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qTpFdbTable\n", vp->magic));
    }
    return NULL;
}


static void get_portList_BF_size(u_long *port_count_p)
{
    dot1Port_info_t table_info;
    switch_iter_t   sit;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        table_info.isid = sit.isid;
        table_info.if_id = VTSS_PORT_NO_START + port_isid_port_count(sit.isid) - 1;
        table_info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&table_info);
    }

    *port_count_p = VTSS_PORTLIST_BF_SIZE(table_info.dot1port);

}


static int
getfirst_dot1qTpGroupTableEntry(dot1qTpGroupTable_entry_t *table_entry)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    vtss_mac_table_entry_t  isid_mac_entry;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    port_iter_t             pit;
    switch_iter_t           sit;


    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 1;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, TRUE) == VTSS_OK) {
        table_entry->dot1qVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qTpGroupAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qTpGroupAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {

            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = sit.isid;
            }
#else
            info.isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;

            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 0);
                }

//                if (mac_entry.destination[sit.isid][pit.iport]) {
//                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 1);
//                } else {
//                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 0);
//                }
            }
        }
        get_portList_BF_size((u_long *)&table_entry->dot1qTpGroupEgressPorts_len);
        table_entry->dot1qTpGroupLearnt_len = table_entry->dot1qTpGroupEgressPorts_len;
        memset(table_entry->dot1qTpGroupLearnt, 0, table_entry->dot1qTpGroupEgressPorts_len);
    } else {
        T_D("no entry");
        return 1;
    }
    return VTSS_RC_OK;
}

static int
get_dot1qTpGroupTableEntry(dot1qTpGroupTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    port_iter_t             pit;
    switch_iter_t           sit;

    vid_mac_in.vid = table_entry->dot1qVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->dot1qTpGroupAddress, 6);

    /* Search only for MC mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK) {
        table_entry->dot1qVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qTpGroupAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qTpGroupAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));


        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = sit.isid;
            }
#else
            info.isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qTpGroupEgressPorts, dot1port_start + pit.iport, 0);
                }
            }
        }
        get_portList_BF_size( (u_long *)&table_entry->dot1qTpGroupEgressPorts_len);
        table_entry->dot1qTpGroupLearnt_len = table_entry->dot1qTpGroupEgressPorts_len;
        memset(table_entry->dot1qTpGroupLearnt, 0, table_entry->dot1qTpGroupEgressPorts_len);
    } else {
        T_D("no entry");
        return 1;
    }
    return VTSS_RC_OK;
}

static int
parse_dot1qTpGroupTable(oid     *name,
                        size_t  *length,
                        int     exact,
                        dot1qTpGroupTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qTpGroupTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->dot1qTpGroupAddress_len = (char) len;
    cp = (u_char *)table_entry->dot1qTpGroupAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qTpGroupTable(oid     *name,
                          size_t  *length,
                          dot1qTpGroupTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;
    len = (int) table_entry->dot1qTpGroupAddress_len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->dot1qTpGroupAddress[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qTpGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qTpGroupTable(struct variable *vp,
                      oid     *name,
                      size_t  *length,
                      int     exact,
                      size_t  *var_len,
                      WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qTpGroupTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qTpGroupTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qTpGroupTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qTpGroupTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qTpGroupTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QTPGROUPEGRESSPORTS: {
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qTpGroupEgressPorts);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qTpGroupEgressPorts, table_entry.dot1qTpGroupEgressPorts_len);
        *var_len = table_entry.dot1qTpGroupEgressPorts_len;

        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QTPGROUPLEARNT: {
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qTpGroupLearnt);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qTpGroupLearnt, table_entry.dot1qTpGroupLearnt_len );
        *var_len = table_entry.dot1qTpGroupLearnt_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qTpGroupTable\n", vp->magic));
    }
    return NULL;
}
static int
getfirst_dot1qForwardAllTableEntry(dot1qForwardAllTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qForwardAllTableEntry(dot1qForwardAllTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1qForwardAllTableEntry(dot1qForwardAllTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1qForwardAllTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           dot1qForwardAllTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qForwardAllTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if 0
static int
fillobj_dot1qForwardAllTable(oid     *name,
                             size_t  *length,
                             dot1qForwardAllTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qForwardAllTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qForwardAllTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qForwardAllTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qForwardAllTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qForwardAllTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qForwardAllTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qForwardAllTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QFORWARDALLPORTS: {
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardAllPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QFORWARDALLSTATICPORTS: {
        *write_method = write_dot1qForwardAllStaticPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardAllStaticPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QFORWARDALLFORBIDDENPORTS: {
        *write_method = write_dot1qForwardAllForbiddenPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardAllForbiddenPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qForwardAllTable\n", vp->magic));
    }
    return NULL;
}
#endif

static int
getfirst_dot1qForwardUnregisteredTableEntry(dot1qForwardUnregisteredTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qForwardUnregisteredTableEntry(dot1qForwardUnregisteredTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1qForwardUnregisteredTableEntry(dot1qForwardUnregisteredTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1qForwardUnregisteredTable(oid     *name,
                                    size_t  *length,
                                    int     exact,
                                    dot1qForwardUnregisteredTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qForwardUnregisteredTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if 0
static int
fillobj_dot1qForwardUnregisteredTable(oid     *name,
                                      size_t  *length,
                                      dot1qForwardUnregisteredTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qForwardUnregisteredTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qForwardUnregisteredTable(struct variable *vp,
                                  oid     *name,
                                  size_t  *length,
                                  int     exact,
                                  size_t  *var_len,
                                  WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qForwardUnregisteredTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qForwardUnregisteredTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qForwardUnregisteredTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qForwardUnregisteredTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qForwardUnregisteredTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QFORWARDUNREGISTEREDPORTS: {
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardUnregisteredPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QFORWARDUNREGISTEREDSTATICPORTS: {
        *write_method = write_dot1qForwardUnregisteredStaticPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardUnregisteredStaticPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QFORWARDUNREGISTEREDFORBIDDENPORTS: {
        *write_method = write_dot1qForwardUnregisteredForbiddenPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qForwardUnregisteredForbiddenPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qForwardUnregisteredTable\n", vp->magic));
    }
    return NULL;
}
#endif


static int
_get_dot1qStaticUnicastTableEntry(dot1qStaticUnicastTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    vtss_mac_table_entry_t  isid_mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    port_iter_t             pit;
    switch_iter_t           sit;

    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->dot1qFdbId;
    memcpy(vid_mac_in.mac.addr, table_entry->dot1qStaticUnicastAddress, 6);

    /* Search only for UC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 1;
    mac_type.not_uc = 0;

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK) {
        table_entry->dot1qFdbId = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qStaticUnicastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qStaticUnicastAddress_len = 6;


        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = sit.isid;
            }
#else
            info.isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qStaticUnicastAllowedToGoTo, dot1port_start + pit.iport, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qStaticUnicastAllowedToGoTo, dot1port_start + pit.iport, 0);
                }
            }
        }
        get_portList_BF_size( (u_long *)&table_entry->dot1qStaticUnicastAllowedToGoTo_len);
        table_entry->dot1qStaticUnicastStatus = 3;    /* permanent */
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}


static int
getfirst_dot1qStaticUnicastTableEntry(dot1qStaticUnicastTable_entry_t *table_entry)
{
    dot1qStaticUnicastTable_entry_t          tmp_entry;
    memset(&tmp_entry, 0, sizeof(tmp_entry));
    if (_get_dot1qStaticUnicastTableEntry (&tmp_entry, TRUE) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &tmp_entry, sizeof(tmp_entry));
    return VTSS_RC_OK;
}

static int
get_dot1qStaticUnicastTableEntry(dot1qStaticUnicastTable_entry_t *table_entry, BOOL getnext)
{
    dot1qStaticUnicastTable_entry_t          tmp_entry;

    if (table_entry->dot1qStaticUnicastReceivePort != 0 && FALSE == getnext) {
        return VTSS_RC_ERROR;
    }

    memset(&tmp_entry, 0, sizeof(tmp_entry));
    tmp_entry.dot1qFdbId = table_entry->dot1qFdbId;
    memcpy(tmp_entry.dot1qStaticUnicastAddress, table_entry->dot1qStaticUnicastAddress, 6);
    if (_get_dot1qStaticUnicastTableEntry (&tmp_entry, getnext) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &tmp_entry, sizeof(tmp_entry));
    return VTSS_RC_OK;
}

static int mac_mgmt_table_add_by_portList (mac_mgmt_addr_entry_t *mac_entry, unsigned char *portList, u_long portList_bf_size)
{
    vtss_common_port_t    dot1port_start;
    u_long bf_size;
    dot1Port_info_t         info;
    port_iter_t             pit;
    switch_iter_t           sit;
    BOOL found = FALSE;


    get_portList_BF_size(&bf_size);
    if ( portList_bf_size == 0 || portList_bf_size > bf_size ) {
        return VTSS_RC_ERROR;
    }

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (VTSS_PORTLIST_BF_GET(portList, dot1port_start + pit.iport)) {
                mac_entry->destination[pit.iport] = TRUE;
                found = TRUE;
            } else {
                mac_entry->destination[pit.iport] = FALSE;
            }
        }
        if (found) {
            (void)mac_mgmt_table_add(sit.isid, mac_entry);
        }
        found = FALSE;
    }

    return VTSS_RC_OK;
}



static int
set_dot1qStaticUnicastTableEntry(dot1qStaticUnicastTable_entry_t *table_entry)
{
    mac_mgmt_addr_entry_t mac_entry;

    memset(&mac_entry, 0, sizeof(mac_entry));
    mac_entry.vid_mac.vid = table_entry->dot1qFdbId;
    memcpy(mac_entry.vid_mac.mac.addr, table_entry->dot1qStaticUnicastAddress, 6);


    return mac_mgmt_table_add_by_portList(&mac_entry, (unsigned char *)table_entry->dot1qStaticUnicastAllowedToGoTo,
                                          table_entry->dot1qStaticUnicastAllowedToGoTo_len);
}

static int
parse_dot1qStaticUnicastTable(oid     *name,
                              size_t  *length,
                              int     exact,
                              dot1qStaticUnicastTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qStaticUnicastTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qFdbId = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->dot1qStaticUnicastAddress_len = (char) len;
    cp = (u_char *)table_entry->dot1qStaticUnicastAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->dot1qStaticUnicastReceivePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qStaticUnicastTable(oid     *name,
                                size_t  *length,
                                dot1qStaticUnicastTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->dot1qFdbId;
    len = (int) table_entry->dot1qStaticUnicastAddress_len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->dot1qStaticUnicastAddress[idx++];
    }
    name[name_pos++] = (oid) table_entry->dot1qStaticUnicastReceivePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qStaticUnicastTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qStaticUnicastTable(struct variable *vp,
                            oid     *name,
                            size_t  *length,
                            int     exact,
                            size_t  *var_len,
                            WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qStaticUnicastTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qStaticUnicastTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qStaticUnicastTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qStaticUnicastTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qStaticUnicastTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QSTATICUNICASTALLOWEDTOGOTO: {
        *write_method = write_dot1qStaticUnicastAllowedToGoTo;
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qStaticUnicastAllowedToGoTo);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qStaticUnicastAllowedToGoTo, table_entry.dot1qStaticUnicastAllowedToGoTo_len);
        *var_len = table_entry.dot1qStaticUnicastAllowedToGoTo_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QSTATICUNICASTSTATUS: {
        *write_method = write_dot1qStaticUnicastStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qStaticUnicastStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qStaticUnicastTable\n", vp->magic));
    }
    return NULL;
}

static int
_get_dot1qStaticMulticastTableEntry(dot1qStaticMulticastTable_entry_t *table_entry, BOOL getnext)
{
    vtss_vid_mac_t          vid_mac_in;
    mac_mgmt_table_stack_t  mac_entry;
    mac_mgmt_addr_type_t    mac_type;
    vtss_mac_table_entry_t  isid_mac_entry;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    port_iter_t             pit;
    switch_iter_t           sit;


    memset(&vid_mac_in, 0, sizeof(vid_mac_in));

    vid_mac_in.vid = table_entry->dot1qVlanIndex;
    memcpy(vid_mac_in.mac.addr, table_entry->dot1qStaticMulticastAddress, 6);

    /* Search only for MC Static mac-addresses */
    mac_type.only_this_vlan = 0;
    mac_type.not_dynamic = 1;
    mac_type.not_static = 0;
    mac_type.not_cpu = 0;
    mac_type.not_mc = 0;
    mac_type.not_uc = 1;

    if (mac_mgmt_stack_get_next(&vid_mac_in, &mac_entry, &mac_type, getnext) == VTSS_OK) {
        table_entry->dot1qVlanIndex = mac_entry.vid_mac.vid;
        memcpy(table_entry->dot1qStaticMulticastAddress, mac_entry.vid_mac.mac.addr, 6);
        table_entry->dot1qStaticMulticastAddress_len = 6;

        memcpy(&isid_mac_entry.vid_mac, &mac_entry.vid_mac, sizeof(vtss_vid_mac_t));
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            if (mac_mgmt_table_get_next(sit.isid, &isid_mac_entry.vid_mac, &isid_mac_entry, FALSE) != VTSS_RC_OK) {
                continue;
            }
#if defined(VTSS_FEATURE_VSTAX_V2) && VTSS_SWITCH_STACKABLE /* For VSTAX 2 we add the Switch id */
            if (vtss_stacking_enabled()) {
                info.isid = topo_usid2isid(mac_mgmt_upsid2usid(isid_mac_entry.vstax2.upsid));
            } else {
                info.isid = sit.isid;
            }
#else
            info.isid = sit.isid;
#endif /* VTSS_FEATURE_VSTAX_V2 */

            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (isid_mac_entry.destination[pit.iport]) {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qStaticMulticastStaticEgressPorts, dot1port_start + pit.iport, 1);
                } else {
                    VTSS_PORTLIST_BF_SET(table_entry->dot1qStaticMulticastStaticEgressPorts, dot1port_start + pit.iport, 0);
                }
            }
        }
        get_portList_BF_size( (u_long *)&table_entry->dot1qStaticMulticastStaticEgressPorts_len);

        table_entry->dot1qStaticMulticastStatus = 3;    /* permanent */
        return 0;
    } else {
        T_D("no entry");
        return 1;
    }
}

static int
getfirst_dot1qStaticMulticastTableEntry(dot1qStaticMulticastTable_entry_t *table_entry)
{
    dot1qStaticMulticastTable_entry_t          tmp_entry;
    memset(&tmp_entry, 0, sizeof(tmp_entry));
    if (_get_dot1qStaticMulticastTableEntry (&tmp_entry, TRUE) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &tmp_entry, sizeof(tmp_entry));
    return VTSS_RC_OK;
}

static int
get_dot1qStaticMulticastTableEntry(dot1qStaticMulticastTable_entry_t *table_entry, BOOL getnext)
{
    dot1qStaticMulticastTable_entry_t          tmp_entry;

    if (table_entry->dot1qStaticMulticastReceivePort != 0 && FALSE == getnext) {
        return VTSS_RC_ERROR;
    }

    memset(&tmp_entry, 0, sizeof(tmp_entry));
    tmp_entry.dot1qVlanIndex = table_entry->dot1qVlanIndex;
    memcpy(tmp_entry.dot1qStaticMulticastAddress, table_entry->dot1qStaticMulticastAddress, 6);
    if (_get_dot1qStaticMulticastTableEntry (&tmp_entry, getnext) != VTSS_RC_OK) {
        return VTSS_RC_ERROR;
    }

    memcpy(table_entry, &tmp_entry, sizeof(tmp_entry));
    return VTSS_RC_OK;
}

static int
set_dot1qStaticMulticastTableEntry(dot1qStaticMulticastTable_entry_t *table_entry)
{
    mac_mgmt_addr_entry_t mac_entry;

    memset(&mac_entry, 0, sizeof(mac_entry));
    mac_entry.vid_mac.vid = table_entry->dot1qVlanIndex;
    memcpy(mac_entry.vid_mac.mac.addr, table_entry->dot1qStaticMulticastAddress, 6);

    return mac_mgmt_table_add_by_portList(&mac_entry, (unsigned char *)table_entry->dot1qStaticMulticastStaticEgressPorts,
                                          table_entry->dot1qStaticMulticastStaticEgressPorts_len);
}

static int
parse_dot1qStaticMulticastTable(oid     *name,
                                size_t  *length,
                                int     exact,
                                dot1qStaticMulticastTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 4)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qStaticMulticastTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = 6;
    table_entry->dot1qStaticMulticastAddress_len = (char) len;
    cp = (u_char *)table_entry->dot1qStaticMulticastAddress;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }
    if (*length > op_pos) {
        table_entry->dot1qStaticMulticastReceivePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qStaticMulticastTable(oid     *name,
                                  size_t  *length,
                                  dot1qStaticMulticastTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;
    len = (int) table_entry->dot1qStaticMulticastAddress_len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->dot1qStaticMulticastAddress[idx++];
    }
    name[name_pos++] = (oid) table_entry->dot1qStaticMulticastReceivePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qStaticMulticastTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qStaticMulticastTable(struct variable *vp,
                              oid     *name,
                              size_t  *length,
                              int     exact,
                              size_t  *var_len,
                              WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qStaticMulticastTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qStaticMulticastTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qStaticMulticastTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qStaticMulticastTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qStaticMulticastTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QSTATICMULTICASTSTATICEGRESSPORTS: {
        *write_method = write_dot1qStaticMulticastStaticEgressPorts;
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qStaticMulticastStaticEgressPorts);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qStaticMulticastStaticEgressPorts, table_entry.dot1qStaticMulticastStaticEgressPorts_len);
        *var_len = table_entry.dot1qStaticMulticastStaticEgressPorts_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
#if 0
    case DOT1QSTATICMULTICASTFORBIDDENEGRESSPORTS: {
        *write_method = write_dot1qStaticMulticastForbiddenEgressPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qStaticMulticastForbiddenEgressPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
#endif
    case DOT1QSTATICMULTICASTSTATUS: {
        *write_method = write_dot1qStaticMulticastStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qStaticMulticastStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qStaticMulticastTable\n", vp->magic));
    }
    return NULL;
}

static int
_get_dot1qVlanCurrentTableEntry(dot1qVlanCurrentTable_entry_t *table_entry, BOOL getnext)
{
    vlan_mgmt_entry_t  vlan_entry;
    vlan_port_conf_t   port_conf;
    dot1Port_info_t    info;
    vtss_common_port_t dot1port_start;
    port_iter_t        pit;
    switch_iter_t      sit;

    vlan_entry.vid = table_entry->dot1qVlanIndex;

    if (vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_entry.vid, &vlan_entry, getnext, VLAN_USER_ALL) != VTSS_OK) {
        return VTSS_RC_ERROR;
    }

    table_entry->dot1qVlanIndex = vlan_entry.vid;
    table_entry->dot1qVlanFdbId = vlan_entry.vid;

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vlan_mgmt_vlan_get(sit.isid, vlan_entry.vid, &vlan_entry, FALSE, VLAN_USER_ALL) != VTSS_OK) {
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (vlan_entry.ports[pit.iport]) {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanCurrentEgressPorts, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanCurrentEgressPorts, dot1port_start + pit.iport, 0);
            }

            if (vlan_mgmt_port_conf_get(sit.isid, pit.iport, &port_conf, VLAN_USER_ALL) == VTSS_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanCurrentUntaggedPorts, dot1port_start + pit.iport, vlan_mgmt_vid_gets_tagged(&port_conf, vlan_entry.vid) ? 0 : 1);
            }
        }
    }
    get_portList_BF_size( (u_long *)&table_entry->dot1qVlanCurrentEgressPorts_len);
    table_entry->dot1qVlanCurrentUntaggedPorts_len = table_entry->dot1qVlanCurrentEgressPorts_len;
    table_entry->dot1qVlanStatus = 2; /* permenent */
    return VTSS_RC_OK;
}


static int
getfirst_dot1qVlanCurrentTableEntry(dot1qVlanCurrentTable_entry_t *table_entry)
{
    table_entry->dot1qVlanIndex = VTSS_VID_NULL;
    return _get_dot1qVlanCurrentTableEntry(table_entry, TRUE);
}

static int
get_dot1qVlanCurrentTableEntry(dot1qVlanCurrentTable_entry_t *table_entry, BOOL getnext)
{
    return _get_dot1qVlanCurrentTableEntry(table_entry, getnext);
}

static int
parse_dot1qVlanCurrentTable(oid     *name,
                            size_t  *length,
                            int     exact,
                            dot1qVlanCurrentTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qVlanCurrentTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanTimeMark = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qVlanCurrentTable(oid     *name,
                              size_t  *length,
                              dot1qVlanCurrentTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qVlanTimeMark;
    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qVlanCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qVlanCurrentTable(struct variable *vp,
                          oid     *name,
                          size_t  *length,
                          int     exact,
                          size_t  *var_len,
                          WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qVlanCurrentTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qVlanCurrentTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qVlanCurrentTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qVlanCurrentTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qVlanCurrentTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QVLANFDBID: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qVlanFdbId;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QVLANCURRENTEGRESSPORTS: {
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanCurrentEgressPorts, table_entry.dot1qVlanCurrentEgressPorts_len);
        *var_len = table_entry.dot1qVlanCurrentEgressPorts_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QVLANCURRENTUNTAGGEDPORTS: {
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanCurrentUntaggedPorts, table_entry.dot1qVlanCurrentUntaggedPorts_len);
        *var_len = table_entry.dot1qVlanCurrentUntaggedPorts_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QVLANSTATUS: {
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qVlanStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
#if 0
    case DOT1QVLANCREATIONTIME: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qVlanCreationTime;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qVlanCurrentTable\n", vp->magic));
    }
    return NULL;
}

static int
_get_dot1qVlanStaticTableEntry(dot1qVlanStaticTable_entry_t *table_entry, BOOL getnext)
{
    vlan_mgmt_entry_t  vlan_entry;
    vlan_port_conf_t   port_conf;
    dot1Port_info_t    info;
    vtss_common_port_t dot1port_start;
    port_iter_t        pit;
    switch_iter_t      sit;
    vtss_rc            rc;

    vlan_entry.vid = table_entry->dot1qVlanIndex;

    if ((rc = vlan_mgmt_vlan_get(VTSS_ISID_GLOBAL, vlan_entry.vid, &vlan_entry, getnext, VLAN_USER_STATIC)) != VTSS_RC_OK) {
        return rc;
    }

    table_entry->dot1qVlanIndex = vlan_entry.vid;

    if ((rc = vlan_mgmt_name_get(vlan_entry.vid, table_entry->dot1qVlanStaticName, NULL)) != VTSS_RC_OK) {
        return rc;
    }

    (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
    while (switch_iter_getnext(&sit)) {
        if (vlan_mgmt_vlan_get(sit.isid, vlan_entry.vid, &vlan_entry, FALSE, VLAN_USER_STATIC) != VTSS_OK) {
            T_E("isid = %u, vid = %d not found", sit.isid, vlan_entry.vid);
            continue;
        }

        (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
        info.isid = sit.isid;
        info.if_id = VTSS_PORT_NO_START;
        info.type = DOT1PORT_TYPE_PORT;
        (void) dot1Port_get_by_interface(&info);
        dot1port_start = info.dot1port - VTSS_PORT_NO_START;
        while (port_iter_getnext(&pit)) {
            if (vlan_entry.ports[pit.iport]) {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanStaticEgressPorts, dot1port_start + pit.iport, 1);
            } else {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanStaticEgressPorts, dot1port_start + pit.iport, 0);
            }

            if (vlan_mgmt_port_conf_get(sit.isid, pit.iport, &port_conf, VLAN_USER_STATIC) == VTSS_OK) {
                VTSS_PORTLIST_BF_SET(table_entry->dot1qVlanStaticUntaggedPorts, dot1port_start + pit.iport, vlan_mgmt_vid_gets_tagged(&port_conf, vlan_entry.vid) ? 0 : 1);
            }
        }
    }
    get_portList_BF_size( (u_long *)&table_entry->dot1qVlanStaticEgressPorts_len);
    table_entry->dot1qVlanStaticUntaggedPorts_len = table_entry->dot1qVlanStaticEgressPorts_len;
    table_entry->dot1qVlanStaticRowStatus = SNMP_ROW_ACTIVE;
    return VTSS_RC_OK;
}



static int
getfirst_dot1qVlanStaticTableEntry(dot1qVlanStaticTable_entry_t *table_entry)
{

    table_entry->dot1qVlanIndex = VTSS_VID_NULL;
    return _get_dot1qVlanStaticTableEntry(table_entry, TRUE);
}

static int
get_dot1qVlanStaticTableEntry(dot1qVlanStaticTable_entry_t *table_entry, BOOL getnext)
{
    return _get_dot1qVlanStaticTableEntry(table_entry, getnext);
}

static int
set_dot1qVlanStaticTableEntry(dot1qVlanStaticTable_entry_t *table_entry)
{
    vlan_mgmt_entry_t vlan_entry;
    u_long bf_size;
    dot1Port_info_t         info;
    vtss_common_port_t      dot1port_start;
    port_iter_t             pit;
    switch_iter_t           sit;

    get_portList_BF_size(&bf_size);
    if (table_entry->dot1qVlanStaticEgressPorts_len > bf_size) {
        return VTSS_RC_ERROR;
    }

    vlan_entry.vid = table_entry->dot1qVlanIndex;
    if (table_entry->dot1qVlanStaticRowStatus == 4) {

        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            memset(vlan_entry.ports, 0, sizeof(vlan_entry.ports));
            if (vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VLAN_USER_STATIC) != VTSS_RC_OK) {
                return VTSS_RC_ERROR;
            }
        }
    } else if (table_entry->dot1qVlanStaticRowStatus == 6) {
        (void)vlan_mgmt_vlan_del(VTSS_ISID_GLOBAL, table_entry->dot1qVlanIndex, VLAN_USER_STATIC);
    } else if (table_entry->dot1qVlanStaticRowStatus == 1) {
        (void)switch_iter_init(&sit, VTSS_ISID_GLOBAL, SWITCH_ITER_SORT_ORDER_ISID);
        while (switch_iter_getnext(&sit)) {
            info.isid = sit.isid;
            info.if_id = VTSS_PORT_NO_START;
            info.type = DOT1PORT_TYPE_PORT;
            (void) dot1Port_get_by_interface(&info);
            dot1port_start = info.dot1port - VTSS_PORT_NO_START;
            (void)port_iter_init(&pit, NULL, sit.isid, PORT_ITER_SORT_ORDER_IPORT, PORT_ITER_FLAGS_NORMAL);
            while (port_iter_getnext(&pit)) {
                if (VTSS_PORTLIST_BF_GET(table_entry->dot1qVlanStaticEgressPorts, dot1port_start + pit.iport)) {
                    vlan_entry.ports[pit.iport] = TRUE;
                } else {
                    vlan_entry.ports[pit.iport] = FALSE;
                }
            }

            (void)vlan_mgmt_vlan_add(sit.isid, &vlan_entry, VLAN_USER_STATIC);
        }
    }
    return VTSS_RC_OK;
}

static int
parse_dot1qVlanStaticTable(oid     *name,
                           size_t  *length,
                           int     exact,
                           dot1qVlanStaticTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qVlanStaticTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qVlanStaticTable(oid     *name,
                             size_t  *length,
                             dot1qVlanStaticTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qVlanStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qVlanStaticTable(struct variable *vp,
                         oid     *name,
                         size_t  *length,
                         int     exact,
                         size_t  *var_len,
                         WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qVlanStaticTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qVlanStaticTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qVlanStaticTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qVlanStaticTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                if (DOT1QVLANSTATICROWSTATUS == vp->magic) {
                    /* if the entry doesn't exist, the write_method still need to register to SNMP Agent */
                    *write_method = write_dot1qVlanStaticRowStatus;
                }
                return NULL;
            }
            if (fillobj_dot1qVlanStaticTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QVLANSTATICNAME: {
        *write_method = write_dot1qVlanStaticName;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanStaticName);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QVLANSTATICEGRESSPORTS: {
        *write_method = write_dot1qVlanStaticEgressPorts;
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanStaticEgressPorts);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanStaticEgressPorts, table_entry.dot1qVlanStaticEgressPorts_len);
        *var_len = table_entry.dot1qVlanStaticEgressPorts_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
#if 0
    case DOT1QVLANFORBIDDENEGRESSPORTS: {
        *write_method = write_dot1qVlanForbiddenEgressPorts;
        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanForbiddenEgressPorts);
        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
#endif
    case DOT1QVLANSTATICUNTAGGEDPORTS: {
//        *write_method = write_dot1qVlanStaticUntaggedPorts;
//        strcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanStaticUntaggedPorts);
//        *var_len = strlen(qBridgeMIB_global_ret.string_ret);
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qVlanStaticUntaggedPorts, table_entry.dot1qVlanStaticUntaggedPorts_len);
        *var_len = table_entry.dot1qVlanStaticUntaggedPorts_len;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QVLANSTATICROWSTATUS: {
        *write_method = write_dot1qVlanStaticRowStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qVlanStaticRowStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qVlanStaticTable\n", vp->magic));
    }
    return NULL;
}
static int
getfirst_dot1qPortVlanTableEntry(dot1qPortVlanTable_entry_t *table_entry)
{
    vlan_port_conf_t  port_conf;
    dot1Port_info_t   info;

    info.dot1port = DOT1PORT_NO_NONE;
    (void) dot1Port_get_next(&info);

    if (vlan_mgmt_port_conf_get(info.isid, info.if_id, &port_conf, VLAN_USER_STATIC) == VTSS_OK) {
        table_entry->dot1dBasePort = info.dot1port;
        table_entry->dot1qPvid = port_conf.pvid;
        if (port_conf.frame_type == VTSS_VLAN_FRAME_ALL) {
            table_entry->dot1qPortAcceptableFrameTypes = 1;   /* admitAll */
        } else {
            table_entry->dot1qPortAcceptableFrameTypes = 2;   /* adminOnlyVlanTagged  */
        }
        if (port_conf.ingress_filter) {
            table_entry->dot1qPortIngressFiltering = 1;    /* TRUE  */
        } else {
            table_entry->dot1qPortIngressFiltering = 2;    /* FALSE */
        }
        return 0;
    }

    return 1;
}

static int
get_dot1qPortVlanTableEntry(dot1qPortVlanTable_entry_t *table_entry, BOOL getnext)
{
    vlan_port_conf_t  port_conf;
    dot1Port_info_t   info;

    info.dot1port = table_entry->dot1dBasePort;

    if (getnext) {
        if (FALSE == dot1Port_get_next(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    } else {
        if (FALSE == dot1Port_get(&info) || info.type != DOT1PORT_TYPE_PORT ) {
            return VTSS_RC_ERROR;
        }
    }

    if (vlan_mgmt_port_conf_get(info.isid, info.if_id, &port_conf, VLAN_USER_STATIC) == VTSS_OK) {
        table_entry->dot1dBasePort = info.dot1port;
        table_entry->dot1qPvid = port_conf.pvid;
        if (port_conf.frame_type == VTSS_VLAN_FRAME_ALL) {
            table_entry->dot1qPortAcceptableFrameTypes = 1;   /* admitAll */
        } else {
            table_entry->dot1qPortAcceptableFrameTypes = 2;   /* adminOnlyVlanTagged  */
        }
        if (port_conf.ingress_filter) {
            table_entry->dot1qPortIngressFiltering = 1;    /* TRUE  */
        } else {
            table_entry->dot1qPortIngressFiltering = 2;    /* FALSE */
        }
        return 0;
    }

    return 1;
}

static int set_dot1qPortVlanTableEntry(dot1qPortVlanTable_entry_t *table_entry)
{
    vlan_port_conf_t port_conf;
    dot1Port_info_t  info;
    vtss_rc          rc;

    info.dot1port = table_entry->dot1dBasePort;

    if (FALSE == dot1Port_get(&info) || info.type != DOT1PORT_TYPE_PORT ) {
        return VTSS_RC_ERROR;
    }

    (void) vlan_mgmt_port_conf_get(info.isid, info.if_id, &port_conf, VLAN_USER_STATIC);

    port_conf.pvid           = table_entry->dot1qPvid;
    port_conf.untagged_vid   = table_entry->dot1qPvid;
    port_conf.frame_type     = (table_entry->dot1qPortAcceptableFrameTypes == 1) ? VTSS_VLAN_FRAME_ALL : VTSS_VLAN_FRAME_TAGGED;
    port_conf.ingress_filter = (table_entry->dot1qPortIngressFiltering == 1) ? TRUE : FALSE;
    port_conf.tx_tag_type    = VLAN_TX_TAG_TYPE_UNTAG_THIS;
    if ((rc = vlan_mgmt_port_conf_set(info.isid, info.if_id, &port_conf, VLAN_USER_STATIC)) != VTSS_RC_OK) {
        T_E("vlan_mgmt_port_conf_set(%u:%u failed (%s)", info.isid, (u32)info.if_id, error_txt(rc));
    }

    return rc;
}

static int
parse_dot1qPortVlanTable(oid     *name,
                         size_t  *length,
                         int     exact,
                         dot1qPortVlanTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 1)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qPortVlanTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qPortVlanTable(oid     *name,
                           size_t  *length,
                           dot1qPortVlanTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qPortVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qPortVlanTable(struct variable *vp,
                       oid     *name,
                       size_t  *length,
                       int     exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qPortVlanTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qPortVlanTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qPortVlanTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qPortVlanTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qPortVlanTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QPVID: {
        *write_method = write_dot1qPvid;
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qPvid;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QPORTACCEPTABLEFRAMETYPES: {
        *write_method = write_dot1qPortAcceptableFrameTypes;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qPortAcceptableFrameTypes;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QPORTINGRESSFILTERING: {
        *write_method = write_dot1qPortIngressFiltering;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qPortIngressFiltering;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
#if 0
    case DOT1QPORTGVRPSTATUS: {
        *write_method = write_dot1qPortGvrpStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qPortGvrpStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QPORTGVRPFAILEDREGISTRATIONS: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qPortGvrpFailedRegistrations;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QPORTGVRPLASTPDUORIGIN: {
        memcpy(qBridgeMIB_global_ret.string_ret, table_entry.dot1qPortGvrpLastPduOrigin, 6);
        *var_len = 6;
        return (u_char *) qBridgeMIB_global_ret.string_ret;
    }
    case DOT1QPORTRESTRICTEDVLANREGISTRATION: {
        *write_method = write_dot1qPortRestrictedVlanRegistration;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qPortRestrictedVlanRegistration;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
#endif
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qPortVlanTable\n", vp->magic));
    }
    return NULL;
}

#if 0
static int
getfirst_dot1qPortVlanStatisticsTableEntry(dot1qPortVlanStatisticsTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qPortVlanStatisticsTableEntry(dot1qPortVlanStatisticsTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1qPortVlanStatisticsTable(oid     *name,
                                   size_t  *length,
                                   int     exact,
                                   dot1qPortVlanStatisticsTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qPortVlanStatisticsTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qPortVlanStatisticsTable(oid     *name,
                                     size_t  *length,
                                     dot1qPortVlanStatisticsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qPortVlanStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qPortVlanStatisticsTable(struct variable *vp,
                                 oid     *name,
                                 size_t  *length,
                                 int     exact,
                                 size_t  *var_len,
                                 WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qPortVlanStatisticsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qPortVlanStatisticsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qPortVlanStatisticsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qPortVlanStatisticsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qPortVlanStatisticsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QTPVLANPORTINFRAMES: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortInFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QTPVLANPORTOUTFRAMES: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortOutFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QTPVLANPORTINDISCARDS: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortInDiscards;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QTPVLANPORTINOVERFLOWFRAMES: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortInOverflowFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QTPVLANPORTOUTOVERFLOWFRAMES: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortOutOverflowFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    case DOT1QTPVLANPORTINOVERFLOWDISCARDS: {
        qBridgeMIB_global_ret.ulong_ret = table_entry.dot1qTpVlanPortInOverflowDiscards;
        *var_len = sizeof(qBridgeMIB_global_ret.ulong_ret);
        return (u_char *) &qBridgeMIB_global_ret.ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qPortVlanStatisticsTable\n", vp->magic));
    }
    return NULL;
}

static int
getfirst_dot1qPortVlanHCStatisticsTableEntry(dot1qPortVlanHCStatisticsTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qPortVlanHCStatisticsTableEntry(dot1qPortVlanHCStatisticsTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1qPortVlanHCStatisticsTable(oid     *name,
                                     size_t  *length,
                                     int     exact,
                                     dot1qPortVlanHCStatisticsTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qPortVlanHCStatisticsTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1qVlanIndex = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

static int
fillobj_dot1qPortVlanHCStatisticsTable(oid     *name,
                                       size_t  *length,
                                       dot1qPortVlanHCStatisticsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1qVlanIndex;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qPortVlanHCStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qPortVlanHCStatisticsTable(struct variable *vp,
                                   oid     *name,
                                   size_t  *length,
                                   int     exact,
                                   size_t  *var_len,
                                   WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qPortVlanHCStatisticsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qPortVlanHCStatisticsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qPortVlanHCStatisticsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qPortVlanHCStatisticsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qPortVlanHCStatisticsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QTPVLANPORTHCINFRAMES: {
        qBridgeMIB_global_ret.c64_ret = table_entry.dot1qTpVlanPortHCInFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.c64_ret);
        return (u_char *) &qBridgeMIB_global_ret.c64_ret;
    }
    case DOT1QTPVLANPORTHCOUTFRAMES: {
        qBridgeMIB_global_ret.c64_ret = table_entry.dot1qTpVlanPortHCOutFrames;
        *var_len = sizeof(qBridgeMIB_global_ret.c64_ret);
        return (u_char *) &qBridgeMIB_global_ret.c64_ret;
    }
    case DOT1QTPVLANPORTHCINDISCARDS: {
        qBridgeMIB_global_ret.c64_ret = table_entry.dot1qTpVlanPortHCInDiscards;
        *var_len = sizeof(qBridgeMIB_global_ret.c64_ret);
        return (u_char *) &qBridgeMIB_global_ret.c64_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qPortVlanHCStatisticsTable\n", vp->magic));
    }
    return NULL;
}
#endif
static int
getfirst_dot1qLearningConstraintsTableEntry(dot1qLearningConstraintsTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1qLearningConstraintsTableEntry(dot1qLearningConstraintsTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1qLearningConstraintsTableEntry(dot1qLearningConstraintsTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1qLearningConstraintsTable(oid     *name,
                                    size_t  *length,
                                    int     exact,
                                    dot1qLearningConstraintsTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1qLearningConstraintsTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1qConstraintVlan = (u_long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1qConstraintSet = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if 0
static int
fillobj_dot1qLearningConstraintsTable(oid     *name,
                                      size_t  *length,
                                      dot1qLearningConstraintsTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1qConstraintVlan;
    name[name_pos++] = (oid) table_entry->dot1qConstraintSet;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1qLearningConstraintsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1qLearningConstraintsTable(struct variable *vp,
                                  oid     *name,
                                  size_t  *length,
                                  int     exact,
                                  size_t  *var_len,
                                  WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1qLearningConstraintsTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1qLearningConstraintsTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1qLearningConstraintsTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1qLearningConstraintsTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1qLearningConstraintsTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1QCONSTRAINTTYPE: {
        *write_method = write_dot1qConstraintType;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qConstraintType;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1QCONSTRAINTSTATUS: {
        *write_method = write_dot1qConstraintStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1qConstraintStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1qLearningConstraintsTable\n", vp->magic));
    }
    return NULL;
}
#endif

static int
getfirst_dot1vProtocolGroupTableEntry(dot1vProtocolGroupTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1vProtocolGroupTableEntry(dot1vProtocolGroupTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1vProtocolGroupTableEntry(dot1vProtocolGroupTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1vProtocolGroupTable(oid     *name,
                              size_t  *length,
                              int     exact,
                              dot1vProtocolGroupTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);
    u_char  *cp = NULL;
    int     len = 0;

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 3)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1vProtocolGroupTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1vProtocolTemplateFrameType = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    len = (int) * op++;
    op_pos++;
    table_entry->dot1vProtocolTemplateProtocolValue_len = (char) len;
    cp = (u_char *)table_entry->dot1vProtocolTemplateProtocolValue;
    while (len-- > 0) {
        if (*length > op_pos) {
            *cp++ = (u_char) * op++;
            op_pos++;
        } else if (exact) {
            return -1;
        } else {
            return 0;
        }
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if 0
static int
fillobj_dot1vProtocolGroupTable(oid     *name,
                                size_t  *length,
                                dot1vProtocolGroupTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;
    int     len = 0, idx = 0;

    name[name_pos++] = (oid) table_entry->dot1vProtocolTemplateFrameType;
    len = (int) table_entry->dot1vProtocolTemplateProtocolValue_len;
    while (len-- > 0) {
        name[name_pos++] = (unsigned char) table_entry->dot1vProtocolTemplateProtocolValue[idx++];
    }

    *length = name_pos;
    return 0;
}

/*
 * var_dot1vProtocolGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1vProtocolGroupTable(struct variable *vp,
                            oid     *name,
                            size_t  *length,
                            int     exact,
                            size_t  *var_len,
                            WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1vProtocolGroupTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1vProtocolGroupTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1vProtocolGroupTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1vProtocolGroupTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1vProtocolGroupTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1VPROTOCOLGROUPID: {
        *write_method = write_dot1vProtocolGroupId;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1vProtocolGroupId;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1VPROTOCOLGROUPROWSTATUS: {
        *write_method = write_dot1vProtocolGroupRowStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1vProtocolGroupRowStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1vProtocolGroupTable\n", vp->magic));
    }
    return NULL;
}
#endif
static int
getfirst_dot1vProtocolPortTableEntry(dot1vProtocolPortTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
get_dot1vProtocolPortTableEntry(dot1vProtocolPortTable_entry_t *table_entry, BOOL getnext)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
set_dot1vProtocolPortTableEntry(dot1vProtocolPortTable_entry_t *table_entry)
{
    /*
     * FIXME : return non-zero value when fail
     */
    return 0;
}

static int
parse_dot1vProtocolPortTable(oid     *name,
                             size_t  *length,
                             int     exact,
                             dot1vProtocolPortTable_entry_t *table_entry)
{
    size_t  op_pos = 11 + 2;
    oid     *op = (oid *)(name + op_pos);

    memset(table_entry, 0, sizeof(*table_entry));

    if (exact && *length < (11 + 1 + 2)) {
        return -1;
    } else if (!exact && *length <= op_pos) {
        if (getfirst_dot1vProtocolPortTableEntry(table_entry)) {
            return -1;
        }
        return 1; /* getfirst */
    }

    if (*length > op_pos) {
        table_entry->dot1dBasePort = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }
    if (*length > op_pos) {
        table_entry->dot1vProtocolPortGroupId = (long) * op++;
        op_pos++;
    } else if (exact) {
        return -1;
    } else {
        return 0;
    }

    if (exact && *length != op_pos) {
        return -1;
    }

    return 0;
}

#if 0
static int
fillobj_dot1vProtocolPortTable(oid     *name,
                               size_t  *length,
                               dot1vProtocolPortTable_entry_t *table_entry)
{
    int     name_pos = 11 + 2;

    name[name_pos++] = (oid) table_entry->dot1dBasePort;
    name[name_pos++] = (oid) table_entry->dot1vProtocolPortGroupId;

    *length = name_pos;
    return 0;
}

/*
 * var_dot1vProtocolPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_qBridgeMIB above.
 */
u_char *
var_dot1vProtocolPortTable(struct variable *vp,
                           oid     *name,
                           size_t  *length,
                           int     exact,
                           size_t  *var_len,
                           WriteMethod **write_method)
{
    int                 rc;
    oid                 newname[MAX_OID_LEN];
    size_t              newname_len;
    dot1vProtocolPortTable_entry_t table_entry;

    *write_method = NULL;
    memcpy((char *) newname, (char *) vp->name, (int) (vp->namelen * sizeof(oid)));
    newname_len = vp->namelen;

    if (memcmp(name, vp->name, sizeof(oid) * vp->namelen) != 0) {
        memcpy(name, vp->name, sizeof(oid) * vp->namelen);
        *length = vp->namelen;
    }

    if ((rc = parse_dot1vProtocolPortTable(name, length, exact, &table_entry)) < 0) {
        return NULL;
    } else if (rc > 0) { /* getfirst */
        if (fillobj_dot1vProtocolPortTable(newname, &newname_len, &table_entry)) {
            return NULL;
        }
    } else {
        do {
            if (get_dot1vProtocolPortTableEntry(&table_entry, exact ? FALSE : TRUE)) {
                return NULL;
            }
            if (fillobj_dot1vProtocolPortTable(newname, &newname_len, &table_entry)) {
                return NULL;
            }
            if (exact) {
                break;
            }
            rc = snmp_oid_compare(newname, newname_len, name, *length);
        } while (rc < 0);
    }

    /*
     * fill in object part of name for current entry
     */
    memcpy((char *) name, (char *) newname, (int) (newname_len * sizeof(oid)));
    *length = newname_len;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT1VPROTOCOLPORTGROUPVID: {
        *write_method = write_dot1vProtocolPortGroupVid;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1vProtocolPortGroupVid;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    case DOT1VPROTOCOLPORTROWSTATUS: {
        *write_method = write_dot1vProtocolPortRowStatus;
        qBridgeMIB_global_ret.long_ret = table_entry.dot1vProtocolPortRowStatus;
        *var_len = sizeof(qBridgeMIB_global_ret.long_ret);
        return (u_char *) &qBridgeMIB_global_ret.long_ret;
    }
    default:
        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_dot1vProtocolPortTable\n", vp->magic));
    }
    return NULL;
}
#endif

int
write_dot1qGvrpStatus(int      action,
                      u_char   *var_val,
                      u_char   var_val_type,
                      size_t   var_val_len,
                      u_char   *statP,
                      oid      *name,
                      size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qBase_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qGvrpStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qGvrpStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qGvrpStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1qBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1qGvrpStatus = set_value;
        if (set_dot1qBaseScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qConstraintSetDefault(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qVlan_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintSetDefault: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintSetDefault: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1qVlanScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1qConstraintSetDefault = set_value;
        if (set_dot1qVlanScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qConstraintTypeDefault(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qVlan_scalar_t scalar_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintTypeDefault: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintTypeDefault: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintTypeDefault: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (get_dot1qVlanScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        scalar_entry.dot1qConstraintTypeDefault = set_value;
        if (set_dot1qVlanScalar(&scalar_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qForwardAllStaticPorts(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    dot1qForwardAllTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardAllStaticPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardAllStaticPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qForwardAllTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qForwardAllTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qForwardAllStaticPorts, var_val, var_val_len);
        table_entry.dot1qForwardAllStaticPorts_len = var_val_len;
        if (set_dot1qForwardAllTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qForwardAllForbiddenPorts(int      action,
                                    u_char   *var_val,
                                    u_char   var_val_type,
                                    size_t   var_val_len,
                                    u_char   *statP,
                                    oid      *name,
                                    size_t   name_len)
{
    dot1qForwardAllTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardAllForbiddenPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardAllForbiddenPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qForwardAllTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qForwardAllTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qForwardAllForbiddenPorts, var_val, var_val_len);
        table_entry.dot1qForwardAllForbiddenPorts_len = var_val_len;
        if (set_dot1qForwardAllTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qForwardUnregisteredStaticPorts(int      action,
                                          u_char   *var_val,
                                          u_char   var_val_type,
                                          size_t   var_val_len,
                                          u_char   *statP,
                                          oid      *name,
                                          size_t   name_len)
{
    dot1qForwardUnregisteredTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardUnregisteredStaticPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardUnregisteredStaticPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qForwardUnregisteredTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qForwardUnregisteredTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qForwardUnregisteredStaticPorts, var_val, var_val_len);
        table_entry.dot1qForwardUnregisteredStaticPorts_len = var_val_len;
        if (set_dot1qForwardUnregisteredTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qForwardUnregisteredForbiddenPorts(int      action,
                                             u_char   *var_val,
                                             u_char   var_val_type,
                                             size_t   var_val_len,
                                             u_char   *statP,
                                             oid      *name,
                                             size_t   name_len)
{
    dot1qForwardUnregisteredTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardUnregisteredForbiddenPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qForwardUnregisteredForbiddenPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qForwardUnregisteredTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qForwardUnregisteredTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qForwardUnregisteredForbiddenPorts, var_val, var_val_len);
        table_entry.dot1qForwardUnregisteredForbiddenPorts_len = var_val_len;
        if (set_dot1qForwardUnregisteredTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticUnicastAllowedToGoTo(int      action,
                                      u_char   *var_val,
                                      u_char   var_val_type,
                                      size_t   var_val_len,
                                      u_char   *statP,
                                      oid      *name,
                                      size_t   name_len)
{
    dot1qStaticUnicastTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticUnicastAllowedToGoTo: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticUnicastAllowedToGoTo: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qStaticUnicastTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qStaticUnicastTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qStaticUnicastAllowedToGoTo, var_val, var_val_len);
        table_entry.dot1qStaticUnicastAllowedToGoTo_len = var_val_len;
        if (set_dot1qStaticUnicastTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticUnicastStatus(int      action,
                               u_char   *var_val,
                               u_char   var_val_type,
                               size_t   var_val_len,
                               u_char   *statP,
                               oid      *name,
                               size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qStaticUnicastTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticUnicastStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticUnicastStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticUnicastStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qStaticUnicastTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qStaticUnicastTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qStaticUnicastStatus = set_value;
        if (set_dot1qStaticUnicastTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticMulticastStaticEgressPorts(int      action,
                                            u_char   *var_val,
                                            u_char   var_val_type,
                                            size_t   var_val_len,
                                            u_char   *statP,
                                            oid      *name,
                                            size_t   name_len)
{
    dot1qStaticMulticastTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastStaticEgressPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastStaticEgressPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qStaticMulticastTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qStaticMulticastTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qStaticMulticastStaticEgressPorts, var_val, var_val_len);
        table_entry.dot1qStaticMulticastStaticEgressPorts_len = var_val_len;
        if (set_dot1qStaticMulticastTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticMulticastForbiddenEgressPorts(int      action,
                                               u_char   *var_val,
                                               u_char   var_val_type,
                                               size_t   var_val_len,
                                               u_char   *statP,
                                               oid      *name,
                                               size_t   name_len)
{
    dot1qStaticMulticastTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastForbiddenEgressPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastForbiddenEgressPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qStaticMulticastTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qStaticMulticastTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qStaticMulticastForbiddenEgressPorts, var_val, var_val_len);
        table_entry.dot1qStaticMulticastForbiddenEgressPorts_len = var_val_len;
        if (set_dot1qStaticMulticastTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticMulticastStatus(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qStaticMulticastTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qStaticMulticastStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qStaticMulticastTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qStaticMulticastTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qStaticMulticastStatus = set_value;
        if (set_dot1qStaticMulticastTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticName(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    dot1qVlanStaticTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticName: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticName: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_len > 32) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */

        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qVlanStaticTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qVlanStaticTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qVlanStaticName, var_val, var_val_len);
        table_entry.dot1qVlanStaticName_len = var_val_len;
        if (set_dot1qVlanStaticTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticEgressPorts(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    dot1qVlanStaticTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticEgressPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticEgressPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qVlanStaticTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qVlanStaticTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qVlanStaticEgressPorts, var_val, var_val_len);
        table_entry.dot1qVlanStaticEgressPorts_len = var_val_len;
        if (set_dot1qVlanStaticTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanForbiddenEgressPorts(int      action,
                                    u_char   *var_val,
                                    u_char   var_val_type,
                                    size_t   var_val_len,
                                    u_char   *statP,
                                    oid      *name,
                                    size_t   name_len)
{
    dot1qVlanStaticTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanForbiddenEgressPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanForbiddenEgressPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qVlanStaticTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qVlanStaticTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qVlanForbiddenEgressPorts, var_val, var_val_len);
        table_entry.dot1qVlanForbiddenEgressPorts_len = var_val_len;
        if (set_dot1qVlanStaticTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticUntaggedPorts(int      action,
                                   u_char   *var_val,
                                   u_char   var_val_type,
                                   size_t   var_val_len,
                                   u_char   *statP,
                                   oid      *name,
                                   size_t   name_len)
{
    dot1qVlanStaticTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_OCTET_STR) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticUntaggedPorts: not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > SPRINT_MAX_LEN) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticUntaggedPorts: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qVlanStaticTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qVlanStaticTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        memcpy(table_entry.dot1qVlanStaticUntaggedPorts, var_val, var_val_len);
        table_entry.dot1qVlanStaticUntaggedPorts_len = var_val_len;
        if (set_dot1qVlanStaticTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticRowStatus(int      action,
                               u_char   *var_val,
                               u_char   var_val_type,
                               size_t   var_val_len,
                               u_char   *statP,
                               oid      *name,
                               size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qVlanStaticTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 4 && set_value != 6) {
            (void) snmp_log(LOG_ERR, "write to dot1qVlanStaticRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qVlanStaticTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if ( set_value != 4 && get_dot1qVlanStaticTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qVlanStaticRowStatus = set_value;
        if (set_dot1qVlanStaticTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qPvid(int      action,
                u_char   *var_val,
                u_char   var_val_type,
                size_t   var_val_len,
                u_char   *statP,
                oid      *name,
                size_t   name_len)
{
    u_long         set_value = var_val ? *((u_long *) var_val) : 0;
    dot1qPortVlanTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_UNSIGNED) {
            (void) snmp_log(LOG_ERR, "write to dot1qPvid: not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) { /* FIXME */
            (void) snmp_log(LOG_ERR, "write to dot1qPvid: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        /*
         * FIXME : check the valid range
         * if (set_value < min_value || set_value > max_value) {
         *  (void) snmp_log(LOG_ERR, "write to dot1qPortVlanTable: bad value\n");
         *   return SNMP_ERR_WRONGVALUE;
         * }
         */
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qPortVlanTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qPortVlanTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qPvid = set_value;
        if (set_dot1qPortVlanTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qPortAcceptableFrameTypes(int      action,
                                    u_char   *var_val,
                                    u_char   var_val_type,
                                    size_t   var_val_len,
                                    u_char   *statP,
                                    oid      *name,
                                    size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qPortVlanTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortAcceptableFrameTypes: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortAcceptableFrameTypes: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortAcceptableFrameTypes: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qPortVlanTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qPortVlanTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qPortAcceptableFrameTypes = set_value;
        if (set_dot1qPortVlanTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qPortIngressFiltering(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qPortVlanTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortIngressFiltering: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortIngressFiltering: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortIngressFiltering: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qPortVlanTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qPortVlanTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qPortIngressFiltering = set_value;
        if (set_dot1qPortVlanTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qPortGvrpStatus(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qPortVlanTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortGvrpStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortGvrpStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortGvrpStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qPortVlanTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qPortVlanTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qPortGvrpStatus = set_value;
        if (set_dot1qPortVlanTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qPortRestrictedVlanRegistration(int      action,
                                          u_char   *var_val,
                                          u_char   var_val_type,
                                          size_t   var_val_len,
                                          u_char   *statP,
                                          oid      *name,
                                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qPortVlanTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortRestrictedVlanRegistration: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortRestrictedVlanRegistration: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qPortRestrictedVlanRegistration: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qPortVlanTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qPortVlanTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qPortRestrictedVlanRegistration = set_value;
        if (set_dot1qPortVlanTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qConstraintType(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qLearningConstraintsTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintType: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintType: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintType: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qLearningConstraintsTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qLearningConstraintsTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qConstraintType = set_value;
        if (set_dot1qLearningConstraintsTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qConstraintStatus(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1qLearningConstraintsTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1qConstraintStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1qLearningConstraintsTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1qLearningConstraintsTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1qConstraintStatus = set_value;
        if (set_dot1qLearningConstraintsTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1vProtocolGroupId(int      action,
                           u_char   *var_val,
                           u_char   var_val_type,
                           size_t   var_val_len,
                           u_char   *statP,
                           oid      *name,
                           size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1vProtocolGroupTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolGroupId: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolGroupId: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1vProtocolGroupTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1vProtocolGroupTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1vProtocolGroupId = set_value;
        if (set_dot1vProtocolGroupTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1vProtocolGroupRowStatus(int      action,
                                  u_char   *var_val,
                                  u_char   var_val_type,
                                  size_t   var_val_len,
                                  u_char   *statP,
                                  oid      *name,
                                  size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1vProtocolGroupTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolGroupRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolGroupRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolGroupRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1vProtocolGroupTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1vProtocolGroupTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1vProtocolGroupRowStatus = set_value;
        if (set_dot1vProtocolGroupTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1vProtocolPortGroupVid(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1vProtocolPortTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolPortGroupVid: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolPortGroupVid: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1vProtocolPortTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1vProtocolPortTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1vProtocolPortGroupVid = set_value;
        if (set_dot1vProtocolPortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1vProtocolPortRowStatus(int      action,
                                 u_char   *var_val,
                                 u_char   var_val_type,
                                 size_t   var_val_len,
                                 u_char   *statP,
                                 oid      *name,
                                 size_t   name_len)
{
    long         set_value = var_val ? *((long *) var_val) : 0;
    dot1vProtocolPortTable_entry_t    table_entry;

    switch (action) {
    case RESERVE1: {
        if (var_val_type != ASN_INTEGER) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolPortRowStatus: not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolPortRowStatus: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        if (set_value != 1
            && set_value != 2
            && set_value != 3
            && set_value != 4
            && set_value != 5
            && set_value != 6
           ) {
            (void) snmp_log(LOG_ERR, "write to dot1vProtocolPortRowStatus: bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    }
    case RESERVE2: {
        /*
         * Allocate memory and similar resources
         */
        break;
    }
    case FREE: {
        /*
         *Release any resources that have been allocated
         */
        break;
    }
    case ACTION: {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*
         * Save to current configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case UNDO: {
        /*
         * Back out any changes made in the ACTION case
         */
        /*
         * Restore current configuration from old configuration
         */
        /*
         * We don't implement UNDO in EstaX project
         */
        break;
    }
    case COMMIT: {
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        /*
         * Update old configuration
         */
        /*
         * In EstaX project, we set new configuration directly
         */
        if (parse_dot1vProtocolPortTable(name, &name_len, TRUE, &table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        if (get_dot1vProtocolPortTableEntry(&table_entry, FALSE)) {
            return SNMP_ERR_COMMITFAILED;
        }
        table_entry.dot1vProtocolPortRowStatus = set_value;
        if (set_dot1vProtocolPortTableEntry(&table_entry)) {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    }
    return SNMP_ERR_NOERROR;
}

