/*

 Vitesse Switch Software.

 Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 Rights Reserved.

 Unpublished rights reserved under the copyright laws of the United States of
 America, other countries and international treaties. Permission to use, copy,
 store and modify, the software and its source code is granted. Permission to
 integrate into other products, disclose, transmit and distribute the software
 in an absolute machine readable format (e.g. HEX file) is also granted.  The
 source code of the software may not be disclosed, transmitted or distributed
 without the written permission of Vitesse. The software and its source code
 may only be used in products utilizing the Vitesse switch products.

 This copyright notice must appear in any copy, modification, disclosure,
 transmission or distribution of the software. Vitesse retains all ownership,
 copyright, trade secret and proprietary rights in the software.

 THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR USE AND NON-INFRINGEMENT.

*/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf
 */

#include <main.h>
#include <pkgconf/hal.h>
#include <cyg/hal/hal_io.h>
#include <cyg/infra/cyg_type.h>
#include <cyg/hal/hal_arch.h>
#include <cyg/infra/diag.h>
#include <cyg/hal/drv_api.h>
#include <cyg/io/eth/netdev.h>
#include <cyg/io/eth/eth_drv.h>
#include <cyg/infra/cyg_ass.h>
#include <sys/param.h>

#include <ucd-snmp/config.h>
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif                          /* HAVE_STDLIB_H */
#if HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif                          /* HAVE_STRING_H */

#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/mibgroup/util_funcs.h>       /* utility function declarations */
#include "rfc4670_radiusclient.h"

#if VTSS_SWITCH_STACKABLE
#include "topo_api.h"
#endif

#include "msg_api.h"
#include "sysutil_api.h"

/*
 * +++ Start (Internal implementation declarations)
 */
#include "vtss_common_os.h"
#include "misc_api.h"
#ifdef VTSS_SW_OPTION_RADIUS
#include "vtss_radius_api.h"
#endif
#include "vtss_radius_api.h"
#include "mibContextTable.h"  //mibContextTable_register

typedef struct {
    u_long                  radiusAccServerInetAddressType;
    u_long                  radiusAccServerInetAddress;
    u_long                  radiusAccClientServerInetPortNumber;
    u_long                  radiusAccClientExtRoundTripTime;
    vtss_common_counter_t   radiusAccClientExtRequests;
    vtss_common_counter_t   radiusAccClientExtRetransmissions;
    vtss_common_counter_t   radiusAccClientExtResponses;
    vtss_common_counter_t   radiusAccClientExtMalformedResponses;
    vtss_common_counter_t   radiusAccClientExtBadAuthenticators;
    u_long                  radiusAccClientExtPendingRequests;
    vtss_common_counter_t   radiusAccClientExtTimeouts;
    vtss_common_counter_t   radiusAccClientExtUnknownTypes;
    vtss_common_counter_t   radiusAccClientExtPacketsDropped;
    u_long                  radiusAccClientCounterDiscontinuity;
} radiusAccServerExtTable_entry_t;

int get_available_radiusAccServerExtTableIndex(int if_num)
{
    vtss_radius_acct_client_server_mib_s   radius_acct_client_server_mib;
    vtss_rc                                rc;
    uint                                   i;

    if ((if_num < 1) || (if_num > VTSS_RADIUS_NUMBER_OF_SERVERS)) {
        return VTSS_RADIUS_NUMBER_OF_SERVERS + 1;
    }

    for (i = if_num; i <= VTSS_RADIUS_NUMBER_OF_SERVERS; i++) {
        rc = vtss_radius_acct_client_mib_get(i - 1, &radius_acct_client_server_mib);
        if ((rc != VTSS_OK) || (radius_acct_client_server_mib.state != VTSS_RADIUS_SERVER_STATE_READY)) {
            continue;
        } else {
            break;
        }
    }
    if (i > VTSS_RADIUS_NUMBER_OF_SERVERS) {
        return VTSS_RADIUS_NUMBER_OF_SERVERS + 1;
    } else {
        return i;
    }
}

BOOL get_radiusAccServerExtTable_entry(int table_index, radiusAccServerExtTable_entry_t *table_entry_p)
{
    vtss_radius_acct_client_server_mib_s   radius_acct_client_server_mib;
    vtss_rc                                rc;

    if (table_index > VTSS_RADIUS_NUMBER_OF_SERVERS) {
        return FALSE;
    }

    memset(table_entry_p, 0x0, sizeof(radiusAccServerExtTable_entry_t));

    rc = vtss_radius_acct_client_mib_get(table_index - 1, &radius_acct_client_server_mib);
    if (rc != VTSS_OK) {
        return FALSE;
    }

    table_entry_p->radiusAccServerInetAddressType = 1; // Always IPv4 now
    table_entry_p->radiusAccServerInetAddress = radius_acct_client_server_mib.radiusAccServerInetAddress;
    table_entry_p->radiusAccClientServerInetPortNumber = radius_acct_client_server_mib.radiusAccClientServerInetPortNumber;
    table_entry_p->radiusAccClientExtRoundTripTime = radius_acct_client_server_mib.radiusAccClientExtRoundTripTime;
    table_entry_p->radiusAccClientExtRequests = radius_acct_client_server_mib.radiusAccClientExtRequests;
    table_entry_p->radiusAccClientExtRetransmissions = radius_acct_client_server_mib.radiusAccClientExtRetransmissions;
    table_entry_p->radiusAccClientExtResponses = radius_acct_client_server_mib.radiusAccClientExtResponses;
    table_entry_p->radiusAccClientExtMalformedResponses = radius_acct_client_server_mib.radiusAccClientExtMalformedResponses;
    table_entry_p->radiusAccClientExtBadAuthenticators = radius_acct_client_server_mib.radiusAccClientExtBadAuthenticators;
    table_entry_p->radiusAccClientExtPendingRequests = radius_acct_client_server_mib.radiusAccClientExtPendingRequests;
    table_entry_p->radiusAccClientExtTimeouts = radius_acct_client_server_mib.radiusAccClientExtTimeouts;
    table_entry_p->radiusAccClientExtUnknownTypes = radius_acct_client_server_mib.radiusAccClientExtUnknownTypes;
    table_entry_p->radiusAccClientExtPacketsDropped = radius_acct_client_server_mib.radiusAccClientExtPacketsDropped;
    table_entry_p->radiusAccClientCounterDiscontinuity = radius_acct_client_server_mib.radiusAccClientCounterDiscontinuity;

    return TRUE;
}

/*
 * --- End (Internal implementation declarations)
 */

/*
 * radiusAccClientMIBObjects_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             radiusAccClientMIBObjects_variables_oid[] =
{ 1, 3, 6, 1, 2, 1, 67, 2, 2, 1 };

/*
 * variable4 radiusAccClientMIBObjects_variables:
 *   this variable defines function callbacks and type return information
 *   for the radiusAccClientMIBObjects mib section
 */

struct variable4 radiusAccClientMIBObjects_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define RADIUSACCCLIENTINVALIDSERVERADDRESSES       1
//    {RADIUSACCCLIENTINVALIDSERVERADDRESSES, ASN_COUNTER, RONLY, var_radiusAccClientMIBObjects, 2, {1, 1}},
#define RADIUSACCCLIENTIDENTIFIER                   2
    {RADIUSACCCLIENTIDENTIFIER, ASN_OCTET_STR, RONLY, var_radiusAccClientMIBObjects, 2, {1, 2}},

    /* These OIDs are Obsolete in RFC 4670
    #define RADIUSACCSERVERINDEX                        3
        {RADIUSACCSERVERINDEX, ASN_INTEGER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 1}},
    #define RADIUSACCSERVERADDRESS                      4
        {RADIUSACCSERVERADDRESS, ASN_IPADDRESS, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 2}},
    #define RADIUSACCCLIENTSERVERPORTNUMBER             5
        {RADIUSACCCLIENTSERVERPORTNUMBER, ASN_INTEGER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 3}},
    #define RADIUSACCCLIENTROUNDTRIPTIME                6
        {RADIUSACCCLIENTROUNDTRIPTIME, ASN_TIMETICKS, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 4}},
    #define RADIUSACCCLIENTREQUESTS                     7
        {RADIUSACCCLIENTREQUESTS, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 5}},
    #define RADIUSACCCLIENTRETRANSMISSIONS              8
        {RADIUSACCCLIENTRETRANSMISSIONS, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 6}},
    #define RADIUSACCCLIENTRESPONSES                    9
        {RADIUSACCCLIENTRESPONSES, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 7}},
    #define RADIUSACCCLIENTMALFORMEDRESPONSES           10
        {RADIUSACCCLIENTMALFORMEDRESPONSES, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 8}},
    #define RADIUSACCCLIENTBADAUTHENTICATORS            11
        {RADIUSACCCLIENTBADAUTHENTICATORS, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 9}},
    #define RADIUSACCCLIENTPENDINGREQUESTS              12
        {RADIUSACCCLIENTPENDINGREQUESTS, ASN_GAUGE, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 10}},
    #define RADIUSACCCLIENTTIMEOUTS                     13
        {RADIUSACCCLIENTTIMEOUTS, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 11}},
    #define RADIUSACCCLIENTUNKNOWNTYPES                 14
        {RADIUSACCCLIENTUNKNOWNTYPES, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 12}},
    #define RADIUSACCCLIENTPACKETSDROPPED               15
        {RADIUSACCCLIENTPACKETSDROPPED, ASN_COUNTER, RONLY, var_radiusAccServerTable, 4, {1, 3, 1, 13}},*/
#define RADIUSACCSERVEREXTINDEX                     16
//    {RADIUSACCSERVEREXTINDEX, ASN_INTEGER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 1}},
#define RADIUSACCSERVERINETADDRESSTYPE              17
    {RADIUSACCSERVERINETADDRESSTYPE, ASN_INTEGER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 2}},
#define RADIUSACCSERVERINETADDRESS                  18
    {RADIUSACCSERVERINETADDRESS, ASN_OCTET_STR, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 3}},
#define RADIUSACCCLIENTSERVERINETPORTNUMBER         19
    {RADIUSACCCLIENTSERVERINETPORTNUMBER, ASN_UNSIGNED, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 4}},
#define RADIUSACCCLIENTEXTROUNDTRIPTIME             20
    {RADIUSACCCLIENTEXTROUNDTRIPTIME, ASN_TIMETICKS, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 5}},
#define RADIUSACCCLIENTEXTREQUESTS                  21
    {RADIUSACCCLIENTEXTREQUESTS, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 6}},
#define RADIUSACCCLIENTEXTRETRANSMISSIONS           22
    {RADIUSACCCLIENTEXTRETRANSMISSIONS, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 7}},
#define RADIUSACCCLIENTEXTRESPONSES                 23
    {RADIUSACCCLIENTEXTRESPONSES, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 8}},
#define RADIUSACCCLIENTEXTMALFORMEDRESPONSES        24
    {RADIUSACCCLIENTEXTMALFORMEDRESPONSES, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 9}},
#define RADIUSACCCLIENTEXTBADAUTHENTICATORS         25
    {RADIUSACCCLIENTEXTBADAUTHENTICATORS, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 10}},
#define RADIUSACCCLIENTEXTPENDINGREQUESTS           26
    {RADIUSACCCLIENTEXTPENDINGREQUESTS, ASN_GAUGE, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 11}},
#define RADIUSACCCLIENTEXTTIMEOUTS                  27
    {RADIUSACCCLIENTEXTTIMEOUTS, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 12}},
#define RADIUSACCCLIENTEXTUNKNOWNTYPES              28
    {RADIUSACCCLIENTEXTUNKNOWNTYPES, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 13}},
#define RADIUSACCCLIENTEXTPACKETSDROPPED            29
    {RADIUSACCCLIENTEXTPACKETSDROPPED, ASN_COUNTER, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 14}},
#define RADIUSACCCLIENTCOUNTERDISCONTINUITY         30
    {RADIUSACCCLIENTCOUNTERDISCONTINUITY, ASN_TIMETICKS, RONLY, var_radiusAccServerExtTable, 4, {1, 4, 1, 15}},
};

/*
 * (L = length of the oidsuffix)
 */

/*
 * FIXME: template declaration for compiler completed
 */
static long     VAR = 0, VALUE = 0;

/*
 * Initializes the radiusAccClientMIBObjects module
 */
void
init_radiusAccClientMIBObjects(void)
{
    // Register mibContextTable
    mibContextTable_register(radiusAccClientMIBObjects_variables_oid,
                             sizeof(radiusAccClientMIBObjects_variables_oid) / sizeof(oid),
                             "RADIUS-ACC-CLIENT-MIB : radiusAccClientMIBObjects");

    DEBUGMSGTL(("radiusAccClientMIBObjects", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("radiusAccClientMIBObjects",
                 radiusAccClientMIBObjects_variables, variable4,
                 radiusAccClientMIBObjects_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_radiusAccClientMIBObjects():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
u_char         *
var_radiusAccClientMIBObjects(struct variable *vp,
                              oid *name,
                              size_t *length,
                              int exact,
                              size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */
    system_conf_t   system_conf;
    static u_char   string[VTSS_SYS_STRING_LEN];

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED) {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSACCCLIENTINVALIDSERVERADDRESSES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTIDENTIFIER: {
        (void)system_get_config(&system_conf);
        *var_len = strlen(system_conf.sys_name);
        memcpy(string, system_conf.sys_name, strlen(system_conf.sys_name));
        return (u_char *)string;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAccClientMIBObjects\n",
                    vp->magic));
    }
    return NULL;
}

#if 0 /* These OIDs are Obsolete in RFC 4670 */
/*
 * var_radiusAccServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_radiusAccClientMIBObjects above.
 */
u_char         *
var_radiusAccServerTable(struct variable *vp,
                         oid *name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int             table_size;
    int             idx_num;
    //radiusAccServerTable_entry_t table_entry; /* FIXME */

    table_size = 1;             /* FIXME */

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];      /* FIXME */
    //table_index = get_available_radiusAccServerTableIndex(idx_num); /* FIXME */
    //if (exact && (table_index != idx_num))
    //    return NULL;
    //if (!get_radiusAccServerTable_entry(table_index, &table_entry) /* FIXME */
    //    return NULL;

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    //name[(*length) - 1] = table_index; /* FIXME */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSACCSERVERINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCSERVERADDRESS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTSERVERPORTNUMBER: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTROUNDTRIPTIME: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTREQUESTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTRETRANSMISSIONS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTRESPONSES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTMALFORMEDRESPONSES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTBADAUTHENTICATORS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTPENDINGREQUESTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTTIMEOUTS: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTUNKNOWNTYPES: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCCLIENTPACKETSDROPPED: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAccServerTable\n",
                    vp->magic));
    }
    return NULL;
}
#endif

/*
 * var_radiusAccServerExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_radiusAccClientMIBObjects above.
 */
u_char         *
var_radiusAccServerExtTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    /*
     * variables we may use later
     * static long long_ret;
     * static u_long ulong_ret;
     * static u_char string[SPRINT_MAX_LEN];
     * static oid objid[MAX_OID_LEN];
     * static struct counter64 c64;
     */

    int                               table_size;
    int                               idx_num;
    int                               table_index;
    radiusAccServerExtTable_entry_t   table_entry;
    static u_long                     ulong_ret;

    table_size = VTSS_RADIUS_NUMBER_OF_SERVERS;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED) {
        return NULL;
    }

    idx_num = name[(*length) - 1];
    table_index = get_available_radiusAccServerExtTableIndex(idx_num);
    if (exact && (table_index != idx_num)) {
        return NULL;
    }
    if (!get_radiusAccServerExtTable_entry(table_index, &table_entry)) {
        return NULL;
    }

    /*
     * Save this one as the "next one", if "table_index" is not sequence
     */
    name[(*length) - 1] = table_index;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case RADIUSACCSERVEREXTINDEX: {
        VAR = VALUE;        /* FIXME */
        return (u_char *) & VAR;    /* FIXME */
    }
    case RADIUSACCSERVERINETADDRESSTYPE: {
        ulong_ret = table_entry.radiusAccServerInetAddressType;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCSERVERINETADDRESS: {
        static char  ip_buf[16];

        (void)misc_ipv4_txt(table_entry.radiusAccServerInetAddress, ip_buf);
        *var_len = strlen(ip_buf);
        return (u_char *)ip_buf;
    }
    case RADIUSACCCLIENTSERVERINETPORTNUMBER: {
        ulong_ret = table_entry.radiusAccClientServerInetPortNumber;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTROUNDTRIPTIME: {
        ulong_ret = table_entry.radiusAccClientExtRoundTripTime * ECOS_MSECS_PER_HWTICK * 100 / 1000;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTREQUESTS: {
        ulong_ret = table_entry.radiusAccClientExtRequests;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTRETRANSMISSIONS: {
        ulong_ret = table_entry.radiusAccClientExtRetransmissions;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTRESPONSES: {
        ulong_ret = table_entry.radiusAccClientExtResponses;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTMALFORMEDRESPONSES: {
        ulong_ret = table_entry.radiusAccClientExtMalformedResponses;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTBADAUTHENTICATORS: {
        ulong_ret = table_entry.radiusAccClientExtBadAuthenticators;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTPENDINGREQUESTS: {
        ulong_ret = table_entry.radiusAccClientExtPendingRequests;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTTIMEOUTS: {
        ulong_ret = table_entry.radiusAccClientExtTimeouts;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTUNKNOWNTYPES: {
        ulong_ret = table_entry.radiusAccClientExtUnknownTypes;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTEXTPACKETSDROPPED: {
        ulong_ret = table_entry.radiusAccClientExtPacketsDropped;
        return (u_char *) & ulong_ret;
    }
    case RADIUSACCCLIENTCOUNTERDISCONTINUITY: {
        ulong_ret = table_entry.radiusAccClientCounterDiscontinuity * ECOS_MSECS_PER_HWTICK * 100 / 1000;
        return (u_char *) & ulong_ret;
    }
    default:
        DEBUGMSGTL(("snmpd",
                    "unknown sub-id %d in var_radiusAccServerExtTable\n",
                    vp->magic));
    }
    return NULL;
}

