/*
 *
 * Vitesse Switch Software.
 *
 * Copyright (c) 2002-2013 Vitesse Semiconductor Corporation "Vitesse". All
 * Rights Reserved.
 *
 * Unpublished rights reserved under the copyright laws of the United States of
 * America, other countries and international treaties. Permission to use, copy,
 * store and modify, the software and its source code is granted. Permission to
 * integrate into other products, disclose, transmit and distribute the software
 * in an absolute machine readable format (e.g. HEX file) is also granted.  The
 * source code of the software may not be disclosed, transmitted or distributed
 * without the written permission of Vitesse. The software and its source code
 * may only be used in products utilizing the Vitesse switch products.
 *
 * This copyright notice must appear in any copy, modification, disclosure,
 * transmission or distribution of the software. Vitesse retains all ownership,
 * copyright, trade secret and proprietary rights in the software.
 *
 * THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY
 * INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR USE AND NON-INFRINGEMENT.
 *
 */

// Note: This file originally auto-generated by mib2c using vtss_mib2c_ucd_snmp.conf v3.40
//       Revise the "FIXME" parts to make it as a completed code.

#include <ucd-snmp/config.h>    /* For HAVE_STDLIB_H, etc.       */
#include <ucd-snmp/mibincl.h>   /* Standard set of SNMP includes */
#include <ucd-snmp/snmp_api.h>  /* snmp_oid_compare()            */

#include "vtss_snmp_api.h"
#include "sysORTable.h"
#if defined(SNMP_HAS_UCD_SNMP)
#include "ucd_snmp_sysORTable.h"
#elif defined(SNMP_HAS_NET_SNMP)
#include "net_snmp_sysORTable.h"
#endif                          /* SNMP_HAS_UCD_SNMP */

#include "vtss_avl_tree_api.h"

/* Trace module */
#include <vtss_module_id.h>
#include <vtss_trace_lvl_api.h>
#define VTSS_TRACE_MODULE_ID        VTSS_MODULE_ID_SNMP
#define VTSS_TRACE_GRP_DEFAULT      0
#define TRACE_GRP_CRIT              1
#define TRACE_GRP_CNT               2

/* mutex for global protection */
#include "critd_api.h"
static critd_t sysORTable_global_critd_mutex;

#if (VTSS_TRACE_ENABLED)
#define SYSORTABLE_CRIT_ENTER() critd_enter(&sysORTable_global_critd_mutex, TRACE_GRP_CRIT, VTSS_TRACE_LVL_NOISE, __FILE__, __LINE__)
#define SYSORTABLE_CRIT_EXIT()  critd_exit( &sysORTable_global_critd_mutex, TRACE_GRP_CRIT, VTSS_TRACE_LVL_NOISE, __FILE__, __LINE__)
#else
#define SYSORTABLE_CRIT_ENTER() critd_enter(&sysORTable_global_critd_mutex)
#define SYSORTABLE_CRIT_EXIT()  critd_exit( &sysORTable_global_critd_mutex)
#endif /* VTSS_TRACE_ENABLED */

static BOOL sysORTable_global_init_flag = FALSE;

/* AVL Tree utility library */
static u32 SYSORTABLE_global_tbl_idx = 1, SYSORTABLE_global_last_change = 0;
static i32 SYSORTABLE_entry_compare_func(void *elm1, void *elm2);

// Create two ACL tree to maintain the same database(sysORTable) with different entry key
VTSS_AVL_TREE(SYSORTABLE_global_table, "SNMP_SYSORTABLE", VTSS_MODULE_ID_SNMP, SYSORTABLE_entry_compare_func, SYSORTABLE_MAX_ENTRY_CNT)

#define VTSS_ALLOC_MODULE_ID VTSS_MODULE_ID_SNMP    // VTSS_MALLOC()


/******************************************************************************/
//
// Local functions
//
/******************************************************************************/
static i32 SYSORTABLE_entry_compare_func(void *element1, void *element2)
{
    sysORTable_entry_t *elm1 = (sysORTable_entry_t *)element1;
    sysORTable_entry_t *elm2 = (sysORTable_entry_t *)element2;

    if (elm1->sysORIndex == elm2->sysORIndex) {
        return 0;
    } else {
        return ((elm1->sysORIndex > elm2->sysORIndex) ? 1 : -1);
    }
}


/******************************************************************************/
// Initial function
/******************************************************************************/
/**
  * \brief Initializes the SNMP-part of the SNMPv2-MIB:sysORTable.
  **/
void
sysORTable_init(void)
{
    T_D("enter");

    if (sysORTable_global_init_flag) {
        return;
    }
    sysORTable_global_init_flag = TRUE;

#if defined(SNMP_HAS_UCD_SNMP)
    ucd_snmp_init_sysORTable();
#elif defined(SNMP_HAS_NET_SNMP)
    net_snmp_init_sysORTable();
#endif                          /* SNMP_HAS_UCD_SNMP */

    /* Create semaphore for critical regions */
    critd_init(&sysORTable_global_critd_mutex, "sysORTable_global_critd_mutex", VTSS_MODULE_ID_SNMP, VTSS_TRACE_MODULE_ID, CRITD_TYPE_MUTEX);
    if (vtss_avl_tree_init(&SYSORTABLE_global_table) != TRUE) {
        T_E("sysORTable - Initialize fail");
    }
    SYSORTABLE_CRIT_EXIT();

    T_D("exit");
}


/******************************************************************************/
//
// SysORTable entry register
//
/******************************************************************************/
/**
  * \brief Register table entry of sysORTable
  *
  * \param oidin  [IN]: The MIB OID which will register to sysORTable
  * \param oidlen [IN]: The OID length of input parameter "oidin"
  * \param descr  [IN]: The desciption of MIB node. Format: <MIB_File_Name> : <Scalar_or_Table_Name>
  **/
void sysORTable_register(oid *oidin, size_t oidlen, const char *descr)
{
    sysORTable_entry_t *entry_p;
    struct timeval      now;
    struct timespec     now_n;
    char                mib_name[SYSORTABLE_STR_LEN_MAX + 1];
    char                *delimit = ":", *ch_p;

    /* Check input parameters */
    SYSORTABLE_CRIT_ENTER();
    if (SYSORTABLE_global_tbl_idx > SYSORTABLE_MAX_ENTRY_CNT ||
        oidlen > SYSORTABLE_OID_LEN_MAX ||
        strlen(descr) >= SYSORTABLE_STR_LEN_MAX) {
        T_E("sysORTable - Input parameter out of valid range");
        SYSORTABLE_CRIT_EXIT();
        return;
    }

    /* Allocate memory for table entry */
    if ((entry_p = (sysORTable_entry_t *)VTSS_MALLOC(sizeof(*entry_p))) == NULL) {
        T_E("sysORTable - Memory allocated fail");
        SYSORTABLE_CRIT_EXIT();
        return;
    }

    /* Fill table entry elements */
    memset(entry_p, 0, sizeof(*entry_p));
    entry_p->sysORIndex = SYSORTABLE_global_tbl_idx++;
    memcpy(entry_p->sysORID, oidin, sizeof(oid) * oidlen);
    entry_p->sysORID_len = oidlen;
    strcpy(entry_p->sysORDescr, descr);
    entry_p->sysORDescr_len = strlen(descr);

    memset(&now_n, 0, sizeof(now_n));
    (void) clock_gettime(CLOCK_MONOTONIC, &now_n);
    now.tv_sec = now_n.tv_sec;
    now.tv_usec = now_n.tv_nsec / 1000;
    entry_p->sysORUpTime = (now.tv_sec * 100) + (now.tv_usec / 10000);

    strcpy(mib_name, descr);
    if ((ch_p = strtok(mib_name, delimit)) != NULL) {
        strcpy(entry_p->mib_name, ch_p);
    }

    /* Add to AVL tree */
    if (vtss_avl_tree_add(&SYSORTABLE_global_table, entry_p) != TRUE) {
        T_W("Register sysORTable failed");
        VTSS_FREE(entry_p);
        SYSORTABLE_CRIT_EXIT();
        return;
    }
    SYSORTABLE_global_last_change = entry_p->sysORUpTime;
    SYSORTABLE_CRIT_EXIT();
}

/**
  * \brief Get the value of sysUpTime at the time of the most recent change in state or value of any instance of sysORID.
  *
  * \param last_change  [OUT]: The last change time of sysORTable entry
  **/
void sysORTable_LastChange_get(u_long *last_change)
{
    SYSORTABLE_CRIT_ENTER();
    *last_change = SYSORTABLE_global_last_change;
    SYSORTABLE_CRIT_EXIT();
}


/******************************************************************************/
//
// Table entry access functions
//
/******************************************************************************/
/**
  * \brief Get first table entry of sysORTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get the first table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
sysORTableEntry_getfirst(sysORTable_entry_t *table_entry)
{
    int                 rc = -1;
    sysORTable_entry_t  *entry_p = table_entry;

    T_D("enter");

    SYSORTABLE_CRIT_ENTER();
    if (vtss_avl_tree_get(&SYSORTABLE_global_table, (void **) &entry_p, VTSS_AVL_TREE_GET_FIRST) == TRUE) {
        rc = 0;
        *table_entry = *entry_p;
    }
    SYSORTABLE_CRIT_EXIT();

    T_D("exit");
    return rc;
}

/**
  * \brief Get/Getnext table entry of sysORTableEntry.
  *
  * \param table_entry [IN_OUT]: Pointer to structure that contains the table
  *                              entry to get/getnext the table entry.
  *
  * \return: 0 if the operation success, non-zero value otherwise.
  **/
int
sysORTableEntry_get(sysORTable_entry_t *table_entry, int getnext)
{
    int                 rc = -1;
    sysORTable_entry_t  *entry_p = table_entry;

    T_D("enter");

    SYSORTABLE_CRIT_ENTER();
    if (vtss_avl_tree_get(&SYSORTABLE_global_table, (void **) &entry_p, getnext ? VTSS_AVL_TREE_GET_NEXT : VTSS_AVL_TREE_GET) == TRUE) {
        rc = 0;
        *table_entry = *entry_p;
    }
    SYSORTABLE_CRIT_EXIT();

    T_D("exit");
    return rc;
}
